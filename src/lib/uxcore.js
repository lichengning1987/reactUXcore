/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ((function(modules) {
	// Check all modules for deduplicated modules
	for(var i in modules) {
		if(Object.prototype.hasOwnProperty.call(modules, i)) {
			switch(typeof modules[i]) {
			case "function": break;
			case "object":
				// Module can be created from a template
				modules[i] = (function(_m) {
					var args = _m.slice(1), fn = modules[_m[0]];
					return function (a,b,c) {
						fn.apply(this, [a,b,c].concat(args));
					};
				}(modules[i]));
				break;
			default:
				// Module is a copy of another module
				modules[i] = modules[modules[i]];
				break;
			}
		}
	}
	return modules;
}([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	window["Uxcore"] = {
	  "Table": __webpack_require__(1),
	  "Form": __webpack_require__(267),
	  "Button": __webpack_require__(258)
		};

/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	/**
	 * Table Component for uxcore
	 * @author zhouquan.yezq
	 *
	 * Copyright 2014-2015, Uxcore Team, Alinw.
	 * All rights reserved.
	 */

	module.exports = __webpack_require__(2);

/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

	function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	/**
	 * Table Component for uxcore
	 * @author zhouquan.yezq
	 *
	 * Copyright 2014-2015, UXCore Team, Alinw.
	 * All rights reserved.
	 */

	var Header = __webpack_require__(3);
	var Tbody = __webpack_require__(158);
	var ActionBar = __webpack_require__(256);
	var CellField = __webpack_require__(163);
	var Pagination = __webpack_require__(261);
	var Const = __webpack_require__(5);
	var assign = __webpack_require__(9);
	var deepcopy = __webpack_require__(242);
	var deepEqual = __webpack_require__(251);
	var classnames = __webpack_require__(19);

	var React = __webpack_require__(7);
	var ReactDOM = __webpack_require__(8);

	var Table = function (_React$Component) {
	    _inherits(Table, _React$Component);

	    function Table(props) {
	        _classCallCheck(this, Table);

	        var _this = _possibleConstructorReturn(this, _React$Component.call(this, props));

	        _this.uid = 0;
	        _this.fields = {};
	        _this.state = {
	            data: _this.addValuesInData(deepcopy(_this.props.jsxdata)), // checkbox 内部交互
	            columns: _this.processColumn(), // column 内部交互
	            showMask: props.showMask, // fetchData 时的内部状态改变
	            pageSize: props.pageSize, // pagination 相关
	            currentPage: props.currentPage, // pagination 相关
	            activeColumn: null,
	            searchTxt: "",
	            passedData: null,
	            params: null,
	            selected: [],
	            expanded: false
	        };
	        return _this;
	    }

	    Table.prototype.componentWillMount = function componentWillMount() {
	        if (this.props.fetchDataOnMount) {
	            this.fetchData();
	        }
	    };

	    Table.prototype.componentDidMount = function componentDidMount() {
	        var me = this;
	        me.el = ReactDOM.findDOMNode(me);
	        if (!!me.state.data && !!me.state.data.datas) {
	            console.warn("Table: 'content.data' rather than 'content.datas' is recommended, the support for 'content.datas' will be end from ver. 1.5.0");
	        }
	        if (me.props.subComp) {
	            console.warn("Table: subComp is deprecated, use renderSubComp instead.");
	        }
	    };

	    Table.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
	        var me = this;
	        var newData = {};
	        if (!!nextProps.jsxdata && !!me.props.jsxdata && !me._isEqual(nextProps.jsxdata, me.props.jsxdata)) {
	            // Data has changed, so uid which is used to mark the data should be reset.
	            me.uid = 0;
	            newData['data'] = me.addValuesInData(deepcopy(nextProps.jsxdata));
	            me.data = deepcopy(newData['data']);
	        }
	        if (nextProps.pageSize != me.props.pageSize) {
	            newData['pageSize'] = nextProps.pageSize;
	        }
	        if (nextProps.currentPage != me.props.currentPage) {
	            newData['currentPage'] = nextProps.currentPage;
	        }
	        if (!!nextProps.jsxcolumns && !!me.props.jsxcolumns && !me._isEqual(nextProps.jsxcolumns, me.props.jsxcolumns)) {
	            newData['columns'] = me.processColumn(nextProps);
	        }
	        if (nextProps.showMask != me.props.showMask) {
	            newData['showMask'] = nextProps.showMask;
	        }
	        if (nextProps.fetchUrl !== me.props.fetchUrl) {
	            me.fetchData('urlChange');
	        }
	        me.setState(newData);
	    };

	    Table.prototype.componentWillUnmount = function componentWillUnmount() {
	        var me = this;
	    };

	    /**
	     * For inline edit
	     * receive changes from cell field and change state.data
	     * inform users of the change with dataKey & pass
	     */

	    Table.prototype.handleDataChange = function handleDataChange(obj) {
	        var me = this;
	        var jsxid = obj.jsxid;
	        var column = obj.column;
	        var value = obj.value;
	        var text = obj.text;
	        var pass = obj.pass;

	        var dataKey = column.dataKey;
	        var editKey = column.editKey || dataKey;
	        var data = deepcopy(me.state.data);
	        var changedData = {};
	        for (var i = 0; i < data.data.length; i++) {
	            if (data.data[i].jsxid == jsxid) {
	                data.data[i][dataKey] = text;
	                data.data[i][editKey] = value;
	                changedData = data.data[i];
	            }
	        }

	        me.setState({
	            data: data
	        }, function () {
	            me.props.onChange({
	                data: me.state.data,
	                editKey: editKey,
	                dataKey: dataKey,
	                changedData: changedData,
	                pass: pass
	            });
	        });
	    };

	    /**
	     * register CellField to Table for the global validation
	     * @param field {element} the cell field to be registered
	     */

	    Table.prototype.attachCellField = function attachCellField(validate, name) {
	        var me = this;
	        if (!name) {
	            console.error("Table: dataKey can not be undefined, check the column config");
	        } else {
	            me.fields[name] = validate;
	        }
	    };

	    /**
	     * cancel the CellField when it is unmounted.
	     * @param field {element} the cell field to be canceled.
	     */

	    Table.prototype.detachCellField = function detachCellField(name) {
	        delete this.fields[name];
	    };

	    /**
	     * simple method to compare two datas, 
	     * only support the data which JSON can parse.
	     */

	    Table.prototype._isEqual = function _isEqual(a, b) {
	        return deepEqual(a, b);
	    };

	    /**
	     * get Query Object by combining data from searchBar, column order, pagination
	     * and fetchParams.
	     * @param from {string} used in props.beforeFetch
	     */

	    Table.prototype.getQueryObj = function getQueryObj(from) {

	        var me = this,
	            queryObj = {};
	        if (me.props.passedData) {
	            var queryKeys = me.props.queryKeys;
	            if (!queryKeys) {
	                queryObj = me.props.passedData;
	            } else {
	                queryKeys.forEach(function (key) {
	                    if (me.props.passedData[key] !== undefined) {
	                        queryObj[key] = me.props.passedData[key];
	                    }
	                });
	            }
	        }

	        // pagination
	        queryObj = assign({}, queryObj, {
	            pageSize: me.state.pageSize,
	            currentPage: me.state.currentPage
	        });

	        // column order
	        var activeColumn = me.state.activeColumn;
	        var orderType = me.state.orderType;
	        if (!!activeColumn) {
	            queryObj = assign({}, queryObj, {
	                orderColumn: activeColumn.dataKey
	            });
	            if (!!orderType && orderType != 'none') {
	                queryObj.orderType = orderType;
	            }
	        }

	        // search query
	        var searchTxt = me.state.searchTxt;
	        if (!!searchTxt) {
	            queryObj = assign({}, queryObj, {
	                searchTxt: searchTxt
	            });
	        }

	        // fetchParams has the top priority
	        if (!!me.props.fetchParams) {
	            queryObj = assign({}, queryObj, me.props.fetchParams);
	        }

	        return me.props.beforeFetch(queryObj, from);
	    };

	    /**
	     * fetch Data via Ajax
	     * @param from {string} tell fetchData where it is invoked, the param will be 
	     * passed to props.beforeFetch in order to help the user.
	     */

	    Table.prototype.fetchData = function fetchData(from) {

	        var me = this;
	        // reset uid cause table data has changed
	        me.uid = 0;

	        // fetchUrl has the top priority.
	        if (!!me.props.fetchUrl) {
	            if (me.ajax) {
	                me.ajax.abort();
	            }
	            if (!me.state.showMask) {
	                me.setState({
	                    showMask: true
	                });
	            }
	            var ajaxOptions = {
	                url: me.props.fetchUrl,
	                data: me.getQueryObj(from),
	                cache: false,
	                dataType: "json",
	                success: function success(result) {
	                    if (result.success === true || result.hasError === false) {
	                        var _data = result.content;
	                        var processedData = me.addValuesInData(me.props.processData(deepcopy(_data)));
	                        var updateObj = {
	                            data: processedData,
	                            showMask: false
	                        };
	                        if (processedData.currentPage !== undefined) {
	                            updateObj.currentPage = processedData.currentPage;
	                        }
	                        me.data = deepcopy(processedData);
	                        me.setState(updateObj);
	                    } else {
	                        me.props.onFetchError(result);
	                    }
	                }
	            };

	            if (/\.jsonp/.test(me.props.fetchUrl)) {
	                ajaxOptions.dataType = "jsonp";
	            }

	            me.ajax = $.ajax(ajaxOptions);
	        } else if (!!me.props.passedData) {

	            if (!me.props.queryKeys) {
	                var data = me.addValuesInData(me.props.processData(deepcopy(me.props.passedData)));
	                me.setState({
	                    data: data
	                });
	                me.data = deepcopy(data);
	            } else {
	                (function () {
	                    var data = {};
	                    me.props.queryKeys.forEach(function (key, index) {
	                        if (me.props.passedData[key] !== undefined) {
	                            data[key] = me.props.passedData[key];
	                        }
	                    });
	                    var processedData = me.addValuesInData(me.props.processData(deepcopy(data)));
	                    me.setState({
	                        data: processedData
	                    });
	                    me.data = deepcopy(processedData);
	                })();
	            }
	        } else if (!!this.props.jsxdata) {
	            var data = this.addValuesInData(deepcopy(this.props.jsxdata));
	            me.setState({
	                data: data
	            });
	            me.data = deepcopy(data);
	        } else {
	            //default will create one row
	            var data = {
	                data: [{
	                    jsxid: me.uid++,
	                    __mode__: Const.MODE.EDIT
	                }],
	                "currentPage": 1,
	                "totalCount": 0
	            };
	            me.data = deepcopy(data);
	            me.setState({
	                "data": deepcopy(data)
	            });
	        }
	    };

	    Table.prototype.processColumn = function processColumn(props) {

	        props = props || this.props;

	        var me = this,
	            columns = deepcopy(props.jsxcolumns),
	            hasCheckboxColumn = false;

	        columns.forEach(function (item, i) {
	            // only one rowSelector can be rendered in Table.
	            if (item.type == 'checkbox' || item.type == 'radioSelector' || item.type == 'checkboxSelector') {
	                if (item.type == 'checkbox') {
	                    console.warn("rowSelector using 'type: checkbox' is deprecated, use 'type: checkboxSelector' instead.");
	                }
	                hasCheckboxColumn = true;
	                me.checkboxColumn = item;
	                me.checkboxColumnKey = item.dataKey;
	                item.width = item.width || 32;
	                item.align = item.align || 'right';
	            }
	        });

	        // filter the column which has a dataKey 'jsxchecked' & 'jsxtreeIcon'

	        columns = columns.filter(function (item) {
	            return item.dataKey !== 'jsxchecked' && item.dataKey !== 'jsxtreeIcon';
	        });

	        // if hidden is not set, it's false
	        columns = columns.map(function (item, index) {
	            item.hidden = !!item.hidden;
	            return item;
	        });

	        if (!!props.rowSelection & !hasCheckboxColumn) {
	            me.checkboxColumn = { dataKey: 'jsxchecked', width: 46, type: props.rowSelector, align: 'right' };
	            me.checkboxColumnKey = 'jsxchecked';

	            columns = [me.checkboxColumn].concat(columns);
	        }

	        // no rowSelection but has parentHasCheckbox, render placeholder
	        else if (!!props.parentHasCheckbox) {
	                columns = [{
	                    dataKey: 'jsxwhite',
	                    width: 46,
	                    type: 'empty'
	                }].concat(columns);
	            }

	        if ((!!props.subComp || !!props.renderSubComp) && props.renderModel !== 'tree') {
	            columns = [{
	                dataKey: 'jsxtreeIcon',
	                width: 34,
	                type: 'treeIcon'
	            }].concat(columns);
	        }
	        // no subComp but has passedData, means sub mode, parent should has tree icon,
	        // render tree icon placeholder
	        else if (!!props.passedData) {
	                columns = [{
	                    dataKey: 'jsxwhite',
	                    width: 34,
	                    type: 'empty'
	                }].concat(columns);
	            }

	        return columns;
	    };

	    Table.prototype.handleColumnPickerChange = function handleColumnPickerChange(checkedKeys) {
	        var _columns = deepcopy(this.state.columns);
	        var notRenderColumns = ['jsxchecked', 'jsxtreeIcon', 'jsxwhite'];

	        _columns.forEach(function (item, index) {
	            if ('group' in item) {
	                item.columns.forEach(function (ele, idx) {
	                    if (checkedKeys.indexOf(ele.dataKey) !== -1) {
	                        ele.hidden = false;
	                    } else {
	                        ele.hidden = true;
	                    }
	                });
	            } else {
	                if (checkedKeys.indexOf(item.dataKey) !== -1 || notRenderColumns.indexOf(item.dataKey) !== -1) {
	                    item.hidden = false;
	                } else {
	                    item.hidden = true;
	                }
	            }
	        });
	        this.setState({
	            columns: _columns
	        });
	    };

	    /**
	     * change SelectedRows data via checkbox, this function will pass to the Cell
	     * @param checked {boolean} the checkbox status
	     * @param rowIndex {number} the row Index
	     * @param fromMount {boolean} onSelect is called from cell Mount is not expected.
	     */

	    Table.prototype.changeSelected = function changeSelected(checked, rowIndex, fromMount) {

	        var me = this;
	        var _content = deepcopy(this.state.data);
	        var _data = _content.datas || _content.data;

	        me.checkboxColumn.type == 'radioSelector' ? _data.map(function (item, index) {
	            if (item.jsxid == rowIndex) {
	                item[me.checkboxColumnKey] = checked;
	                return item;
	            } else if (item[me.checkboxColumnKey]) {
	                item[me.checkboxColumnKey] = false;
	                return item;
	            }
	        }) : _data.map(function (item, index) {
	            if (item.jsxid == rowIndex) {
	                item[me.checkboxColumnKey] = checked;
	                return item;
	            }
	        });

	        me.setState({
	            data: _content
	        }, function () {
	            if (!fromMount) {
	                var data = me.state.data.datas || me.state.data.data;
	                var selectedRows = data.filter(function (item, index) {
	                    return item[me.checkboxColumnKey] == true;
	                });
	                !!me.props.rowSelection && !!me.props.rowSelection.onSelect && me.props.rowSelection.onSelect(checked, data[rowIndex], selectedRows);
	            }
	        });
	    };

	    Table.prototype.selectAll = function selectAll(checked) {

	        var me = this;
	        var _content = deepcopy(me.state.data);
	        var _data = _content.datas || _content.data;
	        var rowSelection = me.props.rowSelection;

	        var selectedRows = [];
	        _data = _data.forEach(function (item, index) {
	            var column = me.checkboxColumn;
	            var key = me.checkboxColumnKey;
	            if (!('isDisable' in column) || !column.isDisable(item)) {
	                item[key] = checked;
	                selectedRows.push(item);
	            }
	        });

	        if (!!rowSelection && !!rowSelection.onSelectAll) {
	            rowSelection.onSelectAll.apply(null, [checked, checked ? selectedRows : []]);
	        }
	        me.setState({
	            data: _content
	        });
	    };

	    Table.prototype.onPageChange = function onPageChange(current) {
	        var me = this;
	        me.setState({
	            currentPage: current
	        }, function () {
	            me.fetchData("pagination");
	        });
	    };

	    Table.prototype.handleShowSizeChange = function handleShowSizeChange(current, pageSize) {
	        var me = this;
	        me.setState({
	            currentPage: current,
	            pageSize: pageSize
	        }, function () {
	            me.fetchData("pagination");
	        });
	    };

	    Table.prototype.renderPager = function renderPager() {
	        var me = this;
	        var _me$state = me.state;
	        var data = _me$state.data;
	        var currentPage = _me$state.currentPage;
	        var pageSize = _me$state.pageSize;
	        var _me$props = me.props;
	        var showPagerTotal = _me$props.showPagerTotal;
	        var showPager = _me$props.showPager;
	        var locale = _me$props.locale;
	        var pagerSizeOptions = _me$props.pagerSizeOptions;


	        if (showPager && data && data.totalCount) {
	            return React.createElement(
	                "div",
	                { className: "kuma-uxtable-page" },
	                React.createElement(Pagination, { className: "mini", locale: locale, showSizeChanger: true, showTotal: showPagerTotal, total: data.totalCount, onShowSizeChange: me.handleShowSizeChange.bind(me),
	                    onChange: me.onPageChange.bind(me), current: currentPage, pageSize: pageSize, sizeOptions: pagerSizeOptions })
	            );
	        }
	    };

	    Table.prototype.handleOrderColumnCB = function handleOrderColumnCB(type, column) {
	        var me = this;
	        me.setState({
	            activeColumn: column,
	            orderType: type
	        }, function () {
	            me.fetchData("order");
	        });
	    };

	    Table.prototype.handleActionBarSearch = function handleActionBarSearch(value) {
	        var me = this;
	        this.setState({
	            searchTxt: value
	        }, function () {
	            me.fetchData("search");
	        });
	    };

	    Table.prototype.getData = function getData(validate) {
	        var me = this;
	        var pass = true;
	        if (validate !== false) {
	            for (name in me.fields) {
	                var fieldPass = me.fields[name]();

	                // if one field fails to pass, the table fails to pass
	                if (pass) {
	                    pass = fieldPass;
	                }
	            }
	        }
	        if (me.props.getSavedData) {
	            // 滤除可能为空的元素
	            var data = deepcopy(me.data);
	            data.data = data.data.filter(function (item) {
	                return item != undefined;
	            });
	            return {
	                data: data,
	                pass: pass
	            };
	        } else {
	            return {
	                data: me.state.data,
	                pass: pass
	            };
	        }
	    };

	    Table.prototype.hasFixColumn = function hasFixColumn() {
	        var props = this.props;
	        var _columns = props.jsxcolumns.filter(function (item) {
	            if (item.fixed) {
	                return true;
	            }
	        });
	        if (_columns.length > 0) {
	            return true;
	        }
	        return false;
	    };

	    Table.prototype.renderHeader = function renderHeader(renderHeaderProps) {

	        if (!this.props.showHeader) {
	            return;
	        }

	        if (this.hasFixColumn()) {
	            return React.createElement(
	                "div",
	                { className: "kuma-uxtable-header-wrapper" },
	                React.createElement(Header, _extends({}, renderHeaderProps, { fixedColumn: "fixed", key: "grid-header-fixed" })),
	                React.createElement(Header, _extends({}, renderHeaderProps, { fixedColumn: "scroll", key: "grid-header-scroll" }))
	            );
	        } else {
	            return React.createElement(
	                "div",
	                { className: "kuma-uxtable-header-wrapper" },
	                React.createElement(Header, _extends({}, renderHeaderProps, { fixedColumn: "no" }))
	            );
	        }
	    };

	    Table.prototype.renderTbody = function renderTbody(renderBodyProps, bodyHeight) {

	        if (this.hasFixColumn()) {
	            var subComp = renderBodyProps.subComp;

	            var fixedBodyProps = _objectWithoutProperties(renderBodyProps, ["subComp"]);

	            return React.createElement(
	                "div",
	                { className: "kuma-uxtable-body-wrapper", style: { height: bodyHeight } },
	                React.createElement(Tbody, _extends({}, fixedBodyProps, { fixedColumn: "fixed", key: "grid-body-fixed" })),
	                React.createElement(Tbody, _extends({}, renderBodyProps, { fixedColumn: "scroll", key: "grid-body-scroll" }))
	            );
	        } else {
	            return React.createElement(
	                "div",
	                { className: "kuma-uxtable-body-wrapper", style: { height: bodyHeight } },
	                React.createElement(Tbody, _extends({}, renderBodyProps, { fixedColumn: "no" }))
	            );
	        }
	    };

	    Table.prototype.getIsSelectAll = function getIsSelectAll(data) {
	        var me = this;
	        var column = me.checkboxColumn;
	        if (!column || data.length == 0) {
	            return false;
	        }
	        var key = me.checkboxColumnKey;
	        var isSelectAll = true;
	        for (var i = 0; i < data.length; i++) {
	            if ('isDisable' in column && column.isDisable(item) || column.disable) {
	                continue;
	            } else {
	                isSelectAll = data[i][key];
	                if (!isSelectAll) {
	                    break;
	                }
	            }
	        }
	        return isSelectAll;
	    };

	    Table.prototype.render = function render() {
	        var _classnames;

	        var me = this;
	        var props = this.props;
	        var state = this.state;

	        var bodyHeight = undefined;
	        // if table is in sub mode, people always want to align the parent
	        // and the sub table, so width should not be cared.
	        var headerHeight = props.headerHeight;


	        var data = state.data ? state.data.datas || state.data.data : [];
	        var isSelectAll = me.getIsSelectAll(data);

	        var _style = {
	            width: !!props.passedData ? "auto" : props.width,
	            height: props.height
	        };
	        var actionBarHeight = props.actionBar ? props.actionBarHeight : 0;
	        var pagerHeight = props.showPager && this.state.data && this.state.data.totalCount ? 50 : 0;

	        // decide whether the table has column groups
	        var hasGroup = false;
	        for (var i = 0; i < this.state.columns.length; i++) {
	            if ('group' in this.state.columns[i]) {
	                hasGroup = true;
	                break;
	            }
	        }

	        headerHeight = headerHeight || (hasGroup ? 80 : 40);

	        if (props.height == 'auto') {
	            bodyHeight = 'auto';
	        } else {
	            bodyHeight = props.height == "100%" ? props.height : props.height - headerHeight - actionBarHeight - pagerHeight;
	        }
	        var renderBodyProps = {
	            columns: state.columns,
	            mask: state.showMask,
	            data: data,
	            rowSelection: props.rowSelection,
	            addRowClassName: props.addRowClassName,
	            subComp: props.subComp,
	            renderSubComp: props.renderSubComp,
	            rowHeight: props.rowHeight,
	            loadingText: props.loadingText,
	            height: bodyHeight,
	            width: props.width,
	            mode: props.mode,
	            levels: props.levels,
	            root: this,
	            renderModel: props.renderModel,
	            changeSelected: this.changeSelected.bind(this),
	            handleDataChange: this.handleDataChange.bind(this),
	            attachCellField: this.attachCellField.bind(this),
	            detachCellField: this.detachCellField.bind(this),
	            key: 'grid-body'
	        },
	            renderHeaderProps = {
	            columns: state.columns,
	            activeColumn: state.activeColumn,
	            orderType: state.orderType,
	            showColumnPicker: props.showColumnPicker,
	            showHeaderBorder: props.showHeaderBorder,
	            headerHeight: props.headerHeight,
	            width: props.width,
	            mode: props.mode,
	            isSelectAll: isSelectAll,
	            selectAll: this.selectAll.bind(this),
	            orderColumnCB: this.handleOrderColumnCB.bind(this),
	            handleColumnPickerChange: this.handleColumnPickerChange.bind(this),
	            key: 'grid-header'
	        };

	        var actionBar = undefined;

	        if (props.actionBar || props.showSearch) {
	            var renderActionProps = {
	                onSearch: this.handleActionBarSearch.bind(this),
	                actionBarConfig: this.props.actionBar,
	                showSearch: this.props.showSearch,
	                searchBarPlaceholder: this.props.searchBarPlaceholder,
	                key: 'grid-actionbar'
	            };
	            actionBar = React.createElement(ActionBar, renderActionProps);
	        }

	        return React.createElement(
	            "div",
	            { className: classnames((_classnames = {}, _classnames[props.jsxprefixCls] = true, _classnames["kuma-subgrid-mode"] = !!props.passedData, _classnames)), style: _style },
	            actionBar,
	            React.createElement(
	                "div",
	                { className: "kuma-uxtable-content", style: { width: !!props.passedData ? "auto" : props.width } },
	                this.renderHeader(renderHeaderProps),
	                this.renderTbody(renderBodyProps, bodyHeight)
	            ),
	            this.renderPager()
	        );
	    };

	    ///////////////////////// Util Method /////////////////////////

	    /**
	     * add some specific value for each row data which will be used in manipulating data & rendering.
	     * used in record API.
	     */

	    Table.prototype.addJSXIdsForRecord = function addJSXIdsForRecord(objAux) {
	        var me = this;
	        if (objAux instanceof Array) {
	            objAux = objAux.map(function (item) {
	                if (item.jsxid == undefined || item.jsxid == null) {
	                    item.jsxid = me.uid++;
	                }
	                if (!item.__mode__) {
	                    item.__mode__ = Const.MODE.EDIT;
	                }
	                return item;
	            });
	        } else {
	            objAux.jsxid = me.uid++;
	        }
	        return objAux;
	    };

	    /**
	     * add some specific value for each row data which will be used in manipulating data & rendering.
	     * used in method fetchData
	     */

	    Table.prototype.addValuesInData = function addValuesInData(objAux) {
	        if (!objAux || !objAux.datas && !objAux.data) return;
	        var me = this;
	        var data = objAux.datas || objAux.data;
	        data.forEach(function (node) {
	            node.jsxid = me.uid++;
	            node.__mode__ = node.__mode__ || Const.MODE.VIEW;
	            me.addValuesInData(node);
	        });
	        return objAux;
	    };

	    /**
	     * merge data
	     */

	    Table.prototype.mergeData = function mergeData(data, obj) {
	        var newData = deepcopy(data);

	        // code compatible
	        if (!!newData.datas) {
	            newData.datas = newData.datas.concat(obj);
	        } else if (!!newData.data) {
	            newData.data = newData.data.concat(obj);
	        }
	        newData.totalCount++;
	        return newData;
	    };

	    /**
	     * insert some data into this.state.data
	     * @param objAux {Array or Object} datum or data need to be inserted
	     */

	    Table.prototype.insertRecords = function insertRecords(objAux) {
	        if ((typeof objAux === "undefined" ? "undefined" : _typeof(objAux)) !== "object") return;
	        var me = this;
	        if (!(objAux instanceof Array)) {
	            objAux = [objAux];
	        }

	        objAux = this.addJSXIdsForRecord(objAux);

	        // me.data = me.mergeData(me.data, objAux);
	        this.setState({
	            data: me.mergeData(me.state.data, objAux)
	        });
	    };

	    /**
	     * @param {objAux} {a:'b',c:'d',jsxid:''}
	     */


	    Table.prototype.updateRecord = function updateRecord(objAux, cb) {
	        var _data = this.state.data;

	        if (!_data) {
	            return;
	        }

	        if (_data.data || _data.datas) {
	            var data = _data.data || _data.datas;

	            data = data.map(function (item) {
	                if (item.jsxid == objAux.jsxid) {
	                    return objAux;
	                } else {
	                    return item;
	                }
	            });
	            if (!!_data.data) {
	                _data.data = data;
	            } else if (!!_data.datas) {
	                _data.datas = data;
	            }
	        }
	        this.setState({
	            data: _data
	        }, function () {
	            !!cb && cb();
	        });
	    };

	    Table.prototype.syncRecord = function syncRecord(objAux) {
	        var me = this;
	        var _data = me.data.data || me.data.datas;

	        me.updateRecord(objAux, function () {
	            var _stateData = me.state.data.data || me.state.data.datas;
	            // _data.forEach((item, index) => {
	            //     if (item.jsxid == objAux.jsxid) {
	            //         _data[index] = _stateData.filter((ele) => {
	            //             return ele.jsxid == objAux.jsxid
	            //         })[0];
	            //     }
	            // });
	            _stateData.forEach(function (item, index) {
	                if (item.jsxid == objAux.jsxid) {
	                    _data[index] = item;
	                }
	            });
	        });
	    };

	    Table.prototype.removeRecords = function removeRecords(objAux) {

	        //at least one record
	        var me = this;
	        var content = this.state.data;
	        var data = content.data || content.datas;

	        // deepcopy protect
	        var _content = deepcopy(content),
	            _data = _content.data || _content.datas;

	        if (Object.prototype.toString.call(objAux) !== "[object Array]") {
	            objAux = [objAux];
	        }

	        objAux.map(function (item) {
	            _data.forEach(function (element, index, array) {
	                if (element.jsxid == item.jsxid) {
	                    _data.splice(index, 1);
	                }
	            });
	        });

	        me.data = _content;

	        this.setState({
	            data: _content
	        });
	    };

	    //////////////////////// CURD for Table ////////////////

	    Table.prototype.addEmptyRow = function addEmptyRow() {
	        this.insertRecords({});
	    };

	    Table.prototype.addRow = function addRow(rowData) {
	        this.insertRecords(rowData);
	    };

	    Table.prototype.resetRow = function resetRow(rowData) {
	        var me = this;
	        var updateData = {};
	        var _data = me.data.datas || me.data.data;
	        for (var i = 0; i < _data.length; i++) {
	            if (_data[i].jsxid == rowData.jsxid) {
	                updateData = deepcopy(_data[i]);
	                break;
	            }
	        }
	        updateData['__mode__'] = Const.MODE.EDIT;
	        this.updateRecord(updateData);
	    };

	    Table.prototype.delRow = function delRow(rowData) {
	        this.removeRecords(rowData);
	    };

	    Table.prototype.editRow = function editRow(rowData) {
	        rowData.__mode__ = Const.MODE.EDIT;
	        this.updateRecord(rowData);
	    };

	    Table.prototype.viewRow = function viewRow(rowData) {
	        rowData.__mode__ = Const.MODE.VIEW;
	        this.updateRecord(rowData);
	    };

	    Table.prototype.saveRow = function saveRow(rowData) {
	        rowData.__mode__ = Const.MODE.VIEW;
	        rowData.__edited__ = true;
	        this.syncRecord(rowData);
	    };

	    Table.prototype.saveAllRow = function saveAllRow() {
	        var me = this;
	        var data = deepcopy(me.state.data.data || me.state.data.datas);
	        data.forEach(function (item) {
	            me.saveRow(item);
	        });
	    };

	    Table.prototype.editAllRow = function editAllRow() {
	        var me = this;
	        var data = deepcopy(me.data.data || me.data.datas);
	        data.forEach(function (item) {
	            me.editRow(item);
	        });
	    };

	    Table.prototype.toggleSubComp = function toggleSubComp(rowData) {
	        var _content = deepcopy(this.state.data);
	        var _data = _content.data || _content.datas;

	        if (_data) {
	            _data = _data.map(function (item) {
	                if (item.jsxid == rowData.jsxid) {
	                    item.showSubComp = !item.showSubComp;
	                    return item;
	                } else {
	                    return item;
	                }
	            });
	        }
	        this.setState({
	            data: _content
	        });
	    };

	    return Table;
	}(React.Component);

	;

	Table.defaultProps = {
	    jsxprefixCls: "kuma-uxtable",
	    locale: "zh-cn",
	    showHeader: true,
	    width: "auto",
	    height: "auto",
	    mode: Const.MODE.EDIT,
	    renderModel: '',
	    levels: 1,
	    actionBarHeight: 40,
	    fetchDataOnMount: true,
	    doubleClickToEdit: true,
	    rowSelector: 'checkboxSelector',
	    showPager: true,
	    showColumnPicker: true,
	    showHeaderBorder: false,
	    showPagerTotal: false,
	    showMask: false,
	    showSearch: false,
	    getSavedData: true,
	    pageSize: 10,
	    pagerSizeOptions: [10, 20, 30, 40],
	    rowHeight: 76,
	    fetchParams: {},
	    currentPage: 1,
	    queryKeys: [],
	    emptyText: "暂无数据",
	    searchBarPlaceholder: "搜索表格内容",
	    loadingText: "loading",
	    processData: function processData(data) {
	        return data;
	    },
	    beforeFetch: function beforeFetch(obj) {
	        return obj;
	    },
	    onFetchError: function onFetchError() {},
	    addRowClassName: function addRowClassName() {},
	    onChange: function onChange() {}
	};

	// http://facebook.github.io/react/docs/reusable-components.html
	Table.propTypes = {
	    /**
	     * @title 国际化
	     * @veFieldStyle block
	     */
	    locale: React.PropTypes.string,
	    /**
	     * @title 列配置
	     */
	    jsxcolumns: React.PropTypes.arrayOf(React.PropTypes.object),
	    /**
	     * @title 表格宽度
	     */
	    width: React.PropTypes.oneOfType([React.PropTypes.string, React.PropTypes.number]),
	    /**
	     * @title 表格高度
	     */
	    height: React.PropTypes.oneOfType([React.PropTypes.string, React.PropTypes.number]),
	    /**
	     * @title 表头高度
	     */
	    headerHeight: React.PropTypes.number,
	    /**
	     * @title 每页显示条数
	     * @veFieldStyle block
	     */
	    pageSize: React.PropTypes.number,
	    /**
	     * @title 哪些参数传递给 subComp (即将废除)
	     * @veIgnore
	     */
	    queryKeys: React.PropTypes.array,
	    /**
	     * @title 是否在初始化时请求数据
	     * @veFieldStyle block
	     */
	    fetchDataOnMount: React.PropTypes.bool,
	    /**
	     * @title 是否双击进入编辑模式
	     * @veFieldStyle block
	     */
	    doubleClickToEdit: React.PropTypes.bool,
	    /**
	     * @title 是否显示列选择器
	     * @veFieldStyle block
	     */
	    showColumnPicker: React.PropTypes.bool,
	    /**
	     * @title 是否显示分页
	     * @veFieldStyle block
	     */
	    showPager: React.PropTypes.bool,
	    /**
	     * @title 分页中是否显示总条数
	     * @veFieldStyle block
	     */
	    showPagerTotal: React.PropTypes.bool,
	    /**
	     * @title  显示的可选 pageSize
	     * @veFieldStyle block
	     */
	    pagerSizeOptions: React.PropTypes.array,
	    /**
	     * @title 是否显示表格头
	     * @veFieldStyle block
	     */
	    showHeader: React.PropTypes.bool,
	    /**
	     * @title 是否显示遮罩
	     * @veFieldStyle block
	     * @veIgnore
	     */
	    showMask: React.PropTypes.bool,
	    /**
	     * @title 是否显示搜索框
	     * @veFieldStyle block
	     */
	    showSearch: React.PropTypes.bool,
	    /**
	     * @title 搜索框占位符
	     * @veFieldStyle block
	     */
	    searchBarPlaceholder: React.PropTypes.string,
	    /**
	     * @title 加载中文案
	     * @veFieldStyle block
	     */
	    loadingText: React.PropTypes.string,
	    /**
	     * @title 子组件(即将废除)
	     * @veIgnore
	     */
	    subComp: React.PropTypes.element,
	    /**
	     * @title 无数据时的文案
	     * @veFieldStyle block
	     */
	    emptyText: React.PropTypes.oneOfType([React.PropTypes.string, React.PropTypes.element]),
	    /**
	     * @title 数据源（手动）
	     * @veFieldStyle block
	     */
	    jsxdata: React.PropTypes.object,
	    /**
	     * @title 数据源（url）
	     * @veFieldStyle block
	     */
	    fetchUrl: React.PropTypes.string,
	    /**
	     * @title 请求携带的参数
	     * @veFieldStyle block
	     */
	    fetchParams: React.PropTypes.object,
	    /**
	     * @title 列选择器的类型
	     * @veFieldStyle block
	     */
	    rowSelector: React.PropTypes.string,
	    /**
	     * @title 操作栏配置
	     * @veFieldStyle block
	     */
	    actionBar: React.PropTypes.oneOfType([React.PropTypes.array, React.PropTypes.object]),
	    /**
	     * @title 处理数据的回调
	     */
	    processData: React.PropTypes.func,
	    /**
	     * @title 发起请求前的回调
	     */
	    beforeFetch: React.PropTypes.func,
	    /**
	     * @title 请求出错时的回调
	     */
	    onFetchError: React.PropTypes.func,
	    /**
	     * @title 渲染每一行前用于添加特殊类名的回调
	     */
	    addRowClassName: React.PropTypes.func,
	    /**
	     * @veIgnore
	     */
	    passedData: React.PropTypes.object,
	    /**
	     * @title getData 获取的是否是保存之后的数据
	     */
	    getSavedData: React.PropTypes.bool,
	    /**
	     * @title 行内编辑时触发的回调
	     */
	    onChange: React.PropTypes.func,
	    /**
	     * @title 是否是树模式
	     * @veIgnore
	     */
	    renderModel: React.PropTypes.string,
	    /**
	     * @title 树的层级
	     * @veIgnore
	     */
	    levels: React.PropTypes.number
	};

	Table.displayName = "Table";
	Table.CellField = CellField;
	Table.Constants = Const;

	module.exports = Table;

/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	/**
	 * Created by xy on 15/4/13.
	 */
	var CheckBox = __webpack_require__(4);
	var assign = __webpack_require__(9);
	var Const = __webpack_require__(5);
	var Menu = __webpack_require__(10);
	var Dropdown = __webpack_require__(56);
	var Tooltip = __webpack_require__(107);
	var classnames = __webpack_require__(19);
	var React = __webpack_require__(7);
	var ReactDOM = __webpack_require__(8);

	var Header = function (_React$Component) {
	    _inherits(Header, _React$Component);

	    function Header(props) {
	        _classCallCheck(this, Header);

	        var _this = _possibleConstructorReturn(this, _React$Component.call(this, props));

	        _this.state = {
	            pickerDisplay: false
	        };
	        return _this;
	    }

	    Header.prototype.handleCheckBoxChange = function handleCheckBoxChange() {
	        var v = this.refs.checkbox.getValue();
	        this.props.selectAll.apply(null, [v]);
	    };

	    Header.prototype.handlePickerSelect = function handlePickerSelect(info) {
	        this.props.handleColumnPickerChange(info.selectedKeys);
	    };

	    Header.prototype.handlePickerDeselect = function handlePickerDeselect(info) {
	        this.props.handleColumnPickerChange(info.selectedKeys);
	    };

	    Header.prototype.handlePickerVisibleChange = function handlePickerVisibleChange(visible) {
	        this.setState({
	            pickerDisplay: visible
	        });
	    };

	    Header.prototype.handleColumnOrder = function handleColumnOrder(column) {
	        var me = this;
	        var _me$props = me.props;
	        var orderColumnCB = _me$props.orderColumnCB;
	        var activeColumn = _me$props.activeColumn;
	        var orderType = _me$props.orderType;

	        var type = 'desc';
	        var typeMap = {
	            desc: 'asc',
	            asc: 'none',
	            none: 'desc'
	        };
	        if (activeColumn && column.dataKey == activeColumn.dataKey && orderType) {
	            type = typeMap[orderType];
	        }
	        orderColumnCB && orderColumnCB(type, column);
	    };

	    Header.prototype.getSelectedKeys = function getSelectedKeys() {
	        var me = this;
	        var columns = me.props.columns;

	        var _columns = [];
	        var selectedKeys = [];
	        columns.forEach(function (item, index) {
	            if ('group' in item) {
	                _columns = _columns.concat(item.columns);
	            } else {
	                _columns.push(item);
	            }
	        });
	        _columns.forEach(function (item, index) {
	            if (!item.hidden) {
	                selectedKeys.push(item.dataKey);
	            }
	        });
	        return selectedKeys;
	    };

	    Header.prototype.renderColumnSelect = function renderColumnSelect() {
	        var me = this;
	        var columns = me.props.columns;

	        var notRenderColumns = ['jsxchecked', 'jsxtreeIcon', 'jsxwhite'];
	        var options = [];
	        columns.forEach(function (item, index) {
	            if (notRenderColumns.indexOf(item.dataKey) == -1) {
	                options.push(React.createElement(
	                    Menu.Item,
	                    { key: item.dataKey },
	                    item.title
	                ));
	            }
	        });
	        return React.createElement(
	            Menu,
	            { multiple: true, selectedKeys: me.getSelectedKeys(), onSelect: me.handlePickerSelect.bind(me), onDeselect: me.handlePickerDeselect.bind(me) },
	            options
	        );
	    };

	    Header.prototype.renderPicker = function renderPicker() {
	        var me = this;
	        var pickerDisplay = me.state.pickerDisplay;


	        var dropdownAlign = {
	            bottomRight: {
	                points: ['br', 'tr'],
	                overflow: {
	                    adjustX: 1,
	                    adjustY: 1
	                },
	                offset: [0, -4],
	                targetOffset: [0, 0]
	            }
	        };

	        return React.createElement(
	            'div',
	            { className: classnames({
	                    "kuma-column-picker-container": true,
	                    "hasGroup": me.hasGroup
	                }) },
	            React.createElement(
	                Dropdown,
	                { trigger: ['click'], overlay: me.renderColumnSelect(), visible: pickerDisplay, overlayClassName: 'kuma-uxtable-column-picker-dropdown',
	                    align: dropdownAlign, onVisibleChange: me.handlePickerVisibleChange.bind(me) },
	                React.createElement('i', { className: 'kuma-icon kuma-icon-target-list kuma-column-picker' })
	            )
	        );
	    };

	    Header.prototype.renderOrderIcon = function renderOrderIcon(column) {
	        var me = this;
	        var _me$props2 = me.props;
	        var orderType = _me$props2.orderType;
	        var activeColumn = _me$props2.activeColumn;

	        if (column.ordered) {
	            var _classnames, _classnames2;

	            var desc = "iconfontdown",
	                asc = "iconfontup";
	            return React.createElement(
	                'span',
	                { className: 'kuma-uxtable-h-sort', onClick: me.handleColumnOrder.bind(me, column) },
	                React.createElement('i', { className: classnames((_classnames = {}, _classnames['kuma-icon kuma-icon-' + asc] = true, _classnames['active'] = activeColumn && activeColumn.dataKey === column.dataKey && orderType == 'asc', _classnames)) }),
	                React.createElement('i', { className: classnames((_classnames2 = {}, _classnames2['kuma-icon kuma-icon-' + desc] = true, _classnames2['active'] = activeColumn && activeColumn.dataKey === column.dataKey && orderType == 'desc', _classnames2)) })
	            );
	        }
	    };

	    Header.prototype.renderMessageIcon = function renderMessageIcon(column) {
	        if (!column.message) return;
	        return React.createElement(
	            Tooltip,
	            { overlay: React.createElement(
	                    'div',
	                    { className: 'kuma-uxtable-column-message' },
	                    column.message
	                ) },
	            React.createElement('i', { className: 'kuma-icon kuma-icon-information' })
	        );
	    };

	    Header.prototype.renderColumn = function renderColumn(item, index, hasGroup, last) {
	        if (item.hidden) return;
	        var me = this;
	        var data = me.props.data;

	        var noBorderColumn = ['jsxchecked', 'jsxtreeIcon', 'jsxwhite'];
	        var _style = {
	            width: item.width ? item.width : 100,
	            textAlign: item.align ? item.align : "left"
	        };
	        var _v = undefined;

	        if (hasGroup) {
	            assign(_style, {
	                height: 100,
	                lineHeight: 100 + 'px'
	            });
	        }

	        if (item.type == 'checkbox' || item.type == 'checkboxSelector') {
	            assign(_style, {
	                paddingRight: 4,
	                paddingLeft: 12,
	                width: item.width ? item.width : 92,
	                borderRight: 'none'
	            });

	            var checkBoxProps = {
	                ref: 'checkbox',
	                jsxchecked: me.props.isSelectAll,
	                disable: me.props.mode !== Const.MODE.VIEW ? item.disable : true,
	                onchange: me.handleCheckBoxChange.bind(me)
	            };

	            _v = React.createElement(CheckBox, checkBoxProps);
	        } else {
	            _v = React.createElement(
	                'span',
	                { title: item.title },
	                item.title
	            );
	        }

	        if (noBorderColumn.indexOf(item.dataKey) !== -1 || last) {
	            assign(_style, {
	                borderRight: 'none'
	            });
	        }

	        return React.createElement(
	            'div',
	            { key: index, className: classnames({
	                    "kuma-uxtable-cell": true,
	                    "show-border": me.props.showHeaderBorder
	                }), style: _style },
	            _v,
	            me.renderMessageIcon(item),
	            me.renderOrderIcon(item)
	        );
	    };

	    Header.prototype.renderColumns = function renderColumns(_columns) {
	        var me = this;
	        var columns = _columns.map(function (item, index) {
	            var last = index == _columns.length - 1;
	            if ('group' in item) {
	                // First determine whether the group should be rendered, if all columns
	                // is hidden, the column group should not be rendered.
	                var shouldRenderGroup = item.columns.some(function (column, i) {
	                    return !column.hidden;
	                });
	                if (shouldRenderGroup) {
	                    return React.createElement(
	                        'div',
	                        { className: 'kuma-uxtable-header-column-group', key: index },
	                        React.createElement(
	                            'div',
	                            { className: 'kuma-uxtable-header-group-name' },
	                            item.group
	                        ),
	                        item.columns.map(function (column, i) {
	                            return me.renderColumn(column, i, false, last);
	                        })
	                    );
	                }
	            } else {
	                return me.renderColumn(item, index, me.hasGroup, last);
	            }
	        });
	        return columns;
	    };

	    Header.prototype.render = function render() {
	        var props = this.props,
	            me = this,
	            _picker = undefined,
	            _width = 0,
	            headerWrapClassName = undefined,
	            _headerStyle = {},
	            _columns = undefined;

	        if (props.showColumnPicker && (props.fixedColumn == 'no' || props.fixedColumn == 'scroll')) {
	            _picker = this.renderPicker();
	        }

	        if (props.fixedColumn == 'fixed') {
	            _columns = props.columns.filter(function (item) {
	                if (item.fixed && !item.hidden) {
	                    if (!item.width) {
	                        item.width = 100;
	                    }
	                    _width = item.width * 1 + _width;
	                    return true;
	                }
	            });
	            assign(_headerStyle, {
	                width: _width,
	                minWidth: _width
	            });
	            headerWrapClassName = "kuma-uxtable-header-fixed";
	        } else if (props.fixedColumn == 'scroll') {
	            _columns = props.columns.filter(function (item) {
	                if (!item.fixed) {
	                    return true;
	                } else if (!item.hidden) {
	                    if (!item.width) {
	                        item.width = 100;
	                    }
	                    _width = item.width * 1 + _width;
	                }
	            });
	            assign(_headerStyle, {
	                width: props.width - _width - 3,
	                minWidth: props.width - _width - 3
	            });
	            headerWrapClassName = "kuma-uxtable-header-scroll";
	        } else {
	            _columns = props.columns;
	            headerWrapClassName = "kuma-uxtable-header-no";
	        }
	        me.hasGroup = false;
	        for (var i = 0; i < _columns.length; i++) {
	            if ('group' in _columns[i]) {
	                me.hasGroup = true;
	                break;
	            }
	        }
	        assign(_headerStyle, {
	            height: props.headerHeight ? props.headerHeight : me.hasGroup ? 80 : 50,
	            lineHeight: (props.headerHeight ? props.headerHeight : 50) + "px"
	        });
	        return React.createElement(
	            'div',
	            { className: headerWrapClassName, style: _headerStyle },
	            React.createElement(
	                'div',
	                { className: props.jsxprefixCls },
	                me.renderColumns(_columns),
	                _picker
	            )
	        );
	    };

	    return Header;
	}(React.Component);

	;

	Header.propTypes = {};

	Header.defaultProps = {
	    jsxprefixCls: "kuma-uxtable-header"
	};

	module.exports = Header;

/***/ },
/* 4 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	/**
	 * A checkbox field
	 */

	var Const = __webpack_require__(5);
	var React = __webpack_require__(7);
	var ReactDOM = __webpack_require__(8);

	var CheckBox = function (_React$Component) {
	    _inherits(CheckBox, _React$Component);

	    function CheckBox(props) {
	        _classCallCheck(this, CheckBox);

	        return _possibleConstructorReturn(this, _React$Component.call(this, props));
	    }

	    CheckBox.prototype.handleChange = function handleChange(e) {
	        var v = this.getValue();
	        v = v ? 'checked' : '';
	        this.props.onchange.apply(null, [e]);
	    };

	    CheckBox.prototype.getValue = function getValue() {
	        return this.refs.checkbox.checked;
	    };

	    CheckBox.prototype.render = function render() {

	        var props = this.props;

	        if (props.mode !== Const.MODE.VIEW) {
	            var renderProps = {
	                className: "kuma-checkbox",
	                checked: this.props.jsxchecked,
	                onChange: this.handleChange.bind(this)
	            };
	            if (!!props.disable) {
	                renderProps.disabled = true;
	            }
	            return React.createElement(
	                'label',
	                { className: 'kuma-uxtable-row-selector' },
	                React.createElement('input', _extends({ type: 'checkbox', ref: 'checkbox' }, renderProps)),
	                React.createElement('s', null)
	            );
	        } else {

	            var renderProps = {
	                className: "kuma-checkbox",
	                checked: this.props.jsxchecked,
	                disabled: true
	            };
	            return React.createElement(
	                'label',
	                { className: 'kuma-uxtable-row-selector' },
	                React.createElement('input', _extends({ type: 'checkbox', ref: 'checkbox' }, renderProps)),
	                React.createElement('s', null)
	            );
	        }
	    };

	    return CheckBox;
	}(React.Component);

	;

	CheckBox.propTypes = {};

	CheckBox.defaultProps = {};

	exports["default"] = CheckBox;
	module.exports = exports['default'];

/***/ },
/* 5 */
[542, 6],
/* 6 */
/***/ function(module, exports) {

	'use strict';

	/**
	 * Const Component for uxcore
	 * @author zhouquan.yezq
	 *
	 * Copyright 2014-2015, Uxcore Team, Alinw.
	 * All rights reserved.
	 */

	var Const = {
	  MODE: {
	    VIEW: 'view',
	    EDIT: 'edit'
	  },
	  ENV: {
	    DEBUG: 'debug',
	    LIVE: 'live'
	  }
	};

	module.exports = Const;

/***/ },
/* 7 */
/***/ function(module, exports) {

	module.exports = window.React;

/***/ },
/* 8 */
/***/ function(module, exports) {

	module.exports = window.ReactDOM || window.React;

/***/ },
/* 9 */
/***/ function(module, exports) {

	'use strict';
	/* eslint-disable no-unused-vars */
	var hasOwnProperty = Object.prototype.hasOwnProperty;
	var propIsEnumerable = Object.prototype.propertyIsEnumerable;

	function toObject(val) {
		if (val === null || val === undefined) {
			throw new TypeError('Object.assign cannot be called with null or undefined');
		}

		return Object(val);
	}

	function shouldUseNative() {
		try {
			if (!Object.assign) {
				return false;
			}

			// Detect buggy property enumeration order in older V8 versions.

			// https://bugs.chromium.org/p/v8/issues/detail?id=4118
			var test1 = new String('abc');  // eslint-disable-line
			test1[5] = 'de';
			if (Object.getOwnPropertyNames(test1)[0] === '5') {
				return false;
			}

			// https://bugs.chromium.org/p/v8/issues/detail?id=3056
			var test2 = {};
			for (var i = 0; i < 10; i++) {
				test2['_' + String.fromCharCode(i)] = i;
			}
			var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
				return test2[n];
			});
			if (order2.join('') !== '0123456789') {
				return false;
			}

			// https://bugs.chromium.org/p/v8/issues/detail?id=3056
			var test3 = {};
			'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
				test3[letter] = letter;
			});
			if (Object.keys(Object.assign({}, test3)).join('') !==
					'abcdefghijklmnopqrst') {
				return false;
			}

			return true;
		} catch (e) {
			// We don't expect any of the above to throw, but better to be safe.
			return false;
		}
	}

	module.exports = shouldUseNative() ? Object.assign : function (target, source) {
		var from;
		var to = toObject(target);
		var symbols;

		for (var s = 1; s < arguments.length; s++) {
			from = Object(arguments[s]);

			for (var key in from) {
				if (hasOwnProperty.call(from, key)) {
					to[key] = from[key];
				}
			}

			if (Object.getOwnPropertySymbols) {
				symbols = Object.getOwnPropertySymbols(from);
				for (var i = 0; i < symbols.length; i++) {
					if (propIsEnumerable.call(from, symbols[i])) {
						to[symbols[i]] = from[symbols[i]];
					}
				}
			}
		}

		return to;
	};


/***/ },
/* 10 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	/**
	 * Menu Component for uxcore
	 * @author vincent.bian
	 *
	 * Copyright 2014-2015, Uxcore Team, Alinw.
	 * All rights reserved.
	 */

	module.exports = __webpack_require__(11);

/***/ },
/* 11 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _react = __webpack_require__(7);

	var _react2 = _interopRequireDefault(_react);

	var _rcMenu = __webpack_require__(12);

	var _rcMenu2 = _interopRequireDefault(_rcMenu);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Menu Component for uxcore
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @author vincent.bian
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Copyright 2014-2015, Uxcore Team, Alinw.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * All rights reserved.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */


	var Menu = function (_React$Component) {
	    _inherits(Menu, _React$Component);

	    function Menu() {
	        _classCallCheck(this, Menu);

	        return _possibleConstructorReturn(this, _React$Component.apply(this, arguments));
	    }

	    Menu.prototype.render = function render() {
	        if (this.props.mode === 'inline') {
	            return _react2["default"].createElement(_rcMenu2["default"], this.props);
	        } else {
	            return _react2["default"].createElement(_rcMenu2["default"], this.props);
	        }
	    };

	    return Menu;
	}(_react2["default"].Component);

	Menu.defaultProps = {
	    prefixCls: 'kuma-menu'
	};
	Menu.propTypes = {
	    prefixCls: _react2["default"].PropTypes.string
	};

	Menu.SubMenu = _rcMenu.SubMenu;
	Menu.Item = _rcMenu.Item;
	Menu.Divider = _rcMenu.Divider;

	exports["default"] = Menu;
	module.exports = exports['default'];

/***/ },
/* 12 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	  value: true
	});

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var _Menu = __webpack_require__(13);

	var _Menu2 = _interopRequireDefault(_Menu);

	var _SubMenu = __webpack_require__(41);

	var _SubMenu2 = _interopRequireDefault(_SubMenu);

	var _MenuItem = __webpack_require__(53);

	var _MenuItem2 = _interopRequireDefault(_MenuItem);

	var _MenuItemGroup = __webpack_require__(54);

	var _MenuItemGroup2 = _interopRequireDefault(_MenuItemGroup);

	var _Divider = __webpack_require__(55);

	var _Divider2 = _interopRequireDefault(_Divider);

	exports.SubMenu = _SubMenu2['default'];
	exports.Item = _MenuItem2['default'];
	exports.MenuItem = _MenuItem2['default'];
	exports.MenuItemGroup = _MenuItemGroup2['default'];
	exports.ItemGroup = _MenuItemGroup2['default'];
	exports.Divider = _Divider2['default'];
	exports['default'] = _Menu2['default'];

/***/ },
/* 13 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	  value: true
	});

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var _react = __webpack_require__(7);

	var _react2 = _interopRequireDefault(_react);

	var _MenuMixin = __webpack_require__(14);

	var _MenuMixin2 = _interopRequireDefault(_MenuMixin);

	var _objectAssign = __webpack_require__(9);

	var _objectAssign2 = _interopRequireDefault(_objectAssign);

	var _util = __webpack_require__(39);

	var Menu = _react2['default'].createClass({
	  displayName: 'Menu',

	  propTypes: {
	    openSubMenuOnMouseEnter: _react2['default'].PropTypes.bool,
	    closeSubMenuOnMouseLeave: _react2['default'].PropTypes.bool,
	    selectedKeys: _react2['default'].PropTypes.arrayOf(_react2['default'].PropTypes.string),
	    defaultSelectedKeys: _react2['default'].PropTypes.arrayOf(_react2['default'].PropTypes.string),
	    defaultOpenKeys: _react2['default'].PropTypes.arrayOf(_react2['default'].PropTypes.string),
	    openKeys: _react2['default'].PropTypes.arrayOf(_react2['default'].PropTypes.string),
	    mode: _react2['default'].PropTypes.string,
	    onClick: _react2['default'].PropTypes.func,
	    onSelect: _react2['default'].PropTypes.func,
	    onDeselect: _react2['default'].PropTypes.func,
	    onDestroy: _react2['default'].PropTypes.func,
	    openTransitionName: _react2['default'].PropTypes.string,
	    openAnimation: _react2['default'].PropTypes.oneOfType([_react2['default'].PropTypes.string, _react2['default'].PropTypes.object]),
	    level: _react2['default'].PropTypes.number,
	    eventKey: _react2['default'].PropTypes.string,
	    selectable: _react2['default'].PropTypes.bool,
	    children: _react2['default'].PropTypes.any
	  },

	  mixins: [_MenuMixin2['default']],

	  getDefaultProps: function getDefaultProps() {
	    return {
	      openSubMenuOnMouseEnter: true,
	      closeSubMenuOnMouseLeave: true,
	      selectable: true,
	      onClick: _util.noop,
	      onSelect: _util.noop,
	      onOpen: _util.noop,
	      onClose: _util.noop,
	      onDeselect: _util.noop,
	      defaultSelectedKeys: [],
	      defaultOpenKeys: []
	    };
	  },

	  getInitialState: function getInitialState() {
	    var props = this.props;
	    var selectedKeys = props.defaultSelectedKeys;
	    var openKeys = props.defaultOpenKeys;
	    if ('selectedKeys' in props) {
	      selectedKeys = props.selectedKeys || [];
	    }
	    if ('openKeys' in props) {
	      openKeys = props.openKeys || [];
	    }
	    return {
	      selectedKeys: selectedKeys, openKeys: openKeys
	    };
	  },

	  componentWillReceiveProps: function componentWillReceiveProps(nextProps) {
	    var props = {};
	    if ('selectedKeys' in nextProps) {
	      props.selectedKeys = nextProps.selectedKeys;
	    }
	    if ('openKeys' in nextProps) {
	      props.openKeys = nextProps.openKeys;
	    }
	    this.setState(props);
	  },

	  onDestroy: function onDestroy(key) {
	    var state = this.state;
	    var props = this.props;
	    var selectedKeys = state.selectedKeys;
	    var openKeys = state.openKeys;
	    var index = selectedKeys.indexOf(key);
	    if (!('selectedKeys' in props) && index !== -1) {
	      selectedKeys.splice(index, 1);
	    }
	    index = openKeys.indexOf(key);
	    if (!('openKeys' in props) && index !== -1) {
	      openKeys.splice(index, 1);
	    }
	  },

	  onItemHover: function onItemHover(e) {
	    var _this = this;

	    var item = e.item;

	    // special for top sub menu
	    if (this.props.mode !== 'inline' && !this.props.closeSubMenuOnMouseLeave && item.isSubMenu) {
	      (function () {
	        var activeKey = _this.state.activeKey;
	        var activeItem = _this.getFlatInstanceArray().filter(function (c) {
	          return c && c.props.eventKey === activeKey;
	        })[0];
	        if (activeItem && activeItem.props.open) {
	          _this.onOpenChange({
	            key: item.props.eventKey,
	            item: e.item,
	            open: true
	          });
	        }
	      })();
	    }

	    this.onCommonItemHover(e);
	  },

	  onSelect: function onSelect(selectInfo) {
	    var props = this.props;
	    if (props.selectable) {
	      // root menu
	      var selectedKeys = this.state.selectedKeys;
	      var selectedKey = selectInfo.key;
	      if (props.multiple) {
	        selectedKeys = selectedKeys.concat([selectedKey]);
	      } else {
	        selectedKeys = [selectedKey];
	      }
	      if (!('selectedKeys' in props)) {
	        this.setState({
	          selectedKeys: selectedKeys
	        });
	      }
	      props.onSelect((0, _objectAssign2['default'])({}, selectInfo, {
	        selectedKeys: selectedKeys
	      }));
	    }
	  },

	  onClick: function onClick(e) {
	    var props = this.props;
	    props.onClick(e);
	  },

	  onOpenChange: function onOpenChange(e) {
	    var openKeys = this.state.openKeys;
	    var props = this.props;
	    var changed = true;
	    if (e.open) {
	      changed = openKeys.indexOf(e.key) === -1;
	      if (changed) {
	        openKeys = openKeys.concat(e.key);
	      }
	    } else {
	      var index = openKeys.indexOf(e.key);
	      changed = index !== -1;
	      if (changed) {
	        openKeys = openKeys.concat();
	        openKeys.splice(index, 1);
	      }
	    }
	    if (changed) {
	      if (!('openKeys' in this.props)) {
	        // hack: batch does not update state
	        this.state.openKeys = openKeys;
	        this.setState({ openKeys: openKeys });
	      }
	      var info = (0, _objectAssign2['default'])({ openKeys: openKeys }, e);
	      if (e.open) {
	        props.onOpen(info);
	      } else {
	        props.onClose(info);
	      }
	    }
	  },

	  onDeselect: function onDeselect(selectInfo) {
	    var props = this.props;
	    if (props.selectable) {
	      var selectedKeys = this.state.selectedKeys.concat();
	      var selectedKey = selectInfo.key;
	      var index = selectedKeys.indexOf(selectedKey);
	      if (index !== -1) {
	        selectedKeys.splice(index, 1);
	      }
	      if (!('selectedKeys' in props)) {
	        this.setState({
	          selectedKeys: selectedKeys
	        });
	      }
	      props.onDeselect((0, _objectAssign2['default'])({}, selectInfo, {
	        selectedKeys: selectedKeys
	      }));
	    }
	  },

	  getOpenTransitionName: function getOpenTransitionName() {
	    var props = this.props;
	    var transitionName = props.openTransitionName;
	    var animationName = props.openAnimation;
	    if (!transitionName && typeof animationName === 'string') {
	      transitionName = props.prefixCls + '-open-' + animationName;
	    }
	    return transitionName;
	  },

	  isInlineMode: function isInlineMode() {
	    return this.props.mode === 'inline';
	  },

	  lastOpenSubMenu: function lastOpenSubMenu() {
	    var _this2 = this;

	    var lastOpen = [];
	    if (this.state.openKeys.length) {
	      lastOpen = this.getFlatInstanceArray().filter(function (c) {
	        return c && _this2.state.openKeys.indexOf(c.props.eventKey) !== -1;
	      });
	    }
	    return lastOpen[0];
	  },

	  renderMenuItem: function renderMenuItem(c, i, subIndex) {
	    var key = (0, _util.getKeyFromChildrenIndex)(c, this.props.eventKey, i);
	    var state = this.state;
	    var extraProps = {
	      openKeys: state.openKeys,
	      open: state.openKeys.indexOf(key) !== -1,
	      selectedKeys: state.selectedKeys,
	      selected: state.selectedKeys.indexOf(key) !== -1,
	      openSubMenuOnMouseEnter: this.props.openSubMenuOnMouseEnter
	    };
	    return this.renderCommonMenuItem(c, i, subIndex, extraProps);
	  },

	  render: function render() {
	    var props = (0, _objectAssign2['default'])({}, this.props);
	    props.className += ' ' + props.prefixCls + '-root';
	    return this.renderRoot(props);
	  }
	});

	exports['default'] = Menu;
	module.exports = exports['default'];

/***/ },
/* 14 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	  value: true
	});

	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

	var _react = __webpack_require__(7);

	var _react2 = _interopRequireDefault(_react);

	var _reactDom = __webpack_require__(8);

	var _reactDom2 = _interopRequireDefault(_reactDom);

	var _rcUtil = __webpack_require__(15);

	var _classnames = __webpack_require__(19);

	var _classnames2 = _interopRequireDefault(_classnames);

	var _domScrollIntoView = __webpack_require__(36);

	var _domScrollIntoView2 = _interopRequireDefault(_domScrollIntoView);

	var _objectAssign = __webpack_require__(9);

	var _objectAssign2 = _interopRequireDefault(_objectAssign);

	var _util = __webpack_require__(39);

	var _DOMWrap = __webpack_require__(40);

	var _DOMWrap2 = _interopRequireDefault(_DOMWrap);

	function allDisabled(arr) {
	  if (!arr.length) {
	    return true;
	  }
	  return arr.every(function (c) {
	    return !!c.props.disabled;
	  });
	}

	function getActiveKey(props, originalActiveKey) {
	  var activeKey = originalActiveKey;
	  var children = props.children;
	  var eventKey = props.eventKey;
	  if (activeKey) {
	    var found = undefined;
	    (0, _util.loopMenuItem)(children, function (c, i) {
	      if (!c.props.disabled && activeKey === (0, _util.getKeyFromChildrenIndex)(c, eventKey, i)) {
	        found = true;
	      }
	    });
	    if (found) {
	      return activeKey;
	    }
	  }
	  activeKey = null;
	  if (props.defaultActiveFirst) {
	    (0, _util.loopMenuItem)(children, function (c, i) {
	      if (!activeKey && !c.props.disabled) {
	        activeKey = (0, _util.getKeyFromChildrenIndex)(c, eventKey, i);
	      }
	    });
	    return activeKey;
	  }
	  return activeKey;
	}

	function saveRef(index, subIndex, c) {
	  if (c) {
	    if (subIndex !== undefined) {
	      this.instanceArray[index] = this.instanceArray[index] || [];
	      this.instanceArray[index][subIndex] = c;
	    } else {
	      this.instanceArray[index] = c;
	    }
	  }
	}

	var MenuMixin = {
	  propTypes: {
	    focusable: _react2['default'].PropTypes.bool,
	    multiple: _react2['default'].PropTypes.bool,
	    style: _react2['default'].PropTypes.object,
	    defaultActiveFirst: _react2['default'].PropTypes.bool,
	    visible: _react2['default'].PropTypes.bool,
	    activeKey: _react2['default'].PropTypes.string,
	    selectedKeys: _react2['default'].PropTypes.arrayOf(_react2['default'].PropTypes.string),
	    defaultSelectedKeys: _react2['default'].PropTypes.arrayOf(_react2['default'].PropTypes.string),
	    defaultOpenKeys: _react2['default'].PropTypes.arrayOf(_react2['default'].PropTypes.string),
	    openKeys: _react2['default'].PropTypes.arrayOf(_react2['default'].PropTypes.string),
	    children: _react2['default'].PropTypes.any
	  },

	  getDefaultProps: function getDefaultProps() {
	    return {
	      prefixCls: 'rc-menu',
	      className: '',
	      mode: 'vertical',
	      level: 1,
	      inlineIndent: 24,
	      visible: true,
	      focusable: true,
	      style: {}
	    };
	  },

	  getInitialState: function getInitialState() {
	    var props = this.props;
	    return {
	      activeKey: getActiveKey(props, props.activeKey)
	    };
	  },

	  componentWillReceiveProps: function componentWillReceiveProps(nextProps) {
	    var props = undefined;
	    if ('activeKey' in nextProps) {
	      props = {
	        activeKey: getActiveKey(nextProps, nextProps.activeKey)
	      };
	    } else {
	      var originalActiveKey = this.state.activeKey;
	      var activeKey = getActiveKey(nextProps, originalActiveKey);
	      // fix: this.setState(), parent.render(),
	      if (activeKey !== originalActiveKey) {
	        props = {
	          activeKey: activeKey
	        };
	      }
	    }
	    if (props) {
	      this.setState(props);
	    }
	  },

	  shouldComponentUpdate: function shouldComponentUpdate(nextProps) {
	    return this.props.visible || nextProps.visible;
	  },

	  componentWillMount: function componentWillMount() {
	    this.instanceArray = [];
	  },

	  // all keyboard events callbacks run from here at first
	  onKeyDown: function onKeyDown(e) {
	    var _this = this;

	    var keyCode = e.keyCode;
	    var handled = undefined;
	    this.getFlatInstanceArray().forEach(function (obj) {
	      if (obj && obj.props.active) {
	        handled = obj.onKeyDown(e);
	      }
	    });
	    if (handled) {
	      return 1;
	    }
	    var activeItem = null;
	    if (keyCode === _rcUtil.KeyCode.UP || keyCode === _rcUtil.KeyCode.DOWN) {
	      activeItem = this.step(keyCode === _rcUtil.KeyCode.UP ? -1 : 1);
	    }
	    if (activeItem) {
	      e.preventDefault();
	      this.setState({
	        activeKey: activeItem.props.eventKey
	      }, function () {
	        (0, _domScrollIntoView2['default'])(_reactDom2['default'].findDOMNode(activeItem), _reactDom2['default'].findDOMNode(_this), {
	          onlyScrollIfNeeded: true
	        });
	      });
	      return 1;
	    } else if (activeItem === undefined) {
	      e.preventDefault();
	      this.setState({
	        activeKey: null
	      });
	      return 1;
	    }
	  },

	  onCommonItemHover: function onCommonItemHover(e) {
	    var mode = this.props.mode;
	    var key = e.key;
	    var hover = e.hover;
	    var trigger = e.trigger;

	    var activeKey = this.state.activeKey;
	    if (!trigger || hover || this.props.closeSubMenuOnMouseLeave || !e.item.isSubMenu || mode === 'inline') {
	      this.setState({
	        activeKey: hover ? key : null
	      });
	    } else {}
	    // keep active for sub menu for click active
	    // empty

	    // clear last open status
	    if (hover && mode !== 'inline') {
	      var activeItem = this.getFlatInstanceArray().filter(function (c) {
	        return c && c.props.eventKey === activeKey;
	      })[0];
	      if (activeItem && activeItem.isSubMenu && activeItem.props.eventKey !== key) {
	        this.onOpenChange({
	          item: activeItem,
	          key: activeItem.props.eventKey,
	          open: false
	        });
	      }
	    }
	  },

	  getFlatInstanceArray: function getFlatInstanceArray() {
	    var instanceArray = this.instanceArray;
	    var hasInnerArray = instanceArray.some(function (a) {
	      return Array.isArray(a);
	    });
	    if (hasInnerArray) {
	      instanceArray = [];
	      this.instanceArray.forEach(function (a) {
	        if (Array.isArray(a)) {
	          instanceArray.push.apply(instanceArray, a);
	        } else {
	          instanceArray.push(a);
	        }
	      });
	      this.instanceArray = instanceArray;
	    }
	    return instanceArray;
	  },

	  renderCommonMenuItem: function renderCommonMenuItem(child, i, subIndex, extraProps) {
	    var state = this.state;
	    var props = this.props;
	    var key = (0, _util.getKeyFromChildrenIndex)(child, props.eventKey, i);
	    var childProps = child.props;
	    var newChildProps = (0, _objectAssign2['default'])({
	      mode: props.mode,
	      level: props.level,
	      inlineIndent: props.inlineIndent,
	      renderMenuItem: this.renderMenuItem,
	      rootPrefixCls: props.prefixCls,
	      index: i,
	      parentMenu: this,
	      ref: childProps.disabled ? undefined : (0, _rcUtil.createChainedFunction)(child.ref, saveRef.bind(this, i, subIndex)),
	      eventKey: key,
	      closeSubMenuOnMouseLeave: props.closeSubMenuOnMouseLeave,
	      onItemHover: this.onItemHover,
	      active: !childProps.disabled && key === state.activeKey,
	      multiple: props.multiple,
	      onClick: this.onClick,
	      openTransitionName: this.getOpenTransitionName(),
	      openAnimation: props.openAnimation,
	      onOpenChange: this.onOpenChange,
	      onDeselect: this.onDeselect,
	      onDestroy: this.onDestroy,
	      onSelect: this.onSelect
	    }, extraProps);
	    if (props.mode === 'inline') {
	      newChildProps.closeSubMenuOnMouseLeave = newChildProps.openSubMenuOnMouseEnter = false;
	    }
	    return _react2['default'].cloneElement(child, newChildProps);
	  },

	  renderRoot: function renderRoot(props) {
	    var _classes;

	    this.instanceArray = [];
	    var classes = (_classes = {}, _defineProperty(_classes, props.prefixCls, 1), _defineProperty(_classes, props.prefixCls + '-' + props.mode, 1), _defineProperty(_classes, props.className, !!props.className), _classes);
	    var domProps = {
	      className: (0, _classnames2['default'])(classes),
	      role: 'menu',
	      'aria-activedescendant': ''
	    };
	    if (props.id) {
	      domProps.id = props.id;
	    }
	    if (props.focusable) {
	      domProps.tabIndex = '0';
	      domProps.onKeyDown = this.onKeyDown;
	    }
	    return(
	      // ESLint is not smart enough to know that the type of `children` was checked.
	      /* eslint-disable */
	      _react2['default'].createElement(
	        _DOMWrap2['default'],
	        _extends({ style: props.style,
	          tag: 'ul',
	          hiddenClassName: props.prefixCls + '-hidden',
	          visible: props.visible
	        }, domProps),
	        _react2['default'].Children.map(props.children, this.renderMenuItem)
	      )
	      /*eslint-enable */

	    );
	  },

	  step: function step(direction) {
	    var children = this.getFlatInstanceArray();
	    var activeKey = this.state.activeKey;
	    var len = children.length;
	    if (direction < 0) {
	      children = children.concat().reverse();
	    }
	    // find current activeIndex
	    var activeIndex = -1;
	    children.every(function (c, ci) {
	      if (c && c.props.eventKey === activeKey) {
	        activeIndex = ci;
	        return false;
	      }
	      return true;
	    });
	    if (!this.props.defaultActiveFirst && activeIndex !== -1) {
	      if (allDisabled(children.slice(activeIndex, len - 1))) {
	        return undefined;
	      }
	    }
	    var start = (activeIndex + 1) % len;
	    var i = start;
	    for (;;) {
	      var child = children[i];
	      if (!child || child.props.disabled) {
	        i = (i + 1 + len) % len;
	        // complete a loop
	        if (i === start) {
	          return null;
	        }
	      } else {
	        return child;
	      }
	    }
	  }
	};

	exports['default'] = MenuMixin;
	module.exports = exports['default'];

/***/ },
/* 15 */
[543, 16, 17, 20, 21, 22, 23, 28, 29, 33, 34, 35],
/* 16 */
/***/ function(module, exports) {

	'use strict';

	var seed = 0;
	module.exports = function guid() {
	  return Date.now() + '_' + seed++;
	};

/***/ },
/* 17 */
[544, 18],
/* 18 */
/***/ function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(global) {
	/**
	 * Module exports.
	 */

	module.exports = deprecate;

	/**
	 * Mark that a method should not be used.
	 * Returns a modified function which warns once by default.
	 *
	 * If `localStorage.noDeprecation = true` is set, then it is a no-op.
	 *
	 * If `localStorage.throwDeprecation = true` is set, then deprecated functions
	 * will throw an Error when invoked.
	 *
	 * If `localStorage.traceDeprecation = true` is set, then deprecated functions
	 * will invoke `console.trace()` instead of `console.error()`.
	 *
	 * @param {Function} fn - the function to deprecate
	 * @param {String} msg - the string to print to the console when `fn` is invoked
	 * @returns {Function} a new "deprecated" version of `fn`
	 * @api public
	 */

	function deprecate (fn, msg) {
	  if (config('noDeprecation')) {
	    return fn;
	  }

	  var warned = false;
	  function deprecated() {
	    if (!warned) {
	      if (config('throwDeprecation')) {
	        throw new Error(msg);
	      } else if (config('traceDeprecation')) {
	        console.trace(msg);
	      } else {
	        console.warn(msg);
	      }
	      warned = true;
	    }
	    return fn.apply(this, arguments);
	  }

	  return deprecated;
	}

	/**
	 * Checks `localStorage` for boolean values for the given `name`.
	 *
	 * @param {String} name
	 * @returns {Boolean}
	 * @api private
	 */

	function config (name) {
	  // accessing global.localStorage can trigger a DOMException in sandboxed iframes
	  try {
	    if (!global.localStorage) return false;
	  } catch (_) {
	    return false;
	  }
	  var val = global.localStorage[name];
	  if (null == val) return false;
	  return String(val).toLowerCase() === 'true';
	}

	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 19 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*!
	  Copyright (c) 2015 Jed Watson.
	  Licensed under the MIT License (MIT), see
	  http://jedwatson.github.io/classnames
	*/
	/* global define */

	(function () {
		'use strict';

		var hasOwn = {}.hasOwnProperty;

		function classNames () {
			var classes = '';

			for (var i = 0; i < arguments.length; i++) {
				var arg = arguments[i];
				if (!arg) continue;

				var argType = typeof arg;

				if (argType === 'string' || argType === 'number') {
					classes += ' ' + arg;
				} else if (Array.isArray(arg)) {
					classes += ' ' + classNames.apply(null, arg);
				} else if (argType === 'object') {
					for (var key in arg) {
						if (hasOwn.call(arg, key) && arg[key]) {
							classes += ' ' + key;
						}
					}
				}
			}

			return classes.substr(1);
		}

		if (typeof module !== 'undefined' && module.exports) {
			module.exports = classNames;
		} else if (true) {
			// register as 'classnames', consistent with npm package name
			!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
				return classNames;
			}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
		} else {
			window.classNames = classNames;
		}
	}());


/***/ },
/* 20 */
[545, 18],
/* 21 */
/***/ function(module, exports) {

	/**
	 * @ignore
	 * some key-codes definition and utils from closure-library
	 * @author yiminghe@gmail.com
	 */

	'use strict';

	var KeyCode = {
	  /**
	   * MAC_ENTER
	   */
	  MAC_ENTER: 3,
	  /**
	   * BACKSPACE
	   */
	  BACKSPACE: 8,
	  /**
	   * TAB
	   */
	  TAB: 9,
	  /**
	   * NUMLOCK on FF/Safari Mac
	   */
	  NUM_CENTER: 12, // NUMLOCK on FF/Safari Mac
	  /**
	   * ENTER
	   */
	  ENTER: 13,
	  /**
	   * SHIFT
	   */
	  SHIFT: 16,
	  /**
	   * CTRL
	   */
	  CTRL: 17,
	  /**
	   * ALT
	   */
	  ALT: 18,
	  /**
	   * PAUSE
	   */
	  PAUSE: 19,
	  /**
	   * CAPS_LOCK
	   */
	  CAPS_LOCK: 20,
	  /**
	   * ESC
	   */
	  ESC: 27,
	  /**
	   * SPACE
	   */
	  SPACE: 32,
	  /**
	   * PAGE_UP
	   */
	  PAGE_UP: 33, // also NUM_NORTH_EAST
	  /**
	   * PAGE_DOWN
	   */
	  PAGE_DOWN: 34, // also NUM_SOUTH_EAST
	  /**
	   * END
	   */
	  END: 35, // also NUM_SOUTH_WEST
	  /**
	   * HOME
	   */
	  HOME: 36, // also NUM_NORTH_WEST
	  /**
	   * LEFT
	   */
	  LEFT: 37, // also NUM_WEST
	  /**
	   * UP
	   */
	  UP: 38, // also NUM_NORTH
	  /**
	   * RIGHT
	   */
	  RIGHT: 39, // also NUM_EAST
	  /**
	   * DOWN
	   */
	  DOWN: 40, // also NUM_SOUTH
	  /**
	   * PRINT_SCREEN
	   */
	  PRINT_SCREEN: 44,
	  /**
	   * INSERT
	   */
	  INSERT: 45, // also NUM_INSERT
	  /**
	   * DELETE
	   */
	  DELETE: 46, // also NUM_DELETE
	  /**
	   * ZERO
	   */
	  ZERO: 48,
	  /**
	   * ONE
	   */
	  ONE: 49,
	  /**
	   * TWO
	   */
	  TWO: 50,
	  /**
	   * THREE
	   */
	  THREE: 51,
	  /**
	   * FOUR
	   */
	  FOUR: 52,
	  /**
	   * FIVE
	   */
	  FIVE: 53,
	  /**
	   * SIX
	   */
	  SIX: 54,
	  /**
	   * SEVEN
	   */
	  SEVEN: 55,
	  /**
	   * EIGHT
	   */
	  EIGHT: 56,
	  /**
	   * NINE
	   */
	  NINE: 57,
	  /**
	   * QUESTION_MARK
	   */
	  QUESTION_MARK: 63, // needs localization
	  /**
	   * A
	   */
	  A: 65,
	  /**
	   * B
	   */
	  B: 66,
	  /**
	   * C
	   */
	  C: 67,
	  /**
	   * D
	   */
	  D: 68,
	  /**
	   * E
	   */
	  E: 69,
	  /**
	   * F
	   */
	  F: 70,
	  /**
	   * G
	   */
	  G: 71,
	  /**
	   * H
	   */
	  H: 72,
	  /**
	   * I
	   */
	  I: 73,
	  /**
	   * J
	   */
	  J: 74,
	  /**
	   * K
	   */
	  K: 75,
	  /**
	   * L
	   */
	  L: 76,
	  /**
	   * M
	   */
	  M: 77,
	  /**
	   * N
	   */
	  N: 78,
	  /**
	   * O
	   */
	  O: 79,
	  /**
	   * P
	   */
	  P: 80,
	  /**
	   * Q
	   */
	  Q: 81,
	  /**
	   * R
	   */
	  R: 82,
	  /**
	   * S
	   */
	  S: 83,
	  /**
	   * T
	   */
	  T: 84,
	  /**
	   * U
	   */
	  U: 85,
	  /**
	   * V
	   */
	  V: 86,
	  /**
	   * W
	   */
	  W: 87,
	  /**
	   * X
	   */
	  X: 88,
	  /**
	   * Y
	   */
	  Y: 89,
	  /**
	   * Z
	   */
	  Z: 90,
	  /**
	   * META
	   */
	  META: 91, // WIN_KEY_LEFT
	  /**
	   * WIN_KEY_RIGHT
	   */
	  WIN_KEY_RIGHT: 92,
	  /**
	   * CONTEXT_MENU
	   */
	  CONTEXT_MENU: 93,
	  /**
	   * NUM_ZERO
	   */
	  NUM_ZERO: 96,
	  /**
	   * NUM_ONE
	   */
	  NUM_ONE: 97,
	  /**
	   * NUM_TWO
	   */
	  NUM_TWO: 98,
	  /**
	   * NUM_THREE
	   */
	  NUM_THREE: 99,
	  /**
	   * NUM_FOUR
	   */
	  NUM_FOUR: 100,
	  /**
	   * NUM_FIVE
	   */
	  NUM_FIVE: 101,
	  /**
	   * NUM_SIX
	   */
	  NUM_SIX: 102,
	  /**
	   * NUM_SEVEN
	   */
	  NUM_SEVEN: 103,
	  /**
	   * NUM_EIGHT
	   */
	  NUM_EIGHT: 104,
	  /**
	   * NUM_NINE
	   */
	  NUM_NINE: 105,
	  /**
	   * NUM_MULTIPLY
	   */
	  NUM_MULTIPLY: 106,
	  /**
	   * NUM_PLUS
	   */
	  NUM_PLUS: 107,
	  /**
	   * NUM_MINUS
	   */
	  NUM_MINUS: 109,
	  /**
	   * NUM_PERIOD
	   */
	  NUM_PERIOD: 110,
	  /**
	   * NUM_DIVISION
	   */
	  NUM_DIVISION: 111,
	  /**
	   * F1
	   */
	  F1: 112,
	  /**
	   * F2
	   */
	  F2: 113,
	  /**
	   * F3
	   */
	  F3: 114,
	  /**
	   * F4
	   */
	  F4: 115,
	  /**
	   * F5
	   */
	  F5: 116,
	  /**
	   * F6
	   */
	  F6: 117,
	  /**
	   * F7
	   */
	  F7: 118,
	  /**
	   * F8
	   */
	  F8: 119,
	  /**
	   * F9
	   */
	  F9: 120,
	  /**
	   * F10
	   */
	  F10: 121,
	  /**
	   * F11
	   */
	  F11: 122,
	  /**
	   * F12
	   */
	  F12: 123,
	  /**
	   * NUMLOCK
	   */
	  NUMLOCK: 144,
	  /**
	   * SEMICOLON
	   */
	  SEMICOLON: 186, // needs localization
	  /**
	   * DASH
	   */
	  DASH: 189, // needs localization
	  /**
	   * EQUALS
	   */
	  EQUALS: 187, // needs localization
	  /**
	   * COMMA
	   */
	  COMMA: 188, // needs localization
	  /**
	   * PERIOD
	   */
	  PERIOD: 190, // needs localization
	  /**
	   * SLASH
	   */
	  SLASH: 191, // needs localization
	  /**
	   * APOSTROPHE
	   */
	  APOSTROPHE: 192, // needs localization
	  /**
	   * SINGLE_QUOTE
	   */
	  SINGLE_QUOTE: 222, // needs localization
	  /**
	   * OPEN_SQUARE_BRACKET
	   */
	  OPEN_SQUARE_BRACKET: 219, // needs localization
	  /**
	   * BACKSLASH
	   */
	  BACKSLASH: 220, // needs localization
	  /**
	   * CLOSE_SQUARE_BRACKET
	   */
	  CLOSE_SQUARE_BRACKET: 221, // needs localization
	  /**
	   * WIN_KEY
	   */
	  WIN_KEY: 224,
	  /**
	   * MAC_FF_META
	   */
	  MAC_FF_META: 224, // Firefox (Gecko) fires this for the meta key instead of 91
	  /**
	   * WIN_IME
	   */
	  WIN_IME: 229
	};

	/*
	 whether text and modified key is entered at the same time.
	 */
	KeyCode.isTextModifyingKeyEvent = function isTextModifyingKeyEvent(e) {
	  var keyCode = e.keyCode;
	  if (e.altKey && !e.ctrlKey || e.metaKey ||
	  // Function keys don't generate text
	  keyCode >= KeyCode.F1 && keyCode <= KeyCode.F12) {
	    return false;
	  }

	  // The following keys are quite harmless, even in combination with
	  // CTRL, ALT or SHIFT.
	  switch (keyCode) {
	    case KeyCode.ALT:
	    case KeyCode.CAPS_LOCK:
	    case KeyCode.CONTEXT_MENU:
	    case KeyCode.CTRL:
	    case KeyCode.DOWN:
	    case KeyCode.END:
	    case KeyCode.ESC:
	    case KeyCode.HOME:
	    case KeyCode.INSERT:
	    case KeyCode.LEFT:
	    case KeyCode.MAC_FF_META:
	    case KeyCode.META:
	    case KeyCode.NUMLOCK:
	    case KeyCode.NUM_CENTER:
	    case KeyCode.PAGE_DOWN:
	    case KeyCode.PAGE_UP:
	    case KeyCode.PAUSE:
	    case KeyCode.PRINT_SCREEN:
	    case KeyCode.RIGHT:
	    case KeyCode.SHIFT:
	    case KeyCode.UP:
	    case KeyCode.WIN_KEY:
	    case KeyCode.WIN_KEY_RIGHT:
	      return false;
	    default:
	      return true;
	  }
	};

	/*
	 whether character is entered.
	 */
	KeyCode.isCharacterKey = function isCharacterKey(keyCode) {
	  if (keyCode >= KeyCode.ZERO && keyCode <= KeyCode.NINE) {
	    return true;
	  }

	  if (keyCode >= KeyCode.NUM_ZERO && keyCode <= KeyCode.NUM_MULTIPLY) {
	    return true;
	  }

	  if (keyCode >= KeyCode.A && keyCode <= KeyCode.Z) {
	    return true;
	  }

	  // Safari sends zero key code for non-latin characters.
	  if (window.navigation.userAgent.indexOf('WebKit') !== -1 && keyCode === 0) {
	    return true;
	  }

	  switch (keyCode) {
	    case KeyCode.SPACE:
	    case KeyCode.QUESTION_MARK:
	    case KeyCode.NUM_PLUS:
	    case KeyCode.NUM_MINUS:
	    case KeyCode.NUM_PERIOD:
	    case KeyCode.NUM_DIVISION:
	    case KeyCode.SEMICOLON:
	    case KeyCode.DASH:
	    case KeyCode.EQUALS:
	    case KeyCode.COMMA:
	    case KeyCode.PERIOD:
	    case KeyCode.SLASH:
	    case KeyCode.APOSTROPHE:
	    case KeyCode.SINGLE_QUOTE:
	    case KeyCode.OPEN_SQUARE_BRACKET:
	    case KeyCode.BACKSLASH:
	    case KeyCode.CLOSE_SQUARE_BRACKET:
	      return true;
	    default:
	      return false;
	  }
	};

	module.exports = KeyCode;

/***/ },
/* 22 */
[546, 23],
/* 23 */
[547, 24],
/* 24 */
[548, 25, 26, 27],
/* 25 */
/***/ function(module, exports) {

	/**
	 * lodash 3.9.1 (Custom Build) <https://lodash.com/>
	 * Build: `lodash modern modularize exports="npm" -o ./`
	 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
	 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
	 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
	 * Available under MIT license <https://lodash.com/license>
	 */

	/** `Object#toString` result references. */
	var funcTag = '[object Function]';

	/** Used to detect host constructors (Safari > 5). */
	var reIsHostCtor = /^\[object .+?Constructor\]$/;

	/**
	 * Checks if `value` is object-like.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
	 */
	function isObjectLike(value) {
	  return !!value && typeof value == 'object';
	}

	/** Used for native method references. */
	var objectProto = Object.prototype;

	/** Used to resolve the decompiled source of functions. */
	var fnToString = Function.prototype.toString;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/**
	 * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
	 * of values.
	 */
	var objToString = objectProto.toString;

	/** Used to detect if a method is native. */
	var reIsNative = RegExp('^' +
	  fnToString.call(hasOwnProperty).replace(/[\\^$.*+?()[\]{}|]/g, '\\$&')
	  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
	);

	/**
	 * Gets the native function at `key` of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @param {string} key The key of the method to get.
	 * @returns {*} Returns the function if it's native, else `undefined`.
	 */
	function getNative(object, key) {
	  var value = object == null ? undefined : object[key];
	  return isNative(value) ? value : undefined;
	}

	/**
	 * Checks if `value` is classified as a `Function` object.
	 *
	 * @static
	 * @memberOf _
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
	 * @example
	 *
	 * _.isFunction(_);
	 * // => true
	 *
	 * _.isFunction(/abc/);
	 * // => false
	 */
	function isFunction(value) {
	  // The use of `Object#toString` avoids issues with the `typeof` operator
	  // in older versions of Chrome and Safari which return 'function' for regexes
	  // and Safari 8 equivalents which return 'object' for typed array constructors.
	  return isObject(value) && objToString.call(value) == funcTag;
	}

	/**
	 * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.
	 * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
	 *
	 * @static
	 * @memberOf _
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
	 * @example
	 *
	 * _.isObject({});
	 * // => true
	 *
	 * _.isObject([1, 2, 3]);
	 * // => true
	 *
	 * _.isObject(1);
	 * // => false
	 */
	function isObject(value) {
	  // Avoid a V8 JIT bug in Chrome 19-20.
	  // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.
	  var type = typeof value;
	  return !!value && (type == 'object' || type == 'function');
	}

	/**
	 * Checks if `value` is a native function.
	 *
	 * @static
	 * @memberOf _
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a native function, else `false`.
	 * @example
	 *
	 * _.isNative(Array.prototype.push);
	 * // => true
	 *
	 * _.isNative(_);
	 * // => false
	 */
	function isNative(value) {
	  if (value == null) {
	    return false;
	  }
	  if (isFunction(value)) {
	    return reIsNative.test(fnToString.call(value));
	  }
	  return isObjectLike(value) && reIsHostCtor.test(value);
	}

	module.exports = getNative;


/***/ },
/* 26 */
/***/ function(module, exports) {

	/**
	 * lodash 3.0.8 (Custom Build) <https://lodash.com/>
	 * Build: `lodash modularize exports="npm" -o ./`
	 * Copyright 2012-2016 The Dojo Foundation <http://dojofoundation.org/>
	 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
	 * Copyright 2009-2016 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
	 * Available under MIT license <https://lodash.com/license>
	 */

	/** Used as references for various `Number` constants. */
	var MAX_SAFE_INTEGER = 9007199254740991;

	/** `Object#toString` result references. */
	var argsTag = '[object Arguments]',
	    funcTag = '[object Function]',
	    genTag = '[object GeneratorFunction]';

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/**
	 * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
	 * of values.
	 */
	var objectToString = objectProto.toString;

	/** Built-in value references. */
	var propertyIsEnumerable = objectProto.propertyIsEnumerable;

	/**
	 * The base implementation of `_.property` without support for deep paths.
	 *
	 * @private
	 * @param {string} key The key of the property to get.
	 * @returns {Function} Returns the new function.
	 */
	function baseProperty(key) {
	  return function(object) {
	    return object == null ? undefined : object[key];
	  };
	}

	/**
	 * Gets the "length" property value of `object`.
	 *
	 * **Note:** This function is used to avoid a [JIT bug](https://bugs.webkit.org/show_bug.cgi?id=142792)
	 * that affects Safari on at least iOS 8.1-8.3 ARM64.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {*} Returns the "length" value.
	 */
	var getLength = baseProperty('length');

	/**
	 * Checks if `value` is likely an `arguments` object.
	 *
	 * @static
	 * @memberOf _
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
	 * @example
	 *
	 * _.isArguments(function() { return arguments; }());
	 * // => true
	 *
	 * _.isArguments([1, 2, 3]);
	 * // => false
	 */
	function isArguments(value) {
	  // Safari 8.1 incorrectly makes `arguments.callee` enumerable in strict mode.
	  return isArrayLikeObject(value) && hasOwnProperty.call(value, 'callee') &&
	    (!propertyIsEnumerable.call(value, 'callee') || objectToString.call(value) == argsTag);
	}

	/**
	 * Checks if `value` is array-like. A value is considered array-like if it's
	 * not a function and has a `value.length` that's an integer greater than or
	 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
	 *
	 * @static
	 * @memberOf _
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
	 * @example
	 *
	 * _.isArrayLike([1, 2, 3]);
	 * // => true
	 *
	 * _.isArrayLike(document.body.children);
	 * // => true
	 *
	 * _.isArrayLike('abc');
	 * // => true
	 *
	 * _.isArrayLike(_.noop);
	 * // => false
	 */
	function isArrayLike(value) {
	  return value != null && isLength(getLength(value)) && !isFunction(value);
	}

	/**
	 * This method is like `_.isArrayLike` except that it also checks if `value`
	 * is an object.
	 *
	 * @static
	 * @memberOf _
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an array-like object, else `false`.
	 * @example
	 *
	 * _.isArrayLikeObject([1, 2, 3]);
	 * // => true
	 *
	 * _.isArrayLikeObject(document.body.children);
	 * // => true
	 *
	 * _.isArrayLikeObject('abc');
	 * // => false
	 *
	 * _.isArrayLikeObject(_.noop);
	 * // => false
	 */
	function isArrayLikeObject(value) {
	  return isObjectLike(value) && isArrayLike(value);
	}

	/**
	 * Checks if `value` is classified as a `Function` object.
	 *
	 * @static
	 * @memberOf _
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
	 * @example
	 *
	 * _.isFunction(_);
	 * // => true
	 *
	 * _.isFunction(/abc/);
	 * // => false
	 */
	function isFunction(value) {
	  // The use of `Object#toString` avoids issues with the `typeof` operator
	  // in Safari 8 which returns 'object' for typed array and weak map constructors,
	  // and PhantomJS 1.9 which returns 'function' for `NodeList` instances.
	  var tag = isObject(value) ? objectToString.call(value) : '';
	  return tag == funcTag || tag == genTag;
	}

	/**
	 * Checks if `value` is a valid array-like length.
	 *
	 * **Note:** This function is loosely based on [`ToLength`](http://ecma-international.org/ecma-262/6.0/#sec-tolength).
	 *
	 * @static
	 * @memberOf _
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
	 * @example
	 *
	 * _.isLength(3);
	 * // => true
	 *
	 * _.isLength(Number.MIN_VALUE);
	 * // => false
	 *
	 * _.isLength(Infinity);
	 * // => false
	 *
	 * _.isLength('3');
	 * // => false
	 */
	function isLength(value) {
	  return typeof value == 'number' &&
	    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
	}

	/**
	 * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.
	 * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
	 *
	 * @static
	 * @memberOf _
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
	 * @example
	 *
	 * _.isObject({});
	 * // => true
	 *
	 * _.isObject([1, 2, 3]);
	 * // => true
	 *
	 * _.isObject(_.noop);
	 * // => true
	 *
	 * _.isObject(null);
	 * // => false
	 */
	function isObject(value) {
	  var type = typeof value;
	  return !!value && (type == 'object' || type == 'function');
	}

	/**
	 * Checks if `value` is object-like. A value is object-like if it's not `null`
	 * and has a `typeof` result of "object".
	 *
	 * @static
	 * @memberOf _
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
	 * @example
	 *
	 * _.isObjectLike({});
	 * // => true
	 *
	 * _.isObjectLike([1, 2, 3]);
	 * // => true
	 *
	 * _.isObjectLike(_.noop);
	 * // => false
	 *
	 * _.isObjectLike(null);
	 * // => false
	 */
	function isObjectLike(value) {
	  return !!value && typeof value == 'object';
	}

	module.exports = isArguments;


/***/ },
/* 27 */
/***/ function(module, exports) {

	/**
	 * lodash 3.0.4 (Custom Build) <https://lodash.com/>
	 * Build: `lodash modern modularize exports="npm" -o ./`
	 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
	 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
	 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
	 * Available under MIT license <https://lodash.com/license>
	 */

	/** `Object#toString` result references. */
	var arrayTag = '[object Array]',
	    funcTag = '[object Function]';

	/** Used to detect host constructors (Safari > 5). */
	var reIsHostCtor = /^\[object .+?Constructor\]$/;

	/**
	 * Checks if `value` is object-like.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
	 */
	function isObjectLike(value) {
	  return !!value && typeof value == 'object';
	}

	/** Used for native method references. */
	var objectProto = Object.prototype;

	/** Used to resolve the decompiled source of functions. */
	var fnToString = Function.prototype.toString;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/**
	 * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
	 * of values.
	 */
	var objToString = objectProto.toString;

	/** Used to detect if a method is native. */
	var reIsNative = RegExp('^' +
	  fnToString.call(hasOwnProperty).replace(/[\\^$.*+?()[\]{}|]/g, '\\$&')
	  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
	);

	/* Native method references for those with the same name as other `lodash` methods. */
	var nativeIsArray = getNative(Array, 'isArray');

	/**
	 * Used as the [maximum length](http://ecma-international.org/ecma-262/6.0/#sec-number.max_safe_integer)
	 * of an array-like value.
	 */
	var MAX_SAFE_INTEGER = 9007199254740991;

	/**
	 * Gets the native function at `key` of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @param {string} key The key of the method to get.
	 * @returns {*} Returns the function if it's native, else `undefined`.
	 */
	function getNative(object, key) {
	  var value = object == null ? undefined : object[key];
	  return isNative(value) ? value : undefined;
	}

	/**
	 * Checks if `value` is a valid array-like length.
	 *
	 * **Note:** This function is based on [`ToLength`](http://ecma-international.org/ecma-262/6.0/#sec-tolength).
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
	 */
	function isLength(value) {
	  return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
	}

	/**
	 * Checks if `value` is classified as an `Array` object.
	 *
	 * @static
	 * @memberOf _
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
	 * @example
	 *
	 * _.isArray([1, 2, 3]);
	 * // => true
	 *
	 * _.isArray(function() { return arguments; }());
	 * // => false
	 */
	var isArray = nativeIsArray || function(value) {
	  return isObjectLike(value) && isLength(value.length) && objToString.call(value) == arrayTag;
	};

	/**
	 * Checks if `value` is classified as a `Function` object.
	 *
	 * @static
	 * @memberOf _
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
	 * @example
	 *
	 * _.isFunction(_);
	 * // => true
	 *
	 * _.isFunction(/abc/);
	 * // => false
	 */
	function isFunction(value) {
	  // The use of `Object#toString` avoids issues with the `typeof` operator
	  // in older versions of Chrome and Safari which return 'function' for regexes
	  // and Safari 8 equivalents which return 'object' for typed array constructors.
	  return isObject(value) && objToString.call(value) == funcTag;
	}

	/**
	 * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.
	 * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
	 *
	 * @static
	 * @memberOf _
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
	 * @example
	 *
	 * _.isObject({});
	 * // => true
	 *
	 * _.isObject([1, 2, 3]);
	 * // => true
	 *
	 * _.isObject(1);
	 * // => false
	 */
	function isObject(value) {
	  // Avoid a V8 JIT bug in Chrome 19-20.
	  // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.
	  var type = typeof value;
	  return !!value && (type == 'object' || type == 'function');
	}

	/**
	 * Checks if `value` is a native function.
	 *
	 * @static
	 * @memberOf _
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a native function, else `false`.
	 * @example
	 *
	 * _.isNative(Array.prototype.push);
	 * // => true
	 *
	 * _.isNative(_);
	 * // => false
	 */
	function isNative(value) {
	  if (value == null) {
	    return false;
	  }
	  if (isFunction(value)) {
	    return reIsNative.test(fnToString.call(value));
	  }
	  return isObjectLike(value) && reIsHostCtor.test(value);
	}

	module.exports = isArray;


/***/ },
/* 28 */
/***/ function(module, exports) {

	/**
	 * Safe chained function
	 *
	 * Will only create a new function if needed,
	 * otherwise will pass back existing functions or null.
	 *
	 * @returns {function|null}
	 */
	"use strict";

	function createChainedFunction() {
	  var args = arguments;
	  return function chainedFunction() {
	    for (var i = 0; i < args.length; i++) {
	      if (args[i] && args[i].apply) {
	        args[i].apply(this, arguments);
	      }
	    }
	  };
	}

	module.exports = createChainedFunction;

/***/ },
/* 29 */
[549, 30],
/* 30 */
[550, 31],
/* 31 */
[551, 32, 9],
/* 32 */
/***/ function(module, exports) {

	/**
	 * @ignore
	 * base event object for custom and dom event.
	 * @author yiminghe@gmail.com
	 */

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	function returnFalse() {
	  return false;
	}

	function returnTrue() {
	  return true;
	}

	function EventBaseObject() {
	  this.timeStamp = Date.now();
	  this.target = undefined;
	  this.currentTarget = undefined;
	}

	EventBaseObject.prototype = {
	  isEventObject: 1,

	  constructor: EventBaseObject,

	  isDefaultPrevented: returnFalse,

	  isPropagationStopped: returnFalse,

	  isImmediatePropagationStopped: returnFalse,

	  preventDefault: function preventDefault() {
	    this.isDefaultPrevented = returnTrue;
	  },

	  stopPropagation: function stopPropagation() {
	    this.isPropagationStopped = returnTrue;
	  },

	  stopImmediatePropagation: function stopImmediatePropagation() {
	    this.isImmediatePropagationStopped = returnTrue;
	    // fixed 1.2
	    // call stopPropagation implicitly
	    this.stopPropagation();
	  },

	  halt: function halt(immediate) {
	    if (immediate) {
	      this.stopImmediatePropagation();
	    } else {
	      this.stopPropagation();
	    }
	    this.preventDefault();
	  }
	};

	exports["default"] = EventBaseObject;
	module.exports = exports["default"];

/***/ },
/* 33 */
/***/ function(module, exports) {

	"use strict";

	module.exports = function contains(root, n) {
	  var node = n;
	  while (node) {
	    if (node === root) {
	      return true;
	    }
	    node = node.parentNode;
	  }

	  return false;
	};

/***/ },
/* 34 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var React = __webpack_require__(7);

	module.exports = function toArray(children) {
	  var ret = [];
	  React.Children.forEach(children, function each(c) {
	    ret.push(c);
	  });
	  return ret;
	};

/***/ },
/* 35 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var React = __webpack_require__(7);

	function mirror(o) {
	  return o;
	}

	module.exports = function mapSelf(children) {
	  // return ReactFragment
	  return React.Children.map(children, mirror);
	};

/***/ },
/* 36 */
[552, 37],
/* 37 */
[553, 38],
/* 38 */
/***/ function(module, exports) {

	'use strict';

	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	var RE_NUM = /[\-+]?(?:\d*\.|)\d+(?:[eE][\-+]?\d+|)/.source;

	function getClientPosition(elem) {
	  var box = undefined;
	  var x = undefined;
	  var y = undefined;
	  var doc = elem.ownerDocument;
	  var body = doc.body;
	  var docElem = doc && doc.documentElement;
	  // 根据 GBS 最新数据，A-Grade Browsers 都已支持 getBoundingClientRect 方法，不用再考虑传统的实现方式
	  box = elem.getBoundingClientRect();

	  // 注：jQuery 还考虑减去 docElem.clientLeft/clientTop
	  // 但测试发现，这样反而会导致当 html 和 body 有边距/边框样式时，获取的值不正确
	  // 此外，ie6 会忽略 html 的 margin 值，幸运地是没有谁会去设置 html 的 margin

	  x = box.left;
	  y = box.top;

	  // In IE, most of the time, 2 extra pixels are added to the top and left
	  // due to the implicit 2-pixel inset border.  In IE6/7 quirks mode and
	  // IE6 standards mode, this border can be overridden by setting the
	  // document element's border to zero -- thus, we cannot rely on the
	  // offset always being 2 pixels.

	  // In quirks mode, the offset can be determined by querying the body's
	  // clientLeft/clientTop, but in standards mode, it is found by querying
	  // the document element's clientLeft/clientTop.  Since we already called
	  // getClientBoundingRect we have already forced a reflow, so it is not
	  // too expensive just to query them all.

	  // ie 下应该减去窗口的边框吧，毕竟默认 absolute 都是相对窗口定位的
	  // 窗口边框标准是设 documentElement ,quirks 时设置 body
	  // 最好禁止在 body 和 html 上边框 ，但 ie < 9 html 默认有 2px ，减去
	  // 但是非 ie 不可能设置窗口边框，body html 也不是窗口 ,ie 可以通过 html,body 设置
	  // 标准 ie 下 docElem.clientTop 就是 border-top
	  // ie7 html 即窗口边框改变不了。永远为 2
	  // 但标准 firefox/chrome/ie9 下 docElem.clientTop 是窗口边框，即使设了 border-top 也为 0

	  x -= docElem.clientLeft || body.clientLeft || 0;
	  y -= docElem.clientTop || body.clientTop || 0;

	  return {
	    left: x,
	    top: y
	  };
	}

	function getScroll(w, top) {
	  var ret = w['page' + (top ? 'Y' : 'X') + 'Offset'];
	  var method = 'scroll' + (top ? 'Top' : 'Left');
	  if (typeof ret !== 'number') {
	    var d = w.document;
	    // ie6,7,8 standard mode
	    ret = d.documentElement[method];
	    if (typeof ret !== 'number') {
	      // quirks mode
	      ret = d.body[method];
	    }
	  }
	  return ret;
	}

	function getScrollLeft(w) {
	  return getScroll(w);
	}

	function getScrollTop(w) {
	  return getScroll(w, true);
	}

	function getOffset(el) {
	  var pos = getClientPosition(el);
	  var doc = el.ownerDocument;
	  var w = doc.defaultView || doc.parentWindow;
	  pos.left += getScrollLeft(w);
	  pos.top += getScrollTop(w);
	  return pos;
	}
	function _getComputedStyle(elem, name, computedStyle_) {
	  var val = '';
	  var d = elem.ownerDocument;
	  var computedStyle = computedStyle_ || d.defaultView.getComputedStyle(elem, null);

	  // https://github.com/kissyteam/kissy/issues/61
	  if (computedStyle) {
	    val = computedStyle.getPropertyValue(name) || computedStyle[name];
	  }

	  return val;
	}

	var _RE_NUM_NO_PX = new RegExp('^(' + RE_NUM + ')(?!px)[a-z%]+$', 'i');
	var RE_POS = /^(top|right|bottom|left)$/;
	var CURRENT_STYLE = 'currentStyle';
	var RUNTIME_STYLE = 'runtimeStyle';
	var LEFT = 'left';
	var PX = 'px';

	function _getComputedStyleIE(elem, name) {
	  // currentStyle maybe null
	  // http://msdn.microsoft.com/en-us/library/ms535231.aspx
	  var ret = elem[CURRENT_STYLE] && elem[CURRENT_STYLE][name];

	  // 当 width/height 设置为百分比时，通过 pixelLeft 方式转换的 width/height 值
	  // 一开始就处理了! CUSTOM_STYLE.height,CUSTOM_STYLE.width ,cssHook 解决@2011-08-19
	  // 在 ie 下不对，需要直接用 offset 方式
	  // borderWidth 等值也有问题，但考虑到 borderWidth 设为百分比的概率很小，这里就不考虑了

	  // From the awesome hack by Dean Edwards
	  // http://erik.eae.net/archives/2007/07/27/18.54.15/#comment-102291
	  // If we're not dealing with a regular pixel number
	  // but a number that has a weird ending, we need to convert it to pixels
	  // exclude left right for relativity
	  if (_RE_NUM_NO_PX.test(ret) && !RE_POS.test(name)) {
	    // Remember the original values
	    var style = elem.style;
	    var left = style[LEFT];
	    var rsLeft = elem[RUNTIME_STYLE][LEFT];

	    // prevent flashing of content
	    elem[RUNTIME_STYLE][LEFT] = elem[CURRENT_STYLE][LEFT];

	    // Put in the new values to get a computed value out
	    style[LEFT] = name === 'fontSize' ? '1em' : ret || 0;
	    ret = style.pixelLeft + PX;

	    // Revert the changed values
	    style[LEFT] = left;

	    elem[RUNTIME_STYLE][LEFT] = rsLeft;
	  }
	  return ret === '' ? 'auto' : ret;
	}

	var getComputedStyleX = undefined;
	if (typeof window !== 'undefined') {
	  getComputedStyleX = window.getComputedStyle ? _getComputedStyle : _getComputedStyleIE;
	}

	function each(arr, fn) {
	  for (var i = 0; i < arr.length; i++) {
	    fn(arr[i]);
	  }
	}

	function isBorderBoxFn(elem) {
	  return getComputedStyleX(elem, 'boxSizing') === 'border-box';
	}

	var BOX_MODELS = ['margin', 'border', 'padding'];
	var CONTENT_INDEX = -1;
	var PADDING_INDEX = 2;
	var BORDER_INDEX = 1;
	var MARGIN_INDEX = 0;

	function swap(elem, options, callback) {
	  var old = {};
	  var style = elem.style;
	  var name = undefined;

	  // Remember the old values, and insert the new ones
	  for (name in options) {
	    if (options.hasOwnProperty(name)) {
	      old[name] = style[name];
	      style[name] = options[name];
	    }
	  }

	  callback.call(elem);

	  // Revert the old values
	  for (name in options) {
	    if (options.hasOwnProperty(name)) {
	      style[name] = old[name];
	    }
	  }
	}

	function getPBMWidth(elem, props, which) {
	  var value = 0;
	  var prop = undefined;
	  var j = undefined;
	  var i = undefined;
	  for (j = 0; j < props.length; j++) {
	    prop = props[j];
	    if (prop) {
	      for (i = 0; i < which.length; i++) {
	        var cssProp = undefined;
	        if (prop === 'border') {
	          cssProp = prop + which[i] + 'Width';
	        } else {
	          cssProp = prop + which[i];
	        }
	        value += parseFloat(getComputedStyleX(elem, cssProp)) || 0;
	      }
	    }
	  }
	  return value;
	}

	/**
	 * A crude way of determining if an object is a window
	 * @member util
	 */
	function isWindow(obj) {
	  // must use == for ie8
	  /* eslint eqeqeq:0 */
	  return obj != null && obj == obj.window;
	}

	var domUtils = {};

	each(['Width', 'Height'], function (name) {
	  domUtils['doc' + name] = function (refWin) {
	    var d = refWin.document;
	    return Math.max(
	    // firefox chrome documentElement.scrollHeight< body.scrollHeight
	    // ie standard mode : documentElement.scrollHeight> body.scrollHeight
	    d.documentElement['scroll' + name],
	    // quirks : documentElement.scrollHeight 最大等于可视窗口多一点？
	    d.body['scroll' + name], domUtils['viewport' + name](d));
	  };

	  domUtils['viewport' + name] = function (win) {
	    // pc browser includes scrollbar in window.innerWidth
	    var prop = 'client' + name;
	    var doc = win.document;
	    var body = doc.body;
	    var documentElement = doc.documentElement;
	    var documentElementProp = documentElement[prop];
	    // 标准模式取 documentElement
	    // backcompat 取 body
	    return doc.compatMode === 'CSS1Compat' && documentElementProp || body && body[prop] || documentElementProp;
	  };
	});

	/*
	 得到元素的大小信息
	 @param elem
	 @param name
	 @param {String} [extra]  'padding' : (css width) + padding
	 'border' : (css width) + padding + border
	 'margin' : (css width) + padding + border + margin
	 */
	function getWH(elem, name, extra) {
	  if (isWindow(elem)) {
	    return name === 'width' ? domUtils.viewportWidth(elem) : domUtils.viewportHeight(elem);
	  } else if (elem.nodeType === 9) {
	    return name === 'width' ? domUtils.docWidth(elem) : domUtils.docHeight(elem);
	  }
	  var which = name === 'width' ? ['Left', 'Right'] : ['Top', 'Bottom'];
	  var borderBoxValue = name === 'width' ? elem.offsetWidth : elem.offsetHeight;
	  var computedStyle = getComputedStyleX(elem);
	  var isBorderBox = isBorderBoxFn(elem, computedStyle);
	  var cssBoxValue = 0;
	  if (borderBoxValue == null || borderBoxValue <= 0) {
	    borderBoxValue = undefined;
	    // Fall back to computed then un computed css if necessary
	    cssBoxValue = getComputedStyleX(elem, name);
	    if (cssBoxValue == null || Number(cssBoxValue) < 0) {
	      cssBoxValue = elem.style[name] || 0;
	    }
	    // Normalize '', auto, and prepare for extra
	    cssBoxValue = parseFloat(cssBoxValue) || 0;
	  }
	  if (extra === undefined) {
	    extra = isBorderBox ? BORDER_INDEX : CONTENT_INDEX;
	  }
	  var borderBoxValueOrIsBorderBox = borderBoxValue !== undefined || isBorderBox;
	  var val = borderBoxValue || cssBoxValue;
	  if (extra === CONTENT_INDEX) {
	    if (borderBoxValueOrIsBorderBox) {
	      return val - getPBMWidth(elem, ['border', 'padding'], which, computedStyle);
	    }
	    return cssBoxValue;
	  }
	  if (borderBoxValueOrIsBorderBox) {
	    var padding = extra === PADDING_INDEX ? -getPBMWidth(elem, ['border'], which, computedStyle) : getPBMWidth(elem, ['margin'], which, computedStyle);
	    return val + (extra === BORDER_INDEX ? 0 : padding);
	  }
	  return cssBoxValue + getPBMWidth(elem, BOX_MODELS.slice(extra), which, computedStyle);
	}

	var cssShow = {
	  position: 'absolute',
	  visibility: 'hidden',
	  display: 'block'
	};

	// fix #119 : https://github.com/kissyteam/kissy/issues/119
	function getWHIgnoreDisplay(elem) {
	  var val = undefined;
	  var args = arguments;
	  // in case elem is window
	  // elem.offsetWidth === undefined
	  if (elem.offsetWidth !== 0) {
	    val = getWH.apply(undefined, args);
	  } else {
	    swap(elem, cssShow, function () {
	      val = getWH.apply(undefined, args);
	    });
	  }
	  return val;
	}

	function css(el, name, v) {
	  var value = v;
	  if ((typeof name === 'undefined' ? 'undefined' : _typeof(name)) === 'object') {
	    for (var i in name) {
	      if (name.hasOwnProperty(i)) {
	        css(el, i, name[i]);
	      }
	    }
	    return undefined;
	  }
	  if (typeof value !== 'undefined') {
	    if (typeof value === 'number') {
	      value += 'px';
	    }
	    el.style[name] = value;
	    return undefined;
	  }
	  return getComputedStyleX(el, name);
	}

	each(['width', 'height'], function (name) {
	  var first = name.charAt(0).toUpperCase() + name.slice(1);
	  domUtils['outer' + first] = function (el, includeMargin) {
	    return el && getWHIgnoreDisplay(el, name, includeMargin ? MARGIN_INDEX : BORDER_INDEX);
	  };
	  var which = name === 'width' ? ['Left', 'Right'] : ['Top', 'Bottom'];

	  domUtils[name] = function (elem, val) {
	    if (val !== undefined) {
	      if (elem) {
	        var computedStyle = getComputedStyleX(elem);
	        var isBorderBox = isBorderBoxFn(elem);
	        if (isBorderBox) {
	          val += getPBMWidth(elem, ['padding', 'border'], which, computedStyle);
	        }
	        return css(elem, name, val);
	      }
	      return undefined;
	    }
	    return elem && getWHIgnoreDisplay(elem, name, CONTENT_INDEX);
	  };
	});

	// 设置 elem 相对 elem.ownerDocument 的坐标
	function setOffset(elem, offset) {
	  // set position first, in-case top/left are set even on static elem
	  if (css(elem, 'position') === 'static') {
	    elem.style.position = 'relative';
	  }

	  var old = getOffset(elem);
	  var ret = {};
	  var current = undefined;
	  var key = undefined;

	  for (key in offset) {
	    if (offset.hasOwnProperty(key)) {
	      current = parseFloat(css(elem, key)) || 0;
	      ret[key] = current + offset[key] - old[key];
	    }
	  }
	  css(elem, ret);
	}

	module.exports = _extends({
	  getWindow: function getWindow(node) {
	    var doc = node.ownerDocument || node;
	    return doc.defaultView || doc.parentWindow;
	  },
	  offset: function offset(el, value) {
	    if (typeof value !== 'undefined') {
	      setOffset(el, value);
	    } else {
	      return getOffset(el);
	    }
	  },

	  isWindow: isWindow,
	  each: each,
	  css: css,
	  clone: function clone(obj) {
	    var ret = {};
	    for (var i in obj) {
	      if (obj.hasOwnProperty(i)) {
	        ret[i] = obj[i];
	      }
	    }
	    var overflow = obj.overflow;
	    if (overflow) {
	      for (var i in obj) {
	        if (obj.hasOwnProperty(i)) {
	          ret.overflow[i] = obj.overflow[i];
	        }
	      }
	    }
	    return ret;
	  },
	  scrollLeft: function scrollLeft(w, v) {
	    if (isWindow(w)) {
	      if (v === undefined) {
	        return getScrollLeft(w);
	      }
	      window.scrollTo(v, getScrollTop(w));
	    } else {
	      if (v === undefined) {
	        return w.scrollLeft;
	      }
	      w.scrollLeft = v;
	    }
	  },
	  scrollTop: function scrollTop(w, v) {
	    if (isWindow(w)) {
	      if (v === undefined) {
	        return getScrollTop(w);
	      }
	      window.scrollTo(getScrollLeft(w), v);
	    } else {
	      if (v === undefined) {
	        return w.scrollTop;
	      }
	      w.scrollTop = v;
	    }
	  },

	  viewportWidth: 0,
	  viewportHeight: 0
	}, domUtils);

/***/ },
/* 39 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	exports.noop = noop;
	exports.getKeyFromChildrenIndex = getKeyFromChildrenIndex;
	exports.loopMenuItem = loopMenuItem;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var _react = __webpack_require__(7);

	var _react2 = _interopRequireDefault(_react);

	var now = Date.now();

	function noop() {}

	function getKeyFromChildrenIndex(child, menuEventKey, index) {
	  var prefix = menuEventKey || '';
	  return child.key || prefix + 'item_' + now + '_' + index;
	}

	function loopMenuItem(children, cb) {
	  var index = -1;
	  _react2['default'].Children.forEach(children, function (c) {
	    index++;
	    if (c && c.type.isMenuItemGroup) {
	      _react2['default'].Children.forEach(c.props.children, function (c2) {
	        index++;
	        cb(c2, index);
	      });
	    } else {
	      cb(c, index);
	    }
	  });
	}

/***/ },
/* 40 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	  value: true
	});

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var _react = __webpack_require__(7);

	var _react2 = _interopRequireDefault(_react);

	var _objectAssign = __webpack_require__(9);

	var _objectAssign2 = _interopRequireDefault(_objectAssign);

	var DOMWrap = _react2['default'].createClass({
	  displayName: 'DOMWrap',

	  propTypes: {
	    tag: _react2['default'].PropTypes.string
	  },

	  getDefaultProps: function getDefaultProps() {
	    return {
	      tag: 'div'
	    };
	  },

	  render: function render() {
	    var props = (0, _objectAssign2['default'])({}, this.props);
	    if (!props.visible) {
	      props.className = props.className || '';
	      props.className += ' ' + props.hiddenClassName;
	    }
	    var Tag = props.tag;
	    return _react2['default'].createElement(Tag, props);
	  }
	});

	exports['default'] = DOMWrap;
	module.exports = exports['default'];

/***/ },
/* 41 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	  value: true
	});

	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

	var _SubPopupMenu = __webpack_require__(42);

	var _SubPopupMenu2 = _interopRequireDefault(_SubPopupMenu);

	var _react = __webpack_require__(7);

	var _react2 = _interopRequireDefault(_react);

	var _rcUtil = __webpack_require__(15);

	var _classnames = __webpack_require__(19);

	var _classnames2 = _interopRequireDefault(_classnames);

	var _objectAssign = __webpack_require__(9);

	var _objectAssign2 = _interopRequireDefault(_objectAssign);

	var SubMenu = _react2['default'].createClass({
	  displayName: 'SubMenu',

	  propTypes: {
	    parentMenu: _react2['default'].PropTypes.object,
	    title: _react2['default'].PropTypes.node,
	    onClick: _react2['default'].PropTypes.func,
	    onOpenChange: _react2['default'].PropTypes.func,
	    rootPrefixCls: _react2['default'].PropTypes.string,
	    eventKey: _react2['default'].PropTypes.string,
	    multiple: _react2['default'].PropTypes.bool,
	    active: _react2['default'].PropTypes.bool,
	    open: _react2['default'].PropTypes.bool,
	    onSelect: _react2['default'].PropTypes.func,
	    closeSubMenuOnMouseLeave: _react2['default'].PropTypes.bool,
	    openSubMenuOnMouseEnter: _react2['default'].PropTypes.bool,
	    onDeselect: _react2['default'].PropTypes.func,
	    onDestroy: _react2['default'].PropTypes.func,
	    onItemHover: _react2['default'].PropTypes.func
	  },

	  mixins: [__webpack_require__(52)],

	  getDefaultProps: function getDefaultProps() {
	    return {
	      onMouseEnter: function onMouseEnter() {},
	      title: ''
	    };
	  },

	  getInitialState: function getInitialState() {
	    this.isSubMenu = 1;
	    return {
	      defaultActiveFirst: false
	    };
	  },

	  componentWillUnmount: function componentWillUnmount() {
	    var props = this.props;
	    if (props.onDestroy) {
	      props.onDestroy(props.eventKey);
	    }
	  },

	  onDestroy: function onDestroy(key) {
	    this.props.onDestroy(key);
	  },

	  onKeyDown: function onKeyDown(e) {
	    var keyCode = e.keyCode;
	    var menu = this.menuInstance;

	    if (keyCode === _rcUtil.KeyCode.ENTER) {
	      this.onClick(e);
	      this.setState({
	        defaultActiveFirst: true
	      });
	      return true;
	    }

	    if (keyCode === _rcUtil.KeyCode.RIGHT) {
	      if (this.props.open) {
	        menu.onKeyDown(e);
	      } else {
	        this.triggerOpenChange(true);
	        this.setState({
	          defaultActiveFirst: true
	        });
	      }
	      return true;
	    }
	    if (keyCode === _rcUtil.KeyCode.LEFT) {
	      var handled = undefined;
	      if (this.props.open) {
	        handled = menu.onKeyDown(e);
	      } else {
	        return undefined;
	      }
	      if (!handled) {
	        this.triggerOpenChange(false);
	        handled = true;
	      }
	      return handled;
	    }

	    if (this.props.open && (keyCode === _rcUtil.KeyCode.UP || keyCode === _rcUtil.KeyCode.DOWN)) {
	      return menu.onKeyDown(e);
	    }
	  },

	  onSubTreeMouseEnter: function onSubTreeMouseEnter() {
	    if (this.leaveTimer) {
	      clearTimeout(this.leaveTimer);
	      this.leaveTimer = null;
	    }
	  },

	  onOpenChange: function onOpenChange(e) {
	    this.props.onOpenChange(this.addKeyPath(e));
	  },

	  onMouseEnter: function onMouseEnter() {
	    if (this.leaveTimer) {
	      clearTimeout(this.leaveTimer);
	      this.leaveTimer = null;
	    }
	    var props = this.props;
	    var parentMenu = props.parentMenu;
	    if (parentMenu.menuItemMouseLeaveTimer) {
	      clearTimeout(parentMenu.menuItemMouseLeaveTimer);
	      parentMenu.menuItemMouseLeaveTimer = null;
	    }
	    props.onItemHover({
	      key: this.props.eventKey,
	      item: this,
	      hover: true,
	      trigger: 'mouseenter'
	    });
	    if (props.openSubMenuOnMouseEnter) {
	      this.triggerOpenChange(true);
	    }
	    this.setState({
	      defaultActiveFirst: false
	    });
	  },

	  onMouseLeave: function onMouseLeave() {
	    var _this = this;

	    // prevent popup menu and submenu gap
	    this.leaveTimer = setTimeout(function () {
	      // leave whole sub tree
	      // still active
	      if (_this.isMounted() && _this.props.active) {
	        _this.props.onItemHover({
	          key: _this.props.eventKey,
	          item: _this,
	          hover: false,
	          trigger: 'mouseleave'
	        });
	      }
	      if (_this.isMounted() && _this.props.open) {
	        if (_this.props.closeSubMenuOnMouseLeave) {
	          _this.triggerOpenChange(false);
	        }
	      }
	    }, 100);
	  },

	  onClick: function onClick() {
	    if (this.props.openSubMenuOnMouseEnter) {
	      return;
	    }
	    this.triggerOpenChange(!this.props.open, 'click');
	    this.setState({
	      defaultActiveFirst: false
	    });
	  },

	  onSubMenuClick: function onSubMenuClick(info) {
	    this.props.onClick(this.addKeyPath(info));
	  },

	  onSelect: function onSelect(info) {
	    this.props.onSelect(info);
	  },

	  onDeselect: function onDeselect(info) {
	    this.props.onDeselect(info);
	  },

	  getPrefixCls: function getPrefixCls() {
	    return this.props.rootPrefixCls + '-submenu';
	  },

	  getActiveClassName: function getActiveClassName() {
	    return this.getPrefixCls() + '-active';
	  },

	  getDisabledClassName: function getDisabledClassName() {
	    return this.getPrefixCls() + '-disabled';
	  },

	  getOpenClassName: function getOpenClassName() {
	    return this.props.rootPrefixCls + '-submenu-open';
	  },

	  saveMenuInstance: function saveMenuInstance(c) {
	    this.menuInstance = c;
	  },

	  addKeyPath: function addKeyPath(info) {
	    return (0, _objectAssign2['default'])({}, info, {
	      keyPath: (info.keyPath || []).concat(this.props.eventKey)
	    });
	  },

	  triggerOpenChange: function triggerOpenChange(open, type) {
	    var key = this.props.eventKey;
	    this.onOpenChange({
	      key: key,
	      item: this,
	      trigger: type,
	      open: open
	    });
	  },

	  renderChildren: function renderChildren(children) {
	    var props = this.props;
	    var baseProps = {
	      mode: props.mode === 'horizontal' ? 'vertical' : props.mode,
	      visible: props.open,
	      level: props.level + 1,
	      inlineIndent: props.inlineIndent,
	      focusable: false,
	      onClick: this.onSubMenuClick,
	      onSelect: this.onSelect,
	      onDeselect: this.onDeselect,
	      onDestroy: this.onDestroy,
	      selectedKeys: props.selectedKeys,
	      eventKey: props.eventKey + '-menu-',
	      openKeys: props.openKeys,
	      openTransitionName: props.openTransitionName,
	      openAnimation: props.openAnimation,
	      onOpenChange: this.onOpenChange,
	      closeSubMenuOnMouseLeave: props.closeSubMenuOnMouseLeave,
	      defaultActiveFirst: this.state.defaultActiveFirst,
	      multiple: props.multiple,
	      prefixCls: props.rootPrefixCls,
	      id: this._menuId,
	      ref: this.saveMenuInstance
	    };
	    return _react2['default'].createElement(
	      _SubPopupMenu2['default'],
	      baseProps,
	      children
	    );
	  },

	  render: function render() {
	    var _classes;

	    this.haveOpen = this.haveOpen || this.props.open;
	    var props = this.props;
	    var prefixCls = this.getPrefixCls();
	    var classes = (_classes = {}, _defineProperty(_classes, props.className, !!props.className), _defineProperty(_classes, prefixCls + '-' + props.mode, 1), _classes);

	    classes[this.getOpenClassName()] = this.props.open;
	    classes[this.getActiveClassName()] = props.active;
	    classes[this.getDisabledClassName()] = props.disabled;
	    this._menuId = this._menuId || (0, _rcUtil.guid)();
	    classes[prefixCls] = true;
	    classes[prefixCls + '-' + props.mode] = 1;
	    var clickEvents = {};
	    var mouseEvents = {};
	    var titleMouseEvents = {};
	    if (!props.disabled) {
	      clickEvents = {
	        onClick: this.onClick
	      };
	      mouseEvents = {
	        onMouseLeave: this.onMouseLeave,
	        onMouseEnter: this.onSubTreeMouseEnter
	      };
	      // only works in title, not outer li
	      titleMouseEvents = {
	        onMouseEnter: this.onMouseEnter
	      };
	    }
	    var style = {};
	    if (props.mode === 'inline') {
	      style.paddingLeft = props.inlineIndent * props.level;
	    }
	    return _react2['default'].createElement(
	      'li',
	      _extends({ className: (0, _classnames2['default'])(classes) }, mouseEvents),
	      _react2['default'].createElement(
	        'div',
	        _extends({
	          style: style,
	          className: prefixCls + '-title'
	        }, titleMouseEvents, clickEvents, {
	          'aria-open': props.open,
	          'aria-owns': this._menuId,
	          'aria-haspopup': 'true'
	        }),
	        props.title
	      ),
	      this.renderChildren(props.children)
	    );
	  }
	});

	exports['default'] = SubMenu;
	module.exports = exports['default'];

/***/ },
/* 42 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	  value: true
	});

	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var _react = __webpack_require__(7);

	var _react2 = _interopRequireDefault(_react);

	var _MenuMixin = __webpack_require__(14);

	var _MenuMixin2 = _interopRequireDefault(_MenuMixin);

	var _objectAssign = __webpack_require__(9);

	var _objectAssign2 = _interopRequireDefault(_objectAssign);

	var _util = __webpack_require__(39);

	var _rcAnimate = __webpack_require__(43);

	var _rcAnimate2 = _interopRequireDefault(_rcAnimate);

	var SubPopupMenu = _react2['default'].createClass({
	  displayName: 'SubPopupMenu',

	  propTypes: {
	    onSelect: _react2['default'].PropTypes.func,
	    onClick: _react2['default'].PropTypes.func,
	    onDeselect: _react2['default'].PropTypes.func,
	    onOpenChange: _react2['default'].PropTypes.func,
	    onDestroy: _react2['default'].PropTypes.func,
	    openTransitionName: _react2['default'].PropTypes.string,
	    openAnimation: _react2['default'].PropTypes.oneOfType([_react2['default'].PropTypes.string, _react2['default'].PropTypes.object]),
	    openKeys: _react2['default'].PropTypes.arrayOf(_react2['default'].PropTypes.string),
	    closeSubMenuOnMouseLeave: _react2['default'].PropTypes.bool,
	    visible: _react2['default'].PropTypes.bool,
	    children: _react2['default'].PropTypes.any
	  },

	  mixins: [_MenuMixin2['default']],

	  onDeselect: function onDeselect(selectInfo) {
	    this.props.onDeselect(selectInfo);
	  },

	  onSelect: function onSelect(selectInfo) {
	    this.props.onSelect(selectInfo);
	  },

	  onClick: function onClick(e) {
	    this.props.onClick(e);
	  },

	  onOpenChange: function onOpenChange(e) {
	    this.props.onOpenChange(e);
	  },

	  onDestroy: function onDestroy(key) {
	    this.props.onDestroy(key);
	  },

	  onItemHover: function onItemHover(e) {
	    this.onCommonItemHover(e);
	  },

	  getOpenTransitionName: function getOpenTransitionName() {
	    return this.props.openTransitionName;
	  },

	  renderMenuItem: function renderMenuItem(c, i, subIndex) {
	    var props = this.props;
	    var key = (0, _util.getKeyFromChildrenIndex)(c, props.eventKey, i);
	    var extraProps = {
	      openKeys: props.openKeys,
	      selectedKeys: props.selectedKeys,
	      open: props.openKeys.indexOf(key) !== -1,
	      selected: props.selectedKeys.indexOf(key) !== -1,
	      openSubMenuOnMouseEnter: true
	    };
	    return this.renderCommonMenuItem(c, i, subIndex, extraProps);
	  },

	  render: function render() {
	    var renderFirst = this.renderFirst;
	    this.renderFirst = 1;
	    this.haveOpened = this.haveOpened || this.props.visible;
	    if (!this.haveOpened) {
	      return null;
	    }
	    var transitionAppear = true;
	    if (!renderFirst && this.props.visible) {
	      transitionAppear = false;
	    }
	    var props = (0, _objectAssign2['default'])({}, this.props);
	    props.className += ' ' + props.prefixCls + '-sub';
	    var animProps = {};
	    if (props.openTransitionName) {
	      animProps.transitionName = props.openTransitionName;
	    } else if (typeof props.openAnimation === 'object') {
	      animProps.animation = (0, _objectAssign2['default'])({}, props.openAnimation);
	      if (!transitionAppear) {
	        delete animProps.animation.appear;
	      }
	    }
	    return _react2['default'].createElement(
	      _rcAnimate2['default'],
	      _extends({}, animProps, {
	        showProp: 'visible',
	        component: '',
	        transitionAppear: transitionAppear }),
	      this.renderRoot(props)
	    );
	  }
	});

	exports['default'] = SubPopupMenu;
	module.exports = exports['default'];

/***/ },
/* 43 */
[554, 44],
/* 44 */
[555, 45, 46, 51],
/* 45 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	exports.toArrayChildren = toArrayChildren;
	exports.findChildInChildrenByKey = findChildInChildrenByKey;
	exports.findShownChildInChildrenByKey = findShownChildInChildrenByKey;
	exports.findHiddenChildInChildrenByKey = findHiddenChildInChildrenByKey;
	exports.isSameChildren = isSameChildren;
	exports.mergeChildren = mergeChildren;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var _react = __webpack_require__(7);

	var _react2 = _interopRequireDefault(_react);

	function toArrayChildren(children) {
	  var ret = [];
	  _react2['default'].Children.forEach(children, function (child) {
	    ret.push(child);
	  });
	  return ret;
	}

	function findChildInChildrenByKey(children, key) {
	  var ret = null;
	  if (children) {
	    children.forEach(function (child) {
	      if (ret) {
	        return;
	      }
	      if (child.key === key) {
	        ret = child;
	      }
	    });
	  }
	  return ret;
	}

	function findShownChildInChildrenByKey(children, key, showProp) {
	  var ret = null;
	  if (children) {
	    children.forEach(function (child) {
	      if (child.key === key && child.props[showProp]) {
	        if (ret) {
	          throw new Error('two child with same key for <rc-animate> children');
	        }
	        ret = child;
	      }
	    });
	  }
	  return ret;
	}

	function findHiddenChildInChildrenByKey(children, key, showProp) {
	  var found = 0;
	  if (children) {
	    children.forEach(function (child) {
	      if (found) {
	        return;
	      }
	      found = child.key === key && !child.props[showProp];
	    });
	  }
	  return found;
	}

	function isSameChildren(c1, c2, showProp) {
	  var same = c1.length === c2.length;
	  if (same) {
	    c1.forEach(function (child, index) {
	      var child2 = c2[index];
	      if (child.key !== child2.key) {
	        same = false;
	      } else if (showProp && child.props[showProp] !== child2.props[showProp]) {
	        same = false;
	      }
	    });
	  }
	  return same;
	}

	function mergeChildren(prev, next) {
	  var ret = [];

	  // For each key of `next`, the list of keys to insert before that key in
	  // the combined list
	  var nextChildrenPending = {};
	  var pendingChildren = [];
	  prev.forEach(function (child) {
	    if (findChildInChildrenByKey(next, child.key)) {
	      if (pendingChildren.length) {
	        nextChildrenPending[child.key] = pendingChildren;
	        pendingChildren = [];
	      }
	    } else {
	      pendingChildren.push(child);
	    }
	  });

	  next.forEach(function (child) {
	    if (nextChildrenPending.hasOwnProperty(child.key)) {
	      ret = ret.concat(nextChildrenPending[child.key]);
	    }
	    ret.push(child);
	  });

	  ret = ret.concat(pendingChildren);

	  return ret;
	}

/***/ },
/* 46 */
[556, 47, 51],
/* 47 */
[557, 48, 49],
/* 48 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var EVENT_NAME_MAP = {
	  transitionend: {
	    transition: 'transitionend',
	    WebkitTransition: 'webkitTransitionEnd',
	    MozTransition: 'mozTransitionEnd',
	    OTransition: 'oTransitionEnd',
	    msTransition: 'MSTransitionEnd'
	  },

	  animationend: {
	    animation: 'animationend',
	    WebkitAnimation: 'webkitAnimationEnd',
	    MozAnimation: 'mozAnimationEnd',
	    OAnimation: 'oAnimationEnd',
	    msAnimation: 'MSAnimationEnd'
	  }
	};

	var endEvents = [];

	function detectEvents() {
	  var testEl = document.createElement('div');
	  var style = testEl.style;

	  if (!('AnimationEvent' in window)) {
	    delete EVENT_NAME_MAP.animationend.animation;
	  }

	  if (!('TransitionEvent' in window)) {
	    delete EVENT_NAME_MAP.transitionend.transition;
	  }

	  for (var baseEventName in EVENT_NAME_MAP) {
	    if (EVENT_NAME_MAP.hasOwnProperty(baseEventName)) {
	      var baseEvents = EVENT_NAME_MAP[baseEventName];
	      for (var styleName in baseEvents) {
	        if (styleName in style) {
	          endEvents.push(baseEvents[styleName]);
	          break;
	        }
	      }
	    }
	  }
	}

	if (typeof window !== 'undefined' && typeof document !== 'undefined') {
	  detectEvents();
	}

	function addEventListener(node, eventName, eventListener) {
	  node.addEventListener(eventName, eventListener, false);
	}

	function removeEventListener(node, eventName, eventListener) {
	  node.removeEventListener(eventName, eventListener, false);
	}

	var TransitionEvents = {
	  addEndEventListener: function addEndEventListener(node, eventListener) {
	    if (endEvents.length === 0) {
	      window.setTimeout(eventListener, 0);
	      return;
	    }
	    endEvents.forEach(function (endEvent) {
	      addEventListener(node, endEvent, eventListener);
	    });
	  },


	  endEvents: endEvents,

	  removeEndEventListener: function removeEndEventListener(node, eventListener) {
	    if (endEvents.length === 0) {
	      return;
	    }
	    endEvents.forEach(function (endEvent) {
	      removeEventListener(node, endEvent, eventListener);
	    });
	  }
	};

	exports["default"] = TransitionEvents;
	module.exports = exports['default'];

/***/ },
/* 49 */
[558, 50, 50],
/* 50 */
/***/ function(module, exports) {

	module.exports = function(arr, obj){
	  if (arr.indexOf) return arr.indexOf(obj);
	  for (var i = 0; i < arr.length; ++i) {
	    if (arr[i] === obj) return i;
	  }
	  return -1;
	};

/***/ },
/* 51 */
/***/ function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var util = {
	  isAppearSupported: function isAppearSupported(props) {
	    return props.transitionName && props.transitionAppear || props.animation.appear;
	  },
	  isEnterSupported: function isEnterSupported(props) {
	    return props.transitionName && props.transitionEnter || props.animation.enter;
	  },
	  isLeaveSupported: function isLeaveSupported(props) {
	    return props.transitionName && props.transitionLeave || props.animation.leave;
	  },

	  allowAppearCallback: function allowAppearCallback(props) {
	    return props.transitionAppear || props.animation.appear;
	  },
	  allowEnterCallback: function allowEnterCallback(props) {
	    return props.transitionEnter || props.animation.enter;
	  },
	  allowLeaveCallback: function allowLeaveCallback(props) {
	    return props.transitionLeave || props.animation.leave;
	  }
	};
	exports["default"] = util;
	module.exports = exports["default"];

/***/ },
/* 52 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	  value: true
	});

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var _rcUtil = __webpack_require__(15);

	var _rcUtil2 = _interopRequireDefault(_rcUtil);

	var _reactDom = __webpack_require__(8);

	var _reactDom2 = _interopRequireDefault(_reactDom);

	exports['default'] = {
	  componentDidMount: function componentDidMount() {
	    this.componentDidUpdate();
	  },

	  componentDidUpdate: function componentDidUpdate() {
	    if (this.props.mode !== 'inline') {
	      if (this.props.open) {
	        this.bindRootCloseHandlers();
	      } else {
	        this.unbindRootCloseHandlers();
	      }
	    }
	  },

	  handleDocumentKeyUp: function handleDocumentKeyUp(e) {
	    if (e.keyCode === _rcUtil.KeyCode.ESC) {
	      this.props.onItemHover({
	        key: this.props.eventKey,
	        item: this,
	        hover: false
	      });
	    }
	  },

	  handleDocumentClick: function handleDocumentClick(e) {
	    // If the click originated from within this component
	    // don't do anything.
	    if (_rcUtil2['default'].Dom.contains(_reactDom2['default'].findDOMNode(this), e.target)) {
	      return;
	    }
	    var props = this.props;
	    props.onItemHover({
	      hover: false,
	      item: this,
	      key: this.props.eventKey
	    });
	    this.triggerOpenChange(false);
	  },

	  bindRootCloseHandlers: function bindRootCloseHandlers() {
	    if (!this._onDocumentClickListener) {
	      this._onDocumentClickListener = _rcUtil2['default'].Dom.addEventListener(document, 'click', this.handleDocumentClick);
	      this._onDocumentKeyupListener = _rcUtil2['default'].Dom.addEventListener(document, 'keyup', this.handleDocumentKeyUp);
	    }
	  },

	  unbindRootCloseHandlers: function unbindRootCloseHandlers() {
	    if (this._onDocumentClickListener) {
	      this._onDocumentClickListener.remove();
	      this._onDocumentClickListener = null;
	    }

	    if (this._onDocumentKeyupListener) {
	      this._onDocumentKeyupListener.remove();
	      this._onDocumentKeyupListener = null;
	    }
	  },

	  componentWillUnmount: function componentWillUnmount() {
	    this.unbindRootCloseHandlers();
	  }
	};
	module.exports = exports['default'];

/***/ },
/* 53 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	  value: true
	});

	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var _react = __webpack_require__(7);

	var _react2 = _interopRequireDefault(_react);

	var _rcUtil = __webpack_require__(15);

	var _classnames = __webpack_require__(19);

	var _classnames2 = _interopRequireDefault(_classnames);

	var MenuItem = _react2['default'].createClass({
	  displayName: 'MenuItem',

	  propTypes: {
	    rootPrefixCls: _react2['default'].PropTypes.string,
	    eventKey: _react2['default'].PropTypes.string,
	    active: _react2['default'].PropTypes.bool,
	    selected: _react2['default'].PropTypes.bool,
	    disabled: _react2['default'].PropTypes.bool,
	    title: _react2['default'].PropTypes.string,
	    onSelect: _react2['default'].PropTypes.func,
	    onClick: _react2['default'].PropTypes.func,
	    onDeselect: _react2['default'].PropTypes.func,
	    parentMenu: _react2['default'].PropTypes.object,
	    onItemHover: _react2['default'].PropTypes.func,
	    onDestroy: _react2['default'].PropTypes.func
	  },

	  getDefaultProps: function getDefaultProps() {
	    return {
	      onSelect: function onSelect() {},
	      onMouseEnter: function onMouseEnter() {}
	    };
	  },

	  componentWillUnmount: function componentWillUnmount() {
	    var props = this.props;
	    if (props.onDestroy) {
	      props.onDestroy(props.eventKey);
	    }
	  },

	  onKeyDown: function onKeyDown(e) {
	    var keyCode = e.keyCode;
	    if (keyCode === _rcUtil.KeyCode.ENTER) {
	      this.onClick(e);
	      return true;
	    }
	  },

	  onMouseLeave: function onMouseLeave() {
	    var _this = this;

	    var eventKey = this.props.eventKey;
	    var parentMenu = this.props.parentMenu;
	    parentMenu.menuItemMouseLeaveTimer = setTimeout(function () {
	      if (_this.isMounted() && _this.props.active) {
	        _this.props.onItemHover({
	          key: eventKey,
	          item: _this,
	          hover: false,
	          trigger: 'mouseleave'
	        });
	      }
	    }, 30);
	  },

	  onMouseEnter: function onMouseEnter() {
	    var props = this.props;
	    var parentMenu = this.props.parentMenu;
	    if (parentMenu.menuItemMouseLeaveTimer) {
	      clearTimeout(parentMenu.menuItemMouseLeaveTimer);
	      parentMenu.menuItemMouseLeaveTimer = null;
	    }
	    var eventKey = props.eventKey;
	    props.onItemHover({
	      key: eventKey,
	      item: this,
	      hover: true,
	      trigger: 'mouseenter'
	    });
	  },

	  onClick: function onClick(e) {
	    var props = this.props;
	    var eventKey = props.eventKey;
	    var info = {
	      key: eventKey,
	      keyPath: [eventKey],
	      item: this,
	      domEvent: e
	    };
	    props.onClick(info);
	    if (props.multiple) {
	      if (props.selected) {
	        props.onDeselect(info);
	      } else {
	        props.onSelect(info);
	      }
	    } else if (!props.selected) {
	      props.onSelect(info);
	    }
	  },

	  getPrefixCls: function getPrefixCls() {
	    return this.props.rootPrefixCls + '-item';
	  },

	  getActiveClassName: function getActiveClassName() {
	    return this.getPrefixCls() + '-active';
	  },

	  getSelectedClassName: function getSelectedClassName() {
	    return this.getPrefixCls() + '-selected';
	  },

	  getDisabledClassName: function getDisabledClassName() {
	    return this.getPrefixCls() + '-disabled';
	  },

	  render: function render() {
	    var props = this.props;
	    var classes = {};
	    classes[this.getActiveClassName()] = !props.disabled && props.active;
	    classes[this.getSelectedClassName()] = props.selected;
	    classes[this.getDisabledClassName()] = props.disabled;
	    classes[this.getPrefixCls()] = true;
	    classes[props.className] = !!props.className;
	    var attrs = _extends({}, props.attribute, {
	      title: props.title,
	      className: (0, _classnames2['default'])(classes),
	      role: 'menuitem',
	      'aria-selected': props.selected,
	      'aria-disabled': props.disabled
	    });
	    var mouseEvent = {};
	    if (!props.disabled) {
	      mouseEvent = {
	        onClick: this.onClick,
	        onMouseLeave: this.onMouseLeave,
	        onMouseEnter: this.onMouseEnter
	      };
	    }
	    var style = _extends({}, props.style);
	    if (props.mode === 'inline') {
	      style.paddingLeft = props.inlineIndent * props.level;
	    }
	    return _react2['default'].createElement(
	      'li',
	      _extends({ style: style
	      }, attrs, mouseEvent),
	      props.children
	    );
	  }
	});

	exports['default'] = MenuItem;
	module.exports = exports['default'];

/***/ },
/* 54 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	  value: true
	});

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var _react = __webpack_require__(7);

	var _react2 = _interopRequireDefault(_react);

	var MenuItemGroup = _react2['default'].createClass({
	  displayName: 'MenuItemGroup',

	  propTypes: {
	    renderMenuItem: _react.PropTypes.func,
	    index: _react.PropTypes.number
	  },

	  getDefaultProps: function getDefaultProps() {
	    return {
	      disabled: true
	    };
	  },

	  renderInnerMenuItem: function renderInnerMenuItem(item, subIndex) {
	    var renderMenuItem = this.props.renderMenuItem;
	    return renderMenuItem(item, this.props.index, subIndex);
	  },

	  render: function render() {
	    var props = this.props;
	    var className = props.className || '';
	    var rootPrefixCls = props.rootPrefixCls;

	    className += ' ' + rootPrefixCls + '-item-group';
	    var titleClassName = rootPrefixCls + '-item-group-title';
	    var listClassName = rootPrefixCls + '-item-group-list';
	    return _react2['default'].createElement(
	      'li',
	      { className: className },
	      _react2['default'].createElement(
	        'div',
	        { className: titleClassName },
	        props.title
	      ),
	      _react2['default'].createElement(
	        'ul',
	        { className: listClassName },
	        _react2['default'].Children.map(props.children, this.renderInnerMenuItem)
	      )
	    );
	  }
	});

	MenuItemGroup.isMenuItemGroup = true;

	exports['default'] = MenuItemGroup;
	module.exports = exports['default'];

/***/ },
/* 55 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	  value: true
	});

	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var _react = __webpack_require__(7);

	var _react2 = _interopRequireDefault(_react);

	var Divider = _react2['default'].createClass({
	  displayName: 'Divider',

	  getDefaultProps: function getDefaultProps() {
	    return {
	      disabled: true
	    };
	  },

	  render: function render() {
	    var props = this.props;
	    var className = props.className || '';
	    var rootPrefixCls = props.rootPrefixCls;
	    className += ' ' + (rootPrefixCls + '-item-divider');
	    return _react2['default'].createElement('li', _extends({}, props, { className: className }));
	  }
	});

	exports['default'] = Divider;
	module.exports = exports['default'];

/***/ },
/* 56 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	/**
	 * Dropdown Component for uxcore
	 * @author 
	 *
	 * Copyright 2014-2015, Uxcore Team, Alinw.
	 * All rights reserved.
	 */

	module.exports = __webpack_require__(57);

/***/ },
/* 57 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _rcDropdown = __webpack_require__(58);

	var _rcDropdown2 = _interopRequireDefault(_rcDropdown);

	var _objectAssign = __webpack_require__(9);

	var _objectAssign2 = _interopRequireDefault(_objectAssign);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var Dropdown = function (_RcDropdown) {
		_inherits(Dropdown, _RcDropdown);

		function Dropdown(props) {
			_classCallCheck(this, Dropdown);

			return _possibleConstructorReturn(this, _RcDropdown.call(this, props));
		}

		return Dropdown;
	}(_rcDropdown2["default"]);

	Dropdown.displayName = 'uxcore-dropdown';
	Dropdown.propTypes = _rcDropdown2["default"].propTypes;
	Dropdown.defaultProps = (0, _objectAssign2["default"])(_rcDropdown2["default"].defaultProps, {
		prefixCls: 'kuma-dropdown',
		overlayClassName: 'uxcore'
	});

	exports["default"] = Dropdown;
	module.exports = exports['default'];

/***/ },
/* 58 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _Dropdown = __webpack_require__(59);

	var _Dropdown2 = _interopRequireDefault(_Dropdown);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

	exports["default"] = _Dropdown2["default"];
	module.exports = exports['default'];

/***/ },
/* 59 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

	var _react = __webpack_require__(7);

	var _react2 = _interopRequireDefault(_react);

	var _reactDom = __webpack_require__(8);

	var _reactDom2 = _interopRequireDefault(_reactDom);

	var _rcTrigger = __webpack_require__(60);

	var _rcTrigger2 = _interopRequireDefault(_rcTrigger);

	var _placements = __webpack_require__(106);

	var _placements2 = _interopRequireDefault(_placements);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

	function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

	function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

	/*

	 var MenuItem = Menu.Item;

	 var menu = <Menu><MenuItem>1</MenuItem></Menu>;

	 <DropDown trigger="click" animationName="" overlay={<>} onSelect={}>
	 <button>open</button>
	 </DropDown>
	 */

	var Dropdown = _react2["default"].createClass({
	  displayName: 'Dropdown',

	  propTypes: {
	    minOverlayWidthMatchTrigger: _react.PropTypes.bool,
	    onVisibleChange: _react.PropTypes.func,
	    prefixCls: _react.PropTypes.string,
	    children: _react.PropTypes.any,
	    transitionName: _react.PropTypes.string,
	    overlayClassName: _react.PropTypes.string,
	    animation: _react.PropTypes.any,
	    align: _react.PropTypes.object,
	    overlayStyle: _react.PropTypes.object,
	    placement: _react.PropTypes.string,
	    trigger: _react.PropTypes.array,
	    showAction: _react.PropTypes.array,
	    hideAction: _react.PropTypes.array,
	    getPopupContainer: _react.PropTypes.func
	  },

	  getDefaultProps: function getDefaultProps() {
	    return {
	      minOverlayWidthMatchTrigger: true,
	      prefixCls: 'rc-dropdown',
	      trigger: ['hover'],
	      showAction: [],
	      hideAction: [],
	      overlayClassName: '',
	      overlayStyle: {},
	      defaultVisible: false,
	      onVisibleChange: function onVisibleChange() {},

	      placement: 'bottomLeft'
	    };
	  },
	  getInitialState: function getInitialState() {
	    var props = this.props;
	    if ('visible' in props) {
	      return {
	        visible: props.visible
	      };
	    }
	    return {
	      visible: props.defaultVisible
	    };
	  },
	  componentWillReceiveProps: function componentWillReceiveProps(props) {
	    if ('visible' in props) {
	      this.setState({
	        visible: props.visible
	      });
	    }
	  },
	  onClick: function onClick(e) {
	    var props = this.props;
	    var overlayProps = props.overlay.props;
	    if (!('visible' in props)) {
	      this.setState({
	        visible: false
	      });
	    }
	    if (overlayProps.onClick) {
	      overlayProps.onClick(e);
	    }
	  },
	  onVisibleChange: function onVisibleChange(v) {
	    var props = this.props;
	    if (!('visible' in props)) {
	      this.setState({
	        visible: v
	      });
	    }
	    props.onVisibleChange(v);
	  },
	  getMenuElement: function getMenuElement() {
	    var props = this.props;
	    return _react2["default"].cloneElement(props.overlay, {
	      prefixCls: props.prefixCls + '-menu',
	      onClick: this.onClick
	    });
	  },
	  getPopupDomNode: function getPopupDomNode() {
	    return this.refs.trigger.getPopupDomNode();
	  },
	  afterVisibleChange: function afterVisibleChange(visible) {
	    if (visible && this.props.minOverlayWidthMatchTrigger) {
	      var overlayNode = this.getPopupDomNode();
	      var rootNode = _reactDom2["default"].findDOMNode(this);
	      if (rootNode.offsetWidth > overlayNode.offsetWidth) {
	        overlayNode.style.width = rootNode.offsetWidth + 'px';
	      }
	    }
	  },
	  render: function render() {
	    var _extends2;

	    var _props = this.props;
	    var prefixCls = _props.prefixCls;
	    var children = _props.children;
	    var transitionName = _props.transitionName;
	    var animation = _props.animation;
	    var align = _props.align;
	    var placement = _props.placement;
	    var getPopupContainer = _props.getPopupContainer;
	    var showAction = _props.showAction;
	    var hideAction = _props.hideAction;
	    var overlayClassName = _props.overlayClassName;
	    var overlayStyle = _props.overlayStyle;
	    var trigger = _props.trigger;

	    var otherProps = _objectWithoutProperties(_props, ['prefixCls', 'children', 'transitionName', 'animation', 'align', 'placement', 'getPopupContainer', 'showAction', 'hideAction', 'overlayClassName', 'overlayStyle', 'trigger']);

	    return _react2["default"].createElement(
	      _rcTrigger2["default"],
	      _extends({}, otherProps, (_extends2 = {
	        prefixCls: prefixCls,
	        ref: 'trigger',
	        popupClassName: overlayClassName,
	        popupStyle: overlayStyle,
	        builtinPlacements: _placements2["default"],
	        action: trigger,
	        showAction: showAction
	      }, _defineProperty(_extends2, 'showAction', showAction), _defineProperty(_extends2, 'hideAction', hideAction), _defineProperty(_extends2, 'popupPlacement', placement), _defineProperty(_extends2, 'popupAlign', align), _defineProperty(_extends2, 'popupTransitionName', transitionName), _defineProperty(_extends2, 'popupAnimation', animation), _defineProperty(_extends2, 'popupVisible', this.state.visible), _defineProperty(_extends2, 'afterPopupVisibleChange', this.afterVisibleChange), _defineProperty(_extends2, 'popup', this.getMenuElement()), _defineProperty(_extends2, 'onPopupVisibleChange', this.onVisibleChange), _defineProperty(_extends2, 'getPopupContainer', getPopupContainer), _extends2)),
	      children
	    );
	  }
	});

	exports["default"] = Dropdown;
	module.exports = exports['default'];

/***/ },
/* 60 */
[559, 61],
/* 61 */
[560, 62, 82, 105],
/* 62 */
[543, 63, 64, 66, 67, 68, 69, 74, 75, 79, 80, 81],
/* 63 */
16,
/* 64 */
[544, 65],
/* 65 */
18,
/* 66 */
[545, 65],
/* 67 */
21,
/* 68 */
[546, 69],
/* 69 */
[547, 70],
/* 70 */
[548, 71, 72, 73],
/* 71 */
25,
/* 72 */
26,
/* 73 */
27,
/* 74 */
28,
/* 75 */
[549, 76],
/* 76 */
[550, 77],
/* 77 */
[551, 78, 9],
/* 78 */
32,
/* 79 */
33,
/* 80 */
34,
/* 81 */
35,
/* 82 */
[561, 83, 94, 103, 104],
/* 83 */
[562, 84],
/* 84 */
[563, 85, 62, 93],
/* 85 */
[564, 86, 87, 88, 89, 90, 91],
/* 86 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	var RE_NUM = /[\-+]?(?:\d*\.|)\d+(?:[eE][\-+]?\d+|)/.source;

	var getComputedStyleX = undefined;

	function css(el, name, v) {
	  var value = v;
	  if (typeof name === 'object') {
	    for (var i in name) {
	      if (name.hasOwnProperty(i)) {
	        css(el, i, name[i]);
	      }
	    }
	    return undefined;
	  }
	  if (typeof value !== 'undefined') {
	    if (typeof value === 'number') {
	      value = value + 'px';
	    }
	    el.style[name] = value;
	    return undefined;
	  }
	  return getComputedStyleX(el, name);
	}

	function getClientPosition(elem) {
	  var box = undefined;
	  var x = undefined;
	  var y = undefined;
	  var doc = elem.ownerDocument;
	  var body = doc.body;
	  var docElem = doc && doc.documentElement;
	  // 根据 GBS 最新数据，A-Grade Browsers 都已支持 getBoundingClientRect 方法，不用再考虑传统的实现方式
	  box = elem.getBoundingClientRect();

	  // 注：jQuery 还考虑减去 docElem.clientLeft/clientTop
	  // 但测试发现，这样反而会导致当 html 和 body 有边距/边框样式时，获取的值不正确
	  // 此外，ie6 会忽略 html 的 margin 值，幸运地是没有谁会去设置 html 的 margin

	  x = box.left;
	  y = box.top;

	  // In IE, most of the time, 2 extra pixels are added to the top and left
	  // due to the implicit 2-pixel inset border.  In IE6/7 quirks mode and
	  // IE6 standards mode, this border can be overridden by setting the
	  // document element's border to zero -- thus, we cannot rely on the
	  // offset always being 2 pixels.

	  // In quirks mode, the offset can be determined by querying the body's
	  // clientLeft/clientTop, but in standards mode, it is found by querying
	  // the document element's clientLeft/clientTop.  Since we already called
	  // getClientBoundingRect we have already forced a reflow, so it is not
	  // too expensive just to query them all.

	  // ie 下应该减去窗口的边框吧，毕竟默认 absolute 都是相对窗口定位的
	  // 窗口边框标准是设 documentElement ,quirks 时设置 body
	  // 最好禁止在 body 和 html 上边框 ，但 ie < 9 html 默认有 2px ，减去
	  // 但是非 ie 不可能设置窗口边框，body html 也不是窗口 ,ie 可以通过 html,body 设置
	  // 标准 ie 下 docElem.clientTop 就是 border-top
	  // ie7 html 即窗口边框改变不了。永远为 2
	  // 但标准 firefox/chrome/ie9 下 docElem.clientTop 是窗口边框，即使设了 border-top 也为 0

	  x -= docElem.clientLeft || body.clientLeft || 0;
	  y -= docElem.clientTop || body.clientTop || 0;

	  return { left: x, top: y };
	}

	function getScroll(w, top) {
	  var ret = w['page' + (top ? 'Y' : 'X') + 'Offset'];
	  var method = 'scroll' + (top ? 'Top' : 'Left');
	  if (typeof ret !== 'number') {
	    var d = w.document;
	    // ie6,7,8 standard mode
	    ret = d.documentElement[method];
	    if (typeof ret !== 'number') {
	      // quirks mode
	      ret = d.body[method];
	    }
	  }
	  return ret;
	}

	function getScrollLeft(w) {
	  return getScroll(w);
	}

	function getScrollTop(w) {
	  return getScroll(w, true);
	}

	function getOffset(el) {
	  var pos = getClientPosition(el);
	  var doc = el.ownerDocument;
	  var w = doc.defaultView || doc.parentWindow;
	  pos.left += getScrollLeft(w);
	  pos.top += getScrollTop(w);
	  return pos;
	}
	function _getComputedStyle(elem, name, cs) {
	  var computedStyle = cs;
	  var val = '';
	  var d = elem.ownerDocument;
	  computedStyle = computedStyle || d.defaultView.getComputedStyle(elem, null);

	  // https://github.com/kissyteam/kissy/issues/61
	  if (computedStyle) {
	    val = computedStyle.getPropertyValue(name) || computedStyle[name];
	  }

	  return val;
	}

	var _RE_NUM_NO_PX = new RegExp('^(' + RE_NUM + ')(?!px)[a-z%]+$', 'i');
	var RE_POS = /^(top|right|bottom|left)$/;
	var CURRENT_STYLE = 'currentStyle';
	var RUNTIME_STYLE = 'runtimeStyle';
	var LEFT = 'left';
	var PX = 'px';

	function _getComputedStyleIE(elem, name) {
	  // currentStyle maybe null
	  // http://msdn.microsoft.com/en-us/library/ms535231.aspx
	  var ret = elem[CURRENT_STYLE] && elem[CURRENT_STYLE][name];

	  // 当 width/height 设置为百分比时，通过 pixelLeft 方式转换的 width/height 值
	  // 一开始就处理了! CUSTOM_STYLE.height,CUSTOM_STYLE.width ,cssHook 解决@2011-08-19
	  // 在 ie 下不对，需要直接用 offset 方式
	  // borderWidth 等值也有问题，但考虑到 borderWidth 设为百分比的概率很小，这里就不考虑了

	  // From the awesome hack by Dean Edwards
	  // http://erik.eae.net/archives/2007/07/27/18.54.15/#comment-102291
	  // If we're not dealing with a regular pixel number
	  // but a number that has a weird ending, we need to convert it to pixels
	  // exclude left right for relativity
	  if (_RE_NUM_NO_PX.test(ret) && !RE_POS.test(name)) {
	    // Remember the original values
	    var style = elem.style;
	    var left = style[LEFT];
	    var rsLeft = elem[RUNTIME_STYLE][LEFT];

	    // prevent flashing of content
	    elem[RUNTIME_STYLE][LEFT] = elem[CURRENT_STYLE][LEFT];

	    // Put in the new values to get a computed value out
	    style[LEFT] = name === 'fontSize' ? '1em' : ret || 0;
	    ret = style.pixelLeft + PX;

	    // Revert the changed values
	    style[LEFT] = left;

	    elem[RUNTIME_STYLE][LEFT] = rsLeft;
	  }
	  return ret === '' ? 'auto' : ret;
	}

	if (typeof window !== 'undefined') {
	  getComputedStyleX = window.getComputedStyle ? _getComputedStyle : _getComputedStyleIE;
	}

	function getOffsetDirection(dir, option) {
	  if (dir === 'left') {
	    return option.useCssRight ? 'right' : dir;
	  }
	  return option.useCssBottom ? 'bottom' : dir;
	}

	function oppositeOffsetDirection(dir) {
	  if (dir === 'left') {
	    return 'right';
	  } else if (dir === 'right') {
	    return 'left';
	  } else if (dir === 'top') {
	    return 'bottom';
	  } else if (dir === 'bottom') {
	    return 'top';
	  }
	}

	// 设置 elem 相对 elem.ownerDocument 的坐标
	function setOffset(elem, offset, option) {
	  // set position first, in-case top/left are set even on static elem
	  if (css(elem, 'position') === 'static') {
	    elem.style.position = 'relative';
	  }
	  var presetH = -999;
	  var presetV = -999;
	  var horizontalProperty = getOffsetDirection('left', option);
	  var verticalProperty = getOffsetDirection('top', option);
	  var oppositeHorizontalProperty = oppositeOffsetDirection(horizontalProperty);
	  var oppositeVerticalProperty = oppositeOffsetDirection(verticalProperty);

	  if (horizontalProperty !== 'left') {
	    presetH = 999;
	  }

	  if (verticalProperty !== 'top') {
	    presetV = 999;
	  }

	  if ('left' in offset) {
	    elem.style[oppositeHorizontalProperty] = '';
	    elem.style[horizontalProperty] = presetH + 'px';
	  }
	  if ('top' in offset) {
	    elem.style[oppositeVerticalProperty] = '';
	    elem.style[verticalProperty] = presetV + 'px';
	  }
	  var old = getOffset(elem);
	  var ret = {};
	  var key = undefined;
	  for (key in offset) {
	    if (offset.hasOwnProperty(key)) {
	      var dir = getOffsetDirection(key, option);
	      var preset = key === 'left' ? presetH : presetV;
	      if (dir === key) {
	        ret[dir] = preset + offset[key] - old[key];
	      } else {
	        ret[dir] = preset + old[key] - offset[key];
	      }
	    }
	  }
	  css(elem, ret);
	}

	function each(arr, fn) {
	  for (var i = 0; i < arr.length; i++) {
	    fn(arr[i]);
	  }
	}

	function isBorderBoxFn(elem) {
	  return getComputedStyleX(elem, 'boxSizing') === 'border-box';
	}

	var BOX_MODELS = ['margin', 'border', 'padding'];
	var CONTENT_INDEX = -1;
	var PADDING_INDEX = 2;
	var BORDER_INDEX = 1;
	var MARGIN_INDEX = 0;

	function swap(elem, options, callback) {
	  var old = {};
	  var style = elem.style;
	  var name = undefined;

	  // Remember the old values, and insert the new ones
	  for (name in options) {
	    if (options.hasOwnProperty(name)) {
	      old[name] = style[name];
	      style[name] = options[name];
	    }
	  }

	  callback.call(elem);

	  // Revert the old values
	  for (name in options) {
	    if (options.hasOwnProperty(name)) {
	      style[name] = old[name];
	    }
	  }
	}

	function getPBMWidth(elem, props, which) {
	  var value = 0;
	  var prop = undefined;
	  var j = undefined;
	  var i = undefined;
	  for (j = 0; j < props.length; j++) {
	    prop = props[j];
	    if (prop) {
	      for (i = 0; i < which.length; i++) {
	        var cssProp = undefined;
	        if (prop === 'border') {
	          cssProp = prop + which[i] + 'Width';
	        } else {
	          cssProp = prop + which[i];
	        }
	        value += parseFloat(getComputedStyleX(elem, cssProp)) || 0;
	      }
	    }
	  }
	  return value;
	}

	/**
	 * A crude way of determining if an object is a window
	 * @member util
	 */
	function isWindow(obj) {
	  // must use == for ie8
	  /* eslint eqeqeq:0 */
	  return obj !== null && obj !== undefined && obj == obj.window;
	}

	var domUtils = {};

	each(['Width', 'Height'], function (name) {
	  domUtils['doc' + name] = function (refWin) {
	    var d = refWin.document;
	    return Math.max(
	    // firefox chrome documentElement.scrollHeight< body.scrollHeight
	    // ie standard mode : documentElement.scrollHeight> body.scrollHeight
	    d.documentElement['scroll' + name],
	    // quirks : documentElement.scrollHeight 最大等于可视窗口多一点？
	    d.body['scroll' + name], domUtils['viewport' + name](d));
	  };

	  domUtils['viewport' + name] = function (win) {
	    // pc browser includes scrollbar in window.innerWidth
	    var prop = 'client' + name;
	    var doc = win.document;
	    var body = doc.body;
	    var documentElement = doc.documentElement;
	    var documentElementProp = documentElement[prop];
	    // 标准模式取 documentElement
	    // backcompat 取 body
	    return doc.compatMode === 'CSS1Compat' && documentElementProp || body && body[prop] || documentElementProp;
	  };
	});

	/*
	 得到元素的大小信息
	 @param elem
	 @param name
	 @param {String} [extra]  'padding' : (css width) + padding
	 'border' : (css width) + padding + border
	 'margin' : (css width) + padding + border + margin
	 */
	function getWH(elem, name, ex) {
	  var extra = ex;
	  if (isWindow(elem)) {
	    return name === 'width' ? domUtils.viewportWidth(elem) : domUtils.viewportHeight(elem);
	  } else if (elem.nodeType === 9) {
	    return name === 'width' ? domUtils.docWidth(elem) : domUtils.docHeight(elem);
	  }
	  var which = name === 'width' ? ['Left', 'Right'] : ['Top', 'Bottom'];
	  var borderBoxValue = name === 'width' ? elem.offsetWidth : elem.offsetHeight;
	  var computedStyle = getComputedStyleX(elem);
	  var isBorderBox = isBorderBoxFn(elem, computedStyle);
	  var cssBoxValue = 0;
	  if (borderBoxValue === null || borderBoxValue === undefined || borderBoxValue <= 0) {
	    borderBoxValue = undefined;
	    // Fall back to computed then un computed css if necessary
	    cssBoxValue = getComputedStyleX(elem, name);
	    if (cssBoxValue === null || cssBoxValue === undefined || Number(cssBoxValue) < 0) {
	      cssBoxValue = elem.style[name] || 0;
	    }
	    // Normalize '', auto, and prepare for extra
	    cssBoxValue = parseFloat(cssBoxValue) || 0;
	  }
	  if (extra === undefined) {
	    extra = isBorderBox ? BORDER_INDEX : CONTENT_INDEX;
	  }
	  var borderBoxValueOrIsBorderBox = borderBoxValue !== undefined || isBorderBox;
	  var val = borderBoxValue || cssBoxValue;
	  if (extra === CONTENT_INDEX) {
	    if (borderBoxValueOrIsBorderBox) {
	      return val - getPBMWidth(elem, ['border', 'padding'], which, computedStyle);
	    }
	    return cssBoxValue;
	  } else if (borderBoxValueOrIsBorderBox) {
	    if (extra === BORDER_INDEX) {
	      return val;
	    }
	    return val + (extra === PADDING_INDEX ? -getPBMWidth(elem, ['border'], which, computedStyle) : getPBMWidth(elem, ['margin'], which, computedStyle));
	  }
	  return cssBoxValue + getPBMWidth(elem, BOX_MODELS.slice(extra), which, computedStyle);
	}

	var cssShow = { position: 'absolute', visibility: 'hidden', display: 'block' };

	// fix #119 : https://github.com/kissyteam/kissy/issues/119
	function getWHIgnoreDisplay() {
	  for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	    args[_key] = arguments[_key];
	  }

	  var val = undefined;
	  var elem = args[0];
	  // in case elem is window
	  // elem.offsetWidth === undefined
	  if (elem.offsetWidth !== 0) {
	    val = getWH.apply(undefined, args);
	  } else {
	    swap(elem, cssShow, function () {
	      val = getWH.apply(undefined, args);
	    });
	  }
	  return val;
	}

	each(['width', 'height'], function (name) {
	  var first = name.charAt(0).toUpperCase() + name.slice(1);
	  domUtils['outer' + first] = function (el, includeMargin) {
	    return el && getWHIgnoreDisplay(el, name, includeMargin ? MARGIN_INDEX : BORDER_INDEX);
	  };
	  var which = name === 'width' ? ['Left', 'Right'] : ['Top', 'Bottom'];

	  domUtils[name] = function (elem, v) {
	    var val = v;
	    if (val !== undefined) {
	      if (elem) {
	        var computedStyle = getComputedStyleX(elem);
	        var isBorderBox = isBorderBoxFn(elem);
	        if (isBorderBox) {
	          val += getPBMWidth(elem, ['padding', 'border'], which, computedStyle);
	        }
	        return css(elem, name, val);
	      }
	      return undefined;
	    }
	    return elem && getWHIgnoreDisplay(elem, name, CONTENT_INDEX);
	  };
	});

	function mix(to, from) {
	  for (var i in from) {
	    if (from.hasOwnProperty(i)) {
	      to[i] = from[i];
	    }
	  }
	  return to;
	}

	var utils = {
	  getWindow: function getWindow(node) {
	    if (node && node.document && node.setTimeout) {
	      return node;
	    }
	    var doc = node.ownerDocument || node;
	    return doc.defaultView || doc.parentWindow;
	  },
	  offset: function offset(el, value, option) {
	    if (typeof value !== 'undefined') {
	      setOffset(el, value, option || {});
	    } else {
	      return getOffset(el);
	    }
	  },
	  isWindow: isWindow,
	  each: each,
	  css: css,
	  clone: function clone(obj) {
	    var i = undefined;
	    var ret = {};
	    for (i in obj) {
	      if (obj.hasOwnProperty(i)) {
	        ret[i] = obj[i];
	      }
	    }
	    var overflow = obj.overflow;
	    if (overflow) {
	      for (i in obj) {
	        if (obj.hasOwnProperty(i)) {
	          ret.overflow[i] = obj.overflow[i];
	        }
	      }
	    }
	    return ret;
	  },
	  mix: mix,
	  getWindowScrollLeft: function getWindowScrollLeft(w) {
	    return getScrollLeft(w);
	  },
	  getWindowScrollTop: function getWindowScrollTop(w) {
	    return getScrollTop(w);
	  },
	  merge: function merge() {
	    var ret = {};

	    for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
	      args[_key2] = arguments[_key2];
	    }

	    for (var i = 0; i < args.length; i++) {
	      utils.mix(ret, args[i]);
	    }
	    return ret;
	  },
	  viewportWidth: 0,
	  viewportHeight: 0
	};

	mix(utils, domUtils);

	exports['default'] = utils;
	module.exports = exports['default'];

/***/ },
/* 87 */
[565, 86],
/* 88 */
[566, 86, 87],
/* 89 */
[567, 86],
/* 90 */
[568, 86],
/* 91 */
[569, 92],
/* 92 */
/***/ function(module, exports) {

	/**
	 * 获取 node 上的 align 对齐点 相对于页面的坐标
	 */

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	function getAlignOffset(region, align) {
	  var V = align.charAt(0);
	  var H = align.charAt(1);
	  var w = region.width;
	  var h = region.height;
	  var x = undefined;
	  var y = undefined;

	  x = region.left;
	  y = region.top;

	  if (V === 'c') {
	    y += h / 2;
	  } else if (V === 'b') {
	    y += h;
	  }

	  if (H === 'c') {
	    x += w / 2;
	  } else if (H === 'r') {
	    x += w;
	  }

	  return {
	    left: x,
	    top: y
	  };
	}

	exports['default'] = getAlignOffset;
	module.exports = exports['default'];

/***/ },
/* 93 */
/***/ function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports["default"] = isWindow;
	function isWindow(obj) {
	  /* eslint no-eq-null: 0 */
	  /* eslint eqeqeq: 0 */
	  return obj != null && obj == obj.window;
	}
	module.exports = exports['default'];

/***/ },
/* 94 */
[554, 95],
/* 95 */
[555, 96, 97, 102],
/* 96 */
45,
/* 97 */
[556, 98, 102],
/* 98 */
[557, 99, 100],
/* 99 */
48,
/* 100 */
[558, 101, 101],
/* 101 */
50,
/* 102 */
51,
/* 103 */
[570, 104],
/* 104 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

	var _react = __webpack_require__(7);

	var _react2 = _interopRequireDefault(_react);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

	var LazyRenderBox = _react2["default"].createClass({
	  displayName: 'LazyRenderBox',

	  propTypes: {
	    children: _react.PropTypes.any,
	    className: _react.PropTypes.string,
	    visible: _react.PropTypes.bool,
	    hiddenClassName: _react.PropTypes.string
	  },
	  shouldComponentUpdate: function shouldComponentUpdate(nextProps) {
	    return nextProps.hiddenClassName || nextProps.visible;
	  },
	  render: function render() {
	    if (this.props.hiddenClassName) {
	      var className = this.props.className;
	      if (!this.props.visible) {
	        className += ' ' + this.props.hiddenClassName;
	      }
	      return _react2["default"].createElement('div', _extends({}, this.props, { className: className }));
	    }
	    if (_react2["default"].Children.count(this.props.children) > 1) {
	      return _react2["default"].createElement('div', this.props);
	    }
	    return _react2["default"].Children.only(this.props.children);
	  }
	});

	exports["default"] = LazyRenderBox;
	module.exports = exports['default'];

/***/ },
/* 105 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

	exports.getAlignFromPlacement = getAlignFromPlacement;
	exports.getPopupClassNameFromAlign = getPopupClassNameFromAlign;
	function isPointsEq(a1, a2) {
	  return a1[0] === a2[0] && a1[1] === a2[1];
	}

	function getAlignFromPlacement(builtinPlacements, placementStr, align) {
	  var baseAlign = builtinPlacements[placementStr] || {};
	  return _extends({}, baseAlign, align);
	}

	function getPopupClassNameFromAlign(builtinPlacements, prefixCls, align) {
	  var points = align.points;
	  for (var placement in builtinPlacements) {
	    if (builtinPlacements.hasOwnProperty(placement)) {
	      if (isPointsEq(builtinPlacements[placement].points, points)) {
	        return prefixCls + '-placement-' + placement;
	      }
	    }
	  }
	  return '';
	}

/***/ },
/* 106 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var autoAdjustOverflow = {
	  adjustX: 1,
	  adjustY: 1
	};

	var targetOffset = [0, 0];

	var placements = exports.placements = {
	  topLeft: {
	    points: ['bl', 'tl'],
	    overflow: autoAdjustOverflow,
	    offset: [0, -4],
	    targetOffset: targetOffset
	  },
	  bottomLeft: {
	    points: ['tl', 'bl'],
	    overflow: autoAdjustOverflow,
	    offset: [0, 4],
	    targetOffset: targetOffset
	  }
	};

	exports["default"] = placements;

/***/ },
/* 107 */
[571, 108],
/* 108 */
[572, 109, 9],
/* 109 */
[573, 110],
/* 110 */
[574, 111, 112],
/* 111 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var autoAdjustOverflow = {
	  adjustX: 1,
	  adjustY: 1
	};

	var targetOffset = [0, 0];

	var placements = exports.placements = {
	  left: {
	    points: ['cr', 'cl'],
	    overflow: autoAdjustOverflow,
	    offset: [-4, 0],
	    targetOffset: targetOffset
	  },
	  right: {
	    points: ['cl', 'cr'],
	    overflow: autoAdjustOverflow,
	    offset: [4, 0],
	    targetOffset: targetOffset
	  },
	  top: {
	    points: ['bc', 'tc'],
	    overflow: autoAdjustOverflow,
	    offset: [0, -4],
	    targetOffset: targetOffset
	  },
	  bottom: {
	    points: ['tc', 'bc'],
	    overflow: autoAdjustOverflow,
	    offset: [0, 4],
	    targetOffset: targetOffset
	  },
	  topLeft: {
	    points: ['bl', 'tl'],
	    overflow: autoAdjustOverflow,
	    offset: [0, -4],
	    targetOffset: targetOffset
	  },
	  leftTop: {
	    points: ['tr', 'tl'],
	    overflow: autoAdjustOverflow,
	    offset: [-4, 0],
	    targetOffset: targetOffset
	  },
	  topRight: {
	    points: ['br', 'tr'],
	    overflow: autoAdjustOverflow,
	    offset: [0, -4],
	    targetOffset: targetOffset
	  },
	  rightTop: {
	    points: ['tl', 'tr'],
	    overflow: autoAdjustOverflow,
	    offset: [4, 0],
	    targetOffset: targetOffset
	  },
	  bottomRight: {
	    points: ['tr', 'br'],
	    overflow: autoAdjustOverflow,
	    offset: [0, 4],
	    targetOffset: targetOffset
	  },
	  rightBottom: {
	    points: ['bl', 'br'],
	    overflow: autoAdjustOverflow,
	    offset: [4, 0],
	    targetOffset: targetOffset
	  },
	  bottomLeft: {
	    points: ['tl', 'bl'],
	    overflow: autoAdjustOverflow,
	    offset: [0, 4],
	    targetOffset: targetOffset
	  },
	  leftBottom: {
	    points: ['br', 'bl'],
	    overflow: autoAdjustOverflow,
	    offset: [-4, 0],
	    targetOffset: targetOffset
	  }
	};

	exports["default"] = placements;

/***/ },
/* 112 */
[559, 113],
/* 113 */
[560, 114, 134, 157],
/* 114 */
[543, 115, 116, 118, 119, 120, 121, 126, 127, 131, 132, 133],
/* 115 */
16,
/* 116 */
[544, 117],
/* 117 */
18,
/* 118 */
[545, 117],
/* 119 */
21,
/* 120 */
[546, 121],
/* 121 */
[547, 122],
/* 122 */
[548, 123, 124, 125],
/* 123 */
25,
/* 124 */
26,
/* 125 */
27,
/* 126 */
28,
/* 127 */
[549, 128],
/* 128 */
[550, 129],
/* 129 */
[551, 130, 9],
/* 130 */
32,
/* 131 */
33,
/* 132 */
34,
/* 133 */
35,
/* 134 */
[561, 135, 146, 155, 156],
/* 135 */
[562, 136],
/* 136 */
[563, 137, 114, 145],
/* 137 */
[564, 138, 139, 140, 141, 142, 143],
/* 138 */
86,
/* 139 */
[565, 138],
/* 140 */
[566, 138, 139],
/* 141 */
[567, 138],
/* 142 */
[568, 138],
/* 143 */
[569, 144],
/* 144 */
92,
/* 145 */
93,
/* 146 */
[554, 147],
/* 147 */
[555, 148, 149, 154],
/* 148 */
45,
/* 149 */
[556, 150, 154],
/* 150 */
[557, 151, 152],
/* 151 */
48,
/* 152 */
[558, 153, 153],
/* 153 */
50,
/* 154 */
51,
/* 155 */
[570, 156],
/* 156 */
104,
/* 157 */
105,
/* 158 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	exports.__esModule = true;

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	/**
	 * Created by xy on 15/4/13.
	 */

	var Row = __webpack_require__(159);
	var Mask = __webpack_require__(254);
	var util = __webpack_require__(255);
	var deepcopy = __webpack_require__(242);

	var React = __webpack_require__(7);
	var ReactDOM = __webpack_require__(8);

	var Tbody = function (_React$Component) {
	    _inherits(Tbody, _React$Component);

	    function Tbody(props) {
	        _classCallCheck(this, Tbody);

	        var _this = _possibleConstructorReturn(this, _React$Component.call(this, props));

	        _this.state = {};
	        return _this;
	    }

	    Tbody.prototype.componentDidMount = function componentDidMount() {
	        var me = this;
	        me.rootEl = ReactDOM.findDOMNode(me.refs.root);
	        me.scrollHandler = me.onScroll.bind(me);
	        $(me.rootEl).on("scroll", me.scrollHandler);
	    };

	    Tbody.prototype.componentWillUnmount = function componentWillUnmount() {
	        var me = this;
	        me.resizeTimer = null;
	        $(me.rootEl).off("scroll", me.scrollHandler);
	    };

	    Tbody.prototype.renderEmptyData = function renderEmptyData() {

	        if (this.props.data.length == 0 && !this.props.mask) {
	            var _style = {
	                lineHeight: this.props.height - 10 + "px"
	            };
	            return React.createElement(
	                "div",
	                { className: "kuma-uxtable-body-emptyword", style: _style },
	                this.props.root.props.emptyText
	            );
	        }
	    };

	    Tbody.prototype.onScroll = function onScroll(e) {
	        // TODO: remove jquery animation
	        //       merge classname scroll/no/fixed

	        this.el = ReactDOM.findDOMNode(this);
	        var $tableEl = $(this.el).parents(".kuma-uxtable");
	        if (this.props.fixedColumn == 'no') {
	            $tableEl.find('.kuma-uxtable-header-no').animate({
	                scrollLeft: $tableEl.find('.kuma-uxtable-body-no').scrollLeft()
	            }, 0);
	            return;
	        }

	        var target = $(e.target);
	        if (target.hasClass('kuma-uxtable-body-scroll')) {

	            $tableEl.find('.kuma-uxtable-body-fixed').animate({
	                scrollTop: $tableEl.find('.kuma-uxtable-body-scroll').scrollTop()
	            }, 0);
	            $tableEl.find('.kuma-uxtable-header-scroll').animate({
	                scrollLeft: $tableEl.find('.kuma-uxtable-body-scroll').scrollLeft()
	            }, 0);
	        } else {
	            $tableEl.find('.kuma-uxtable-body-scroll').animate({
	                scrollTop: $tableEl.find('.kuma-uxtable-body-fixed').scrollTop()
	            }, 0);
	        }
	    };

	    Tbody.prototype.render = function render() {

	        var me = this,
	            _props = me.props,
	            _columns = _props.columns,
	            _data = _props.data.length > 0 ? _props.data : [],
	            _style = {},
	            _width = 0,
	            bodyWrapClassName = undefined;

	        if (_props.fixedColumn == 'fixed') {
	            _columns = _props.columns.filter(function (item) {
	                if (item.fixed && !item.hidden) {
	                    if (!item.width) {
	                        item.width = 100;
	                    }
	                    _width = item.width * 1 + _width;
	                    return true;
	                }
	            });
	            _style = {
	                width: _width,
	                minWidth: _width
	            };
	            bodyWrapClassName = "kuma-uxtable-body-fixed";
	        } else if (_props.fixedColumn == 'scroll') {
	            var fixedWidth = 0;
	            _columns = _props.columns.filter(function (item) {
	                if (!item.fixed) {
	                    return true;
	                } else if (!item.hidden) {
	                    if (!item.width) {
	                        item.width = 100;
	                    }
	                    _width = item.width * 1 + _width;
	                }
	            });

	            // content-box: border-box
	            var delta = 2;
	            if (util.isIE(8)) {
	                delta = 3;
	            }
	            _style = {
	                width: _props.width - _width - delta, //change 2 to 3, fix ie8 issue
	                minWidth: _props.width - _width - delta
	            };
	            bodyWrapClassName = "kuma-uxtable-body-scroll";
	        } else {
	            bodyWrapClassName = "kuma-uxtable-body-no";
	        }
	        return React.createElement(
	            "div",
	            { className: bodyWrapClassName, ref: "root", style: _style },
	            React.createElement(
	                "ul",
	                { className: this.props.jsxprefixCls },
	                this.renderEmptyData(),
	                _data.map(function (item, index) {
	                    var renderProps = {
	                        columns: _columns,
	                        rowIndex: item.jsxid, //tree mode, rowIndex need think more, so use jsxid
	                        rowData: deepcopy(_data[index]),
	                        index: index,
	                        data: _data,
	                        root: _props.root,
	                        addRowClassName: _props.addRowClassName,
	                        rowSelection: _props.rowSelection,
	                        changeSelected: me.props.changeSelected,
	                        subComp: _props.subComp,
	                        renderSubComp: _props.renderSubComp,
	                        actions: _props.actions,
	                        key: 'row' + index,
	                        mode: _props.mode,
	                        renderModel: _props.renderModel,
	                        fixedColumn: _props.fixedColumn,
	                        level: 1,
	                        levels: _props.levels,
	                        handleDataChange: _props.handleDataChange,
	                        attachCellField: _props.attachCellField,
	                        detachCellField: _props.detachCellField,
	                        visible: true
	                    };
	                    return React.createElement(Row, renderProps);
	                }),
	                React.createElement(Mask, { visible: _props.mask, text: _props.loadingText })
	            )
	        );
	    };

	    return Tbody;
	}(React.Component);

	;

	Tbody.propTypes = {};

	Tbody.defaultProps = {
	    jsxprefixCls: "kuma-uxtable-body"
	};

	exports["default"] = Tbody;
	module.exports = exports['default'];

/***/ },
/* 159 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	/**
	 * Created by xy on 15/4/13.
	 */
	var Cell = __webpack_require__(160);
	var classnames = __webpack_require__(19);
	var assign = __webpack_require__(9);
	var Const = __webpack_require__(5);
	var deepEqual = __webpack_require__(251);
	var deepcopy = __webpack_require__(242);

	var React = __webpack_require__(7);
	var ReactDOM = __webpack_require__(8);

	var Row = function (_React$Component) {
	    _inherits(Row, _React$Component);

	    function Row(props) {
	        _classCallCheck(this, Row);

	        var _this = _possibleConstructorReturn(this, _React$Component.call(this, props));

	        _this.state = {
	            expanded: _this.props.level < _this.props.levels ? true : false
	        };
	        return _this;
	    }

	    Row.prototype.shouldComponentUpdate = function shouldComponentUpdate(nextProps, nextState) {
	        // 需要考虑的 prop 包括
	        // columns, rowIndex(s), rowData, index(s), addRowClassName(f), rowSelection, subComp(f), actions
	        // mode(s), renderModel(s), fixedColumn(s), levels(s), visible(s)
	        var me = this;
	        var shouldUpdate = false;
	        ['rowIndex', 'index', 'mode', 'renderModel', 'fixedColumn', 'levels', 'addRowClassName', 'subComp', 'visible'].forEach(function (item) {
	            if (me.props[item] !== nextProps[item]) {
	                shouldUpdate = true;
	            }
	        });
	        if (!shouldUpdate) {
	            ['columns', 'rowData', 'rowSelection', 'actions'].forEach(function (item, index) {
	                if (!deepEqual(me.props[item], nextProps[item])) {
	                    shouldUpdate = true;
	                }
	            });
	        };
	        if (!shouldUpdate) {
	            shouldUpdate = me.state.expanded !== nextState.expanded;
	        }
	        return shouldUpdate;
	    };

	    Row.prototype.handleClick = function handleClick(rowData) {
	        var me = this;
	    };

	    Row.prototype.handleDoubleClick = function handleDoubleClick(rowData) {
	        var table = this.props.root;
	        if (table.props.doubleClickToEdit) {
	            table.editRow(deepcopy(rowData));
	        }
	    };

	    Row.prototype.showSubCompFunc = function showSubCompFunc() {
	        var me = this;
	        me.props.root.toggleSubComp(me.props.rowData);
	    };

	    Row.prototype.renderSubComp = function renderSubComp() {
	        var props = this.props;

	        if (props.renderModel == 'tree') {
	            return false;
	        } else {
	            if (props.subComp) {
	                if (props.rowData.showSubComp) {
	                    var subComp = React.cloneElement(props.subComp, {
	                        passedData: this.props.rowData,
	                        parentHasCheckbox: !!this.props.rowSelection,
	                        parentHasCheck: !!this.props.rowSelection /////
	                    });
	                    return React.createElement(
	                        'div',
	                        { className: 'kuma-uxtable-subrow', ref: 'subRow' },
	                        subComp
	                    );
	                }
	                return false;
	            } else if (props.renderSubComp) {
	                var subComp = props.renderSubComp(deepcopy(props.rowData));
	                if (subComp && props.rowData.showSubComp) {
	                    return React.createElement(
	                        'div',
	                        { className: 'kuma-uxtable-subrow', ref: 'subRow' },
	                        subComp
	                    );
	                }
	                return false;
	            } else {
	                return false;
	            }
	        }
	    };

	    Row.prototype.renderChild = function renderChild() {

	        var props = this.props,
	            me = this,
	            children = [];

	        if (props.renderModel !== 'tree') {
	            return children;
	        }
	        if (props.rowData.datas) {
	            props.rowData.datas.forEach(function (node) {
	                var renderProps = assign({}, props, {
	                    level: me.props.level + 1,
	                    rowData: node,
	                    rowIndex: node.jsxid,
	                    key: node.jsxid,
	                    showSubComp: false,
	                    visible: me.state.expanded && me.props.visible
	                });
	                children.push(React.createElement(Row, renderProps));
	            });

	            var renderProps = {
	                key: "treeRow" + this.props.rowData.jsxid,
	                className: "kuma-uxtable-tree-row"
	            };

	            children = React.createElement(
	                'ul',
	                renderProps,
	                children
	            );
	        }

	        return children;
	    };

	    Row.prototype.renderExpendIcon = function renderExpendIcon(rowIndex) {

	        var expandCollapseIcon = undefined,
	            props = this.props,
	            _expandIconClass = undefined;

	        if (props.renderModel !== 'tree') {
	            return false;
	        }

	        if (props.rowData.datas) {
	            if (!this.state.expanded) {

	                _expandIconClass = {
	                    "kuma-icon": true,
	                    "kuma-icon-tree-open-2": false,
	                    "kuma-icon-tree-close-2": true
	                };
	                _expandIconClass["kuma-uxtable-expandIcon-" + props.fixedColumn + "-" + rowIndex] = true;

	                expandCollapseIcon = React.createElement(
	                    'span',
	                    { className: 'kuma-uxtable-tree-icon', 'data-type': props.fixedColumn, 'data-index': rowIndex,
	                        onClick: this.toggleExpanded.bind(this) },
	                    React.createElement('i', { className: classnames(_expandIconClass) })
	                );
	            } else {

	                _expandIconClass = {
	                    "kuma-icon": true,
	                    "kuma-icon-tree-open-2": true,
	                    "kuma-icon-tree-close-2": false
	                };
	                _expandIconClass["kuma-uxtable-expandIcon-" + props.fixedColumn + "-" + rowIndex] = true;

	                expandCollapseIcon = React.createElement(
	                    'span',
	                    { className: 'kuma-uxtable-tree-icon', 'data-type': props.fixedColumn, 'data-index': rowIndex,
	                        onClick: this.toggleExpanded.bind(this) },
	                    React.createElement('i', { className: classnames(_expandIconClass) })
	                );
	            }
	        } else {
	            expandCollapseIcon = React.createElement('span', { className: 'kuma-uxtable-emptyicon' });
	        }
	        return expandCollapseIcon;
	    };

	    Row.prototype.renderIndent = function renderIndent() {
	        var indents = [];
	        if (this.props.renderModel == 'tree') {
	            for (var i = 0; i < this.props.level - 1; i++) {
	                var renderProps = {
	                    className: "indent",
	                    key: 'indent' + i
	                };
	                indents.push(React.createElement('span', renderProps));
	            }
	        }

	        return indents;
	    };

	    Row.prototype.toggleExpanded = function toggleExpanded(e) {
	        this.setState({
	            expanded: !this.state.expanded
	        });
	        e.stopPropagation();
	        var t = $(e.target);
	        if (!t.hasClass('kuma-uxtable-tree-icon')) {
	            t = t.parents('.kuma-uxtable-tree-icon');
	        }
	        if (t.data('type') == 'fixed') {
	            $(".kuma-uxtable-expandIcon-scroll" + "-" + t.data('index')).trigger('click');
	        } else if (t.data('type') == 'scroll') {
	            $(".kuma-uxtable-expandIcon-fixed" + "-" + t.data('index')).trigger('click');
	        }
	    };

	    Row.prototype.render = function render() {
	        var _classnames;

	        var props = this.props,
	            _columns = [],
	            _style = {},
	            _data = props.data,
	            me = this,
	            otherCls = props.addRowClassName(_data[props.rowIndex]);

	        if (!this.props.visible) {
	            _style = {
	                display: 'none'
	            };
	        }

	        props.columns.forEach(function (column, index) {
	            if ("group" in column) {
	                _columns = _columns.concat(column.columns);
	            } else {
	                _columns.push(column);
	            }
	        });

	        var firstVisableColumn = 0;

	        return React.createElement(
	            'li',
	            { className: classnames((_classnames = {}, _classnames[this.props.prefixCls] = true, _classnames[otherCls] = !!otherCls, _classnames['even'] = props.rowIndex % 2 == 1 ? true : false, _classnames)), style: _style,
	                onClick: this.handleClick.bind(this, props.rowData),
	                onDoubleClick: this.handleDoubleClick.bind(this, props.rowData) },
	            React.createElement(
	                'div',
	                { className: this.props.prefixCls + '-cells' },
	                _columns.map(function (item, index) {
	                    if (item.hidden) return;
	                    firstVisableColumn++;
	                    var renderProps = {
	                        column: item,
	                        root: props.root,
	                        align: item.align,
	                        rowData: props.rowData,
	                        rowIndex: props.rowIndex,
	                        index: props.index,
	                        cellIndex: index,
	                        hasSubComp: props.subComp ? true : props.renderSubComp ? props.renderSubComp(deepcopy(props.rowData)) : false,
	                        data: _data,
	                        changeSelected: me.props.changeSelected,
	                        showSubCompCallback: me.showSubCompFunc.bind(me),
	                        rowSelection: props.rowSelection,
	                        actions: props.actions,
	                        mode: props.mode,
	                        handleDataChange: props.handleDataChange,
	                        attachCellField: props.attachCellField,
	                        detachCellField: props.detachCellField,
	                        key: "cell" + index
	                    };

	                    if (firstVisableColumn == 1) {
	                        return React.createElement(
	                            Cell,
	                            renderProps,
	                            me.renderIndent(),
	                            me.renderExpendIcon(props.rowIndex)
	                        );
	                    }
	                    //if have vertical data structure, how to process it
	                    return React.createElement(Cell, renderProps);
	                })
	            ),
	            me.renderChild(),
	            this.renderSubComp()
	        );
	    };

	    return Row;
	}(React.Component);

	;

	Row.propTypes = {
	    prefixCls: React.PropTypes.string,
	    showSubComp: React.PropTypes.bool
	};

	Row.defaultProps = {
	    prefixCls: "kuma-uxtable-row",
	    showSubComp: false
	};

	exports["default"] = Row;
	module.exports = exports['default'];

/***/ },
/* 160 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	/**
	 * Created by xy on 15/4/13.
	 */

	var React = __webpack_require__(7);
	var ReactDOM = __webpack_require__(8);
	var Const = __webpack_require__(5);
	var Dropdown = __webpack_require__(56);
	var Menu = __webpack_require__(10);

	var CheckBox = __webpack_require__(4);
	var Radio = __webpack_require__(161);
	var TextField = __webpack_require__(162);
	var SelectField = __webpack_require__(164);
	var RadioField = __webpack_require__(235);
	var util = __webpack_require__(239);
	var classnames = __webpack_require__(19);
	var assign = __webpack_require__(9);
	var deepcopy = __webpack_require__(242);
	var fieldsMap = {
	    "select": SelectField,
	    "text": TextField,
	    "radio": RadioField
	};

	var Cell = function (_React$Component) {
	    _inherits(Cell, _React$Component);

	    function Cell(props) {
	        _classCallCheck(this, Cell);

	        var _this = _possibleConstructorReturn(this, _React$Component.call(this, props));

	        _this.state = {
	            'fold': 1, // 1- fold  0-unfold
	            'checked': !!_this.getCellData()
	        };
	        return _this;
	    }

	    Cell.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
	        var me = this;
	        if (me.props.column.type == "checkbox" || me.props.column.type == "checkboxSelector" || me.props.column.type == "radioSelector") {
	            me.setState({
	                checked: !!me.getCellData(nextProps)
	            });
	        }
	    };

	    Cell.prototype.componentDidMount = function componentDidMount() {
	        var me = this;
	        if (me.props.column.type == "checkbox" || me.props.column.type == "checkboxSelector" || me.props.column.type == "radioSelector") {
	            me.props.changeSelected(me.state.checked, me.props.rowIndex, true);
	        }
	    };

	    Cell.prototype.handleCheckChange = function handleCheckChange(e) {
	        var me = this,
	            _props = this.props,
	            v = _props.rowData;
	        me.props.changeSelected(e.target.checked, _props.rowIndex, false);
	    };

	    Cell.prototype.handleDropdownVisibleChange = function handleDropdownVisibleChange(visible) {
	        var me = this;
	        me.setState({
	            dropdownVisible: visible
	        });
	    };

	    Cell.prototype.showSubComp = function showSubComp() {
	        this.props.showSubCompCallback.apply();
	    };

	    /**
	     * @param actions {Array or Object}
	     */


	    Cell.prototype.getActionItems = function getActionItems(actions) {
	        if ((typeof actions === 'undefined' ? 'undefined' : _typeof(actions)) !== "object") {
	            console.error("Table: Actions should be an object or array");
	            return [];
	        } else {
	            var me = this;
	            me.items = [];
	            if (actions instanceof Array) {
	                me.items = actions;
	            } else {
	                for (var i in actions) {
	                    if (actions.hasOwnProperty(i)) {
	                        me.items.push({
	                            title: i,
	                            callback: actions[i]
	                        });
	                    }
	                }
	            }

	            return me.items;
	        }
	    };

	    Cell.prototype.getEditData = function getEditData() {
	        var me = this;
	        var column = me.props.column;
	        var editKey = column.editKey || column.dataKey;
	        return me.props.rowData[editKey];
	    };

	    Cell.prototype.getCellData = function getCellData(nextProps) {

	        var props = nextProps || this.props,
	            _column = props.column,
	            cellData = props.rowData[_column.dataKey];

	        return cellData;
	    };

	    Cell.prototype.handleActionClick = function handleActionClick(cb, e) {
	        e.stopPropagation();
	        var me = this;
	        me.setState({
	            dropdownVisible: false
	        });
	        cb && cb();
	    };

	    Cell.prototype.render = function render() {

	        var me = this,
	            props = me.props,
	            _column = props.column,
	            _width = _column.width,
	            _mode = props.rowData['__mode__'],
	            _style = {
	            width: _width ? _width : 100,
	            textAlign: props.align ? props.align : "left"
	        },
	            _v = deepcopy(props.rowData),
	            renderProps = undefined;

	        if (_column.type == 'action') {
	            _v = React.createElement(
	                'div',
	                { className: 'action-container' },
	                me.renderActionItems(_column, _v, _mode)
	            );
	        } else if (_column.type == 'checkbox' || _column.type == 'checkboxSelector') {

	            _style.paddingRight = 4;
	            _style.paddingLeft = 12;

	            var checked = undefined;
	            if (me.state.checked) {
	                checked = 'checked';
	            } else {
	                checked = "";
	            }

	            var disable = false;
	            if ('disable' in _column) {
	                disable = _column.disable;
	            } else if ('isDisable' in _column) {
	                disable = !!_column.isDisable(props.rowData);
	            }
	            _v = React.createElement(CheckBox, { disable: disable, mode: props.mode, align: props.align, jsxchecked: checked, ref: 'checkbox', onchange: me.handleCheckChange.bind(me) });
	        } else if (_column.type == 'radioSelector') {
	            _style.paddingRight = 4;
	            _style.paddingLeft = 12;

	            var checked = undefined;
	            if (me.state.checked) {
	                checked = 'checked';
	            } else {
	                checked = "";
	            }

	            var disable = false;
	            if ('disable' in _column) {
	                disable = _column.disable;
	            } else if ('isDisable' in _column) {
	                disable = !!_column.isDisable(props.rowData);
	            }
	            _v = React.createElement(Radio, { disable: disable, mode: props.mode, align: props.align, jsxchecked: checked, onchange: me.handleCheckChange.bind(me) });
	        } else if (_column.type == 'treeIcon') {
	            _v = me.renderTreeIcon();
	        }

	        // inline edit mode
	        else if ((_column.type == 'custom' || _column.type in fieldsMap) && _mode == Const.MODE.EDIT && (!('canEdit' in _column) || _column.canEdit(props.rowData))) {
	                renderProps = {
	                    value: me.getEditData(),
	                    rowData: props.rowData,
	                    index: props.index,
	                    column: _column,
	                    handleDataChange: props.handleDataChange,
	                    attachCellField: props.attachCellField,
	                    detachCellField: props.detachCellField
	                };
	                var Field = undefined;

	                if (_column.type == 'custom') {
	                    Field = props.column.customField;
	                } else {
	                    Field = fieldsMap[_column.type];
	                }
	                _v = React.createElement(Field, renderProps);
	            } else if (_column.type == 'money' || _column.type == "card" || _column.type == "cnmobile") {
	                _v = React.createElement(
	                    'div',
	                    { className: 'default-cell', title: me.getCellData() },
	                    util.formatValue(me.getCellData(), _column.type, _column.delimiter)
	                );
	            } else if (_column.render) {
	                _v = _column.render.apply(null, [me.getCellData(), _v]);
	            } else {
	                _v = React.createElement(
	                    'div',
	                    { className: 'default-cell', title: me.getCellData() },
	                    me.getCellData()
	                );
	            }

	        var child = me.props.children;
	        return React.createElement(
	            'div',
	            { className: props.jsxprefixCls, style: _style },
	            child,
	            _v
	        );
	    };

	    /**
	     * @param {Object} column current column config
	     * @param {Object} rowData current row data
	     * @param {String} mode current row mode: edit or view, same as rowData['__mode__'] 
	     */

	    Cell.prototype.renderActionItems = function renderActionItems(column, rowData, mode) {
	        var me = this;
	        var actions = me.getActionItems(column.actions).filter(function (item) {
	            return !('mode' in item) || item.mode == mode;
	        });
	        if (actions.length <= 2) {
	            return actions.map(function (item, index) {
	                return React.createElement(
	                    'a',
	                    { href: 'javascript:void(0);', key: index, className: 'action', onClick: me.handleActionClick.bind(me, item.callback.bind(me, rowData, me.props.root)) },
	                    !!item.render ? item.render(item.title, me.props.rowData) : item.title
	                );
	            });
	        } else {
	            var arr = [];
	            arr.push(React.createElement(
	                'a',
	                { href: 'javascript:void(0);', className: 'action', key: 'action', onClick: me.handleActionClick.bind(me, actions[0].callback.bind(me, rowData, me.props.root)) },
	                !!actions[0].render ? actions[0].render(actions[0].title, me.props.rowData) : actions[0].title
	            ));
	            var menu = React.createElement(
	                Menu,
	                null,
	                actions.slice(1).map(function (action, index) {
	                    return React.createElement(
	                        Menu.Item,
	                        { key: index },
	                        React.createElement(
	                            'a',
	                            { href: 'javascript:void(0);', className: 'action', key: 'action', onClick: me.handleActionClick.bind(me, action.callback.bind(me, rowData, me.props.root)) },
	                            !!action.render ? action.render(action.title, me.props.rowData) : action.title
	                        )
	                    );
	                })
	            );
	            arr.push(React.createElement('i', { className: 'kuma-icon kuma-icon-triangle-down', key: 'icon' }));
	            var dropdownOptions = {
	                key: 'icon',
	                overlay: menu,
	                trigger: ['click'],
	                visible: me.state.dropdownVisible,
	                onVisibleChange: me.handleDropdownVisibleChange.bind(me)
	            };
	            return React.createElement(
	                Dropdown,
	                dropdownOptions,
	                React.createElement(
	                    'span',
	                    null,
	                    arr
	                )
	            );
	        }
	    };

	    Cell.prototype.renderTreeIcon = function renderTreeIcon() {
	        if (this.props.cellIndex == 0 && this.props.hasSubComp) {
	            var open = this.props.rowData.showSubComp;
	            return React.createElement(
	                'span',
	                { className: 'kuma-uxtable-tree-icon', onClick: this.showSubComp.bind(this) },
	                React.createElement('i', { className: classnames({
	                        "kuma-icon": true,
	                        "kuma-icon-tree-open": open,
	                        "kuma-icon-tree-close": !open
	                    }) })
	            );
	        }
	    };

	    return Cell;
	}(React.Component);

	;

	Cell.propTypes = {};

	Cell.defaultProps = {
	    jsxprefixCls: "kuma-uxtable-cell"
	};

	exports["default"] = Cell;
	module.exports = exports['default'];

/***/ },
/* 161 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	/**
	 * A radio field
	 */

	var Const = __webpack_require__(5);
	var React = __webpack_require__(7);
	var ReactDOM = __webpack_require__(8);

	var Radio = function (_React$Component) {
	    _inherits(Radio, _React$Component);

	    function Radio(props) {
	        _classCallCheck(this, Radio);

	        var _this = _possibleConstructorReturn(this, _React$Component.call(this, props));

	        _this.state = {
	            checked: !!_this.props.checked
	        };
	        return _this;
	    }

	    Radio.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
	        this.state.checked = !!nextProps.jsxchecked;
	    };

	    Radio.prototype.handleChange = function handleChange(e) {
	        if (e.target.checked != this.state.checked) {
	            this.state.checked = !this.state.checked;
	            this.props.onchange.apply(null, [e]);
	        }
	    };

	    Radio.prototype.getValue = function getValue() {
	        return this.refs.radio.checked;
	    };

	    Radio.prototype.render = function render() {

	        var props = this.props;

	        if (props.mode !== Const.MODE.VIEW) {
	            var renderProps = {
	                className: "kuma-checkbox",
	                checked: this.props.jsxchecked,
	                onChange: this.handleChange.bind(this)
	            };
	            if (!!props.disable) {
	                renderProps.disabled = true;
	            }
	            return React.createElement(
	                'label',
	                { className: 'kuma-uxtable-row-selector' },
	                React.createElement('input', _extends({ type: 'radio', ref: 'radio' }, renderProps)),
	                React.createElement('s', null)
	            );
	        } else {

	            var renderProps = {
	                className: "kuma-checkbox",
	                checked: this.props.jsxchecked,
	                disabled: true
	            };
	            return React.createElement(
	                'label',
	                { className: 'kuma-uxtable-row-selector' },
	                React.createElement('input', _extends({ type: 'radio', ref: 'radio' }, renderProps)),
	                React.createElement('s', null)
	            );
	        }
	    };

	    return Radio;
	}(React.Component);

	;

	Radio.propTypes = {};

	Radio.defaultProps = {};

	exports["default"] = Radio;
	module.exports = exports['default'];

/***/ },
/* 162 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	/**
	 * A editable plain text field
	 */

	var CellField = __webpack_require__(163);
	var classnames = __webpack_require__(19);
	var assign = __webpack_require__(9);
	var React = __webpack_require__(7);
	var ReactDOM = __webpack_require__(8);

	var TextField = function (_CellField) {
	    _inherits(TextField, _CellField);

	    function TextField(props) {
	        _classCallCheck(this, TextField);

	        return _possibleConstructorReturn(this, _CellField.call(this, props));
	    }

	    TextField.prototype.renderContent = function renderContent() {
	        var me = this;
	        var dataKey = me.props.column.dataKey;
	        var fieldProps = {
	            className: classnames({
	                "kuma-input": true
	            }),
	            onChange: function onChange(e) {
	                me.handleDataChange({
	                    jsxid: me.props.rowData['jsxid'],
	                    column: me.props.column,
	                    value: e.target.value,
	                    text: e.target.value
	                });
	            },
	            value: me.props.value
	        };
	        if (me.props.column.config) {
	            var _me$props$column$conf = me.props.column.config;
	            var className = _me$props$column$conf.className;
	            var onChange = _me$props$column$conf.onChange;

	            var customProps = _objectWithoutProperties(_me$props$column$conf, ['className', 'onChange']);

	            assign(fieldProps, customProps);
	        }
	        return React.createElement('input', fieldProps);
	    };

	    return TextField;
	}(CellField);

	;

	TextField.propTypes = assign({}, CellField.propTypes);

	TextField.defaultProps = assign({}, CellField.defaultProps);

	module.exports = TextField;

/***/ },
/* 163 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var classnames = __webpack_require__(19);
	var assgin = __webpack_require__(9);

	var React = __webpack_require__(7);
	var ReactDOM = __webpack_require__(8);

	var CellField = function (_React$Component) {
	    _inherits(CellField, _React$Component);

	    function CellField(props) {
	        _classCallCheck(this, CellField);

	        var _this = _possibleConstructorReturn(this, _React$Component.call(this, props));

	        _this.state = {
	            pass: true
	        };

	        return _this;
	    }

	    CellField.prototype.componentDidMount = function componentDidMount() {
	        var me = this;
	        me.props.attachCellField(me.validate.bind(this), me.getName());
	    };

	    CellField.prototype.componentWillUnmount = function componentWillUnmount() {
	        var me = this;
	        me.props.detachCellField(me.getName());
	    };

	    CellField.prototype.handleDataChange = function handleDataChange(obj) {
	        var me = this;
	        var jsxid = obj.jsxid;
	        var column = obj.column;
	        var value = obj.value;
	        var text = obj.text;

	        me.validate(value, function (pass) {
	            me.props.handleDataChange(assgin({}, obj, {
	                pass: pass
	            }));
	        });
	    };

	    CellField.prototype.getName = function getName() {
	        var me = this;
	        return me.props.column.dataKey + "." + me.props.index;
	    };

	    CellField.prototype.validate = function validate(value, cb) {
	        var me = this;
	        value = value || me.props.value;
	        var rowData = me.props.rowData;
	        var rules = me.props.column.rules;

	        var pass = true;
	        var errMsg = "";
	        if ((typeof rules === 'undefined' ? 'undefined' : _typeof(rules)) == "object" && !Array.isArray(rules)) {
	            pass = !!rules.validator(value, rowData);
	            errMsg = rules.errMsg;
	        } else if (Array.isArray(rules)) {
	            for (var i = 0; i < rules.length; i++) {
	                pass = rules[i].validator(value, rowData);
	                if (!pass) {
	                    errMsg = rules[i].errMsg;
	                    break;
	                }
	            }
	        }
	        !!cb && cb(pass);
	        me.setState({
	            pass: pass,
	            errMsg: errMsg
	        });
	        return pass;
	    };

	    CellField.prototype.renderContent = function renderContent() {};

	    CellField.prototype.addSpecificClass = function addSpecificClass() {
	        return this.props.prefixCls;
	    };

	    CellField.prototype.render = function render() {
	        var _classnames;

	        var me = this;
	        var specificCls = me.addSpecificClass();
	        return React.createElement(
	            'div',
	            { className: classnames((_classnames = {
	                    "hasError": !me.state.pass
	                }, _classnames[specificCls] = true, _classnames[me.props.className] = !!me.props.className, _classnames)) },
	            me.renderContent()
	        );
	    };

	    return CellField;
	}(React.Component);

	CellField.displayName = "CellField";
	CellField.propTypes = {
	    prefixCls: React.PropTypes.string
	};

	CellField.defaultProps = {
	    prefixCls: 'kuma-uxtable-cell-field'
	};

	module.exports = CellField;

/***/ },
/* 164 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var CellField = __webpack_require__(163);
	var classnames = __webpack_require__(19);
	var assign = __webpack_require__(9);
	var Select = __webpack_require__(165);
	var Option = Select.Option;

	var React = __webpack_require__(7);
	var ReactDOM = __webpack_require__(8);

	var SelectField = function (_CellField) {
	    _inherits(SelectField, _CellField);

	    function SelectField(props) {
	        _classCallCheck(this, SelectField);

	        return _possibleConstructorReturn(this, _CellField.call(this, props));
	    }

	    SelectField.prototype.renderContent = function renderContent() {
	        var me = this;
	        var fieldProps = {
	            onSelect: function onSelect(value, Option) {
	                me.handleDataChange({
	                    jsxid: me.props.rowData['jsxid'],
	                    column: me.props.column,
	                    text: Option.props.children,
	                    value: value
	                });
	            },
	            value: me.props.value
	        };
	        if (me.props.column.config) {
	            var _me$props$column$conf = me.props.column.config;
	            var value = _me$props$column$conf.value;
	            var onSelect = _me$props$column$conf.onSelect;

	            var customProps = _objectWithoutProperties(_me$props$column$conf, ['value', 'onSelect']);

	            assign(fieldProps, customProps);
	        }
	        return React.createElement(
	            Select,
	            fieldProps,
	            me.props.column.renderChildren && me.props.column.renderChildren()
	        );
	    };

	    return SelectField;
	}(CellField);

	;

	SelectField.propTypes = assign({}, CellField.propTypes);

	SelectField.defaultProps = assign({}, CellField.defaultProps);

	module.exports = SelectField;

/***/ },
/* 165 */
[575, 166],
/* 166 */
[576, 167, 9],
/* 167 */
[577, 168, 234, 189],
/* 168 */
[578, 169, 189, 190, 196, 199, 214, 233],
/* 169 */
[543, 170, 171, 173, 174, 175, 176, 181, 182, 186, 187, 188],
/* 170 */
16,
/* 171 */
[544, 172],
/* 172 */
18,
/* 173 */
[545, 172],
/* 174 */
21,
/* 175 */
[546, 176],
/* 176 */
[547, 177],
/* 177 */
[548, 178, 179, 180],
/* 178 */
25,
/* 179 */
26,
/* 180 */
27,
/* 181 */
28,
/* 182 */
[549, 183],
/* 183 */
[550, 184],
/* 184 */
[551, 185, 9],
/* 185 */
32,
/* 186 */
33,
/* 187 */
34,
/* 188 */
35,
/* 189 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _react = __webpack_require__(7);

	var _react2 = _interopRequireDefault(_react);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var OptGroup = function (_React$Component) {
	  _inherits(OptGroup, _React$Component);

	  function OptGroup() {
	    _classCallCheck(this, OptGroup);

	    return _possibleConstructorReturn(this, Object.getPrototypeOf(OptGroup).apply(this, arguments));
	  }

	  return OptGroup;
	}(_react2["default"].Component);

	exports["default"] = OptGroup;
	module.exports = exports['default'];

/***/ },
/* 190 */
[554, 191],
/* 191 */
[555, 192, 193, 198],
/* 192 */
45,
/* 193 */
[556, 194, 198],
/* 194 */
[557, 195, 196],
/* 195 */
48,
/* 196 */
[558, 197, 197],
/* 197 */
50,
/* 198 */
51,
/* 199 */
[579, 200],
/* 200 */
[580, 201, 208, 211, 212, 213],
/* 201 */
[581, 202, 9, 206],
/* 202 */
[582, 169, 203, 9, 206, 207],
/* 203 */
[552, 204],
/* 204 */
[553, 205],
/* 205 */
38,
/* 206 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.noop = noop;
	exports.getKeyFromChildrenIndex = getKeyFromChildrenIndex;
	exports.loopMenuItem = loopMenuItem;

	var _react = __webpack_require__(7);

	var _react2 = _interopRequireDefault(_react);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

	var now = Date.now();

	function noop() {}

	function getKeyFromChildrenIndex(child, menuEventKey, index) {
	  var prefix = menuEventKey || '';
	  return child.key || prefix + 'item_' + now + '_' + index;
	}

	function loopMenuItem(children, cb) {
	  var index = -1;
	  _react2["default"].Children.forEach(children, function (c) {
	    index++;
	    if (c && c.type.isMenuItemGroup) {
	      _react2["default"].Children.forEach(c.props.children, function (c2) {
	        index++;
	        cb(c2, index);
	      });
	    } else {
	      cb(c, index);
	    }
	  });
	}

/***/ },
/* 207 */
[583, 9],
/* 208 */
[584, 209, 169, 206, 210],
/* 209 */
[585, 202, 9, 206, 190],
/* 210 */
[586, 169],
/* 211 */
[587, 169, 206],
/* 212 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _react = __webpack_require__(7);

	var _react2 = _interopRequireDefault(_react);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

	var MenuItemGroup = _react2["default"].createClass({
	  displayName: 'MenuItemGroup',

	  propTypes: {
	    renderMenuItem: _react.PropTypes.func,
	    index: _react.PropTypes.number
	  },

	  getDefaultProps: function getDefaultProps() {
	    return {
	      disabled: true
	    };
	  },
	  renderInnerMenuItem: function renderInnerMenuItem(item, subIndex) {
	    var renderMenuItem = this.props.renderMenuItem;
	    return renderMenuItem(item, this.props.index, subIndex);
	  },
	  render: function render() {
	    var props = this.props;
	    var className = props.className || '';
	    var rootPrefixCls = props.rootPrefixCls;

	    className += ' ' + rootPrefixCls + '-item-group';
	    var titleClassName = rootPrefixCls + '-item-group-title';
	    var listClassName = rootPrefixCls + '-item-group-list';
	    return _react2["default"].createElement(
	      'li',
	      { className: className },
	      _react2["default"].createElement(
	        'div',
	        { className: titleClassName },
	        props.title
	      ),
	      _react2["default"].createElement(
	        'ul',
	        { className: listClassName },
	        _react2["default"].Children.map(props.children, this.renderInnerMenuItem)
	      )
	    );
	  }
	});

	MenuItemGroup.isMenuItemGroup = true;

	exports["default"] = MenuItemGroup;
	module.exports = exports['default'];

/***/ },
/* 213 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

	var _react = __webpack_require__(7);

	var _react2 = _interopRequireDefault(_react);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

	var Divider = _react2["default"].createClass({
	  displayName: 'Divider',
	  getDefaultProps: function getDefaultProps() {
	    return {
	      disabled: true
	    };
	  },
	  render: function render() {
	    var props = this.props;
	    var className = props.className || '';
	    var rootPrefixCls = props.rootPrefixCls;
	    className += ' ' + (rootPrefixCls + '-item-divider');
	    return _react2["default"].createElement('li', _extends({}, props, { className: className }));
	  }
	});

	exports["default"] = Divider;
	module.exports = exports['default'];

/***/ },
/* 214 */
[588, 215, 232],
/* 215 */
[559, 216],
/* 216 */
[560, 169, 217, 231],
/* 217 */
[561, 218, 190, 229, 230],
/* 218 */
[562, 219],
/* 219 */
[563, 220, 169, 228],
/* 220 */
[564, 221, 222, 223, 224, 225, 226],
/* 221 */
86,
/* 222 */
[565, 221],
/* 223 */
[566, 221, 222],
/* 224 */
[567, 221],
/* 225 */
[568, 221],
/* 226 */
[569, 227],
/* 227 */
92,
/* 228 */
93,
/* 229 */
[570, 230],
/* 230 */
104,
/* 231 */
105,
/* 232 */
[589, 199, 200, 203],
/* 233 */
[590, 189, 199, 200],
/* 234 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _react = __webpack_require__(7);

	var _react2 = _interopRequireDefault(_react);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var Option = function (_React$Component) {
	  _inherits(Option, _React$Component);

	  function Option() {
	    _classCallCheck(this, Option);

	    return _possibleConstructorReturn(this, Object.getPrototypeOf(Option).apply(this, arguments));
	  }

	  return Option;
	}(_react2["default"].Component);

	exports["default"] = Option;
	module.exports = exports['default'];

/***/ },
/* 235 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var CellField = __webpack_require__(163);
	var classnames = __webpack_require__(19);
	var assign = __webpack_require__(9);
	var RadioGroup = __webpack_require__(236);
	var React = __webpack_require__(7);
	var ReactDOM = __webpack_require__(8);

	var RadioField = function (_CellField) {
	    _inherits(RadioField, _CellField);

	    function RadioField(props) {
	        _classCallCheck(this, RadioField);

	        return _possibleConstructorReturn(this, _CellField.call(this, props));
	    }

	    RadioField.prototype.processChildren = function processChildren() {
	        var me = this;
	        var obj = {};
	        if (me.props.column.renderChildren) {
	            me.props.column.renderChildren().forEach(function (item) {
	                obj[item.props.value] = item.props.text;
	            });
	        } else {
	            console.error("RadioCellField: renderChildren must be passed");
	        }
	        return obj;
	    };

	    RadioField.prototype.renderContent = function renderContent() {
	        var me = this;
	        var dataKey = me.props.column.dataKey;
	        var textMap = me.processChildren();
	        var fieldProps = {
	            onChange: function onChange(value) {
	                me.handleDataChange({
	                    jsxid: me.props.rowData['jsxid'],
	                    column: me.props.column,
	                    text: textMap[value],
	                    value: value
	                });
	            },
	            value: me.props.value
	        };
	        if (me.props.column.config) {
	            var _me$props$column$conf = me.props.column.config;
	            var value = _me$props$column$conf.value;
	            var onChange = _me$props$column$conf.onChange;

	            var customProps = _objectWithoutProperties(_me$props$column$conf, ['value', 'onChange']);

	            assign(fieldProps, customProps);
	        }
	        return React.createElement(
	            RadioGroup,
	            fieldProps,
	            me.props.column.renderChildren()
	        );
	    };

	    return RadioField;
	}(CellField);

	;

	RadioField.propTypes = assign({}, CellField.propTypes);

	RadioField.defaultProps = assign({}, CellField.defaultProps);

	module.exports = RadioField;

/***/ },
/* 236 */
[591, 237],
/* 237 */
[592, 238],
/* 238 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var React = __webpack_require__(7);
	var ReactDOM = __webpack_require__(8);

	var RadiogroupItem = function (_React$Component) {
	    _inherits(RadiogroupItem, _React$Component);

	    function RadiogroupItem(props) {
	        _classCallCheck(this, RadiogroupItem);

	        return _possibleConstructorReturn(this, _React$Component.call(this, props));
	    }

	    RadiogroupItem.prototype._handleChange = function _handleChange(e) {
	        var me = this;
	        me.props.onChange(me.props.value);
	    };

	    RadiogroupItem.prototype.render = function render() {
	        var me = this;
	        return React.createElement(
	            'label',
	            { className: '' + me.props.prefixCls },
	            React.createElement('input', { type: 'radio', disabled: me.props.disabled, ref: 'radio', className: 'kuma-checkbox', checked: me.props.checked, onChange: me._handleChange.bind(me) }),
	            React.createElement('s', null),
	            React.createElement(
	                'span',
	                { className: me.props.prefixCls + '-content' },
	                me.props.text
	            )
	        );
	    };

	    return RadiogroupItem;
	}(React.Component);

	RadiogroupItem.displayName = "RadiogroupItem";
	RadiogroupItem.propTypes = {
	    prefixCls: React.PropTypes.string,
	    text: React.PropTypes.string,
	    value: React.PropTypes.string,
	    className: React.PropTypes.string,
	    disabled: React.PropTypes.bool,
	    onChange: React.PropTypes.func
	};
	RadiogroupItem.defaultProps = {
	    prefixCls: "kuma-radio-group-item",
	    text: "",
	    value: "",
	    className: "kuma-checkbox",
	    disabled: false,
	    onChange: function onChange() {}
	};

	module.exports = RadiogroupItem;

/***/ },
/* 239 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var Formatter = __webpack_require__(240);
	var util = {
	    formatValue: function formatValue(value, type, delimiter) {
	        delimiter = delimiter || " ";
	        if (value === null || value === undefined) {
	            return value;
	        }
	        value = value + "";
	        if (type == "money") {
	            return Formatter.money(value, delimiter);
	        } else if (type == "card") {
	            return Formatter.card(value, delimiter);
	        } else if (type == "cnmobile") {
	            return Formatter.cnmobile(value, delimiter);
	        }
	    }
	};

	module.exports = util;

/***/ },
/* 240 */
[593, 241],
/* 241 */
/***/ function(module, exports) {

	/**
	 * Formatter Component for uxcore
	 * @author eternalsky
	 *
	 * Copyright 2014-2015, Uxcore Team, Alinw.
	 * All rights reserved.
	 */

	var Formatter = {};

	Formatter.date = function(str, pattern) {
	    var date = new Date(str);
	    pattern = pattern || 'YYYY-MM-DD';
	    var o = {
	        "M+": date.getMonth() + 1, //月份 
	        "D+": date.getDate(), //日 
	        "d+": date.getDate(), //日 
	        "H+": date.getHours(), //小时 
	        "h+": date.getHours(), //小时 
	        "m+": date.getMinutes(), //分 
	        "s+": date.getSeconds(), //秒 
	        "Q+": Math.floor((date.getMonth() + 3) / 3), //季度 
	        "q+": Math.floor((date.getMonth() + 3) / 3), //季度 
	        "S": date.getMilliseconds() //毫秒 
	    };
	    if (/(y+)/i.test(pattern)) {
	        pattern = pattern.replace(RegExp.$1, (date.getFullYear() + "").substr(4 - RegExp.$1.length));
	    }
	    for (var k in o) {
	        if (new RegExp("(" + k + ")").test(pattern)) pattern = pattern.replace(RegExp.$1, (RegExp.$1.length == 1) ? (o[k]) : (("00" + o[k]).substr(("" + o[k]).length)));
	    }
	    return pattern;
	}

	Formatter.money = function(str, delimiter, fixedNum) {
	    delimiter = delimiter || " ";
	    if (fixedNum) {
	        str = parseFloat(str).toFixed(fixedNum).toString()
	    }
	    if (str.indexOf(".") !== -1) {
	        return str.replace(/(\d)(?=(?:\d{3})+(\.))/g, function(match, $1) {
	            return $1 + delimiter;
	        }).replace(/(\d{3})(?![$|\.|\(|\s])/g, function(match, $1) {
	            return $1;
	        });
	    }
	    else {
	        return str.replace(/(\d)(?=(?:\d{3})+$)/g, function(match, $1) {
	            return $1 + delimiter;
	        })
	    }
	}

	Formatter.cnmobile = function(str, delimiter) {
	    delimiter = delimiter || " ";
	    return str.replace(/^(\+?0?86)(?!$)/, "$1" + delimiter).replace(/(\d{4})(?!$)/g, "$1" + delimiter);
	}

	Formatter.card = function(str, delimiter) {
	    delimiter = delimiter || " ";
	    return str.replace(/(\d{4})(?!$)/g, "$1" + delimiter);
	}

	module.exports = Formatter;

/***/ },
/* 242 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(process, Buffer) {/*!
	 * @license deepcopy.js Copyright(c) 2013 sasa+1
	 * https://github.com/sasaplus1/deepcopy.js
	 * Released under the MIT license.
	 */


	/**
	 * export to AMD/CommonJS/global.
	 *
	 * @param {Object} global global object.
	 * @param {Function} factory factory method.
	 */
	(function(global, factory) {
	  'use strict';

	  if (true) {
	    !(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	  } else if (typeof exports === 'object') {
	    module.exports = factory();
	  } else {
	    global.deepcopy = factory();
	  }
	}(this, function() {
	  'use strict';

	  var isNode, util, isBuffer, getKeys, getSymbols, indexOfArray;

	  // is node.js/io.js?
	  isNode = (typeof process !== 'undefined' && "function" !== 'undefined');

	  // fallback util module for browser.
	  util = (isNode) ? __webpack_require__(248) : (function() {
	    function isArray(value) {
	      return (typeof value === 'object' &&
	          Object.prototype.toString.call(value) === '[object Array]');
	    }

	    function isDate(value) {
	      return (typeof value === 'object' &&
	          Object.prototype.toString.call(value) === '[object Date]');
	    }

	    function isRegExp(value) {
	      return (typeof value === 'object' &&
	          Object.prototype.toString.call(value) === '[object RegExp]');
	    }

	    function isSymbol(value) {
	      return (typeof value === 'symbol');
	    }

	    return {
	      isArray: (typeof Array.isArray === 'function') ?
	          function(obj) {
	            return Array.isArray(obj);
	          } : isArray,
	      isDate: isDate,
	      isRegExp: isRegExp,
	      isSymbol: (typeof Symbol === 'function') ?
	          isSymbol :
	          function() {
	            // always return false when Symbol is not supported.
	            return false;
	          }
	    };
	  }());

	  // fallback Buffer.isBuffer
	  isBuffer = (isNode) ?
	      function(obj) {
	        return Buffer.isBuffer(obj);
	      } :
	      function() {
	        // if browser, always return false
	        return false;
	      };

	  // fallback Object.keys for old browsers.
	  getKeys = (typeof Object.keys === 'function') ?
	      function(obj) {
	        return Object.keys(obj);
	      } :
	      function(obj) {
	        var keys = [],
	            key;

	        if (obj === null || typeof obj !== 'object') {
	          throw new TypeError('obj is not an Object');
	        }

	        for (key in obj) {
	          obj.hasOwnProperty(key) && keys.push(key);
	        }

	        return keys;
	      };

	  // get symbols in object.
	  getSymbols = (typeof Symbol === 'function') ?
	      function(obj) {
	        return Object.getOwnPropertySymbols(obj);
	      } :
	      function() {
	        // always return empty array when Symbol is not supported.
	        return [];
	      };

	  // fallback Array#indexOf for old browsers.
	  indexOfArray = (typeof Array.prototype.indexOf === 'function') ?
	      function(array, searchElement) {
	        return array.indexOf(searchElement);
	      } :
	      function(array, searchElement) {
	        var i, len;

	        if (!util.isArray(array)) {
	          throw new TypeError('array is not an Array');
	        }

	        for (i = 0, len = array.length; i < len; ++i) {
	          if (array[i] === searchElement) {
	            return i;
	          }
	        }

	        return -1;
	      };

	  /**
	   * recursive deep copy for value.
	   *
	   * @private
	   * @param {*} value copy target.
	   * @param {*} clone
	   * @param {Array} visited
	   * @param {Array} reference
	   * @return {*} copied value.
	   */
	  function copyValue_(value, clone, visited, reference) {
	    var str, pos, buf, keys, i, len, key, val, idx, obj, ref;

	    // number, string, boolean, null, undefined, function and symbol.
	    if (value === null || typeof value !== 'object') {
	      return value;
	    }

	    // Date.
	    if (util.isDate(value)) {
	      // Firefox need to convert to Number
	      //
	      // Firefox:
	      //   var date = new Date;
	      //   +date;            // 1420909365967
	      //   +new Date(date);  // 1420909365000
	      //   +new Date(+date); // 1420909365967
	      // Chrome:
	      //   var date = new Date;
	      //   +date;            // 1420909757913
	      //   +new Date(date);  // 1420909757913
	      //   +new Date(+date); // 1420909757913
	      return new Date(+value);
	    }

	    // RegExp.
	    if (util.isRegExp(value)) {
	      // Chrome, Safari:
	      //   (new RegExp).source => "(?:)"
	      // Firefox:
	      //   (new RegExp).source => ""
	      // Chrome, Safari, Firefox
	      //   String(new RegExp) => "/(?:)/"
	      str = String(value);
	      pos = str.lastIndexOf('/');

	      return new RegExp(str.slice(1, pos), str.slice(pos + 1));
	    }

	    // Buffer, node.js only.
	    if (isBuffer(value)) {
	      buf = new Buffer(value.length);
	      value.copy(buf);

	      return buf;
	    }

	    // Object or Array.
	    keys = getKeys(value).concat(getSymbols(value));

	    for (i = 0, len = keys.length; i < len; ++i) {
	      key = keys[i];
	      val = value[key];

	      if (val !== null && typeof val === 'object') {
	        idx = indexOfArray(visited, val);

	        if (idx === -1) {
	          // not circular reference
	          obj = (util.isArray(val)) ? [] : {};

	          visited.push(val);
	          reference.push(obj);
	        } else {
	          // circular reference
	          ref = reference[idx];
	        }
	      }

	      clone[key] = ref || copyValue_(val, obj, visited, reference);
	    }

	    return clone;
	  }

	  /**
	   * deep copy for value.
	   *
	   * @param {*} value copy target.
	   */
	  function deepcopy(value) {
	    var clone = (util.isArray(value)) ? [] : {},
	        visited = [value],
	        reference = [clone];

	    return copyValue_(value, clone, visited, reference);
	  }

	  return deepcopy;
	}));

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(243), __webpack_require__(244).Buffer))

/***/ },
/* 243 */
/***/ function(module, exports) {

	// shim for using process in browser

	var process = module.exports = {};
	var queue = [];
	var draining = false;
	var currentQueue;
	var queueIndex = -1;

	function cleanUpNextTick() {
	    if (!draining || !currentQueue) {
	        return;
	    }
	    draining = false;
	    if (currentQueue.length) {
	        queue = currentQueue.concat(queue);
	    } else {
	        queueIndex = -1;
	    }
	    if (queue.length) {
	        drainQueue();
	    }
	}

	function drainQueue() {
	    if (draining) {
	        return;
	    }
	    var timeout = setTimeout(cleanUpNextTick);
	    draining = true;

	    var len = queue.length;
	    while(len) {
	        currentQueue = queue;
	        queue = [];
	        while (++queueIndex < len) {
	            if (currentQueue) {
	                currentQueue[queueIndex].run();
	            }
	        }
	        queueIndex = -1;
	        len = queue.length;
	    }
	    currentQueue = null;
	    draining = false;
	    clearTimeout(timeout);
	}

	process.nextTick = function (fun) {
	    var args = new Array(arguments.length - 1);
	    if (arguments.length > 1) {
	        for (var i = 1; i < arguments.length; i++) {
	            args[i - 1] = arguments[i];
	        }
	    }
	    queue.push(new Item(fun, args));
	    if (queue.length === 1 && !draining) {
	        setTimeout(drainQueue, 0);
	    }
	};

	// v8 likes predictible objects
	function Item(fun, array) {
	    this.fun = fun;
	    this.array = array;
	}
	Item.prototype.run = function () {
	    this.fun.apply(null, this.array);
	};
	process.title = 'browser';
	process.browser = true;
	process.env = {};
	process.argv = [];
	process.version = ''; // empty string to avoid regexp issues
	process.versions = {};

	function noop() {}

	process.on = noop;
	process.addListener = noop;
	process.once = noop;
	process.off = noop;
	process.removeListener = noop;
	process.removeAllListeners = noop;
	process.emit = noop;

	process.binding = function (name) {
	    throw new Error('process.binding is not supported');
	};

	process.cwd = function () { return '/' };
	process.chdir = function (dir) {
	    throw new Error('process.chdir is not supported');
	};
	process.umask = function() { return 0; };


/***/ },
/* 244 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer, global) {/*!
	 * The buffer module from node.js, for the browser.
	 *
	 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
	 * @license  MIT
	 */
	/* eslint-disable no-proto */

	'use strict'

	var base64 = __webpack_require__(245)
	var ieee754 = __webpack_require__(246)
	var isArray = __webpack_require__(247)

	exports.Buffer = Buffer
	exports.SlowBuffer = SlowBuffer
	exports.INSPECT_MAX_BYTES = 50
	Buffer.poolSize = 8192 // not used by this implementation

	var rootParent = {}

	/**
	 * If `Buffer.TYPED_ARRAY_SUPPORT`:
	 *   === true    Use Uint8Array implementation (fastest)
	 *   === false   Use Object implementation (most compatible, even IE6)
	 *
	 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
	 * Opera 11.6+, iOS 4.2+.
	 *
	 * Due to various browser bugs, sometimes the Object implementation will be used even
	 * when the browser supports typed arrays.
	 *
	 * Note:
	 *
	 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
	 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
	 *
	 *   - Safari 5-7 lacks support for changing the `Object.prototype.constructor` property
	 *     on objects.
	 *
	 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
	 *
	 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
	 *     incorrect length in some situations.

	 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
	 * get the Object implementation, which is slower but behaves correctly.
	 */
	Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined
	  ? global.TYPED_ARRAY_SUPPORT
	  : typedArraySupport()

	function typedArraySupport () {
	  function Bar () {}
	  try {
	    var arr = new Uint8Array(1)
	    arr.foo = function () { return 42 }
	    arr.constructor = Bar
	    return arr.foo() === 42 && // typed array instances can be augmented
	        arr.constructor === Bar && // constructor can be set
	        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
	        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
	  } catch (e) {
	    return false
	  }
	}

	function kMaxLength () {
	  return Buffer.TYPED_ARRAY_SUPPORT
	    ? 0x7fffffff
	    : 0x3fffffff
	}

	/**
	 * Class: Buffer
	 * =============
	 *
	 * The Buffer constructor returns instances of `Uint8Array` that are augmented
	 * with function properties for all the node `Buffer` API functions. We use
	 * `Uint8Array` so that square bracket notation works as expected -- it returns
	 * a single octet.
	 *
	 * By augmenting the instances, we can avoid modifying the `Uint8Array`
	 * prototype.
	 */
	function Buffer (arg) {
	  if (!(this instanceof Buffer)) {
	    // Avoid going through an ArgumentsAdaptorTrampoline in the common case.
	    if (arguments.length > 1) return new Buffer(arg, arguments[1])
	    return new Buffer(arg)
	  }

	  if (!Buffer.TYPED_ARRAY_SUPPORT) {
	    this.length = 0
	    this.parent = undefined
	  }

	  // Common case.
	  if (typeof arg === 'number') {
	    return fromNumber(this, arg)
	  }

	  // Slightly less common case.
	  if (typeof arg === 'string') {
	    return fromString(this, arg, arguments.length > 1 ? arguments[1] : 'utf8')
	  }

	  // Unusual.
	  return fromObject(this, arg)
	}

	function fromNumber (that, length) {
	  that = allocate(that, length < 0 ? 0 : checked(length) | 0)
	  if (!Buffer.TYPED_ARRAY_SUPPORT) {
	    for (var i = 0; i < length; i++) {
	      that[i] = 0
	    }
	  }
	  return that
	}

	function fromString (that, string, encoding) {
	  if (typeof encoding !== 'string' || encoding === '') encoding = 'utf8'

	  // Assumption: byteLength() return value is always < kMaxLength.
	  var length = byteLength(string, encoding) | 0
	  that = allocate(that, length)

	  that.write(string, encoding)
	  return that
	}

	function fromObject (that, object) {
	  if (Buffer.isBuffer(object)) return fromBuffer(that, object)

	  if (isArray(object)) return fromArray(that, object)

	  if (object == null) {
	    throw new TypeError('must start with number, buffer, array or string')
	  }

	  if (typeof ArrayBuffer !== 'undefined') {
	    if (object.buffer instanceof ArrayBuffer) {
	      return fromTypedArray(that, object)
	    }
	    if (object instanceof ArrayBuffer) {
	      return fromArrayBuffer(that, object)
	    }
	  }

	  if (object.length) return fromArrayLike(that, object)

	  return fromJsonObject(that, object)
	}

	function fromBuffer (that, buffer) {
	  var length = checked(buffer.length) | 0
	  that = allocate(that, length)
	  buffer.copy(that, 0, 0, length)
	  return that
	}

	function fromArray (that, array) {
	  var length = checked(array.length) | 0
	  that = allocate(that, length)
	  for (var i = 0; i < length; i += 1) {
	    that[i] = array[i] & 255
	  }
	  return that
	}

	// Duplicate of fromArray() to keep fromArray() monomorphic.
	function fromTypedArray (that, array) {
	  var length = checked(array.length) | 0
	  that = allocate(that, length)
	  // Truncating the elements is probably not what people expect from typed
	  // arrays with BYTES_PER_ELEMENT > 1 but it's compatible with the behavior
	  // of the old Buffer constructor.
	  for (var i = 0; i < length; i += 1) {
	    that[i] = array[i] & 255
	  }
	  return that
	}

	function fromArrayBuffer (that, array) {
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    // Return an augmented `Uint8Array` instance, for best performance
	    array.byteLength
	    that = Buffer._augment(new Uint8Array(array))
	  } else {
	    // Fallback: Return an object instance of the Buffer class
	    that = fromTypedArray(that, new Uint8Array(array))
	  }
	  return that
	}

	function fromArrayLike (that, array) {
	  var length = checked(array.length) | 0
	  that = allocate(that, length)
	  for (var i = 0; i < length; i += 1) {
	    that[i] = array[i] & 255
	  }
	  return that
	}

	// Deserialize { type: 'Buffer', data: [1,2,3,...] } into a Buffer object.
	// Returns a zero-length buffer for inputs that don't conform to the spec.
	function fromJsonObject (that, object) {
	  var array
	  var length = 0

	  if (object.type === 'Buffer' && isArray(object.data)) {
	    array = object.data
	    length = checked(array.length) | 0
	  }
	  that = allocate(that, length)

	  for (var i = 0; i < length; i += 1) {
	    that[i] = array[i] & 255
	  }
	  return that
	}

	if (Buffer.TYPED_ARRAY_SUPPORT) {
	  Buffer.prototype.__proto__ = Uint8Array.prototype
	  Buffer.__proto__ = Uint8Array
	} else {
	  // pre-set for values that may exist in the future
	  Buffer.prototype.length = undefined
	  Buffer.prototype.parent = undefined
	}

	function allocate (that, length) {
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    // Return an augmented `Uint8Array` instance, for best performance
	    that = Buffer._augment(new Uint8Array(length))
	    that.__proto__ = Buffer.prototype
	  } else {
	    // Fallback: Return an object instance of the Buffer class
	    that.length = length
	    that._isBuffer = true
	  }

	  var fromPool = length !== 0 && length <= Buffer.poolSize >>> 1
	  if (fromPool) that.parent = rootParent

	  return that
	}

	function checked (length) {
	  // Note: cannot use `length < kMaxLength` here because that fails when
	  // length is NaN (which is otherwise coerced to zero.)
	  if (length >= kMaxLength()) {
	    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
	                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
	  }
	  return length | 0
	}

	function SlowBuffer (subject, encoding) {
	  if (!(this instanceof SlowBuffer)) return new SlowBuffer(subject, encoding)

	  var buf = new Buffer(subject, encoding)
	  delete buf.parent
	  return buf
	}

	Buffer.isBuffer = function isBuffer (b) {
	  return !!(b != null && b._isBuffer)
	}

	Buffer.compare = function compare (a, b) {
	  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
	    throw new TypeError('Arguments must be Buffers')
	  }

	  if (a === b) return 0

	  var x = a.length
	  var y = b.length

	  var i = 0
	  var len = Math.min(x, y)
	  while (i < len) {
	    if (a[i] !== b[i]) break

	    ++i
	  }

	  if (i !== len) {
	    x = a[i]
	    y = b[i]
	  }

	  if (x < y) return -1
	  if (y < x) return 1
	  return 0
	}

	Buffer.isEncoding = function isEncoding (encoding) {
	  switch (String(encoding).toLowerCase()) {
	    case 'hex':
	    case 'utf8':
	    case 'utf-8':
	    case 'ascii':
	    case 'binary':
	    case 'base64':
	    case 'raw':
	    case 'ucs2':
	    case 'ucs-2':
	    case 'utf16le':
	    case 'utf-16le':
	      return true
	    default:
	      return false
	  }
	}

	Buffer.concat = function concat (list, length) {
	  if (!isArray(list)) throw new TypeError('list argument must be an Array of Buffers.')

	  if (list.length === 0) {
	    return new Buffer(0)
	  }

	  var i
	  if (length === undefined) {
	    length = 0
	    for (i = 0; i < list.length; i++) {
	      length += list[i].length
	    }
	  }

	  var buf = new Buffer(length)
	  var pos = 0
	  for (i = 0; i < list.length; i++) {
	    var item = list[i]
	    item.copy(buf, pos)
	    pos += item.length
	  }
	  return buf
	}

	function byteLength (string, encoding) {
	  if (typeof string !== 'string') string = '' + string

	  var len = string.length
	  if (len === 0) return 0

	  // Use a for loop to avoid recursion
	  var loweredCase = false
	  for (;;) {
	    switch (encoding) {
	      case 'ascii':
	      case 'binary':
	      // Deprecated
	      case 'raw':
	      case 'raws':
	        return len
	      case 'utf8':
	      case 'utf-8':
	        return utf8ToBytes(string).length
	      case 'ucs2':
	      case 'ucs-2':
	      case 'utf16le':
	      case 'utf-16le':
	        return len * 2
	      case 'hex':
	        return len >>> 1
	      case 'base64':
	        return base64ToBytes(string).length
	      default:
	        if (loweredCase) return utf8ToBytes(string).length // assume utf8
	        encoding = ('' + encoding).toLowerCase()
	        loweredCase = true
	    }
	  }
	}
	Buffer.byteLength = byteLength

	function slowToString (encoding, start, end) {
	  var loweredCase = false

	  start = start | 0
	  end = end === undefined || end === Infinity ? this.length : end | 0

	  if (!encoding) encoding = 'utf8'
	  if (start < 0) start = 0
	  if (end > this.length) end = this.length
	  if (end <= start) return ''

	  while (true) {
	    switch (encoding) {
	      case 'hex':
	        return hexSlice(this, start, end)

	      case 'utf8':
	      case 'utf-8':
	        return utf8Slice(this, start, end)

	      case 'ascii':
	        return asciiSlice(this, start, end)

	      case 'binary':
	        return binarySlice(this, start, end)

	      case 'base64':
	        return base64Slice(this, start, end)

	      case 'ucs2':
	      case 'ucs-2':
	      case 'utf16le':
	      case 'utf-16le':
	        return utf16leSlice(this, start, end)

	      default:
	        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
	        encoding = (encoding + '').toLowerCase()
	        loweredCase = true
	    }
	  }
	}

	Buffer.prototype.toString = function toString () {
	  var length = this.length | 0
	  if (length === 0) return ''
	  if (arguments.length === 0) return utf8Slice(this, 0, length)
	  return slowToString.apply(this, arguments)
	}

	Buffer.prototype.equals = function equals (b) {
	  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
	  if (this === b) return true
	  return Buffer.compare(this, b) === 0
	}

	Buffer.prototype.inspect = function inspect () {
	  var str = ''
	  var max = exports.INSPECT_MAX_BYTES
	  if (this.length > 0) {
	    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
	    if (this.length > max) str += ' ... '
	  }
	  return '<Buffer ' + str + '>'
	}

	Buffer.prototype.compare = function compare (b) {
	  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
	  if (this === b) return 0
	  return Buffer.compare(this, b)
	}

	Buffer.prototype.indexOf = function indexOf (val, byteOffset) {
	  if (byteOffset > 0x7fffffff) byteOffset = 0x7fffffff
	  else if (byteOffset < -0x80000000) byteOffset = -0x80000000
	  byteOffset >>= 0

	  if (this.length === 0) return -1
	  if (byteOffset >= this.length) return -1

	  // Negative offsets start from the end of the buffer
	  if (byteOffset < 0) byteOffset = Math.max(this.length + byteOffset, 0)

	  if (typeof val === 'string') {
	    if (val.length === 0) return -1 // special case: looking for empty string always fails
	    return String.prototype.indexOf.call(this, val, byteOffset)
	  }
	  if (Buffer.isBuffer(val)) {
	    return arrayIndexOf(this, val, byteOffset)
	  }
	  if (typeof val === 'number') {
	    if (Buffer.TYPED_ARRAY_SUPPORT && Uint8Array.prototype.indexOf === 'function') {
	      return Uint8Array.prototype.indexOf.call(this, val, byteOffset)
	    }
	    return arrayIndexOf(this, [ val ], byteOffset)
	  }

	  function arrayIndexOf (arr, val, byteOffset) {
	    var foundIndex = -1
	    for (var i = 0; byteOffset + i < arr.length; i++) {
	      if (arr[byteOffset + i] === val[foundIndex === -1 ? 0 : i - foundIndex]) {
	        if (foundIndex === -1) foundIndex = i
	        if (i - foundIndex + 1 === val.length) return byteOffset + foundIndex
	      } else {
	        foundIndex = -1
	      }
	    }
	    return -1
	  }

	  throw new TypeError('val must be string, number or Buffer')
	}

	// `get` is deprecated
	Buffer.prototype.get = function get (offset) {
	  console.log('.get() is deprecated. Access using array indexes instead.')
	  return this.readUInt8(offset)
	}

	// `set` is deprecated
	Buffer.prototype.set = function set (v, offset) {
	  console.log('.set() is deprecated. Access using array indexes instead.')
	  return this.writeUInt8(v, offset)
	}

	function hexWrite (buf, string, offset, length) {
	  offset = Number(offset) || 0
	  var remaining = buf.length - offset
	  if (!length) {
	    length = remaining
	  } else {
	    length = Number(length)
	    if (length > remaining) {
	      length = remaining
	    }
	  }

	  // must be an even number of digits
	  var strLen = string.length
	  if (strLen % 2 !== 0) throw new Error('Invalid hex string')

	  if (length > strLen / 2) {
	    length = strLen / 2
	  }
	  for (var i = 0; i < length; i++) {
	    var parsed = parseInt(string.substr(i * 2, 2), 16)
	    if (isNaN(parsed)) throw new Error('Invalid hex string')
	    buf[offset + i] = parsed
	  }
	  return i
	}

	function utf8Write (buf, string, offset, length) {
	  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
	}

	function asciiWrite (buf, string, offset, length) {
	  return blitBuffer(asciiToBytes(string), buf, offset, length)
	}

	function binaryWrite (buf, string, offset, length) {
	  return asciiWrite(buf, string, offset, length)
	}

	function base64Write (buf, string, offset, length) {
	  return blitBuffer(base64ToBytes(string), buf, offset, length)
	}

	function ucs2Write (buf, string, offset, length) {
	  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
	}

	Buffer.prototype.write = function write (string, offset, length, encoding) {
	  // Buffer#write(string)
	  if (offset === undefined) {
	    encoding = 'utf8'
	    length = this.length
	    offset = 0
	  // Buffer#write(string, encoding)
	  } else if (length === undefined && typeof offset === 'string') {
	    encoding = offset
	    length = this.length
	    offset = 0
	  // Buffer#write(string, offset[, length][, encoding])
	  } else if (isFinite(offset)) {
	    offset = offset | 0
	    if (isFinite(length)) {
	      length = length | 0
	      if (encoding === undefined) encoding = 'utf8'
	    } else {
	      encoding = length
	      length = undefined
	    }
	  // legacy write(string, encoding, offset, length) - remove in v0.13
	  } else {
	    var swap = encoding
	    encoding = offset
	    offset = length | 0
	    length = swap
	  }

	  var remaining = this.length - offset
	  if (length === undefined || length > remaining) length = remaining

	  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
	    throw new RangeError('attempt to write outside buffer bounds')
	  }

	  if (!encoding) encoding = 'utf8'

	  var loweredCase = false
	  for (;;) {
	    switch (encoding) {
	      case 'hex':
	        return hexWrite(this, string, offset, length)

	      case 'utf8':
	      case 'utf-8':
	        return utf8Write(this, string, offset, length)

	      case 'ascii':
	        return asciiWrite(this, string, offset, length)

	      case 'binary':
	        return binaryWrite(this, string, offset, length)

	      case 'base64':
	        // Warning: maxLength not taken into account in base64Write
	        return base64Write(this, string, offset, length)

	      case 'ucs2':
	      case 'ucs-2':
	      case 'utf16le':
	      case 'utf-16le':
	        return ucs2Write(this, string, offset, length)

	      default:
	        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
	        encoding = ('' + encoding).toLowerCase()
	        loweredCase = true
	    }
	  }
	}

	Buffer.prototype.toJSON = function toJSON () {
	  return {
	    type: 'Buffer',
	    data: Array.prototype.slice.call(this._arr || this, 0)
	  }
	}

	function base64Slice (buf, start, end) {
	  if (start === 0 && end === buf.length) {
	    return base64.fromByteArray(buf)
	  } else {
	    return base64.fromByteArray(buf.slice(start, end))
	  }
	}

	function utf8Slice (buf, start, end) {
	  end = Math.min(buf.length, end)
	  var res = []

	  var i = start
	  while (i < end) {
	    var firstByte = buf[i]
	    var codePoint = null
	    var bytesPerSequence = (firstByte > 0xEF) ? 4
	      : (firstByte > 0xDF) ? 3
	      : (firstByte > 0xBF) ? 2
	      : 1

	    if (i + bytesPerSequence <= end) {
	      var secondByte, thirdByte, fourthByte, tempCodePoint

	      switch (bytesPerSequence) {
	        case 1:
	          if (firstByte < 0x80) {
	            codePoint = firstByte
	          }
	          break
	        case 2:
	          secondByte = buf[i + 1]
	          if ((secondByte & 0xC0) === 0x80) {
	            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
	            if (tempCodePoint > 0x7F) {
	              codePoint = tempCodePoint
	            }
	          }
	          break
	        case 3:
	          secondByte = buf[i + 1]
	          thirdByte = buf[i + 2]
	          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
	            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
	            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
	              codePoint = tempCodePoint
	            }
	          }
	          break
	        case 4:
	          secondByte = buf[i + 1]
	          thirdByte = buf[i + 2]
	          fourthByte = buf[i + 3]
	          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
	            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
	            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
	              codePoint = tempCodePoint
	            }
	          }
	      }
	    }

	    if (codePoint === null) {
	      // we did not generate a valid codePoint so insert a
	      // replacement char (U+FFFD) and advance only 1 byte
	      codePoint = 0xFFFD
	      bytesPerSequence = 1
	    } else if (codePoint > 0xFFFF) {
	      // encode to utf16 (surrogate pair dance)
	      codePoint -= 0x10000
	      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
	      codePoint = 0xDC00 | codePoint & 0x3FF
	    }

	    res.push(codePoint)
	    i += bytesPerSequence
	  }

	  return decodeCodePointsArray(res)
	}

	// Based on http://stackoverflow.com/a/22747272/680742, the browser with
	// the lowest limit is Chrome, with 0x10000 args.
	// We go 1 magnitude less, for safety
	var MAX_ARGUMENTS_LENGTH = 0x1000

	function decodeCodePointsArray (codePoints) {
	  var len = codePoints.length
	  if (len <= MAX_ARGUMENTS_LENGTH) {
	    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
	  }

	  // Decode in chunks to avoid "call stack size exceeded".
	  var res = ''
	  var i = 0
	  while (i < len) {
	    res += String.fromCharCode.apply(
	      String,
	      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
	    )
	  }
	  return res
	}

	function asciiSlice (buf, start, end) {
	  var ret = ''
	  end = Math.min(buf.length, end)

	  for (var i = start; i < end; i++) {
	    ret += String.fromCharCode(buf[i] & 0x7F)
	  }
	  return ret
	}

	function binarySlice (buf, start, end) {
	  var ret = ''
	  end = Math.min(buf.length, end)

	  for (var i = start; i < end; i++) {
	    ret += String.fromCharCode(buf[i])
	  }
	  return ret
	}

	function hexSlice (buf, start, end) {
	  var len = buf.length

	  if (!start || start < 0) start = 0
	  if (!end || end < 0 || end > len) end = len

	  var out = ''
	  for (var i = start; i < end; i++) {
	    out += toHex(buf[i])
	  }
	  return out
	}

	function utf16leSlice (buf, start, end) {
	  var bytes = buf.slice(start, end)
	  var res = ''
	  for (var i = 0; i < bytes.length; i += 2) {
	    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
	  }
	  return res
	}

	Buffer.prototype.slice = function slice (start, end) {
	  var len = this.length
	  start = ~~start
	  end = end === undefined ? len : ~~end

	  if (start < 0) {
	    start += len
	    if (start < 0) start = 0
	  } else if (start > len) {
	    start = len
	  }

	  if (end < 0) {
	    end += len
	    if (end < 0) end = 0
	  } else if (end > len) {
	    end = len
	  }

	  if (end < start) end = start

	  var newBuf
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    newBuf = Buffer._augment(this.subarray(start, end))
	  } else {
	    var sliceLen = end - start
	    newBuf = new Buffer(sliceLen, undefined)
	    for (var i = 0; i < sliceLen; i++) {
	      newBuf[i] = this[i + start]
	    }
	  }

	  if (newBuf.length) newBuf.parent = this.parent || this

	  return newBuf
	}

	/*
	 * Need to make sure that buffer isn't trying to write out of bounds.
	 */
	function checkOffset (offset, ext, length) {
	  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
	  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
	}

	Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) checkOffset(offset, byteLength, this.length)

	  var val = this[offset]
	  var mul = 1
	  var i = 0
	  while (++i < byteLength && (mul *= 0x100)) {
	    val += this[offset + i] * mul
	  }

	  return val
	}

	Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) {
	    checkOffset(offset, byteLength, this.length)
	  }

	  var val = this[offset + --byteLength]
	  var mul = 1
	  while (byteLength > 0 && (mul *= 0x100)) {
	    val += this[offset + --byteLength] * mul
	  }

	  return val
	}

	Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 1, this.length)
	  return this[offset]
	}

	Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length)
	  return this[offset] | (this[offset + 1] << 8)
	}

	Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length)
	  return (this[offset] << 8) | this[offset + 1]
	}

	Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)

	  return ((this[offset]) |
	      (this[offset + 1] << 8) |
	      (this[offset + 2] << 16)) +
	      (this[offset + 3] * 0x1000000)
	}

	Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)

	  return (this[offset] * 0x1000000) +
	    ((this[offset + 1] << 16) |
	    (this[offset + 2] << 8) |
	    this[offset + 3])
	}

	Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) checkOffset(offset, byteLength, this.length)

	  var val = this[offset]
	  var mul = 1
	  var i = 0
	  while (++i < byteLength && (mul *= 0x100)) {
	    val += this[offset + i] * mul
	  }
	  mul *= 0x80

	  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

	  return val
	}

	Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) checkOffset(offset, byteLength, this.length)

	  var i = byteLength
	  var mul = 1
	  var val = this[offset + --i]
	  while (i > 0 && (mul *= 0x100)) {
	    val += this[offset + --i] * mul
	  }
	  mul *= 0x80

	  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

	  return val
	}

	Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 1, this.length)
	  if (!(this[offset] & 0x80)) return (this[offset])
	  return ((0xff - this[offset] + 1) * -1)
	}

	Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length)
	  var val = this[offset] | (this[offset + 1] << 8)
	  return (val & 0x8000) ? val | 0xFFFF0000 : val
	}

	Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length)
	  var val = this[offset + 1] | (this[offset] << 8)
	  return (val & 0x8000) ? val | 0xFFFF0000 : val
	}

	Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)

	  return (this[offset]) |
	    (this[offset + 1] << 8) |
	    (this[offset + 2] << 16) |
	    (this[offset + 3] << 24)
	}

	Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)

	  return (this[offset] << 24) |
	    (this[offset + 1] << 16) |
	    (this[offset + 2] << 8) |
	    (this[offset + 3])
	}

	Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)
	  return ieee754.read(this, offset, true, 23, 4)
	}

	Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)
	  return ieee754.read(this, offset, false, 23, 4)
	}

	Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 8, this.length)
	  return ieee754.read(this, offset, true, 52, 8)
	}

	Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 8, this.length)
	  return ieee754.read(this, offset, false, 52, 8)
	}

	function checkInt (buf, value, offset, ext, max, min) {
	  if (!Buffer.isBuffer(buf)) throw new TypeError('buffer must be a Buffer instance')
	  if (value > max || value < min) throw new RangeError('value is out of bounds')
	  if (offset + ext > buf.length) throw new RangeError('index out of range')
	}

	Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
	  value = +value
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0)

	  var mul = 1
	  var i = 0
	  this[offset] = value & 0xFF
	  while (++i < byteLength && (mul *= 0x100)) {
	    this[offset + i] = (value / mul) & 0xFF
	  }

	  return offset + byteLength
	}

	Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
	  value = +value
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0)

	  var i = byteLength - 1
	  var mul = 1
	  this[offset + i] = value & 0xFF
	  while (--i >= 0 && (mul *= 0x100)) {
	    this[offset + i] = (value / mul) & 0xFF
	  }

	  return offset + byteLength
	}

	Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
	  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
	  this[offset] = (value & 0xff)
	  return offset + 1
	}

	function objectWriteUInt16 (buf, value, offset, littleEndian) {
	  if (value < 0) value = 0xffff + value + 1
	  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; i++) {
	    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
	      (littleEndian ? i : 1 - i) * 8
	  }
	}

	Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value & 0xff)
	    this[offset + 1] = (value >>> 8)
	  } else {
	    objectWriteUInt16(this, value, offset, true)
	  }
	  return offset + 2
	}

	Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 8)
	    this[offset + 1] = (value & 0xff)
	  } else {
	    objectWriteUInt16(this, value, offset, false)
	  }
	  return offset + 2
	}

	function objectWriteUInt32 (buf, value, offset, littleEndian) {
	  if (value < 0) value = 0xffffffff + value + 1
	  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; i++) {
	    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
	  }
	}

	Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset + 3] = (value >>> 24)
	    this[offset + 2] = (value >>> 16)
	    this[offset + 1] = (value >>> 8)
	    this[offset] = (value & 0xff)
	  } else {
	    objectWriteUInt32(this, value, offset, true)
	  }
	  return offset + 4
	}

	Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 24)
	    this[offset + 1] = (value >>> 16)
	    this[offset + 2] = (value >>> 8)
	    this[offset + 3] = (value & 0xff)
	  } else {
	    objectWriteUInt32(this, value, offset, false)
	  }
	  return offset + 4
	}

	Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) {
	    var limit = Math.pow(2, 8 * byteLength - 1)

	    checkInt(this, value, offset, byteLength, limit - 1, -limit)
	  }

	  var i = 0
	  var mul = 1
	  var sub = value < 0 ? 1 : 0
	  this[offset] = value & 0xFF
	  while (++i < byteLength && (mul *= 0x100)) {
	    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
	  }

	  return offset + byteLength
	}

	Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) {
	    var limit = Math.pow(2, 8 * byteLength - 1)

	    checkInt(this, value, offset, byteLength, limit - 1, -limit)
	  }

	  var i = byteLength - 1
	  var mul = 1
	  var sub = value < 0 ? 1 : 0
	  this[offset + i] = value & 0xFF
	  while (--i >= 0 && (mul *= 0x100)) {
	    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
	  }

	  return offset + byteLength
	}

	Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
	  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
	  if (value < 0) value = 0xff + value + 1
	  this[offset] = (value & 0xff)
	  return offset + 1
	}

	Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value & 0xff)
	    this[offset + 1] = (value >>> 8)
	  } else {
	    objectWriteUInt16(this, value, offset, true)
	  }
	  return offset + 2
	}

	Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 8)
	    this[offset + 1] = (value & 0xff)
	  } else {
	    objectWriteUInt16(this, value, offset, false)
	  }
	  return offset + 2
	}

	Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value & 0xff)
	    this[offset + 1] = (value >>> 8)
	    this[offset + 2] = (value >>> 16)
	    this[offset + 3] = (value >>> 24)
	  } else {
	    objectWriteUInt32(this, value, offset, true)
	  }
	  return offset + 4
	}

	Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
	  if (value < 0) value = 0xffffffff + value + 1
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 24)
	    this[offset + 1] = (value >>> 16)
	    this[offset + 2] = (value >>> 8)
	    this[offset + 3] = (value & 0xff)
	  } else {
	    objectWriteUInt32(this, value, offset, false)
	  }
	  return offset + 4
	}

	function checkIEEE754 (buf, value, offset, ext, max, min) {
	  if (value > max || value < min) throw new RangeError('value is out of bounds')
	  if (offset + ext > buf.length) throw new RangeError('index out of range')
	  if (offset < 0) throw new RangeError('index out of range')
	}

	function writeFloat (buf, value, offset, littleEndian, noAssert) {
	  if (!noAssert) {
	    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
	  }
	  ieee754.write(buf, value, offset, littleEndian, 23, 4)
	  return offset + 4
	}

	Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
	  return writeFloat(this, value, offset, true, noAssert)
	}

	Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
	  return writeFloat(this, value, offset, false, noAssert)
	}

	function writeDouble (buf, value, offset, littleEndian, noAssert) {
	  if (!noAssert) {
	    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
	  }
	  ieee754.write(buf, value, offset, littleEndian, 52, 8)
	  return offset + 8
	}

	Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
	  return writeDouble(this, value, offset, true, noAssert)
	}

	Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
	  return writeDouble(this, value, offset, false, noAssert)
	}

	// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
	Buffer.prototype.copy = function copy (target, targetStart, start, end) {
	  if (!start) start = 0
	  if (!end && end !== 0) end = this.length
	  if (targetStart >= target.length) targetStart = target.length
	  if (!targetStart) targetStart = 0
	  if (end > 0 && end < start) end = start

	  // Copy 0 bytes; we're done
	  if (end === start) return 0
	  if (target.length === 0 || this.length === 0) return 0

	  // Fatal error conditions
	  if (targetStart < 0) {
	    throw new RangeError('targetStart out of bounds')
	  }
	  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
	  if (end < 0) throw new RangeError('sourceEnd out of bounds')

	  // Are we oob?
	  if (end > this.length) end = this.length
	  if (target.length - targetStart < end - start) {
	    end = target.length - targetStart + start
	  }

	  var len = end - start
	  var i

	  if (this === target && start < targetStart && targetStart < end) {
	    // descending copy from end
	    for (i = len - 1; i >= 0; i--) {
	      target[i + targetStart] = this[i + start]
	    }
	  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
	    // ascending copy from start
	    for (i = 0; i < len; i++) {
	      target[i + targetStart] = this[i + start]
	    }
	  } else {
	    target._set(this.subarray(start, start + len), targetStart)
	  }

	  return len
	}

	// fill(value, start=0, end=buffer.length)
	Buffer.prototype.fill = function fill (value, start, end) {
	  if (!value) value = 0
	  if (!start) start = 0
	  if (!end) end = this.length

	  if (end < start) throw new RangeError('end < start')

	  // Fill 0 bytes; we're done
	  if (end === start) return
	  if (this.length === 0) return

	  if (start < 0 || start >= this.length) throw new RangeError('start out of bounds')
	  if (end < 0 || end > this.length) throw new RangeError('end out of bounds')

	  var i
	  if (typeof value === 'number') {
	    for (i = start; i < end; i++) {
	      this[i] = value
	    }
	  } else {
	    var bytes = utf8ToBytes(value.toString())
	    var len = bytes.length
	    for (i = start; i < end; i++) {
	      this[i] = bytes[i % len]
	    }
	  }

	  return this
	}

	/**
	 * Creates a new `ArrayBuffer` with the *copied* memory of the buffer instance.
	 * Added in Node 0.12. Only available in browsers that support ArrayBuffer.
	 */
	Buffer.prototype.toArrayBuffer = function toArrayBuffer () {
	  if (typeof Uint8Array !== 'undefined') {
	    if (Buffer.TYPED_ARRAY_SUPPORT) {
	      return (new Buffer(this)).buffer
	    } else {
	      var buf = new Uint8Array(this.length)
	      for (var i = 0, len = buf.length; i < len; i += 1) {
	        buf[i] = this[i]
	      }
	      return buf.buffer
	    }
	  } else {
	    throw new TypeError('Buffer.toArrayBuffer not supported in this browser')
	  }
	}

	// HELPER FUNCTIONS
	// ================

	var BP = Buffer.prototype

	/**
	 * Augment a Uint8Array *instance* (not the Uint8Array class!) with Buffer methods
	 */
	Buffer._augment = function _augment (arr) {
	  arr.constructor = Buffer
	  arr._isBuffer = true

	  // save reference to original Uint8Array set method before overwriting
	  arr._set = arr.set

	  // deprecated
	  arr.get = BP.get
	  arr.set = BP.set

	  arr.write = BP.write
	  arr.toString = BP.toString
	  arr.toLocaleString = BP.toString
	  arr.toJSON = BP.toJSON
	  arr.equals = BP.equals
	  arr.compare = BP.compare
	  arr.indexOf = BP.indexOf
	  arr.copy = BP.copy
	  arr.slice = BP.slice
	  arr.readUIntLE = BP.readUIntLE
	  arr.readUIntBE = BP.readUIntBE
	  arr.readUInt8 = BP.readUInt8
	  arr.readUInt16LE = BP.readUInt16LE
	  arr.readUInt16BE = BP.readUInt16BE
	  arr.readUInt32LE = BP.readUInt32LE
	  arr.readUInt32BE = BP.readUInt32BE
	  arr.readIntLE = BP.readIntLE
	  arr.readIntBE = BP.readIntBE
	  arr.readInt8 = BP.readInt8
	  arr.readInt16LE = BP.readInt16LE
	  arr.readInt16BE = BP.readInt16BE
	  arr.readInt32LE = BP.readInt32LE
	  arr.readInt32BE = BP.readInt32BE
	  arr.readFloatLE = BP.readFloatLE
	  arr.readFloatBE = BP.readFloatBE
	  arr.readDoubleLE = BP.readDoubleLE
	  arr.readDoubleBE = BP.readDoubleBE
	  arr.writeUInt8 = BP.writeUInt8
	  arr.writeUIntLE = BP.writeUIntLE
	  arr.writeUIntBE = BP.writeUIntBE
	  arr.writeUInt16LE = BP.writeUInt16LE
	  arr.writeUInt16BE = BP.writeUInt16BE
	  arr.writeUInt32LE = BP.writeUInt32LE
	  arr.writeUInt32BE = BP.writeUInt32BE
	  arr.writeIntLE = BP.writeIntLE
	  arr.writeIntBE = BP.writeIntBE
	  arr.writeInt8 = BP.writeInt8
	  arr.writeInt16LE = BP.writeInt16LE
	  arr.writeInt16BE = BP.writeInt16BE
	  arr.writeInt32LE = BP.writeInt32LE
	  arr.writeInt32BE = BP.writeInt32BE
	  arr.writeFloatLE = BP.writeFloatLE
	  arr.writeFloatBE = BP.writeFloatBE
	  arr.writeDoubleLE = BP.writeDoubleLE
	  arr.writeDoubleBE = BP.writeDoubleBE
	  arr.fill = BP.fill
	  arr.inspect = BP.inspect
	  arr.toArrayBuffer = BP.toArrayBuffer

	  return arr
	}

	var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g

	function base64clean (str) {
	  // Node strips out invalid characters like \n and \t from the string, base64-js does not
	  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
	  // Node converts strings with length < 2 to ''
	  if (str.length < 2) return ''
	  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
	  while (str.length % 4 !== 0) {
	    str = str + '='
	  }
	  return str
	}

	function stringtrim (str) {
	  if (str.trim) return str.trim()
	  return str.replace(/^\s+|\s+$/g, '')
	}

	function toHex (n) {
	  if (n < 16) return '0' + n.toString(16)
	  return n.toString(16)
	}

	function utf8ToBytes (string, units) {
	  units = units || Infinity
	  var codePoint
	  var length = string.length
	  var leadSurrogate = null
	  var bytes = []

	  for (var i = 0; i < length; i++) {
	    codePoint = string.charCodeAt(i)

	    // is surrogate component
	    if (codePoint > 0xD7FF && codePoint < 0xE000) {
	      // last char was a lead
	      if (!leadSurrogate) {
	        // no lead yet
	        if (codePoint > 0xDBFF) {
	          // unexpected trail
	          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
	          continue
	        } else if (i + 1 === length) {
	          // unpaired lead
	          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
	          continue
	        }

	        // valid lead
	        leadSurrogate = codePoint

	        continue
	      }

	      // 2 leads in a row
	      if (codePoint < 0xDC00) {
	        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
	        leadSurrogate = codePoint
	        continue
	      }

	      // valid surrogate pair
	      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
	    } else if (leadSurrogate) {
	      // valid bmp char, but last char was a lead
	      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
	    }

	    leadSurrogate = null

	    // encode utf8
	    if (codePoint < 0x80) {
	      if ((units -= 1) < 0) break
	      bytes.push(codePoint)
	    } else if (codePoint < 0x800) {
	      if ((units -= 2) < 0) break
	      bytes.push(
	        codePoint >> 0x6 | 0xC0,
	        codePoint & 0x3F | 0x80
	      )
	    } else if (codePoint < 0x10000) {
	      if ((units -= 3) < 0) break
	      bytes.push(
	        codePoint >> 0xC | 0xE0,
	        codePoint >> 0x6 & 0x3F | 0x80,
	        codePoint & 0x3F | 0x80
	      )
	    } else if (codePoint < 0x110000) {
	      if ((units -= 4) < 0) break
	      bytes.push(
	        codePoint >> 0x12 | 0xF0,
	        codePoint >> 0xC & 0x3F | 0x80,
	        codePoint >> 0x6 & 0x3F | 0x80,
	        codePoint & 0x3F | 0x80
	      )
	    } else {
	      throw new Error('Invalid code point')
	    }
	  }

	  return bytes
	}

	function asciiToBytes (str) {
	  var byteArray = []
	  for (var i = 0; i < str.length; i++) {
	    // Node's code seems to be doing this and not & 0x7F..
	    byteArray.push(str.charCodeAt(i) & 0xFF)
	  }
	  return byteArray
	}

	function utf16leToBytes (str, units) {
	  var c, hi, lo
	  var byteArray = []
	  for (var i = 0; i < str.length; i++) {
	    if ((units -= 2) < 0) break

	    c = str.charCodeAt(i)
	    hi = c >> 8
	    lo = c % 256
	    byteArray.push(lo)
	    byteArray.push(hi)
	  }

	  return byteArray
	}

	function base64ToBytes (str) {
	  return base64.toByteArray(base64clean(str))
	}

	function blitBuffer (src, dst, offset, length) {
	  for (var i = 0; i < length; i++) {
	    if ((i + offset >= dst.length) || (i >= src.length)) break
	    dst[i + offset] = src[i]
	  }
	  return i
	}

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(244).Buffer, (function() { return this; }())))

/***/ },
/* 245 */
/***/ function(module, exports, __webpack_require__) {

	var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

	;(function (exports) {
		'use strict';

	  var Arr = (typeof Uint8Array !== 'undefined')
	    ? Uint8Array
	    : Array

		var PLUS   = '+'.charCodeAt(0)
		var SLASH  = '/'.charCodeAt(0)
		var NUMBER = '0'.charCodeAt(0)
		var LOWER  = 'a'.charCodeAt(0)
		var UPPER  = 'A'.charCodeAt(0)
		var PLUS_URL_SAFE = '-'.charCodeAt(0)
		var SLASH_URL_SAFE = '_'.charCodeAt(0)

		function decode (elt) {
			var code = elt.charCodeAt(0)
			if (code === PLUS ||
			    code === PLUS_URL_SAFE)
				return 62 // '+'
			if (code === SLASH ||
			    code === SLASH_URL_SAFE)
				return 63 // '/'
			if (code < NUMBER)
				return -1 //no match
			if (code < NUMBER + 10)
				return code - NUMBER + 26 + 26
			if (code < UPPER + 26)
				return code - UPPER
			if (code < LOWER + 26)
				return code - LOWER + 26
		}

		function b64ToByteArray (b64) {
			var i, j, l, tmp, placeHolders, arr

			if (b64.length % 4 > 0) {
				throw new Error('Invalid string. Length must be a multiple of 4')
			}

			// the number of equal signs (place holders)
			// if there are two placeholders, than the two characters before it
			// represent one byte
			// if there is only one, then the three characters before it represent 2 bytes
			// this is just a cheap hack to not do indexOf twice
			var len = b64.length
			placeHolders = '=' === b64.charAt(len - 2) ? 2 : '=' === b64.charAt(len - 1) ? 1 : 0

			// base64 is 4/3 + up to two characters of the original data
			arr = new Arr(b64.length * 3 / 4 - placeHolders)

			// if there are placeholders, only get up to the last complete 4 chars
			l = placeHolders > 0 ? b64.length - 4 : b64.length

			var L = 0

			function push (v) {
				arr[L++] = v
			}

			for (i = 0, j = 0; i < l; i += 4, j += 3) {
				tmp = (decode(b64.charAt(i)) << 18) | (decode(b64.charAt(i + 1)) << 12) | (decode(b64.charAt(i + 2)) << 6) | decode(b64.charAt(i + 3))
				push((tmp & 0xFF0000) >> 16)
				push((tmp & 0xFF00) >> 8)
				push(tmp & 0xFF)
			}

			if (placeHolders === 2) {
				tmp = (decode(b64.charAt(i)) << 2) | (decode(b64.charAt(i + 1)) >> 4)
				push(tmp & 0xFF)
			} else if (placeHolders === 1) {
				tmp = (decode(b64.charAt(i)) << 10) | (decode(b64.charAt(i + 1)) << 4) | (decode(b64.charAt(i + 2)) >> 2)
				push((tmp >> 8) & 0xFF)
				push(tmp & 0xFF)
			}

			return arr
		}

		function uint8ToBase64 (uint8) {
			var i,
				extraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes
				output = "",
				temp, length

			function encode (num) {
				return lookup.charAt(num)
			}

			function tripletToBase64 (num) {
				return encode(num >> 18 & 0x3F) + encode(num >> 12 & 0x3F) + encode(num >> 6 & 0x3F) + encode(num & 0x3F)
			}

			// go through the array every three bytes, we'll deal with trailing stuff later
			for (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {
				temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])
				output += tripletToBase64(temp)
			}

			// pad the end with zeros, but make sure to not forget the extra bytes
			switch (extraBytes) {
				case 1:
					temp = uint8[uint8.length - 1]
					output += encode(temp >> 2)
					output += encode((temp << 4) & 0x3F)
					output += '=='
					break
				case 2:
					temp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1])
					output += encode(temp >> 10)
					output += encode((temp >> 4) & 0x3F)
					output += encode((temp << 2) & 0x3F)
					output += '='
					break
			}

			return output
		}

		exports.toByteArray = b64ToByteArray
		exports.fromByteArray = uint8ToBase64
	}( false ? (this.base64js = {}) : exports))


/***/ },
/* 246 */
/***/ function(module, exports) {

	exports.read = function (buffer, offset, isLE, mLen, nBytes) {
	  var e, m
	  var eLen = nBytes * 8 - mLen - 1
	  var eMax = (1 << eLen) - 1
	  var eBias = eMax >> 1
	  var nBits = -7
	  var i = isLE ? (nBytes - 1) : 0
	  var d = isLE ? -1 : 1
	  var s = buffer[offset + i]

	  i += d

	  e = s & ((1 << (-nBits)) - 1)
	  s >>= (-nBits)
	  nBits += eLen
	  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

	  m = e & ((1 << (-nBits)) - 1)
	  e >>= (-nBits)
	  nBits += mLen
	  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

	  if (e === 0) {
	    e = 1 - eBias
	  } else if (e === eMax) {
	    return m ? NaN : ((s ? -1 : 1) * Infinity)
	  } else {
	    m = m + Math.pow(2, mLen)
	    e = e - eBias
	  }
	  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
	}

	exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
	  var e, m, c
	  var eLen = nBytes * 8 - mLen - 1
	  var eMax = (1 << eLen) - 1
	  var eBias = eMax >> 1
	  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
	  var i = isLE ? 0 : (nBytes - 1)
	  var d = isLE ? 1 : -1
	  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

	  value = Math.abs(value)

	  if (isNaN(value) || value === Infinity) {
	    m = isNaN(value) ? 1 : 0
	    e = eMax
	  } else {
	    e = Math.floor(Math.log(value) / Math.LN2)
	    if (value * (c = Math.pow(2, -e)) < 1) {
	      e--
	      c *= 2
	    }
	    if (e + eBias >= 1) {
	      value += rt / c
	    } else {
	      value += rt * Math.pow(2, 1 - eBias)
	    }
	    if (value * c >= 2) {
	      e++
	      c /= 2
	    }

	    if (e + eBias >= eMax) {
	      m = 0
	      e = eMax
	    } else if (e + eBias >= 1) {
	      m = (value * c - 1) * Math.pow(2, mLen)
	      e = e + eBias
	    } else {
	      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
	      e = 0
	    }
	  }

	  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

	  e = (e << mLen) | m
	  eLen += mLen
	  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

	  buffer[offset + i - d] |= s * 128
	}


/***/ },
/* 247 */
/***/ function(module, exports) {

	var toString = {}.toString;

	module.exports = Array.isArray || function (arr) {
	  return toString.call(arr) == '[object Array]';
	};


/***/ },
/* 248 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global, process) {// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	var formatRegExp = /%[sdj%]/g;
	exports.format = function(f) {
	  if (!isString(f)) {
	    var objects = [];
	    for (var i = 0; i < arguments.length; i++) {
	      objects.push(inspect(arguments[i]));
	    }
	    return objects.join(' ');
	  }

	  var i = 1;
	  var args = arguments;
	  var len = args.length;
	  var str = String(f).replace(formatRegExp, function(x) {
	    if (x === '%%') return '%';
	    if (i >= len) return x;
	    switch (x) {
	      case '%s': return String(args[i++]);
	      case '%d': return Number(args[i++]);
	      case '%j':
	        try {
	          return JSON.stringify(args[i++]);
	        } catch (_) {
	          return '[Circular]';
	        }
	      default:
	        return x;
	    }
	  });
	  for (var x = args[i]; i < len; x = args[++i]) {
	    if (isNull(x) || !isObject(x)) {
	      str += ' ' + x;
	    } else {
	      str += ' ' + inspect(x);
	    }
	  }
	  return str;
	};


	// Mark that a method should not be used.
	// Returns a modified function which warns once by default.
	// If --no-deprecation is set, then it is a no-op.
	exports.deprecate = function(fn, msg) {
	  // Allow for deprecating things in the process of starting up.
	  if (isUndefined(global.process)) {
	    return function() {
	      return exports.deprecate(fn, msg).apply(this, arguments);
	    };
	  }

	  if (process.noDeprecation === true) {
	    return fn;
	  }

	  var warned = false;
	  function deprecated() {
	    if (!warned) {
	      if (process.throwDeprecation) {
	        throw new Error(msg);
	      } else if (process.traceDeprecation) {
	        console.trace(msg);
	      } else {
	        console.error(msg);
	      }
	      warned = true;
	    }
	    return fn.apply(this, arguments);
	  }

	  return deprecated;
	};


	var debugs = {};
	var debugEnviron;
	exports.debuglog = function(set) {
	  if (isUndefined(debugEnviron))
	    debugEnviron = process.env.NODE_DEBUG || '';
	  set = set.toUpperCase();
	  if (!debugs[set]) {
	    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
	      var pid = process.pid;
	      debugs[set] = function() {
	        var msg = exports.format.apply(exports, arguments);
	        console.error('%s %d: %s', set, pid, msg);
	      };
	    } else {
	      debugs[set] = function() {};
	    }
	  }
	  return debugs[set];
	};


	/**
	 * Echos the value of a value. Trys to print the value out
	 * in the best way possible given the different types.
	 *
	 * @param {Object} obj The object to print out.
	 * @param {Object} opts Optional options object that alters the output.
	 */
	/* legacy: obj, showHidden, depth, colors*/
	function inspect(obj, opts) {
	  // default options
	  var ctx = {
	    seen: [],
	    stylize: stylizeNoColor
	  };
	  // legacy...
	  if (arguments.length >= 3) ctx.depth = arguments[2];
	  if (arguments.length >= 4) ctx.colors = arguments[3];
	  if (isBoolean(opts)) {
	    // legacy...
	    ctx.showHidden = opts;
	  } else if (opts) {
	    // got an "options" object
	    exports._extend(ctx, opts);
	  }
	  // set default options
	  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
	  if (isUndefined(ctx.depth)) ctx.depth = 2;
	  if (isUndefined(ctx.colors)) ctx.colors = false;
	  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
	  if (ctx.colors) ctx.stylize = stylizeWithColor;
	  return formatValue(ctx, obj, ctx.depth);
	}
	exports.inspect = inspect;


	// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
	inspect.colors = {
	  'bold' : [1, 22],
	  'italic' : [3, 23],
	  'underline' : [4, 24],
	  'inverse' : [7, 27],
	  'white' : [37, 39],
	  'grey' : [90, 39],
	  'black' : [30, 39],
	  'blue' : [34, 39],
	  'cyan' : [36, 39],
	  'green' : [32, 39],
	  'magenta' : [35, 39],
	  'red' : [31, 39],
	  'yellow' : [33, 39]
	};

	// Don't use 'blue' not visible on cmd.exe
	inspect.styles = {
	  'special': 'cyan',
	  'number': 'yellow',
	  'boolean': 'yellow',
	  'undefined': 'grey',
	  'null': 'bold',
	  'string': 'green',
	  'date': 'magenta',
	  // "name": intentionally not styling
	  'regexp': 'red'
	};


	function stylizeWithColor(str, styleType) {
	  var style = inspect.styles[styleType];

	  if (style) {
	    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
	           '\u001b[' + inspect.colors[style][1] + 'm';
	  } else {
	    return str;
	  }
	}


	function stylizeNoColor(str, styleType) {
	  return str;
	}


	function arrayToHash(array) {
	  var hash = {};

	  array.forEach(function(val, idx) {
	    hash[val] = true;
	  });

	  return hash;
	}


	function formatValue(ctx, value, recurseTimes) {
	  // Provide a hook for user-specified inspect functions.
	  // Check that value is an object with an inspect function on it
	  if (ctx.customInspect &&
	      value &&
	      isFunction(value.inspect) &&
	      // Filter out the util module, it's inspect function is special
	      value.inspect !== exports.inspect &&
	      // Also filter out any prototype objects using the circular check.
	      !(value.constructor && value.constructor.prototype === value)) {
	    var ret = value.inspect(recurseTimes, ctx);
	    if (!isString(ret)) {
	      ret = formatValue(ctx, ret, recurseTimes);
	    }
	    return ret;
	  }

	  // Primitive types cannot have properties
	  var primitive = formatPrimitive(ctx, value);
	  if (primitive) {
	    return primitive;
	  }

	  // Look up the keys of the object.
	  var keys = Object.keys(value);
	  var visibleKeys = arrayToHash(keys);

	  if (ctx.showHidden) {
	    keys = Object.getOwnPropertyNames(value);
	  }

	  // IE doesn't make error fields non-enumerable
	  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
	  if (isError(value)
	      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
	    return formatError(value);
	  }

	  // Some type of object without properties can be shortcutted.
	  if (keys.length === 0) {
	    if (isFunction(value)) {
	      var name = value.name ? ': ' + value.name : '';
	      return ctx.stylize('[Function' + name + ']', 'special');
	    }
	    if (isRegExp(value)) {
	      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
	    }
	    if (isDate(value)) {
	      return ctx.stylize(Date.prototype.toString.call(value), 'date');
	    }
	    if (isError(value)) {
	      return formatError(value);
	    }
	  }

	  var base = '', array = false, braces = ['{', '}'];

	  // Make Array say that they are Array
	  if (isArray(value)) {
	    array = true;
	    braces = ['[', ']'];
	  }

	  // Make functions say that they are functions
	  if (isFunction(value)) {
	    var n = value.name ? ': ' + value.name : '';
	    base = ' [Function' + n + ']';
	  }

	  // Make RegExps say that they are RegExps
	  if (isRegExp(value)) {
	    base = ' ' + RegExp.prototype.toString.call(value);
	  }

	  // Make dates with properties first say the date
	  if (isDate(value)) {
	    base = ' ' + Date.prototype.toUTCString.call(value);
	  }

	  // Make error with message first say the error
	  if (isError(value)) {
	    base = ' ' + formatError(value);
	  }

	  if (keys.length === 0 && (!array || value.length == 0)) {
	    return braces[0] + base + braces[1];
	  }

	  if (recurseTimes < 0) {
	    if (isRegExp(value)) {
	      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
	    } else {
	      return ctx.stylize('[Object]', 'special');
	    }
	  }

	  ctx.seen.push(value);

	  var output;
	  if (array) {
	    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
	  } else {
	    output = keys.map(function(key) {
	      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
	    });
	  }

	  ctx.seen.pop();

	  return reduceToSingleString(output, base, braces);
	}


	function formatPrimitive(ctx, value) {
	  if (isUndefined(value))
	    return ctx.stylize('undefined', 'undefined');
	  if (isString(value)) {
	    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
	                                             .replace(/'/g, "\\'")
	                                             .replace(/\\"/g, '"') + '\'';
	    return ctx.stylize(simple, 'string');
	  }
	  if (isNumber(value))
	    return ctx.stylize('' + value, 'number');
	  if (isBoolean(value))
	    return ctx.stylize('' + value, 'boolean');
	  // For some reason typeof null is "object", so special case here.
	  if (isNull(value))
	    return ctx.stylize('null', 'null');
	}


	function formatError(value) {
	  return '[' + Error.prototype.toString.call(value) + ']';
	}


	function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
	  var output = [];
	  for (var i = 0, l = value.length; i < l; ++i) {
	    if (hasOwnProperty(value, String(i))) {
	      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
	          String(i), true));
	    } else {
	      output.push('');
	    }
	  }
	  keys.forEach(function(key) {
	    if (!key.match(/^\d+$/)) {
	      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
	          key, true));
	    }
	  });
	  return output;
	}


	function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
	  var name, str, desc;
	  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
	  if (desc.get) {
	    if (desc.set) {
	      str = ctx.stylize('[Getter/Setter]', 'special');
	    } else {
	      str = ctx.stylize('[Getter]', 'special');
	    }
	  } else {
	    if (desc.set) {
	      str = ctx.stylize('[Setter]', 'special');
	    }
	  }
	  if (!hasOwnProperty(visibleKeys, key)) {
	    name = '[' + key + ']';
	  }
	  if (!str) {
	    if (ctx.seen.indexOf(desc.value) < 0) {
	      if (isNull(recurseTimes)) {
	        str = formatValue(ctx, desc.value, null);
	      } else {
	        str = formatValue(ctx, desc.value, recurseTimes - 1);
	      }
	      if (str.indexOf('\n') > -1) {
	        if (array) {
	          str = str.split('\n').map(function(line) {
	            return '  ' + line;
	          }).join('\n').substr(2);
	        } else {
	          str = '\n' + str.split('\n').map(function(line) {
	            return '   ' + line;
	          }).join('\n');
	        }
	      }
	    } else {
	      str = ctx.stylize('[Circular]', 'special');
	    }
	  }
	  if (isUndefined(name)) {
	    if (array && key.match(/^\d+$/)) {
	      return str;
	    }
	    name = JSON.stringify('' + key);
	    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
	      name = name.substr(1, name.length - 2);
	      name = ctx.stylize(name, 'name');
	    } else {
	      name = name.replace(/'/g, "\\'")
	                 .replace(/\\"/g, '"')
	                 .replace(/(^"|"$)/g, "'");
	      name = ctx.stylize(name, 'string');
	    }
	  }

	  return name + ': ' + str;
	}


	function reduceToSingleString(output, base, braces) {
	  var numLinesEst = 0;
	  var length = output.reduce(function(prev, cur) {
	    numLinesEst++;
	    if (cur.indexOf('\n') >= 0) numLinesEst++;
	    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
	  }, 0);

	  if (length > 60) {
	    return braces[0] +
	           (base === '' ? '' : base + '\n ') +
	           ' ' +
	           output.join(',\n  ') +
	           ' ' +
	           braces[1];
	  }

	  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
	}


	// NOTE: These type checking functions intentionally don't use `instanceof`
	// because it is fragile and can be easily faked with `Object.create()`.
	function isArray(ar) {
	  return Array.isArray(ar);
	}
	exports.isArray = isArray;

	function isBoolean(arg) {
	  return typeof arg === 'boolean';
	}
	exports.isBoolean = isBoolean;

	function isNull(arg) {
	  return arg === null;
	}
	exports.isNull = isNull;

	function isNullOrUndefined(arg) {
	  return arg == null;
	}
	exports.isNullOrUndefined = isNullOrUndefined;

	function isNumber(arg) {
	  return typeof arg === 'number';
	}
	exports.isNumber = isNumber;

	function isString(arg) {
	  return typeof arg === 'string';
	}
	exports.isString = isString;

	function isSymbol(arg) {
	  return typeof arg === 'symbol';
	}
	exports.isSymbol = isSymbol;

	function isUndefined(arg) {
	  return arg === void 0;
	}
	exports.isUndefined = isUndefined;

	function isRegExp(re) {
	  return isObject(re) && objectToString(re) === '[object RegExp]';
	}
	exports.isRegExp = isRegExp;

	function isObject(arg) {
	  return typeof arg === 'object' && arg !== null;
	}
	exports.isObject = isObject;

	function isDate(d) {
	  return isObject(d) && objectToString(d) === '[object Date]';
	}
	exports.isDate = isDate;

	function isError(e) {
	  return isObject(e) &&
	      (objectToString(e) === '[object Error]' || e instanceof Error);
	}
	exports.isError = isError;

	function isFunction(arg) {
	  return typeof arg === 'function';
	}
	exports.isFunction = isFunction;

	function isPrimitive(arg) {
	  return arg === null ||
	         typeof arg === 'boolean' ||
	         typeof arg === 'number' ||
	         typeof arg === 'string' ||
	         typeof arg === 'symbol' ||  // ES6 symbol
	         typeof arg === 'undefined';
	}
	exports.isPrimitive = isPrimitive;

	exports.isBuffer = __webpack_require__(249);

	function objectToString(o) {
	  return Object.prototype.toString.call(o);
	}


	function pad(n) {
	  return n < 10 ? '0' + n.toString(10) : n.toString(10);
	}


	var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
	              'Oct', 'Nov', 'Dec'];

	// 26 Feb 16:19:34
	function timestamp() {
	  var d = new Date();
	  var time = [pad(d.getHours()),
	              pad(d.getMinutes()),
	              pad(d.getSeconds())].join(':');
	  return [d.getDate(), months[d.getMonth()], time].join(' ');
	}


	// log is just a thin wrapper to console.log that prepends a timestamp
	exports.log = function() {
	  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
	};


	/**
	 * Inherit the prototype methods from one constructor into another.
	 *
	 * The Function.prototype.inherits from lang.js rewritten as a standalone
	 * function (not on Function.prototype). NOTE: If this file is to be loaded
	 * during bootstrapping this function needs to be rewritten using some native
	 * functions as prototype setup using normal JavaScript does not work as
	 * expected during bootstrapping (see mirror.js in r114903).
	 *
	 * @param {function} ctor Constructor function which needs to inherit the
	 *     prototype.
	 * @param {function} superCtor Constructor function to inherit prototype from.
	 */
	exports.inherits = __webpack_require__(250);

	exports._extend = function(origin, add) {
	  // Don't do anything if add isn't an object
	  if (!add || !isObject(add)) return origin;

	  var keys = Object.keys(add);
	  var i = keys.length;
	  while (i--) {
	    origin[keys[i]] = add[keys[i]];
	  }
	  return origin;
	};

	function hasOwnProperty(obj, prop) {
	  return Object.prototype.hasOwnProperty.call(obj, prop);
	}

	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()), __webpack_require__(243)))

/***/ },
/* 249 */
/***/ function(module, exports) {

	module.exports = function isBuffer(arg) {
	  return arg && typeof arg === 'object'
	    && typeof arg.copy === 'function'
	    && typeof arg.fill === 'function'
	    && typeof arg.readUInt8 === 'function';
	}

/***/ },
/* 250 */
/***/ function(module, exports) {

	if (typeof Object.create === 'function') {
	  // implementation from standard node.js 'util' module
	  module.exports = function inherits(ctor, superCtor) {
	    ctor.super_ = superCtor
	    ctor.prototype = Object.create(superCtor.prototype, {
	      constructor: {
	        value: ctor,
	        enumerable: false,
	        writable: true,
	        configurable: true
	      }
	    });
	  };
	} else {
	  // old school shim for old browsers
	  module.exports = function inherits(ctor, superCtor) {
	    ctor.super_ = superCtor
	    var TempCtor = function () {}
	    TempCtor.prototype = superCtor.prototype
	    ctor.prototype = new TempCtor()
	    ctor.prototype.constructor = ctor
	  }
	}


/***/ },
/* 251 */
[594, 252, 253],
/* 252 */
/***/ function(module, exports) {

	exports = module.exports = typeof Object.keys === 'function'
	  ? Object.keys : shim;

	exports.shim = shim;
	function shim (obj) {
	  var keys = [];
	  for (var key in obj) keys.push(key);
	  return keys;
	}


/***/ },
/* 253 */
/***/ function(module, exports) {

	var supportsArgumentsClass = (function(){
	  return Object.prototype.toString.call(arguments)
	})() == '[object Arguments]';

	exports = module.exports = supportsArgumentsClass ? supported : unsupported;

	exports.supported = supported;
	function supported(object) {
	  return Object.prototype.toString.call(object) == '[object Arguments]';
	};

	exports.unsupported = unsupported;
	function unsupported(object){
	  return object &&
	    typeof object == 'object' &&
	    typeof object.length == 'number' &&
	    Object.prototype.hasOwnProperty.call(object, 'callee') &&
	    !Object.prototype.propertyIsEnumerable.call(object, 'callee') ||
	    false;
	};


/***/ },
/* 254 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	/**
	 * @author: zhouquan.yezq
	 * @time : 8/12 2015
	 */

	var classnames = __webpack_require__(19);

	var React = __webpack_require__(7);
	var ReactDOM = __webpack_require__(8);

	var Mask = function (_React$Component) {
	    _inherits(Mask, _React$Component);

	    function Mask(props) {
	        _classCallCheck(this, Mask);

	        return _possibleConstructorReturn(this, _React$Component.call(this, props));
	    }

	    Mask.prototype.render = function render() {
	        var _classnames;

	        var props = this.props;
	        var visible = props.visible;
	        var text = props.text;

	        var className = classnames((_classnames = {}, _classnames[props.prefixCls] = true, _classnames[props.prefixCls + "-hide"] = !visible, _classnames));
	        return React.createElement(
	            'div',
	            { className: className },
	            React.createElement(
	                'div',
	                { className: props.prefixCls + '-centerblk' },
	                React.createElement('span', { className: 'kuma-loading' }),
	                React.createElement(
	                    'span',
	                    { className: props.prefixCls + '-text' },
	                    text
	                )
	            )
	        );
	    };

	    return Mask;
	}(React.Component);

	Mask.propTypes = {
	    prefixCls: React.PropTypes.string
	};

	Mask.defaultProps = {
	    prefixCls: "kuma-uxmask",
	    text: '加载中'
	};

	exports["default"] = Mask;
	module.exports = exports['default'];

/***/ },
/* 255 */
/***/ function(module, exports) {

	"use strict";

	module.exports = {
	    isIE: function isIE(version) {
	        if (navigator.appName == "Microsoft Internet Explorer") {
	            if (!version) {
	                return true;
	            } else {
	                return navigator.appVersion.split(";")[1].replace(/[ ]/g, "") == "MSIE" + version + ".0";
	            }
	        } else {
	            return false;
	        }
	    }
	};

/***/ },
/* 256 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	/**
	 * Grid Component for uxcore
	 * @author zhouquan.yezq
	 *
	 * Copyright 2014-2015, UXCore Team, Alinw.
	 * All rights reserved.
	 */

	var SearchBar = __webpack_require__(257);
	var classnames = __webpack_require__(19);
	var Button = __webpack_require__(258);
	var React = __webpack_require__(7);
	var ReactDOM = __webpack_require__(8);

	var ActionBar = function (_React$Component) {
	    _inherits(ActionBar, _React$Component);

	    function ActionBar(props) {
	        _classCallCheck(this, ActionBar);

	        return _possibleConstructorReturn(this, _React$Component.call(this, props));
	    }

	    ActionBar.prototype.handleSearch = function handleSearch(value) {
	        this.props.onSearch(value);
	    };

	    ActionBar.prototype.renderActionBtn = function renderActionBtn(item, index) {
	        var me = this;
	        var itemProps = {
	            className: me.props.jsxprefixCls + "-item",
	            onClick: item.callback || function () {},
	            key: index
	        };
	        if (!!item.render && typeof item.render == "function") {
	            return React.createElement(
	                "div",
	                itemProps,
	                item.render(item.title)
	            );
	        } else {
	            return React.createElement(
	                Button,
	                _extends({ type: "outline", size: "medium" }, itemProps),
	                item.title
	            );
	        }
	    };

	    ActionBar.prototype.renderSearchBar = function renderSearchBar() {
	        if (this.props.showSearch) {
	            var me = this;
	            var searchBarProps = {
	                onSearch: me.handleSearch.bind(me),
	                key: 'searchbar',
	                placeholder: me.props.searchBarPlaceholder
	            };
	            return React.createElement(SearchBar, searchBarProps);
	        }
	    };

	    /**
	     *  convert ActionBar config from hash to array
	     */


	    ActionBar.prototype.getActionItem = function getActionItem(config) {
	        var items = [];
	        if (config instanceof Array) {
	            items = config;
	        } else if ((typeof config === "undefined" ? "undefined" : _typeof(config)) == "object") {
	            for (var item in config) {
	                if (config.hasOwnProperty(item)) {
	                    items.push({
	                        title: item,
	                        callback: config[item]
	                    });
	                }
	            }
	        }
	        return items;
	    };

	    ActionBar.prototype.render = function render() {
	        var _classnames;

	        var me = this,
	            _props = this.props,
	            _barConfig = _props.actionBarConfig;

	        return React.createElement(
	            "div",
	            { className: classnames((_classnames = {}, _classnames[_props.jsxprefixCls] = _props.jsxprefixCls, _classnames["fn-clear"] = true, _classnames)) },
	            me.getActionItem(_barConfig).map(function (item, index) {
	                return me.renderActionBtn(item, index);
	            }),
	            me.renderSearchBar()
	        );
	    };

	    return ActionBar;
	}(React.Component);

	;

	ActionBar.propTypes = {};

	ActionBar.defaultProps = {
	    jsxprefixCls: "kuma-uxtable-actionbar"
	};

	module.exports = ActionBar;

/***/ },
/* 257 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	/**
	 * Grid Component for uxcore
	 * @author zhouquan.yezq
	 *
	 * Copyright 2014-2015, UXCore Team, Alinw.
	 * All rights reserved.
	 */

	var React = __webpack_require__(7);
	var ReactDOM = __webpack_require__(8);

	var SearchBar = function (_React$Component) {
	    _inherits(SearchBar, _React$Component);

	    function SearchBar(props) {
	        _classCallCheck(this, SearchBar);

	        var _this = _possibleConstructorReturn(this, _React$Component.call(this, props));

	        _this.state = {
	            searchTxt: ""
	        };
	        return _this;
	    }

	    SearchBar.prototype.doSearch = function doSearch() {
	        this.props.onSearch(this.state.searchTxt);
	    };

	    SearchBar.prototype.onKeyDown = function onKeyDown(e) {
	        if (e.keyCode == 13) {
	            this.doSearch();
	        }
	    };

	    SearchBar.prototype.handleChange = function handleChange(e) {
	        this.setState({
	            searchTxt: e.target.value
	        });
	    };

	    SearchBar.prototype.render = function render() {
	        var me = this;
	        var placeholder = me.props.placeholder;

	        return React.createElement(
	            'div',
	            { className: this.props.jsxprefixCls },
	            React.createElement('input', { type: 'text', className: 'kuma-input', placeholder: placeholder, value: this.state.value, onKeyDown: this.onKeyDown.bind(this), onChange: this.handleChange.bind(this) }),
	            React.createElement('i', { className: 'kuma-icon kuma-icon-search', onClick: this.doSearch.bind(this) })
	        );
	    };

	    return SearchBar;
	}(React.Component);

	;

	SearchBar.propTypes = {};

	SearchBar.defaultProps = {
	    jsxprefixCls: "kuma-uxtable-searchbar",
	    onSearch: function onSearch() {}
	};

	module.exports = SearchBar;

/***/ },
/* 258 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _Button = __webpack_require__(259);

	var _Button2 = _interopRequireDefault(_Button);

	var _ButtonGroup = __webpack_require__(260);

	var _ButtonGroup2 = _interopRequireDefault(_ButtonGroup);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

	/**
	 * Button Component for uxcore
	 * @author
	 *
	 * Copyright 2014-2015, Uxcore Team, Alinw.
	 * All rights reserved.
	 */

	_Button2["default"].ButtonGroup = _ButtonGroup2["default"];
	module.exports = _Button2["default"];

/***/ },
/* 259 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

	var _react = __webpack_require__(7);

	var _react2 = _interopRequireDefault(_react);

	var _reactDom = __webpack_require__(8);

	var _reactDom2 = _interopRequireDefault(_reactDom);

	var _classnames = __webpack_require__(19);

	var _classnames2 = _interopRequireDefault(_classnames);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

	function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var sizeMap = {
	    small: 'sm',
	    medium: '',
	    large: 'lg'
	},
	    typeMap = {
	    primary: 'primary',
	    secondary: 'secondary',
	    outline: 'outline',
	    disabled: 'disabled'
	},
	    clsPrefix = 'kuma-button';

	var Button = function (_React$Component) {
	    _inherits(Button, _React$Component);

	    function Button(props) {
	        _classCallCheck(this, Button);

	        return _possibleConstructorReturn(this, _React$Component.call(this, props));
	    }

	    Button.prototype.render = function render() {
	        var props = this.props;
	        var type = props.type;
	        var disabled = props.disabled;
	        var className = props.className;
	        var size = props.size;
	        var children = props.children;
	        var htmlType = props.htmlType;

	        var others = _objectWithoutProperties(props, ['type', 'disabled', 'className', 'size', 'children', 'htmlType']);

	        type = disabled ? 'disabled' : type;
	        var clsObj = {};
	        if (className) {
	            clsObj[className] = true;
	        }
	        if (sizeMap[size]) {
	            clsObj[clsPrefix + '-' + sizeMap[size]] = true;
	        }
	        var classNames = (0, _classnames2["default"])(clsPrefix, clsPrefix + '-' + typeMap[type], clsObj);
	        return _react2["default"].createElement(
	            'button',
	            _extends({
	                type: htmlType,
	                className: classNames,
	                disabled: disabled
	            }, others),
	            props.children
	        );
	    };

	    return Button;
	}(_react2["default"].Component);

	Button.displayName = 'uxcore-button';
	Button.propTypes = {
	    /**
	     * @title 尺寸
	     */
	    size: _react2["default"].PropTypes.oneOf(['small', 'medium', 'large']),
	    /**
	     * @title 样式
	     */
	    style: _react2["default"].PropTypes.object,
	    /**
	    * @title 类型
	    */
	    type: _react2["default"].PropTypes.oneOf(['primary', 'secondary', 'outline', 'disabled']),
	    /**
	     * @title 是否禁用
	     * @veIgnore
	     */
	    disabled: _react2["default"].PropTypes.bool,
	    /**
	     * @title 类名
	     * @veIgnore
	     */
	    className: _react2["default"].PropTypes.string,
	    /**
	     * @title 内容
	     */
	    children: _react2["default"].PropTypes.oneOfType([_react2["default"].PropTypes.element, _react2["default"].PropTypes.string]),
	    /**
	     * @title <button> 的 type
	     * @veIgnore
	     */
	    htmlType: _react2["default"].PropTypes.oneOf(['submit', 'button', 'reset'])
	};
	Button.defaultProps = {
	    size: 'medium',
	    type: 'primary',
	    disabled: false,
	    className: '',
	    children: 'Button',
	    htmlType: 'button'
	};

	module.exports = Button;

/***/ },
/* 260 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _react = __webpack_require__(7);

	var _react2 = _interopRequireDefault(_react);

	var _reactDom = __webpack_require__(8);

	var _reactDom2 = _interopRequireDefault(_reactDom);

	var _classnames = __webpack_require__(19);

	var _classnames2 = _interopRequireDefault(_classnames);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var ButtonGroup = function (_React$Component) {
		_inherits(ButtonGroup, _React$Component);

		function ButtonGroup(props) {
			_classCallCheck(this, ButtonGroup);

			return _possibleConstructorReturn(this, _React$Component.call(this, props));
		}

		ButtonGroup.prototype.render = function render() {
			return _react2["default"].createElement(
				'div',
				{ className: 'kuma-button-group' },
				this.props.children
			);
		};

		return ButtonGroup;
	}(_react2["default"].Component);

	ButtonGroup.displayName = 'ButtonGroup';
	ButtonGroup.propTypes = {};
	ButtonGroup.defaultProps = {};

	module.exports = ButtonGroup;

/***/ },
/* 261 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	/**
	 * Pagination Component for uxcore
	 * @author 
	 *
	 * Copyright 2014-2015, Uxcore Team, Alinw.
	 * All rights reserved.
	 */

	module.exports = __webpack_require__(262);

/***/ },
/* 262 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	/**
	 * Forked from project rc-pagination
	 * @maintainer eternalsky
	 */

	var Select = __webpack_require__(165);
	var Pager = __webpack_require__(263);
	var Options = __webpack_require__(264);
	var KEYCODE = __webpack_require__(265);
	var React = __webpack_require__(7);
	var ReactDOM = __webpack_require__(8);
	var i18n = __webpack_require__(266);

	function noop() {}

	var Pagination = function (_React$Component) {
	  _inherits(Pagination, _React$Component);

	  function Pagination(props) {
	    _classCallCheck(this, Pagination);

	    var _this = _possibleConstructorReturn(this, _React$Component.call(this, props));

	    _this.state = {
	      current: props.current,
	      _current: props.current,
	      pageSize: props.pageSize
	    };

	    ['render', '_handleChange', '_handleKeyUp', '_handleKeyDown', '_changePageSize', '_isValid', '_prev', '_next', '_hasPrev', '_hasNext', '_jumpPrev', '_jumpNext'].forEach(function (method) {
	      return _this[method] = _this[method].bind(_this);
	    });
	    return _this;
	  }

	  Pagination.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
	    if (nextProps.current != this.props.current) {
	      this.setState({
	        current: nextProps.current,
	        _current: nextProps.current
	      });
	    }

	    if (nextProps.pageSize != this.props.pageSize) {
	      this.setState({
	        pageSize: nextProps.pageSize
	      });
	    }
	  };

	  Pagination.prototype.renderTotal = function renderTotal() {
	    var prefix = this.props.locale == 'zh-cn' ? "共" : "";
	    if (this.props.showTotal) {
	      return React.createElement(
	        'li',
	        { className: this.props.prefixCls + "-total" },
	        prefix + this.props.total + i18n[this.props.locale]['item']
	      );
	    }
	  };

	  Pagination.prototype.render = function render() {
	    var props = this.props;

	    var prefixCls = props.prefixCls;
	    var allPages = this._calcPage();
	    var pagerList = [];
	    var jumpPrev = null;
	    var jumpNext = null;
	    var firstPager = null;
	    var lastPager = null;

	    if (props.simple) {
	      return React.createElement(
	        'ul',
	        { className: prefixCls + ' ' + prefixCls + '-simple ' + props.className },
	        React.createElement(
	          'div',
	          { title: 'Page ' + this.state.current + ' of ' + allPages, className: prefixCls + '-simple-pager' },
	          React.createElement(
	            'span',
	            { className: prefixCls + '-current' },
	            this.state._current
	          ),
	          React.createElement(
	            'span',
	            { className: prefixCls + '-slash' },
	            '/'
	          ),
	          allPages
	        ),
	        React.createElement(
	          'li',
	          { title: 'Previous Page', onClick: this._prev, className: (this._hasPrev() ? '' : prefixCls + '-disabled ') + (prefixCls + '-prev') },
	          React.createElement('a', { className: 'kuma-icon kuma-icon-triangle-left' })
	        ),
	        React.createElement(
	          'li',
	          { title: 'Next Page', onClick: this._next, className: (this._hasNext() ? '' : prefixCls + '-disabled ') + (prefixCls + '-next') },
	          React.createElement('a', { className: 'kuma-icon kuma-icon-triangle-right' })
	        )
	      );
	    }

	    if (allPages <= 9) {
	      for (var i = 1; i <= allPages; i++) {
	        var active = this.state.current === i;
	        pagerList.push(React.createElement(Pager, { rootPrefixCls: prefixCls, onClick: this._handleChange.bind(this, i), key: i, page: i, active: active }));
	      }
	    } else {
	      jumpPrev = React.createElement(
	        'li',
	        { title: 'Previous 5 Page', key: 'prev', onClick: this._jumpPrev, className: prefixCls + '-jump-prev' },
	        React.createElement('a', null)
	      );
	      jumpNext = React.createElement(
	        'li',
	        { title: 'Next 5 Page', key: 'next', onClick: this._jumpNext, className: prefixCls + '-jump-next' },
	        React.createElement('a', null)
	      );
	      lastPager = React.createElement(Pager, { last: true, rootPrefixCls: prefixCls, onClick: this._handleChange.bind(this, allPages), key: allPages, page: allPages, active: false });
	      firstPager = React.createElement(Pager, { rootPrefixCls: prefixCls, onClick: this._handleChange.bind(this, 1), key: 1, page: 1, active: false });

	      var current = this.state.current;

	      var left = Math.max(1, current - 2);
	      var right = Math.min(current + 2, allPages);

	      if (current - 1 <= 2) {
	        right = 1 + 4;
	      }

	      if (allPages - current <= 2) {
	        left = allPages - 4;
	      }

	      for (var _i = left; _i <= right; _i++) {
	        var _active = current === _i;
	        pagerList.push(React.createElement(Pager, { rootPrefixCls: prefixCls, onClick: this._handleChange.bind(this, _i), key: _i, page: _i, active: _active }));
	      }

	      if (current - 1 >= 4) {
	        pagerList.unshift(jumpPrev);
	      }
	      if (allPages - current >= 4) {
	        pagerList.push(jumpNext);
	      }

	      if (left !== 1) {
	        pagerList.unshift(firstPager);
	      }
	      if (right !== allPages) {
	        pagerList.push(lastPager);
	      }
	    }

	    return React.createElement(
	      'ul',
	      { className: prefixCls + ' ' + props.className,
	        unselectable: 'unselectable' },
	      React.createElement(
	        'li',
	        { title: 'Previous Page', onClick: this._prev, className: (this._hasPrev() ? '' : prefixCls + '-disabled ') + (prefixCls + '-prev') },
	        React.createElement('a', { className: 'kuma-icon kuma-icon-triangle-left' })
	      ),
	      pagerList,
	      React.createElement(
	        'li',
	        { title: 'Next Page', onClick: this._next, className: (this._hasNext() ? '' : prefixCls + '-disabled ') + (prefixCls + '-next') },
	        React.createElement('a', { className: 'kuma-icon kuma-icon-triangle-right' })
	      ),
	      this.renderTotal(),
	      React.createElement(Options, { rootPrefixCls: prefixCls,
	        locale: props.locale,
	        selectComponentClass: props.selectComponentClass,
	        selectPrefixCls: props.selectPrefixCls,
	        changeSize: this.props.showSizeChanger ? this._changePageSize.bind(this) : null,
	        current: this.state.current,
	        pageSize: props.pageSize,
	        sizeOptions: props.sizeOptions,
	        quickGo: this.props.showQuickJumper ? this._handleChange.bind(this) : null })
	    );
	  };

	  // private methods

	  Pagination.prototype._calcPage = function _calcPage(p) {
	    var pageSize = p;
	    if (typeof pageSize === 'undefined') {
	      pageSize = this.state.pageSize;
	    }
	    return Math.floor((this.props.total - 1) / pageSize) + 1;
	  };

	  Pagination.prototype._isValid = function _isValid(page) {
	    return typeof page === 'number' && page >= 1 && page !== this.state.current;
	  };

	  Pagination.prototype._handleKeyDown = function _handleKeyDown(evt) {
	    if (evt.keyCode === KEYCODE.ARROW_UP || evt.keyCode === KEYCODE.ARROW_DOWN) {
	      evt.preventDefault();
	    }
	  };

	  Pagination.prototype._handleKeyUp = function _handleKeyUp(evt) {
	    var _val = evt.target.value;
	    var val = void 0;

	    if (_val === '') {
	      val = _val;
	    } else if (isNaN(Number(_val))) {
	      val = this.state._current;
	    } else {
	      val = Number(_val);
	    }

	    this.setState({
	      _current: val
	    });

	    if (evt.keyCode === KEYCODE.ENTER) {
	      this._handleChange(val);
	    } else if (evt.keyCode === KEYCODE.ARROW_UP) {
	      this._handleChange(val - 1);
	    } else if (evt.keyCode === KEYCODE.ARROW_DOWN) {
	      this._handleChange(val + 1);
	    }
	  };

	  Pagination.prototype._changePageSize = function _changePageSize(size) {
	    if (typeof size === 'number') {
	      var current = this.state.current;

	      this.setState({
	        pageSize: size
	      });

	      if (this.state.current > this._calcPage(size)) {
	        current = this._calcPage(size);
	        this.setState({
	          current: current,
	          _current: current
	        });
	      }

	      this.props.onShowSizeChange(current, size);
	    }
	  };

	  Pagination.prototype._handleChange = function _handleChange(p) {
	    var page = p;
	    var me = this;
	    if (this._isValid(page)) {
	      if (page > this._calcPage()) {
	        page = this._calcPage();
	      }
	      this.setState({
	        current: page,
	        _current: page
	      }, function () {
	        me.props.onChange(page);
	      });

	      return page;
	    }

	    return this.state.current;
	  };

	  Pagination.prototype._prev = function _prev() {
	    if (this._hasPrev()) {
	      this._handleChange(this.state.current - 1);
	    }
	  };

	  Pagination.prototype._next = function _next() {
	    if (this._hasNext()) {
	      this._handleChange(this.state.current + 1);
	    }
	  };

	  Pagination.prototype._jumpPrev = function _jumpPrev() {
	    this._handleChange(Math.max(1, this.state.current - 5));
	  };

	  Pagination.prototype._jumpNext = function _jumpNext() {
	    this._handleChange(Math.min(this._calcPage(), this.state.current + 5));
	  };

	  Pagination.prototype._hasPrev = function _hasPrev() {
	    return this.state.current > 1;
	  };

	  Pagination.prototype._hasNext = function _hasNext() {
	    return this.state.current < this._calcPage();
	  };

	  return Pagination;
	}(React.Component);

	Pagination.propTypes = {
	  current: React.PropTypes.number,
	  total: React.PropTypes.number,
	  locale: React.PropTypes.string,
	  showTotal: React.PropTypes.bool,
	  pageSize: React.PropTypes.number,
	  sizeOptions: React.PropTypes.array,
	  onChange: React.PropTypes.func,
	  showSizeChanger: React.PropTypes.bool,
	  onShowSizeChange: React.PropTypes.func,
	  selectComponentClass: React.PropTypes.func,
	  showQuickJumper: React.PropTypes.bool
	};

	Pagination.defaultProps = {
	  current: 1,
	  total: 0,
	  locale: 'zh-cn',
	  showTotal: false,
	  pageSize: 10,
	  sizeOptions: [10, 20, 30, 40],
	  onChange: noop,
	  className: '',
	  selectPrefixCls: 'kuma-select2',
	  prefixCls: 'kuma-page',
	  selectComponentClass: Select,
	  showQuickJumper: false,
	  showSizeChanger: false,
	  onShowSizeChange: noop
	};

	Pagination.displayName = 'Pagination';

	module.exports = Pagination;

/***/ },
/* 263 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var React = __webpack_require__(7);
	var ReactDOM = __webpack_require__(8);

	var Pager = function (_React$Component) {
	  _inherits(Pager, _React$Component);

	  function Pager() {
	    _classCallCheck(this, Pager);

	    return _possibleConstructorReturn(this, _React$Component.apply(this, arguments));
	  }

	  Pager.prototype.render = function render() {
	    var props = this.props;
	    var prefixCls = props.rootPrefixCls + '-item';
	    var cls = prefixCls + ' ' + prefixCls + '-' + props.page;

	    if (props.active) {
	      cls = cls + ' ' + prefixCls + '-active';
	    }

	    var title = void 0;
	    if (props.page === 1) {
	      title = 'First Page';
	    } else if (props.last) {
	      title = 'Last Page: ' + props.page;
	    } else {
	      title = 'Page ' + props.page;
	    }
	    return React.createElement(
	      'li',
	      { title: title, className: cls, onClick: props.onClick },
	      React.createElement(
	        'a',
	        null,
	        props.page
	      )
	    );
	  };

	  return Pager;
	}(React.Component);

	Pager.propTypes = {
	  page: React.PropTypes.number,
	  active: React.PropTypes.bool,
	  last: React.PropTypes.bool
	};

	module.exports = Pager;

/***/ },
/* 264 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var React = __webpack_require__(7);
	var ReactDOM = __webpack_require__(8);
	var KEYCODE = __webpack_require__(265);
	var i18n = __webpack_require__(266);

	var Options = function (_React$Component) {
	  _inherits(Options, _React$Component);

	  function Options(props) {
	    _classCallCheck(this, Options);

	    var _this = _possibleConstructorReturn(this, _React$Component.call(this, props));

	    _this.state = {
	      current: props.current,
	      _current: props.current
	    };

	    ['_handleChange', '_changeSize', '_go'].forEach(function (method) {
	      return _this[method] = _this[method].bind(_this);
	    });
	    return _this;
	  }

	  Options.prototype.render = function render() {
	    var _this2 = this;

	    var props = this.props;
	    var state = this.state;
	    var prefixCls = props.rootPrefixCls + '-options';
	    var sizeOptions = props.sizeOptions;
	    var pageSize = props.pageSize;
	    var changeSize = props.changeSize;
	    var quickGo = props.quickGo;
	    var Select = props.selectComponentClass;
	    var changeSelect = null;
	    var goInput = null;

	    if (!(changeSize || quickGo)) {
	      return null;
	    }

	    if (changeSize && Select) {
	      (function () {
	        var Option = Select.Option;
	        changeSelect = React.createElement(
	          Select,
	          {
	            prefixCls: props.selectPrefixCls, showSearch: false,
	            className: prefixCls + '-size-changer',
	            optionLabelProp: 'children',
	            dropdownClassName: prefixCls + '-size-changer-dropdown',
	            defaultValue: sizeOptions.indexOf(pageSize) == -1 ? sizeOptions[0] + "" : pageSize + "",
	            onChange: _this2._changeSize },
	          sizeOptions.map(function (option, index) {
	            return React.createElement(
	              Option,
	              { key: option, value: option + "" },
	              option + i18n[props.locale]['items_per_page']
	            );
	          })
	        );
	      })();
	    }

	    if (quickGo) {
	      goInput = React.createElement(
	        'div',
	        { title: 'Quick jump to page', className: prefixCls + '-quick-jumper' },
	        i18n[props.locale]['jump_to'],
	        React.createElement('input', { type: 'text', value: state._current, onChange: this._handleChange.bind(this), onKeyUp: this._go.bind(this) }),
	        i18n[props.locale]['page']
	      );
	    }

	    return React.createElement(
	      'div',
	      { className: '' + prefixCls },
	      changeSelect,
	      goInput
	    );
	  };

	  Options.prototype._changeSize = function _changeSize(value) {
	    this.props.changeSize(Number(value));
	  };

	  Options.prototype._handleChange = function _handleChange(evt) {
	    var _val = evt.target.value;

	    this.setState({
	      _current: _val
	    });
	  };

	  Options.prototype._go = function _go(e) {
	    var _val = e.target.value;
	    if (_val === '') {
	      return;
	    }
	    var val = Number(this.state._current);
	    if (isNaN(val)) {
	      val = this.state.current;
	    }
	    if (e.keyCode === KEYCODE.ENTER) {
	      var c = this.props.quickGo(val);
	      this.setState({
	        _current: c,
	        current: c
	      });
	    }
	  };

	  return Options;
	}(React.Component);

	Options.propTypes = {
	  changeSize: React.PropTypes.func,
	  quickGo: React.PropTypes.func,
	  selectComponentClass: React.PropTypes.func,
	  current: React.PropTypes.number
	};

	module.exports = Options;

/***/ },
/* 265 */
/***/ function(module, exports) {

	"use strict";

	module.exports = {
	  ZERO: 48,
	  NINE: 57,

	  NUMPAD_ZERO: 96,
	  NUMPAD_NINE: 105,

	  BACKSPACE: 8,
	  DELETE: 46,
	  ENTER: 13,

	  ARROW_UP: 38,
	  ARROW_DOWN: 40
	};

/***/ },
/* 266 */
/***/ function(module, exports) {

	'use strict';

	var locale = {
	    "en-us": {
	        items_per_page: '/page',
	        jump_to: 'Goto',
	        page: '',

	        // Pagination.js
	        item: ' entries'
	    },
	    "zh-cn": {
	        // Options.js
	        items_per_page: '条/页',
	        jump_to: '跳至',
	        page: '页',

	        // Pagination.js
	        item: '条'
	    }
	};
	locale['en'] = locale['en-us'];

	module.exports = locale;

/***/ },
/* 267 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	/**
	 * Form Component for uxcore
	 * @author eternalsky
	 *
	 * Copyright 2014-2015, Uxcore Team, Alinw.
	 * All rights reserved.
	 */
	var Form = __webpack_require__(268);

	// 以 Form 插件的形式给出
	Form.TextAreaFormField = __webpack_require__(286);
	Form.InputFormField = __webpack_require__(289);
	Form.RadioGroupFormField = __webpack_require__(292);
	Form.SelectFormField = __webpack_require__(296);
	Form.NumberInputFormField = __webpack_require__(370);
	Form.DateFormField = __webpack_require__(374);
	Form.CheckboxGroupFormField = __webpack_require__(528);
	Form.CascadeSelectFormField = __webpack_require__(532);
	Form.OtherFormField = __webpack_require__(533);
	Form.ButtonGroupFormField = __webpack_require__(535);
	Form.EditorFormField = __webpack_require__(536);
	Form.SearchFormField = __webpack_require__(541);

	module.exports = Form;

/***/ },
/* 268 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	/**
	 * Form Component for uxcore
	 * @author eternalsky
	 *
	 * Copyright 2014-2015, Uxcore Team, Alinw.
	 * All rights reserved.
	 */

	var React = __webpack_require__(7);
	var ReactDOM = __webpack_require__(8);
	var FormRow = __webpack_require__(269);
	var FormRowTitle = __webpack_require__(271);
	var FormField = __webpack_require__(274);

	var Constants = __webpack_require__(272);
	var Validators = __webpack_require__(280);
	var KeyCode = __webpack_require__(283);

	var classnames = __webpack_require__(19);
	var assign = __webpack_require__(284);
	var deepcopy = __webpack_require__(285);
	var deepEqual = __webpack_require__(277);

	var Form = function (_React$Component) {
	    _inherits(Form, _React$Component);

	    function Form(props) {
	        _classCallCheck(this, Form);

	        var _this = _possibleConstructorReturn(this, _React$Component.call(this, props));

	        _this.fields = {};
	        _this.errors = {};
	        _this.data = {};
	        _this.state = {};
	        return _this;
	    }

	    Form.prototype.componentDidMount = function componentDidMount() {
	        var me = this;
	    };

	    Form.prototype._copy = function _copy(a) {
	        return deepcopy(a);
	    };

	    Form.prototype.attachFormField = function attachFormField(field) {
	        var name = field.getName();
	        if (!name) {
	            console.warn("Each field needs a name to identify itself");
	        } else {
	            this.fields[name] = field;
	        }
	    };

	    Form.prototype.detachFormField = function detachFormField(field) {
	        var name = field.getName();
	        delete this.fields[name];
	        delete this.data[name];
	    };

	    Form.prototype.handleDataChange = function handleDataChange(field, fieldData, fromMount) {
	        var me = this;
	        me.data[field.props.jsxname] = fieldData.value;
	        if (!fromMount) {
	            me.props.jsxonChange(me._copy(me.data), field.props.jsxname, fieldData.pass);
	        }
	    };

	    Form.prototype.getValues = function getValues(force) {
	        var me = this;
	        var _flag = me.doValidate(force);
	        return {
	            values: me._copy(me.data),
	            pass: _flag
	        };
	    };

	    Form.prototype.resetValues = function resetValues() {
	        var me = this;
	        var keys = Object.keys(me.fields);
	        var data = me.props.jsxvalues || me.props.passedData || {};
	        for (var i = 0; i < keys.length; i++) {
	            me.fields[keys[i]] && me.fields[keys[i]].handleDataChange(data[keys[i]] == undefined ? null : data[keys[i]], true);
	        }
	    };

	    /*
	     * set Form values manually
	     */

	    Form.prototype.setValues = function setValues(data) {
	        if ((typeof data === 'undefined' ? 'undefined' : _typeof(data)) != 'object') return;
	        var me = this;
	        var savedData = me.data;
	        var keys = Object.keys(data);
	        for (var i = 0; i < keys.length; i++) {
	            if (!deepEqual(data[keys[i]], savedData[keys[i]])) {
	                me.fields[keys[i]].handleDataChange(data[keys[i]] == undefined ? null : data[keys[i]], true);
	            }
	        }
	    };

	    Form.prototype.doValidate = function doValidate(force) {
	        var me = this;
	        var pass = true;
	        var keys = Object.keys(me.fields);
	        for (var i = 0; i < keys.length; i++) {
	            var itemPass = me.fields[keys[i]].doValidate(force);
	            me.errors[keys[i]] = !itemPass;
	            if (!itemPass) {
	                pass = false;
	            }
	        }
	        return pass;
	    };

	    Form.prototype.isDirty = function isDirty() {
	        return !this.doValidate();
	    };

	    /*
	     * 统一数据流，所有的 props，通过 Form -> FormRow -> FormField 向下传递，如果有的
	     * 子元素是 FormField，则自动在他的外面包一层 FormRow。
	     * @param {React Elements Array} children this.props.children
	     */

	    Form.prototype._processChild = function _processChild(children) {
	        var length = React.Children.count(children);
	        var elements = [];
	        if (length == 0) {
	            console.warn("FORM: You must pass children to the form component");
	            return false;
	        }

	        React.Children.forEach(children, function (child, index) {
	            // 如果是自己添加的 DOM 直接抛弃
	            if (typeof child.type == 'function') {
	                var displayName = child.type.displayName;
	                if (displayName === 'EngineNode') {
	                    displayName = child.props._componentName;
	                }
	                if (/FormField/.test(displayName)) {
	                    elements.push(React.createElement(
	                        FormRow,
	                        null,
	                        child
	                    ));
	                } else if (/FormRow/.test(displayName)) {
	                    elements.push(child);
	                }
	            }
	        });

	        return elements;
	    };

	    Form.prototype.render = function render() {
	        var _classnames;

	        var me = this;
	        var elements = me._processChild(me.props.children);

	        return React.createElement(
	            'div',
	            { className: classnames((_classnames = {}, _classnames[me.props.jsxprefixCls] = true, _classnames[me.props.className] = !!me.props.className, _classnames["kuma-uxform-edit-mode"] = me.props.jsxmode == Constants.MODE.EDIT, _classnames["kuma-uxform-view-mode"] = me.props.jsxmode == Constants.MODE.VIEW, _classnames)) },
	            !!elements && elements.map(function (child, index) {
	                return React.cloneElement(child, {
	                    mode: me.props.jsxmode,
	                    instantValidate: me.props.instantValidate,
	                    data: deepcopy(me.props.jsxvalues || me.props.passedData || {}),
	                    key: index,
	                    attachFormField: me.attachFormField.bind(me),
	                    detachFormField: me.detachFormField.bind(me),
	                    handleDataChange: me.handleDataChange.bind(me),
	                    getValues: me.getValues.bind(me),
	                    resetValues: me.resetValues.bind(me)
	                });
	            })
	        );
	    };

	    return Form;
	}(React.Component);

	// 以 Form 的插件的形式给出


	Form.FormRow = FormRow;
	Form.FormRowTitle = FormRowTitle;
	Form.FormField = FormField;

	// Form.MentionFormField = MentionFormField;
	Form.Constants = Constants;
	Form.Validators = Validators;
	Form.KeyCode = KeyCode;

	Form.defaultProps = {
	    jsxprefixCls: "kuma-uxform",
	    jsxmode: Constants.MODE.EDIT,
	    instantValidate: true,
	    jsxonChange: function jsxonChange() {}
	};

	// http://facebook.github.io/react/docs/reusable-components.html
	Form.propTypes = {
	    /**
	     * @title: 类名前缀
	     * @veIgnore
	     */
	    jsxprefixCls: React.PropTypes.string,
	    /**
	     * @title CSS类名
	     * @veIgnore
	     */
	    className: React.PropTypes.string,
	    /**
	     * @title 显示模式
	     */
	    jsxmode: React.PropTypes.string,
	    /**
	     * @title 默认值
	     */
	    jsxvalues: React.PropTypes.object,
	    /**
	     * @title 是否即时校验
	     * @veFieldStyle block
	     */
	    instantValidate: React.PropTypes.bool,
	    /**
	     * @title 表单域改变时的回调
	     */
	    jsxonChange: React.PropTypes.func
	};

	Form.displayName = "Form";

	module.exports = Form;

/***/ },
/* 269 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	/**
	 * FormRow Component for uxcore
	 * @author eternalsky
	 *
	 * Copyright 2014-2015, Uxcore Team, Alinw.
	 * All rights reserved.
	 */

	module.exports = __webpack_require__(270);

/***/ },
/* 270 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var React = __webpack_require__(7);
	var ReactDOM = __webpack_require__(8);
	var classnames = __webpack_require__(19);

	var FormRow = function (_React$Component) {
	    _inherits(FormRow, _React$Component);

	    function FormRow(props) {
	        _classCallCheck(this, FormRow);

	        var _this = _possibleConstructorReturn(this, _React$Component.call(this, props));

	        _this.totalFlex = 0;
	        return _this;
	    }

	    FormRow.prototype._processChild = function _processChild(children) {
	        var me = this;
	        me.totalFlex = 0;
	        var length = React.Children.count(children);
	        var elements = [];
	        if (length == 0) {
	            console.warn("FORM: You must pass children to the form component");
	            return false;
	        }
	        React.Children.forEach(children, function (child, index) {
	            // 如果是自己添加的 DOM 直接抛弃
	            if (typeof child.type == 'function') {
	                var displayName = child.type.displayName;
	                if (displayName === 'EngineNode') {
	                    displayName = child.props._componentName;
	                }
	                if (/FormField/.test(displayName)) {
	                    if (child.props.jsxshow) {
	                        me.totalFlex += child.props.jsxflex || 1;
	                    }
	                    elements.push(child);
	                }
	            }
	        });

	        return elements;
	    };

	    FormRow.prototype.render = function render() {
	        var _classnames;

	        var me = this;
	        var elements = me._processChild(me.props.children);
	        var totalFlex = me.props.totalFlex || me.totalFlex;
	        return React.createElement(
	            'div',
	            { className: classnames((_classnames = {}, _classnames[me.props.jsxprefixCls] = true, _classnames[me.props.className] = !!me.props.className, _classnames)) },
	            !!elements && elements.map(function (child, index) {
	                var value = me.props.data[child.props.jsxname];
	                return React.cloneElement(child, {
	                    mode: me.props.mode,
	                    jsxinstant: me.props.instantValidate,
	                    value: value,
	                    key: child.props.jsxname || index,
	                    totalFlex: totalFlex,
	                    style: { width: child.props.jsxflex / me.totalFlex * 100 + '%' },
	                    attachFormField: me.props.attachFormField,
	                    detachFormField: me.props.detachFormField,
	                    handleDataChange: me.props.handleDataChange,
	                    getValues: me.props.getValues,
	                    resetValues: me.props.resetValues
	                });

	                return child;
	            })
	        );
	    };

	    return FormRow;
	}(React.Component);

	FormRow.defaultProps = {
	    jsxprefixCls: "kuma-uxform-row"
	};
	FormRow.propTypes = {
	    /**
	     * @title 类名前缀
	     * @veIgnore
	     */
	    jsxprefixCls: React.PropTypes.string,
	    /**
	     * @title 弹性比例总和
	     */
	    totalFlex: React.PropTypes.number,
	    /**
	     * @title CSS类名
	     * @veIgnore
	     */
	    className: React.PropTypes.string
	};
	FormRow.displayName = "FormRow";

	module.exports = FormRow;

/***/ },
/* 271 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	/**
	 * @author: zhouquan.yezq
	 * @time: 8/7 2015
	 * Form Row Title
	 */
	var React = __webpack_require__(7);
	var ReactDOM = __webpack_require__(8);
	var Constants = __webpack_require__(272);
	var classnames = __webpack_require__(19);

	var FormRowTitle = function (_React$Component) {
	    _inherits(FormRowTitle, _React$Component);

	    function FormRowTitle(props) {
	        _classCallCheck(this, FormRowTitle);

	        return _possibleConstructorReturn(this, _React$Component.call(this, props));
	    }

	    FormRowTitle.prototype.render = function render() {
	        var _classnames;

	        var me = this;
	        var length = React.Children.count(me.props.children);
	        return React.createElement(
	            'div',
	            { className: classnames((_classnames = {}, _classnames[me.props.jsxprefixCls] = true, _classnames[me.props.className] = !!me.props.className, _classnames)) },
	            me.props.jsxtitle,
	            !!length && React.Children.map(me.props.children, function (item) {
	                return item;
	            })
	        );
	    };

	    return FormRowTitle;
	}(React.Component);

	;

	FormRowTitle.propTypes = {
	    jsxprefixCls: React.PropTypes.string,
	    jsxtitle: React.PropTypes.string
	};

	FormRowTitle.defaultProps = {
	    jsxprefixCls: "kuma-uxform-row-title",
	    jsxtitle: ""
	};

	FormRowTitle.displayName = "FormRowTitle";

	module.exports = FormRowTitle;

/***/ },
/* 272 */
[542, 273],
/* 273 */
6,
/* 274 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	/**
	 * FormField Component for uxcore
	 * @author eternalsky
	 *
	 * Copyright 2014-2015, Uxcore Team, Alinw.
	 * All rights reserved.
	 */

	module.exports = __webpack_require__(275);

/***/ },
/* 275 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var React = __webpack_require__(7);
	var ReactDOM = __webpack_require__(8);
	var Constants = __webpack_require__(272);
	var classnames = __webpack_require__(19);
	var assign = __webpack_require__(276);
	var deepequal = __webpack_require__(277);

	var FormField = function (_React$Component) {
	    _inherits(FormField, _React$Component);

	    function FormField(props) {
	        _classCallCheck(this, FormField);

	        var _this = _possibleConstructorReturn(this, _React$Component.call(this, props));

	        _this.state = {
	            value: props.value,
	            formatValue: _this.formatValue(props.value),
	            error: false,
	            errMsg: ''
	        };
	        return _this;
	    }

	    FormField.prototype.componentDidMount = function componentDidMount() {
	        var me = this;
	        if (!me.props.standalone) {
	            me.props.attachFormField(me);
	            me.props.handleDataChange(me, {
	                value: me.props.value,
	                pass: true
	            }, true);
	        }
	    };

	    FormField.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
	        var me = this;
	        if (!me._isEqual(nextProps.value, me.props.value)) {
	            me.handleDataChange(nextProps.value, true);
	        }
	    };

	    FormField.prototype._isEqual = function _isEqual(a, b) {
	        return deepequal(a, b);
	    };

	    FormField.prototype.componentWillUnmount = function componentWillUnmount() {
	        var me = this;
	        if (!me.props.standalone) {
	            this.props.detachFormField(this);
	        }
	    };

	    FormField.prototype.getName = function getName() {
	        return this.props.jsxname;
	    };

	    /*
	     * Fired when field value changes，update form's state and then trigger re-render.
	     * @param fromReset {boolean} if handleDataChange is invoked by form's resetValues,
	     * doValidate should not be invoked.
	     */

	    FormField.prototype.handleDataChange = function handleDataChange(value, fromReset) {
	        var me = this;
	        me.setState({
	            value: value,
	            formatValue: me.formatValue(value),
	            error: !!fromReset ? false : me.state.error,
	            /*
	             * why set state fromReset? some field like editor cannot be reset in the common way
	             * so set this state to tell the field that you need to reset by yourself.
	             */
	            fromReset: !!fromReset
	        }, function () {
	            var pass = true;
	            // validateOnBlur only support InputFormField & TextAraeFormField now
	            if (!fromReset && !me.props.standalone && !me.props.validateOnBlur) {
	                pass = me.doValidate();
	            }
	            !!me.props.handleDataChange && me.props.handleDataChange(me, {
	                value: value,
	                pass: pass
	            });
	        });
	    };

	    /**
	     * @return {boolean} if validate pass, return true, or, return false
	     * if no rule, it means validate pass.
	     */

	    FormField.prototype.doValidate = function doValidate(force) {
	        var me = this;
	        var instant = true;
	        if ('instantValidate' in me.props) {
	            instant = me.props.instantValidate;
	        } else {
	            instant = me.props.jsxinstant;
	        }
	        // `force` has the top priority, `undefined` is not equal to `false`
	        // `instant` has the sceond priority here
	        // eternalsky@2016.03.15
	        if (force === true || force !== false && instant) {
	            if (me.props.jsxrules) {
	                var error = me.isDirty();
	                me.setState({ error: error.isDirty, errMsg: error.errMsg });
	                return !error.isDirty;
	            } else {
	                return true;
	            }
	        } else {
	            return true;
	        }
	    };

	    /*
	     * rule can be an object, containing errMsg & validator,
	     * and rule can also be an array containing such objects.
	     * this func will check them one by one, and return false
	     * unless all rules pass
	     */

	    FormField.prototype.isDirty = function isDirty() {
	        var me = this;
	        var rules = me.props.jsxrules;
	        var isDirty = false;
	        var errMsg = "";
	        if ((typeof rules === 'undefined' ? 'undefined' : _typeof(rules)) == "object" && !Array.isArray(rules)) {
	            isDirty = !rules.validator(me.state.value);
	            errMsg = rules.errMsg;
	        } else if (Array.isArray(rules)) {
	            for (var i = 0; i < rules.length; i++) {
	                isDirty = !rules[i].validator(me.state.value);
	                if (isDirty) {
	                    errMsg = rules[i].errMsg;
	                    break;
	                }
	            }
	        }
	        return {
	            isDirty: isDirty,
	            errMsg: errMsg
	        };
	    };

	    FormField.prototype.renderTips = function renderTips() {
	        var me = this;
	        var mode = me.props.jsxmode || me.props.mode;
	        if (mode != Constants.MODE.EDIT) return;
	        if (me.props.standalone && me.props.message && me.props.message.type == "tip") {
	            return React.createElement(
	                'li',
	                { className: 'kuma-uxform-tips' },
	                React.createElement('i', { className: 'kuma-icon kuma-icon-information' }),
	                me.props.message.message
	            );
	        }
	        if (!!this.props.jsxtips && !me.state.error) {
	            return React.createElement(
	                'li',
	                { className: 'kuma-uxform-tips' },
	                React.createElement('i', { className: 'kuma-icon kuma-icon-information' }),
	                this.props.jsxtips
	            );
	        }
	    };

	    /*
	     * You should rewrite this method，when you need to format the value as you concern.
	     */

	    FormField.prototype.formatValue = function formatValue(value) {
	        return value;
	    };

	    /*
	     * You should rewrite this method, when you are developing a new type of form field.
	     */

	    FormField.prototype.renderField = function renderField() {};

	    FormField.prototype.renderErrorMsg = function renderErrorMsg() {
	        var me = this;
	        var mode = me.props.jsxmode || me.props.mode;
	        if (mode != Constants.MODE.EDIT) return;
	        if (me.props.standalone && me.props.message && me.props.message.type == "error") {
	            return React.createElement(
	                'li',
	                { className: 'kuma-uxform-errormsg' },
	                React.createElement('i', { className: 'kuma-icon kuma-icon-error' }),
	                me.props.message.message
	            );
	        }
	        if (!!me.state.error) {
	            return React.createElement(
	                'li',
	                { className: 'kuma-uxform-errormsg' },
	                React.createElement('i', { className: 'kuma-icon kuma-icon-error' }),
	                me.state.errMsg
	            );
	        }
	    };

	    FormField.prototype.renderLabel = function renderLabel() {
	        var me = this;
	        var mode = me.props.jsxmode || me.props.mode;
	        var align = me.props.verticalAlign || me.props.jsxVerticalAlign; // jsxVerticalAlign is an internal varible.
	        if (me.props.jsxshowLabel) {
	            return React.createElement(
	                'label',
	                { className: classnames({
	                        "kuma-label": true,
	                        "vertical-align": align
	                    }) },
	                React.createElement(
	                    'span',
	                    { className: 'required' },
	                    me.props.required && mode == Constants.MODE.EDIT ? "* " : ""
	                ),
	                React.createElement('span', { className: 'label-content', dangerouslySetInnerHTML: { __html: me.props.jsxlabel } })
	            );
	        }
	    };

	    FormField.prototype.addSpecificClass = function addSpecificClass(classname) {
	        return this.props.jsxprefixCls;
	    };

	    FormField.prototype.render = function render() {
	        var _classnames;

	        var me = this;
	        var specificCls = me.addSpecificClass();
	        var mode = me.props.jsxmode || me.props.mode;
	        var style = {
	            width: me.props.jsxflex / me.props.totalFlex * 100 + '%'
	        };
	        return React.createElement(
	            'div',
	            { className: classnames((_classnames = {}, _classnames[specificCls] = true, _classnames[me.props.className] = !!me.props.className, _classnames)), style: assign({}, style, {
	                    display: me.props.jsxshow ? "table" : "none"
	                }) },
	            me.renderLabel(),
	            React.createElement(
	                'ul',
	                { className: classnames({
	                        "kuma-uxform-field-content": true,
	                        "view-mode": mode == Constants.MODE.VIEW,
	                        "edit-mode": mode == Constants.MODE.EDIT,
	                        "has-error": !!me.state.error
	                    }) },
	                React.createElement(
	                    'li',
	                    { className: 'kuma-uxform-field-core' },
	                    me.renderField()
	                ),
	                me.renderTips(),
	                me.renderErrorMsg()
	            )
	        );
	    };

	    return FormField;
	}(React.Component);

	;

	FormField.propTypes = {
	    instantValidate: React.PropTypes.bool,
	    jsxshow: React.PropTypes.bool,
	    jsxmode: React.PropTypes.string,
	    jsxshowLabel: React.PropTypes.bool,
	    jsxprefixCls: React.PropTypes.string,
	    jsxflex: React.PropTypes.number,
	    jsxname: React.PropTypes.string.isRequired,
	    jsxplaceholder: React.PropTypes.string,
	    jsxlabel: React.PropTypes.string,
	    jsxtips: React.PropTypes.string,
	    jsxrules: React.PropTypes.oneOfType([React.PropTypes.object, React.PropTypes.array]),
	    totalFlex: React.PropTypes.number,
	    standalone: React.PropTypes.bool,
	    required: React.PropTypes.bool
	};

	FormField.defaultProps = {
	    jsxshow: true,
	    jsxshowLabel: true,
	    jsxprefixCls: "kuma-uxform-field",
	    jsxflex: 1,
	    jsxname: "",
	    jsxplaceholder: "",
	    jsxlabel: "",
	    jsxtips: "",
	    standalone: false,
	    mode: Constants.MODE.EDIT,
	    required: false
	};

	FormField.displayName = "FormField";

	module.exports = FormField;

/***/ },
/* 276 */
/***/ function(module, exports) {

	/* eslint-disable no-unused-vars */
	'use strict';
	var hasOwnProperty = Object.prototype.hasOwnProperty;
	var propIsEnumerable = Object.prototype.propertyIsEnumerable;

	function toObject(val) {
		if (val === null || val === undefined) {
			throw new TypeError('Object.assign cannot be called with null or undefined');
		}

		return Object(val);
	}

	module.exports = Object.assign || function (target, source) {
		var from;
		var to = toObject(target);
		var symbols;

		for (var s = 1; s < arguments.length; s++) {
			from = Object(arguments[s]);

			for (var key in from) {
				if (hasOwnProperty.call(from, key)) {
					to[key] = from[key];
				}
			}

			if (Object.getOwnPropertySymbols) {
				symbols = Object.getOwnPropertySymbols(from);
				for (var i = 0; i < symbols.length; i++) {
					if (propIsEnumerable.call(from, symbols[i])) {
						to[symbols[i]] = from[symbols[i]];
					}
				}
			}
		}

		return to;
	};


/***/ },
/* 277 */
[594, 278, 279],
/* 278 */
252,
/* 279 */
253,
/* 280 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	/**
	 * Created by xy on 15/4/16.
	 */

	module.exports = __webpack_require__(281);

/***/ },
/* 281 */
[595, 282],
/* 282 */
/***/ function(module, exports) {

	'use strict';

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	/**
	 * Created by xy on 15/4/16.
	 */

	var Validator = {};

	var PATTERN = {
	    EMAIL: /^([a-z0-9_\.-]+)@([\da-z\.-]+)\.([a-z\.]{2,6})$/,
	    URL: /^https?:\/\/(?!\-)(?:[a-zA-Z\d\-]{0,62}[a-zA-Z\d]\.){1,126}(?!\d+)[a-zA-Z\d]{1,63}/,
	    HEX: /^#?([a-f0-9]{6}|[a-f0-9]{3})$/i,
	    NUM: /^((-?\d+\.\d+)|(-?\d+)|(-?\.\d+))$/,
	    IDCARD: /(^\d{15}$)|(^\d{17}([0-9]|X)$)/i,
	    CNMOBILE: /^(0|86|17951)?(13[0-9]|15[012356789]|17[0678]|18[0-9]|14[57])[0-9]{8}$/
	};

	Validator.isNotEmpty = function (value) {
	    // empty means empty string, empty array, empty object & null & undefined
	    if (typeof value == "string") {
	        return value.length !== 0;
	    } else if ((typeof value === 'undefined' ? 'undefined' : _typeof(value)) == 'object') {
	        if (value instanceof Array) {
	            return value.length !== 0;
	        } else {
	            var i = 0;
	            for (var key in value) {
	                i++;
	            }
	            return !!i;
	        }
	    } else if (typeof value == 'number') {
	        return true;
	    } else {
	        return !!value;
	    }
	};

	Validator.isNum = function (value) {
	    return PATTERN.NUM.test(value);
	};

	Validator.isInt = function (value) {
	    return Validator.isNum(value) && parseInt(value) == value;
	};

	Validator.isDecimal = function (value) {
	    return Validator.isNum(value) && !Validator.isInt(value);
	};

	Validator.isArray = function (value) {
	    return Array.isArray(value);
	};

	Validator.isRegExp = function (value) {
	    if (value instanceof RegExp) {
	        return true;
	    }
	    try {
	        return !!new RegExp(value);
	    } catch (e) {
	        return false;
	    }
	};

	Validator.isObject = function (value) {
	    return (typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object' && !Validator.isArray(value);
	};

	Validator.isFunc = function (value) {
	    return typeof value === 'function';
	};

	Validator.isEmail = function (value) {
	    return typeof value === 'string' && PATTERN.EMAIL.test(value);
	};

	Validator.isUrl = function (value) {
	    return typeof value === 'string' && PATTERN.URL.test(value);
	};

	Validator.isHex = function (value) {
	    return typeof value === 'string' && PATTERN.HEX.test(value);
	};

	Validator.isIdCard = function (value) {
	    return typeof value === 'string' && PATTERN.IDCARD.test(value);
	};

	Validator.isCNMobile = function (value) {
	    return typeof value === 'string' && PATTERN.CNMOBILE.test(value);
	};
	module.exports = Validator;

/***/ },
/* 283 */
/***/ function(module, exports) {

	"use strict";

	module.exports = {
	  /*
	   * Enter
	   */
	  Enter: 13
	};

/***/ },
/* 284 */
9,
/* 285 */
242,
/* 286 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	/**
	 * TextareaFormField Component for uxcore
	 * @author eternalsky
	 *
	 * Copyright 2014-2015, Uxcore Team, Alinw.
	 * All rights reserved.
	 */

	module.exports = __webpack_require__(287);

/***/ },
/* 287 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	/**
	 * TextareaFormField Component for uxcore
	 * @author eternalsky
	 *
	 * Copyright 2015-2016, Uxcore Team, Alinw.
	 * All rights reserved.
	 */

	var FormField = __webpack_require__(274);
	var Constants = __webpack_require__(272);
	var assign = __webpack_require__(284);
	var autosize = __webpack_require__(288);

	var TextAreaFormField = function (_FormField) {
	    _inherits(TextAreaFormField, _FormField);

	    function TextAreaFormField(props) {
	        _classCallCheck(this, TextAreaFormField);

	        return _possibleConstructorReturn(this, _FormField.call(this, props));
	    }

	    TextAreaFormField.prototype.componentDidMount = function componentDidMount() {
	        var me = this;
	        if (!me.props.standalone) {
	            me.props.attachFormField(me);
	            me.props.handleDataChange(me, {
	                value: me.props.value,
	                pass: true
	            }, true);
	        }
	        me.props.autosize && autosize(me.refs.root);
	    };

	    TextAreaFormField.prototype.componentWillUnmount = function componentWillUnmount() {
	        var me = this;
	        if (!me.props.standalone) {
	            this.props.detachFormField(this);
	        }
	        me.props.autosize && autosize.destroy(me.refs.root);
	    };

	    TextAreaFormField.prototype.componentDidUpdate = function componentDidUpdate(prevProps, prevState) {
	        var me = this;
	        var mode = me.props.jsxmode || me.props.mode;
	        var prevMode = prevProps.jsxmode || prevProps.mode;
	        if (prevMode == Constants.MODE.VIEW && mode == Constants.MODE.EDIT) {
	            autosize(me.refs.root);
	        } else if (prevMode == Constants.MODE.EDIT && mode == Constants.MODE.MODE) {
	            autosize.destroy(me.refs.root);
	        }
	    };

	    TextAreaFormField.prototype.handleChange = function handleChange(e) {
	        var me = this;
	        var autoTrim = me.props.autoTrim;

	        var value = e.currentTarget.value;
	        if (autoTrim) {
	            value = me.trim(value);
	        }
	        me.handleDataChange(value);
	    };

	    TextAreaFormField.prototype.trim = function trim(str) {
	        return str.replace(/(^\s+|\s+$)/g, "");
	    };

	    TextAreaFormField.prototype.addSpecificClass = function addSpecificClass() {
	        var me = this;
	        if (me.props.jsxprefixCls == "kuma-uxform-field") {
	            return me.props.jsxprefixCls + " kuma-textarea-uxform-field";
	        } else {
	            return me.props.jsxprefixCls;
	        }
	    };

	    TextAreaFormField.prototype.handleFocus = function handleFocus(e) {
	        this.props.onFocus(e);
	    };

	    TextAreaFormField.prototype.handleBlur = function handleBlur(e) {
	        var me = this;
	        var pass = true;
	        if (me.props.validateOnBlur) {
	            pass = me.doValidate();
	        }
	        me.props.onBlur(e, pass);
	    };

	    TextAreaFormField.prototype.handleKeyDown = function handleKeyDown(e) {
	        var me = this;
	        me.props.onKeyDown(e);
	    };

	    TextAreaFormField.prototype.renderField = function renderField() {
	        var me = this;
	        var mode = me.props.jsxmode || me.props.mode;
	        if (mode == Constants.MODE.EDIT) {
	            return React.createElement('textarea', {
	                disabled: me.props.jsxdisabled,
	                placeholder: me.props.jsxplaceholder,
	                className: 'kuma-textarea',
	                ref: 'root',
	                value: me.state.value || "",
	                onChange: me.handleChange.bind(me),
	                onFocus: me.handleFocus.bind(me),
	                onBlur: me.handleBlur.bind(me),
	                onKeyDown: me.handleKeyDown.bind(me) });
	        } else if (mode == Constants.MODE.VIEW) {
	            return React.createElement(
	                'span',
	                null,
	                me.state.value
	            );
	        }
	    };

	    return TextAreaFormField;
	}(FormField);

	TextAreaFormField.displayName = "TextAreaFormField";

	TextAreaFormField.propTypes = assign({}, FormField.propTypes, {
	    onBlur: React.PropTypes.func,
	    onFocus: React.PropTypes.func,
	    onKeyDown: React.PropTypes.func,
	    validateOnBlur: React.PropTypes.bool,
	    autoTrim: React.PropTypes.bool,
	    autosize: React.PropTypes.bool
	});

	TextAreaFormField.defaultProps = assign({}, FormField.defaultProps, {
	    onBlur: function onBlur() {},
	    onFocus: function onFocus() {},
	    onKeyDown: function onKeyDown() {},
	    validateOnBlur: false,
	    autosize: true
	});

	module.exports = TextAreaFormField;

/***/ },
/* 288 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
		Autosize 3.0.15
		license: MIT
		http://www.jacklmoore.com/autosize
	*/
	(function (global, factory) {
		if (true) {
			!(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports, module], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
		} else if (typeof exports !== 'undefined' && typeof module !== 'undefined') {
			factory(exports, module);
		} else {
			var mod = {
				exports: {}
			};
			factory(mod.exports, mod);
			global.autosize = mod.exports;
		}
	})(this, function (exports, module) {
		'use strict';

		var set = typeof Set === 'function' ? new Set() : (function () {
			var list = [];

			return {
				has: function has(key) {
					return Boolean(list.indexOf(key) > -1);
				},
				add: function add(key) {
					list.push(key);
				},
				'delete': function _delete(key) {
					list.splice(list.indexOf(key), 1);
				} };
		})();

		var createEvent = function createEvent(name) {
			return new Event(name);
		};
		try {
			new Event('test');
		} catch (e) {
			// IE does not support `new Event()`
			createEvent = function (name) {
				var evt = document.createEvent('Event');
				evt.initEvent(name, true, false);
				return evt;
			};
		}

		function assign(ta) {
			var _ref = arguments[1] === undefined ? {} : arguments[1];

			var _ref$setOverflowX = _ref.setOverflowX;
			var setOverflowX = _ref$setOverflowX === undefined ? true : _ref$setOverflowX;
			var _ref$setOverflowY = _ref.setOverflowY;
			var setOverflowY = _ref$setOverflowY === undefined ? true : _ref$setOverflowY;

			if (!ta || !ta.nodeName || ta.nodeName !== 'TEXTAREA' || set.has(ta)) return;

			var heightOffset = null;
			var overflowY = null;
			var clientWidth = ta.clientWidth;

			function init() {
				var style = window.getComputedStyle(ta, null);

				overflowY = style.overflowY;

				if (style.resize === 'vertical') {
					ta.style.resize = 'none';
				} else if (style.resize === 'both') {
					ta.style.resize = 'horizontal';
				}

				if (style.boxSizing === 'content-box') {
					heightOffset = -(parseFloat(style.paddingTop) + parseFloat(style.paddingBottom));
				} else {
					heightOffset = parseFloat(style.borderTopWidth) + parseFloat(style.borderBottomWidth);
				}
				// Fix when a textarea is not on document body and heightOffset is Not a Number
				if (isNaN(heightOffset)) {
					heightOffset = 0;
				}

				update();
			}

			function changeOverflow(value) {
				{
					// Chrome/Safari-specific fix:
					// When the textarea y-overflow is hidden, Chrome/Safari do not reflow the text to account for the space
					// made available by removing the scrollbar. The following forces the necessary text reflow.
					var width = ta.style.width;
					ta.style.width = '0px';
					// Force reflow:
					/* jshint ignore:start */
					ta.offsetWidth;
					/* jshint ignore:end */
					ta.style.width = width;
				}

				overflowY = value;

				if (setOverflowY) {
					ta.style.overflowY = value;
				}

				resize();
			}

			function resize() {
				var htmlTop = window.pageYOffset;
				var bodyTop = document.body.scrollTop;
				var originalHeight = ta.style.height;

				ta.style.height = 'auto';

				var endHeight = ta.scrollHeight + heightOffset;

				if (ta.scrollHeight === 0) {
					// If the scrollHeight is 0, then the element probably has display:none or is detached from the DOM.
					ta.style.height = originalHeight;
					return;
				}

				ta.style.height = endHeight + 'px';

				// used to check if an update is actually necessary on window.resize
				clientWidth = ta.clientWidth;

				// prevents scroll-position jumping
				document.documentElement.scrollTop = htmlTop;
				document.body.scrollTop = bodyTop;
			}

			function update() {
				var startHeight = ta.style.height;

				resize();

				var style = window.getComputedStyle(ta, null);

				if (style.height !== ta.style.height) {
					if (overflowY !== 'visible') {
						changeOverflow('visible');
					}
				} else {
					if (overflowY !== 'hidden') {
						changeOverflow('hidden');
					}
				}

				if (startHeight !== ta.style.height) {
					var evt = createEvent('autosize:resized');
					ta.dispatchEvent(evt);
				}
			}

			var pageResize = function pageResize() {
				if (ta.clientWidth !== clientWidth) {
					update();
				}
			};

			var destroy = (function (style) {
				window.removeEventListener('resize', pageResize, false);
				ta.removeEventListener('input', update, false);
				ta.removeEventListener('keyup', update, false);
				ta.removeEventListener('autosize:destroy', destroy, false);
				ta.removeEventListener('autosize:update', update, false);
				set['delete'](ta);

				Object.keys(style).forEach(function (key) {
					ta.style[key] = style[key];
				});
			}).bind(ta, {
				height: ta.style.height,
				resize: ta.style.resize,
				overflowY: ta.style.overflowY,
				overflowX: ta.style.overflowX,
				wordWrap: ta.style.wordWrap });

			ta.addEventListener('autosize:destroy', destroy, false);

			// IE9 does not fire onpropertychange or oninput for deletions,
			// so binding to onkeyup to catch most of those events.
			// There is no way that I know of to detect something like 'cut' in IE9.
			if ('onpropertychange' in ta && 'oninput' in ta) {
				ta.addEventListener('keyup', update, false);
			}

			window.addEventListener('resize', pageResize, false);
			ta.addEventListener('input', update, false);
			ta.addEventListener('autosize:update', update, false);
			set.add(ta);

			if (setOverflowX) {
				ta.style.overflowX = 'hidden';
				ta.style.wordWrap = 'break-word';
			}

			init();
		}

		function destroy(ta) {
			if (!(ta && ta.nodeName && ta.nodeName === 'TEXTAREA')) return;
			var evt = createEvent('autosize:destroy');
			ta.dispatchEvent(evt);
		}

		function update(ta) {
			if (!(ta && ta.nodeName && ta.nodeName === 'TEXTAREA')) return;
			var evt = createEvent('autosize:update');
			ta.dispatchEvent(evt);
		}

		var autosize = null;

		// Do nothing in Node.js environment and IE8 (or lower)
		if (typeof window === 'undefined' || typeof window.getComputedStyle !== 'function') {
			autosize = function (el) {
				return el;
			};
			autosize.destroy = function (el) {
				return el;
			};
			autosize.update = function (el) {
				return el;
			};
		} else {
			autosize = function (el, options) {
				if (el) {
					Array.prototype.forEach.call(el.length ? el : [el], function (x) {
						return assign(x, options);
					});
				}
				return el;
			};
			autosize.destroy = function (el) {
				if (el) {
					Array.prototype.forEach.call(el.length ? el : [el], destroy);
				}
				return el;
			};
			autosize.update = function (el) {
				if (el) {
					Array.prototype.forEach.call(el.length ? el : [el], update);
				}
				return el;
			};
		}

		module.exports = autosize;
	});

/***/ },
/* 289 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	/**
	 * InputFormField Component for uxcore
	 * @author eternalsky
	 *
	 * Copyright 2015-2016, Uxcore Team, Alinw.
	 * All rights reserved.
	 */

	module.exports = __webpack_require__(290);

/***/ },
/* 290 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	/**
	 * InputFormField Component for uxcore
	 * @author eternalsky
	 *
	 * Copyright 2015-2016, Uxcore Team, Alinw.
	 * All rights reserved.
	 */

	var React = __webpack_require__(7);
	var ReactDOM = __webpack_require__(8);
	var FormField = __webpack_require__(274);
	var Constants = __webpack_require__(272);
	var classnames = __webpack_require__(19);
	var assign = __webpack_require__(284);
	var util = __webpack_require__(291);

	var FormCount = function (_React$Component) {
	    _inherits(FormCount, _React$Component);

	    function FormCount(props) {
	        _classCallCheck(this, FormCount);

	        return _possibleConstructorReturn(this, _React$Component.call(this, props));
	    }

	    FormCount.prototype.render = function render() {
	        var me = this;
	        return React.createElement(
	            'div',
	            { className: 'kuma-uxform-count' },
	            me.props.length + "/" + me.props.total
	        );
	    };

	    return FormCount;
	}(React.Component);

	FormCount.defaultProps = {};
	FormCount.propTypes = {
	    length: React.PropTypes.number,
	    total: React.PropTypes.number
	};

	FormCount.displayName = "FormCount";

	var LeftAddon = function (_React$Component2) {
	    _inherits(LeftAddon, _React$Component2);

	    function LeftAddon(props) {
	        _classCallCheck(this, LeftAddon);

	        return _possibleConstructorReturn(this, _React$Component2.call(this, props));
	    }

	    LeftAddon.prototype.render = function render() {
	        var me = this;
	        return React.createElement(
	            'div',
	            { className: classnames({
	                    "kuma-uxform-left-icon": true,
	                    "kuma-uxform-left-icon-focus": !!me.props.focus
	                }) },
	            me.props.children
	        );
	    };

	    return LeftAddon;
	}(React.Component);

	LeftAddon.defaultProps = {};
	LeftAddon.propTypes = {};
	LeftAddon.displayName = "LeftAddon";

	var RightAddon = function (_React$Component3) {
	    _inherits(RightAddon, _React$Component3);

	    function RightAddon(props) {
	        _classCallCheck(this, RightAddon);

	        return _possibleConstructorReturn(this, _React$Component3.call(this, props));
	    }

	    RightAddon.prototype.render = function render() {
	        var me = this;
	        return React.createElement(
	            'div',
	            { className: 'kuma-uxform-right-icon ' },
	            me.props.children
	        );
	    };

	    return RightAddon;
	}(React.Component);

	RightAddon.defaultProps = {};
	RightAddon.propTypes = {};
	RightAddon.displayName = "RightAddon";

	/**
	 * extend FormField, rewrite renderField method
	 */

	var InputFormField = function (_FormField) {
	    _inherits(InputFormField, _FormField);

	    function InputFormField(props) {
	        _classCallCheck(this, InputFormField);

	        return _possibleConstructorReturn(this, _FormField.call(this, props));
	    }

	    InputFormField.prototype.getValue = function getValue() {
	        return ReactDOM.findDOMNode(this.refs.root).value();
	    };

	    InputFormField.prototype.handleChange = function handleChange(e) {
	        var me = this;
	        var autoTrim = me.props.autoTrim;

	        var value = e.currentTarget.value;
	        if (autoTrim) {
	            value = me.trim(value);
	        }
	        me.handleDataChange(me.deFormatValue(value));
	    };

	    InputFormField.prototype.trim = function trim(str) {
	        return str.replace(/(^\s+|\s+$)/g, "");
	    };

	    InputFormField.prototype.handleFocus = function handleFocus(e) {
	        this.setState({
	            focus: true
	        });
	        this.props.onFocus(e);
	    };

	    InputFormField.prototype.handleBlur = function handleBlur(e) {
	        var me = this;
	        me.setState({
	            focus: false
	        });
	        var pass = true;
	        if (me.props.validateOnBlur) {
	            pass = me.doValidate();
	        }
	        me.props.onBlur(e, pass);
	    };

	    InputFormField.prototype.handleKeyDown = function handleKeyDown(e) {
	        var me = this;
	        me.props.onKeyDown(e);
	    };

	    InputFormField.prototype.deFormatValue = function deFormatValue(value) {
	        return value;
	    };

	    InputFormField.prototype.addSpecificClass = function addSpecificClass() {
	        var me = this;
	        if (me.props.jsxprefixCls == "kuma-uxform-field") {
	            return me.props.jsxprefixCls + " kuma-input-uxform-field";
	        } else {
	            return me.props.jsxprefixCls;
	        }
	    };

	    InputFormField.prototype.getCount = function getCount() {
	        var me = this;
	        var children = me.props.children;
	        var element = void 0;
	        React.Children.map(children, function (child) {
	            if (child && typeof child.type == 'function' && child.type.displayName == 'FormCount') {
	                element = child;
	            }
	        });
	        if (!!element) {
	            var total = element.props.total;
	            var Count = React.cloneElement(element, {
	                length: !!me.state.value ? me.state.value.length : 0,
	                key: "count"
	            });

	            return {
	                element: Count,
	                total: total
	            };
	        }
	    };

	    InputFormField.prototype.renderLeftAddon = function renderLeftAddon() {
	        var me = this;
	        var children = me.props.children;
	        var element = void 0;
	        React.Children.map(children, function (child) {
	            if (child && typeof child.type == 'function' && child.type.displayName == 'LeftAddon') {
	                element = child;
	            }
	        });
	        if (!!element) {
	            return React.cloneElement(element, {
	                focus: !!me.state.focus,
	                key: "left"
	            });
	        }
	    };

	    InputFormField.prototype.renderRightAddon = function renderRightAddon() {
	        var me = this;
	        var children = me.props.children;
	        var element = void 0;
	        React.Children.map(children, function (child) {
	            if (child && typeof child.type == 'function' && child.type.displayName == 'RightAddon') {
	                element = child;
	            }
	        });

	        if (!!element) {
	            return React.cloneElement(element, {
	                key: "right"
	            });
	        }
	    };

	    InputFormField.prototype.renderField = function renderField() {
	        var me = this;
	        var arr = [];
	        var mode = me.props.jsxmode || me.props.mode;
	        var count = me.getCount();
	        var leftAddon = me.renderLeftAddon();
	        var rightAddon = me.renderRightAddon();
	        var children = me.props.children;
	        if (mode == Constants.MODE.EDIT) {
	            var otherOptions = {};
	            // if (!!count) {
	            //     otherOptions.maxLength = count.total + "";
	            // }
	            if (!!leftAddon) {
	                arr.push(leftAddon);
	            }
	            var IEver = util.getIEVer();
	            var placeholder = IEver >= 10 ? "" : me.props.jsxplaceholder;
	            arr.push(React.createElement('input', _extends({
	                className: classnames({
	                    "kuma-input": true,
	                    'kuma-uxform-input-has-right': !!count || !!rightAddon,
	                    "kuma-uxform-input-has-left": !!leftAddon
	                }),
	                ref: 'root',
	                key: me.props.inputType,
	                type: me.props.inputType,
	                placeholder: placeholder,
	                disabled: me.props.jsxdisabled == "disabled" || me.props.jsxdisabled == true ? "disabled" : "",
	                name: me.props.key,
	                value: me.state.formatValue,
	                onFocus: me.handleFocus.bind(me),
	                onBlur: me.handleBlur.bind(me),
	                onChange: me.handleChange.bind(me),
	                onKeyDown: me.handleKeyDown.bind(me)
	            }, otherOptions)));

	            if (!!rightAddon) {
	                arr.push(rightAddon);
	            } else if (!!count) {
	                arr.push(count.element);
	            }
	        } else if (mode == Constants.MODE.VIEW) {
	            arr.push(React.createElement(
	                'span',
	                { key: 'text' },
	                me.state.formatValue
	            ));
	        }
	        return arr;
	    };

	    return InputFormField;
	}(FormField);

	InputFormField.Count = FormCount;
	InputFormField.LeftAddon = LeftAddon;
	InputFormField.RightAddon = RightAddon;
	InputFormField.propTypes = assign({}, FormField.propTypes, {
	    onBlur: React.PropTypes.func,
	    onFocus: React.PropTypes.func,
	    onKeyDown: React.PropTypes.func,
	    validateOnBlur: React.PropTypes.bool,
	    autoTrim: React.PropTypes.bool,
	    inputType: React.PropTypes.string
	});
	InputFormField.defaultProps = assign({}, FormField.defaultProps, {
	    onBlur: function onBlur() {},
	    onFocus: function onFocus() {},
	    onKeyDown: function onKeyDown() {},
	    validateOnBlur: false,
	    inputType: 'text'
	});
	InputFormField.displayName = "InputFormField";
	module.exports = InputFormField;

/***/ },
/* 291 */
/***/ function(module, exports) {

	"use strict";

	module.exports = {
	    getIEVer: function getIEVer() {
	        if (window) {
	            var ua = window.navigator.userAgent;
	            var idx = ua.indexOf('MSIE');
	            if (idx > 0) {
	                // "Mozilla/5.0 (compatible; MSIE 10.0; Windows NT 6.1; WOW64; Trident/6.0; SLCC2; .NET CLR 2.0.50727)"
	                return parseInt(ua.substring(idx + 5, ua.indexOf(".", idx)));
	            }
	            if (!!ua.match(/Trident\/7\./)) {
	                // "Mozilla/5.0 (Windows NT 6.1; WOW64; Trident/7.0; SLCC2; .NET CLR 2.0.50727; rv:11.0) like Gecko"
	                return 11;
	            }
	            return 0;
	        }
	        return 0;
	    }
	};

/***/ },
/* 292 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	/**
	 * Created by xy on 15/4/13.
	 */
	var FormField = __webpack_require__(274);
	var Constants = __webpack_require__(272);
	var RadioGroup = __webpack_require__(293);
	var Item = RadioGroup.Item;

	var RadioGroupFormField = function (_FormField) {
	    _inherits(RadioGroupFormField, _FormField);

	    function RadioGroupFormField(props) {
	        _classCallCheck(this, RadioGroupFormField);

	        return _possibleConstructorReturn(this, _FormField.call(this, props));
	    }

	    RadioGroupFormField.prototype.handleChange = function handleChange(value) {
	        var me = this;
	        me.handleDataChange(value);
	    };

	    RadioGroupFormField.prototype.addSpecificClass = function addSpecificClass() {
	        var me = this;
	        if (me.props.jsxprefixCls == "kuma-uxform-field") {
	            return me.props.jsxprefixCls + " kuma-radio-group-uxform-field";
	        } else {
	            return me.props.jsxprefixCls;
	        }
	    };

	    RadioGroupFormField.prototype.renderField = function renderField() {
	        var me = this;
	        var arr = [];
	        var mode = me.props.jsxmode || me.props.mode;
	        if (mode == Constants.MODE.EDIT) {
	            arr.push(React.createElement(
	                RadioGroup,
	                {
	                    ref: 'el',
	                    key: 'radiogroup',
	                    value: me.state.value,
	                    onChange: me.handleChange.bind(me) },
	                me.props.children
	            ));
	        } else {
	            var text = me.props.children.filter(function (child, index) {
	                return child.props.value == me.state.value;
	            });

	            if (text.length) {
	                arr.push(React.createElement(
	                    'span',
	                    { key: 'radiogroup' },
	                    text[0].props.text
	                ));
	            }
	        }
	        return arr;
	    };

	    return RadioGroupFormField;
	}(FormField);

	RadioGroupFormField.displayName = "RadioGroupFormField";
	RadioGroupFormField.propTypes = FormField.propTypes;
	RadioGroupFormField.defaultProps = FormField.defaultProps;
	RadioGroupFormField.Item = Item;
	module.exports = RadioGroupFormField;

/***/ },
/* 293 */
[591, 294],
/* 294 */
[592, 295],
/* 295 */
238,
/* 296 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	/**
	 * SelectFormField Component for uxcore
	 * @author eternalsky
	 *
	 * Copyright 2014-2015, Uxcore Team, Alinw.
	 * All rights reserved.
	 */

	module.exports = __webpack_require__(297);

/***/ },
/* 297 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	/**
	 * Created by xy on 15/4/13.
	 */
	var FormField = __webpack_require__(274);
	var Constants = __webpack_require__(272);
	var Select = __webpack_require__(298);
	var assign = __webpack_require__(284);
	var Validator = __webpack_require__(368);
	var isObject = Validator.isObject;
	var isArray = Validator.isArray;
	var Option = Select.Option;

	var selectOptions = ['onSelect', 'onDeselect', 'getPopupContainer', 'multiple', 'filterOption', 'allowClear', 'combobox', 'searchPlaceholder', 'tags', 'disabled', 'showSearch', 'placeholder', 'optionLabelProp', 'maxTagTextLength', 'dropdownMatchSelectWidth', 'dropdownClassName', 'notFoundContent'];

	var SelectFormField = function (_FormField) {
	    _inherits(SelectFormField, _FormField);

	    function SelectFormField(props) {
	        _classCallCheck(this, SelectFormField);

	        var _this = _possibleConstructorReturn(this, _FormField.call(this, props));

	        var me = _this;
	        assign(me.state, {
	            data: me._processData(props.jsxdata)
	        });
	        return _this;
	    }

	    SelectFormField.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
	        var me = this;
	        if (!me._isEqual(nextProps.value, me.props.value)) {
	            me.handleDataChange(me._processValue(nextProps.value), true);
	        }
	        if (!me._isEqual(nextProps.jsxdata, me.props.jsxdata)) {
	            me.setState({
	                data: me._processData(nextProps.jsxdata)
	            });
	        }
	    };

	    SelectFormField.prototype.componentWillMount = function componentWillMount() {
	        var me = this;
	        if (me.props.jsxfetchUrl) {
	            me.fetchData();
	        }
	    };

	    SelectFormField.prototype.componentDidMount = function componentDidMount() {
	        var me = this;
	        if (!me.props.standalone) {
	            me.props.attachFormField(me);
	            me.props.handleDataChange(me, {
	                value: me._processValue(me.props.value),
	                pass: true
	            }, true);
	        }
	        me.hasDeprecatedProps();
	    };

	    SelectFormField.prototype.handleDataChange = function handleDataChange(value, fromReset) {
	        var me = this;
	        me.setState({
	            value: value,
	            formatValue: me.formatValue(value),
	            error: !!fromReset ? false : me.state.error,
	            /*
	             * why set state fromReset? some field like editor cannot be reset in the common way
	             * so set this state to tell the field that you need to reset by yourself.
	             */
	            fromReset: fromReset
	        }, function () {
	            var pass = true;
	            if (!fromReset) {
	                pass = me.doValidate();
	            }
	            me.props.handleDataChange(me, {
	                value: value,
	                pass: pass
	            });
	        });
	    };

	    SelectFormField.prototype.fetchData = function fetchData(value) {
	        var me = this;
	        var ajaxOptions = {
	            url: me.props.jsxfetchUrl,
	            dataType: me.props.dataType,
	            data: me.props.beforeFetch({
	                q: value
	            }),
	            success: function success(data) {
	                var fetchData = me._processData(me.props.afterFetch(data));
	                if (!!me.props.jsxdata) {
	                    fetchData = me._processData(me.props.jsxdata).concat(fetchData);
	                }
	                me.setState({
	                    data: fetchData
	                });
	            },
	            fail: function fail() {
	                console.log("Fetch Data failed");
	            }
	        };
	        if (/\.jsonp/.test(me.props.jsxfetchUrl)) {
	            ajaxOptions.dataType = "jsonp";
	        }
	        $.ajax(ajaxOptions);
	    };

	    SelectFormField.prototype.handleChange = function handleChange(value, label) {
	        var me = this;
	        me.handleDataChange(value, false, label);
	    };

	    SelectFormField.prototype.handleSearch = function handleSearch(value) {
	        var me = this;
	        if (me.props.jsxfetchUrl) {
	            me.fetchData(value);
	        } else {
	            me.props.onSearch && me.props.onSearch(value);
	        }
	    };
	    /**
	     * jsxdata can be one of two types: hash map or array
	     * hash map is like {value: text}
	     * array is like [{value: xxx, text: xxx}]
	     */

	    SelectFormField.prototype._processData = function _processData(data) {
	        var values = [];
	        if ((typeof data === 'undefined' ? 'undefined' : _typeof(data)) == 'object' && !(data instanceof Array)) {
	            var keys = Object.keys(data);
	            values = keys.map(function (key) {
	                return {
	                    value: key,
	                    text: data[key]
	                };
	            });
	        } else {
	            values = data;
	        }
	        return values;
	    };

	    SelectFormField.prototype._transferDataToObj = function _transferDataToObj(data) {
	        var obj = {};
	        data.forEach(function (item, index) {
	            var key = item.value == "" ? "__all__" : item.value;
	            obj[key] = item.text;
	        });
	        return obj;
	    };

	    SelectFormField.prototype._generateOptionsFromData = function _generateOptionsFromData() {
	        var me = this;
	        var values = me.state.data;
	        var children = me.props.children;
	        if (!values.length) {
	            // console.warn("You need to pass data to initialize Select.");
	            if (!!children) {
	                return children;
	            }
	        } else {
	            var arr = values.map(function (item, index) {
	                var _me$props = me.props;
	                var multiple = _me$props.multiple;
	                var jsxmultiple = _me$props.jsxmultiple;
	                var combobox = _me$props.combobox;
	                var jsxcombobox = _me$props.jsxcombobox;


	                return React.createElement(
	                    Option,
	                    { key: item.value, title: item.text },
	                    item.text
	                );
	            });
	            return arr;
	        }
	    };

	    SelectFormField.prototype._processValue = function _processValue(value) {
	        var me = this;
	        value = value || me.state.value;
	        if (!me.props.jsxfetchUrl && !me.props.onSearch) {
	            return value;
	        }
	        if (typeof value == "string") {
	            return {
	                key: value
	            };
	        } else if (value instanceof Array) {
	            return value.map(function (item) {
	                if (typeof item == "string") {
	                    return {
	                        key: item
	                    };
	                } else {
	                    return item;
	                }
	            });
	        } else {
	            return value;
	        }
	    };

	    SelectFormField.prototype.addSpecificClass = function addSpecificClass() {
	        var me = this;
	        if (me.props.jsxprefixCls == "kuma-uxform-field") {
	            return me.props.jsxprefixCls + " kuma-select-uxform-field";
	        } else {
	            return me.props.jsxprefixCls;
	        }
	    };

	    SelectFormField.prototype.getValuePropValue = function getValuePropValue(child) {
	        var key = "";
	        if ('value' in child.props) {
	            key = child.props.value;
	        } else {
	            key = child.key;
	        }
	        return key;
	    };

	    SelectFormField.prototype.hasDeprecatedProps = function hasDeprecatedProps() {
	        var arr = ['jsxmultiple', 'jsxallowClear', 'jsxcombobox', 'jsxsearchPlaceholder', 'jsxtags', 'jsxdisabled', 'jsxshowSearch', 'jsxplaceholder'];
	        var me = this;
	        var keys = Object.keys(me.props);
	        var hasDeprecated = keys.some(function (item, index) {
	            return arr.indexOf(item) != -1;
	        });
	        if (hasDeprecated) {
	            console.warn("SelectFormField: props same as uxcore-select2 can be passed without prefix 'jsx' now (exclude style). we will remove the support of the props mentioned above with prefix 'jsx' at uxcore-form@1.3.0 .");
	        }
	    };

	    SelectFormField.prototype.renderField = function renderField() {
	        var me = this;
	        var arr = [];
	        var mode = me.props.jsxmode || me.props.mode;

	        if (mode == Constants.MODE.EDIT) {
	            (function () {
	                var options = {
	                    ref: "el",
	                    key: "select",
	                    optionLabelProp: me.props.optionLabelProp,
	                    style: me.props.jsxstyle,
	                    multiple: me.props.jsxmultiple,
	                    allowClear: me.props.jsxallowClear,
	                    combobox: me.props.jsxcombobox,
	                    searchPlaceholder: me.props.jsxsearchPlaceholder,
	                    tags: me.props.jsxtags,
	                    optionFilterProp: me.props.optionFilterProp,
	                    disabled: !!me.props.jsxdisabled,
	                    showSearch: me.props.jsxshowSearch,
	                    placeholder: me.props.jsxplaceholder,
	                    onChange: me.handleChange.bind(me),
	                    onSearch: me.handleSearch.bind(me)
	                };

	                selectOptions.forEach(function (item, index) {
	                    if (item in me.props) {
	                        options[item] = me.props[item];
	                    }
	                });

	                // only jsxfetchUrl mode need pass label, for the options always change.
	                // when mount, state.label is undefined, which cause defalutValue cannot be used.
	                if (!!me.props.jsxfetchUrl || !!me.props.onSearch) {
	                    options.labelInValue = true;
	                }

	                if (!me.props.combobox || me.state.fromReset) {
	                    options.value = me._processValue() || [];
	                }

	                if (!!me.props.jsxfetchUrl) {
	                    options.filterOption = false;
	                }
	                arr.push(React.createElement(
	                    Select,
	                    options,
	                    me._generateOptionsFromData()
	                ));
	            })();
	        } else if (mode == Constants.MODE.VIEW) {
	            var str = '';
	            if (me.state.value) {
	                (function () {
	                    var value = me._processValue();
	                    var values = !isArray(value) ? [value] : value;
	                    // labelInValue mode
	                    if (me.props.jsxfetchUrl || me.props.onSearch || me.props.labelInValue) {
	                        str = values.map(function (item) {
	                            return item.label;
	                        }).join(" ");
	                    }
	                    // <Option> mode
	                    else if (me.props.children) {
	                            me.props.children && me.props.children.forEach(function (child, index) {
	                                var valuePropValue = me.getValuePropValue(child);
	                                if (values.indexOf(valuePropValue) !== -1) {
	                                    str += child.props[me.props.optionLabelProp] + " ";
	                                }
	                            });
	                        }
	                        // only jsxdata
	                        else {
	                                values.forEach(function (value, index) {
	                                    str += me._transferDataToObj(me.state.data)[value == "" ? "__all__" : value] + " ";
	                                });
	                            }
	                })();
	            }
	            arr.push(React.createElement(
	                'span',
	                { key: 'select' },
	                str
	            ));
	        }
	        return arr;
	    };

	    return SelectFormField;
	}(FormField);

	SelectFormField.Option = Option;
	SelectFormField.displayName = "SelectFormField";
	SelectFormField.propTypes = assign({}, FormField.propTypes, {
	    jsxstyle: React.PropTypes.object,
	    jsxplaceholder: React.PropTypes.string,
	    jsxcombobox: React.PropTypes.bool,
	    jsxdata: React.PropTypes.oneOfType([React.PropTypes.object, React.PropTypes.array]),
	    beforeFetch: React.PropTypes.func,
	    afterFetch: React.PropTypes.func,
	    jsxshowSearch: React.PropTypes.bool,
	    jsxtags: React.PropTypes.bool,
	    jsxmultiple: React.PropTypes.bool,
	    jsxallowClear: React.PropTypes.bool,
	    jsxsearchPlaceholder: React.PropTypes.string,
	    optionFilterProp: React.PropTypes.string,
	    dataType: React.PropTypes.string
	});

	SelectFormField.defaultProps = assign({}, FormField.defaultProps, {
	    jsxstyle: {},
	    jsxplaceholder: "请下拉选择",
	    jsxcombobox: false,
	    jsxdata: {},
	    beforeFetch: function beforeFetch(obj) {
	        return obj;
	    },
	    afterFetch: function afterFetch(obj) {
	        return obj;
	    },
	    jsxshowSearch: true,
	    jsxallowClear: false,
	    jsxtags: false,
	    jsxmultiple: false,
	    jsxsearchPlaceholder: "",
	    optionFilterProp: "children",
	    optionLabelProp: "children",
	    dataType: 'json'
	});

	module.exports = SelectFormField;

/***/ },
/* 298 */
[575, 299],
/* 299 */
[576, 300, 284],
/* 300 */
[577, 301, 367, 322],
/* 301 */
[578, 302, 322, 323, 329, 332, 347, 366],
/* 302 */
[543, 303, 304, 306, 307, 308, 309, 314, 315, 319, 320, 321],
/* 303 */
16,
/* 304 */
[544, 305],
/* 305 */
18,
/* 306 */
[545, 305],
/* 307 */
21,
/* 308 */
[546, 309],
/* 309 */
[547, 310],
/* 310 */
[548, 311, 312, 313],
/* 311 */
25,
/* 312 */
26,
/* 313 */
27,
/* 314 */
28,
/* 315 */
[549, 316],
/* 316 */
[550, 317],
/* 317 */
[551, 318, 284],
/* 318 */
32,
/* 319 */
33,
/* 320 */
34,
/* 321 */
35,
/* 322 */
189,
/* 323 */
[554, 324],
/* 324 */
[555, 325, 326, 331],
/* 325 */
45,
/* 326 */
[556, 327, 331],
/* 327 */
[557, 328, 329],
/* 328 */
48,
/* 329 */
[558, 330, 330],
/* 330 */
50,
/* 331 */
51,
/* 332 */
[579, 333],
/* 333 */
[580, 334, 341, 344, 345, 346],
/* 334 */
[581, 335, 284, 339],
/* 335 */
[582, 302, 336, 284, 339, 340],
/* 336 */
[552, 337],
/* 337 */
[553, 338],
/* 338 */
38,
/* 339 */
206,
/* 340 */
[583, 284],
/* 341 */
[584, 342, 302, 339, 343],
/* 342 */
[585, 335, 284, 339, 323],
/* 343 */
[586, 302],
/* 344 */
[587, 302, 339],
/* 345 */
212,
/* 346 */
213,
/* 347 */
[588, 348, 365],
/* 348 */
[559, 349],
/* 349 */
[560, 302, 350, 364],
/* 350 */
[561, 351, 323, 362, 363],
/* 351 */
[562, 352],
/* 352 */
[563, 353, 302, 361],
/* 353 */
[564, 354, 355, 356, 357, 358, 359],
/* 354 */
86,
/* 355 */
[565, 354],
/* 356 */
[566, 354, 355],
/* 357 */
[567, 354],
/* 358 */
[568, 354],
/* 359 */
[569, 360],
/* 360 */
92,
/* 361 */
93,
/* 362 */
[570, 363],
/* 363 */
104,
/* 364 */
105,
/* 365 */
[589, 332, 333, 336],
/* 366 */
[590, 322, 332, 333],
/* 367 */
234,
/* 368 */
[595, 369],
/* 369 */
/***/ function(module, exports) {

	'use strict';

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	/**
	 * Created by xy on 15/4/16.
	 */

	var Validator = {};

	var PATTERN = {
	    EMAIL: /^([a-z0-9_\.-]+)@([\da-z\.-]+)\.([a-z\.]{2,6})$/,
	    URL: /^(https?:\/\/)?([\da-z\.-]+)\.([a-z\.]{2,6})([\/\w \.-]*)*\/?$/,
	    HEX: /^#?([a-f0-9]{6}|[a-f0-9]{3})$/i,
	    NUM: /^((-?\d+\.\d+)|(-?\d+)|(-?\.\d+))$/,
	    IDCARD: /(^\d{15}$)|(^\d{17}([0-9]|X)$)/i,
	    CNMOBILE: /^(0|86|17951)?(13[0-9]|15[012356789]|17[0678]|18[0-9]|14[57])[0-9]{8}$/
	};

	Validator.isNotEmpty = function (value) {
	    // empty means empty string, empty array, empty object & null & undefined
	    if (typeof value == "string") {
	        return value.length !== 0;
	    } else if ((typeof value === 'undefined' ? 'undefined' : _typeof(value)) == 'object') {
	        if (value instanceof Array) {
	            return value.length !== 0;
	        } else {
	            var i = 0;
	            for (var key in value) {
	                i++;
	            }
	            return !!i;
	        }
	    } else if (typeof value == 'number') {
	        return true;
	    } else {
	        return !!value;
	    }
	};

	Validator.isNum = function (value) {
	    return PATTERN.NUM.test(value);
	};

	Validator.isInt = function (value) {
	    return Validator.isNum(value) && parseInt(value) == value;
	};

	Validator.isDecimal = function (value) {
	    return Validator.isNum(value) && !Validator.isInt(value);
	};

	Validator.isArray = function (value) {
	    return Array.isArray(value);
	};

	Validator.isRegExp = function (value) {
	    if (value instanceof RegExp) {
	        return true;
	    }
	    try {
	        return !!new RegExp(value);
	    } catch (e) {
	        return false;
	    }
	};

	Validator.isObject = function (value) {
	    return (typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object' && !Validator.isArray(value);
	};

	Validator.isFunc = function (value) {
	    return typeof value === 'function';
	};

	Validator.isEmail = function (value) {
	    return typeof value === 'string' && PATTERN.EMAIL.test(value);
	};

	Validator.isUrl = function (value) {
	    return typeof value === 'string' && PATTERN.URL.test(value);
	};

	Validator.isHex = function (value) {
	    return typeof value === 'string' && PATTERN.HEX.test(value);
	};

	Validator.isIdCard = function (value) {
	    return typeof value === 'string' && PATTERN.IDCARD.test(value);
	};

	Validator.isCNMobile = function (value) {
	    return typeof value === 'string' && PATTERN.CNMOBILE.test(value);
	};
	module.exports = Validator;

/***/ },
/* 370 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var InputFormField = __webpack_require__(371);
	var Formatter = __webpack_require__(372);
	var assign = __webpack_require__(284);

	var NumberInputFormField = function (_InputFormField) {
	    _inherits(NumberInputFormField, _InputFormField);

	    function NumberInputFormField(props) {
	        _classCallCheck(this, NumberInputFormField);

	        return _possibleConstructorReturn(this, _InputFormField.call(this, props));
	    }

	    NumberInputFormField.prototype.formatValue = function formatValue(value) {
	        if (value === undefined || value === null) return "";
	        var me = this;
	        value = value + "";
	        if (me.props.jsxtype == "money") {
	            if (value.match(/\.(\d+)/) && value.match(/\.(\d+)/)[1].length > me.props.fixedNum) {
	                return Formatter.money(value, me.props.delimiter, me.props.fixedNum);
	            } else {
	                return Formatter.money(value, me.props.delimiter);
	            }
	        } else if (me.props.jsxtype == "cnmobile") {
	            return Formatter.cnmobile(value, me.props.delimiter);
	        } else if (me.props.jsxtype == "card") {
	            return Formatter.card(value, me.props.delimiter);
	        } else {
	            return value;
	        }
	    };

	    NumberInputFormField.prototype.deFormatValue = function deFormatValue(value) {
	        var me = this;
	        if (me.props.jsxtype == "money" || me.props.jsxtype == "cnmobile" || me.props.jsxtype == "card") {
	            return value.split(me.props.delimiter).join("");
	        } else {
	            return value;
	        }
	    };

	    NumberInputFormField.prototype.addSpecificClass = function addSpecificClass() {
	        var me = this;
	        if (me.props.jsxprefixCls == "kuma-uxform-field") {
	            return me.props.jsxprefixCls + " kuma-number-input-uxform-field";
	        } else {
	            return me.props.jsxprefixCls;
	        }
	    };

	    return NumberInputFormField;
	}(InputFormField);

	NumberInputFormField.displayName = "NumberInputFormField";
	NumberInputFormField.propTypes = assign({}, InputFormField.propTypes, {
	    jsxtype: React.PropTypes.string,
	    delimiter: React.PropTypes.string,
	    fixedNum: React.PropTypes.number
	});
	NumberInputFormField.defaultProps = assign({}, InputFormField.defaultProps, {
	    jsxtype: '',
	    delimiter: ' '
	});

	module.exports = NumberInputFormField;

/***/ },
/* 371 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var React = __webpack_require__(7);
	var ReactDOM = __webpack_require__(8);
	var FormField = __webpack_require__(274);
	var Constants = __webpack_require__(272);
	var classnames = __webpack_require__(19);
	var assign = __webpack_require__(284);

	var FormCount = function (_React$Component) {
	    _inherits(FormCount, _React$Component);

	    function FormCount(props) {
	        _classCallCheck(this, FormCount);

	        return _possibleConstructorReturn(this, _React$Component.call(this, props));
	    }

	    FormCount.prototype.render = function render() {
	        var me = this;
	        return React.createElement(
	            'div',
	            { className: 'kuma-uxform-count' },
	            me.props.length + "/" + me.props.total
	        );
	    };

	    return FormCount;
	}(React.Component);

	FormCount.defaultProps = {};
	FormCount.propTypes = {
	    length: React.PropTypes.number,
	    total: React.PropTypes.number
	};

	FormCount.displayName = "FormCount";

	var LeftAddon = function (_React$Component2) {
	    _inherits(LeftAddon, _React$Component2);

	    function LeftAddon(props) {
	        _classCallCheck(this, LeftAddon);

	        return _possibleConstructorReturn(this, _React$Component2.call(this, props));
	    }

	    LeftAddon.prototype.render = function render() {
	        var me = this;
	        return React.createElement(
	            'div',
	            { className: classnames({
	                    "kuma-uxform-left-icon": true,
	                    "kuma-uxform-left-icon-focus": !!me.props.focus
	                }) },
	            me.props.children
	        );
	    };

	    return LeftAddon;
	}(React.Component);

	LeftAddon.defaultProps = {};
	LeftAddon.propTypes = {};
	LeftAddon.displayName = "LeftAddon";

	var RightAddon = function (_React$Component3) {
	    _inherits(RightAddon, _React$Component3);

	    function RightAddon(props) {
	        _classCallCheck(this, RightAddon);

	        return _possibleConstructorReturn(this, _React$Component3.call(this, props));
	    }

	    RightAddon.prototype.render = function render() {
	        var me = this;
	        return React.createElement(
	            'div',
	            { className: 'kuma-uxform-right-icon ' },
	            me.props.children
	        );
	    };

	    return RightAddon;
	}(React.Component);

	RightAddon.defaultProps = {};
	RightAddon.propTypes = {};
	RightAddon.displayName = "RightAddon";

	/**
	 * extend FormField, rewrite renderField method
	 */

	var InputFormField = function (_FormField) {
	    _inherits(InputFormField, _FormField);

	    function InputFormField(props) {
	        _classCallCheck(this, InputFormField);

	        return _possibleConstructorReturn(this, _FormField.call(this, props));
	    }

	    InputFormField.prototype.getValue = function getValue() {
	        return ReactDOM.findDOMNode(this.refs.root).value();
	    };

	    InputFormField.prototype.handleChange = function handleChange(e) {
	        var me = this;
	        var autoTrim = me.props.autoTrim;

	        var value = e.currentTarget.value;
	        if (autoTrim) {
	            value = me.trim(value);
	        }
	        me.handleDataChange(me.deFormatValue(value));
	    };

	    InputFormField.prototype.trim = function trim(str) {
	        return str.replace(/(^\s+|\s+$)/g, "");
	    };

	    InputFormField.prototype.handleFocus = function handleFocus(e) {
	        this.setState({
	            focus: true
	        });
	        this.props.onFocus(e);
	    };

	    InputFormField.prototype.handleBlur = function handleBlur(e) {
	        var me = this;
	        me.setState({
	            focus: false
	        });
	        var pass = true;
	        if (me.props.validateOnBlur) {
	            pass = me.doValidate();
	        }
	        me.props.onBlur(e, pass);
	    };

	    InputFormField.prototype.handleKeyDown = function handleKeyDown(e) {
	        var me = this;
	        me.props.onKeyDown(e);
	    };

	    InputFormField.prototype.deFormatValue = function deFormatValue(value) {
	        return value;
	    };

	    InputFormField.prototype.addSpecificClass = function addSpecificClass() {
	        var me = this;
	        if (me.props.jsxprefixCls == "kuma-uxform-field") {
	            return me.props.jsxprefixCls + " kuma-input-uxform-field";
	        } else {
	            return me.props.jsxprefixCls;
	        }
	    };

	    InputFormField.prototype.getCount = function getCount() {
	        var me = this;
	        var children = me.props.children;
	        var element = void 0;
	        React.Children.map(children, function (child) {
	            if (child && typeof child.type == 'function' && child.type.displayName == 'FormCount') {
	                element = child;
	            }
	        });
	        if (!!element) {
	            var total = element.props.total;
	            var Count = React.cloneElement(element, {
	                length: !!me.state.value ? me.state.value.length : 0,
	                key: "count"
	            });

	            return {
	                element: Count,
	                total: total
	            };
	        }
	    };

	    InputFormField.prototype.renderLeftAddon = function renderLeftAddon() {
	        var me = this;
	        var children = me.props.children;
	        var element = void 0;
	        React.Children.map(children, function (child) {
	            if (child && typeof child.type == 'function' && child.type.displayName == 'LeftAddon') {
	                element = child;
	            }
	        });
	        if (!!element) {
	            return React.cloneElement(element, {
	                focus: !!me.state.focus,
	                key: "left"
	            });
	        }
	    };

	    InputFormField.prototype.renderRightAddon = function renderRightAddon() {
	        var me = this;
	        var children = me.props.children;
	        var element = void 0;
	        React.Children.map(children, function (child) {
	            if (child && typeof child.type == 'function' && child.type.displayName == 'RightAddon') {
	                element = child;
	            }
	        });

	        if (!!element) {
	            return React.cloneElement(element, {
	                key: "right"
	            });
	        }
	    };

	    InputFormField.prototype.renderField = function renderField() {
	        var me = this;
	        var arr = [];
	        var mode = me.props.jsxmode || me.props.mode;
	        var count = me.getCount();
	        var leftAddon = me.renderLeftAddon();
	        var rightAddon = me.renderRightAddon();
	        var children = me.props.children;
	        if (mode == Constants.MODE.EDIT) {
	            var otherOptions = {};
	            // if (!!count) {
	            //     otherOptions.maxLength = count.total + "";
	            // }
	            if (!!leftAddon) {
	                arr.push(leftAddon);
	            }
	            arr.push(React.createElement('input', _extends({
	                className: classnames({
	                    "kuma-input": true,
	                    'kuma-uxform-input-has-right': !!count || !!rightAddon,
	                    "kuma-uxform-input-has-left": !!leftAddon
	                }),
	                ref: 'root',
	                key: me.props.inputType,
	                type: me.props.inputType,
	                placeholder: me.props.jsxplaceholder,
	                disabled: me.props.jsxdisabled == "disabled" || me.props.jsxdisabled == true ? "disabled" : "",
	                name: me.props.key,
	                value: me.state.formatValue,
	                onFocus: me.handleFocus.bind(me),
	                onBlur: me.handleBlur.bind(me),
	                onChange: me.handleChange.bind(me),
	                onKeyDown: me.handleKeyDown.bind(me)
	            }, otherOptions)));

	            if (!!rightAddon) {
	                arr.push(rightAddon);
	            } else if (!!count) {
	                arr.push(count.element);
	            }
	        } else if (mode == Constants.MODE.VIEW) {
	            arr.push(React.createElement(
	                'span',
	                { key: 'text' },
	                me.state.formatValue
	            ));
	        }
	        return arr;
	    };

	    return InputFormField;
	}(FormField);

	InputFormField.Count = FormCount;
	InputFormField.LeftAddon = LeftAddon;
	InputFormField.RightAddon = RightAddon;
	InputFormField.propTypes = assign({}, FormField.propTypes, {
	    onBlur: React.PropTypes.func,
	    onFocus: React.PropTypes.func,
	    onKeyDown: React.PropTypes.func,
	    validateOnBlur: React.PropTypes.bool,
	    autoTrim: React.PropTypes.bool,
	    inputType: React.PropTypes.string
	});
	InputFormField.defaultProps = assign({}, FormField.defaultProps, {
	    onBlur: function onBlur() {},
	    onFocus: function onFocus() {},
	    onKeyDown: function onKeyDown() {},
	    validateOnBlur: false,
	    inputType: 'text'
	});
	InputFormField.displayName = "InputFormField";
	module.exports = InputFormField;

/***/ },
/* 372 */
[593, 373],
/* 373 */
241,
/* 374 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	/**
	 * DateFormField Component for uxcore
	 * @author eternalsky
	 *
	 * Copyright 2015-2016, Uxcore Team, Alinw.
	 * All rights reserved.
	 */

	module.exports = __webpack_require__(375);

/***/ },
/* 375 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

	function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	/**
	 * DateFormField Component for uxcore
	 * @author eternalsky
	 *
	 * Copyright 2015-2016, Uxcore Team, Alinw.
	 * All rights reserved.
	 */

	var FormField = __webpack_require__(274);
	var Constants = __webpack_require__(272);
	var classnames = __webpack_require__(19);
	var Calendar = __webpack_require__(376);
	var assign = __webpack_require__(284);
	var deepcopy = __webpack_require__(285);
	var Formatter = __webpack_require__(372);

	var DateFormField = function (_FormField) {
	    _inherits(DateFormField, _FormField);

	    function DateFormField(props) {
	        _classCallCheck(this, DateFormField);

	        return _possibleConstructorReturn(this, _FormField.call(this, props));
	    }

	    DateFormField.prototype.handleChange = function handleChange(value) {
	        var me = this;
	        me.handleDataChange(new Date(value).getTime());
	    };

	    DateFormField.prototype.handleCascadeChange = function handleCascadeChange(i, value) {
	        var me = this;
	        var values = deepcopy(me.state.value) || [];
	        values[i] = new Date(value).getTime();
	        if (i == 0 && !!values[1] && new Date(value).getTime() > new Date(values[1]).getTime()) {
	            values.pop();
	        }
	        if (i == 1 && !!values[0] && new Date(value).getTime() < new Date(values[0]).getTime()) {
	            values[0] = undefined;
	        }
	        me.handleDataChange(values);
	    };

	    DateFormField.prototype.addSpecificClass = function addSpecificClass() {
	        var me = this;
	        if (me.props.jsxprefixCls == "kuma-uxform-field") {
	            var str = me.props.jsxprefixCls + " kuma-date-uxform-field";
	            if (me.props.jsxtype == "cascade") {
	                str += " kuma-cascade-date-uxform-field";
	            }
	            return str;
	        } else {
	            return me.props.jsxprefixCls;
	        }
	    };

	    DateFormField.prototype.processTime = function processTime(time) {
	        // if showTime is true or timePicker is set, we use time to compare
	        // otherwise we use day to compare
	        var me = this;
	        var _me$props = me.props;
	        var showTime = _me$props.showTime;
	        var timePicker = _me$props.timePicker;

	        if (showTime || timePicker) {
	            return new Date(time).getTime();
	        } else {
	            return new Date(Formatter.date(time, 'YYYY-MM-DD')).getTime();
	        }
	    };

	    DateFormField.prototype.renderField = function renderField() {
	        var me = this;
	        var _me$props2 = me.props;
	        var onSelect = _me$props2.onSelect;
	        var style = _me$props2.style;
	        var prefixCls = _me$props2.prefixCls;
	        var value = _me$props2.value;
	        var jsxtype = _me$props2.jsxtype;
	        var jsxfrom = _me$props2.jsxfrom;
	        var jsxto = _me$props2.jsxto;
	        var disabledDate = _me$props2.disabledDate;

	        var others = _objectWithoutProperties(_me$props2, ['onSelect', 'style', 'prefixCls', 'value', 'jsxtype', 'jsxfrom', 'jsxto', 'disabledDate']);

	        var from = !!jsxfrom ? me.processTime(jsxfrom) : 0;
	        var to = !!jsxto ? me.processTime(jsxto) : Infinity;
	        var mode = me.props.jsxmode || me.props.mode;
	        if (mode == Constants.MODE.EDIT) {
	            if (jsxtype == "single") {
	                return React.createElement(Calendar, _extends({
	                    value: me.state.value,
	                    onSelect: me.handleChange.bind(me),
	                    disabledDate: disabledDate ? disabledDate : function (current, value) {
	                        // if showTime is true or timePicker is set, we use time to compare
	                        // otherwise we use day to compare

	                        return me.processTime(current.getTime()) < from || me.processTime(current.getTime()) > to;
	                    }
	                }, others));
	            } else if (jsxtype == "cascade") {
	                var arr = [];
	                var others1 = assign({}, others);
	                var others2 = assign({}, others);
	                if (me.state.value && me.state.value[0]) {
	                    others1 = assign({}, others, {
	                        value: me.state.value[0]
	                    });
	                } else {
	                    others1 = assign({}, others, {
	                        value: null
	                    });
	                }
	                if (me.state.value && me.state.value[1]) {
	                    others2 = assign({}, others, {
	                        value: me.state.value[1]
	                    });
	                } else {
	                    others2 = assign({}, others, {
	                        value: null
	                    });
	                }
	                arr.push(React.createElement(Calendar, _extends({
	                    key: 'calendar1',
	                    onSelect: me.handleCascadeChange.bind(me, 0),
	                    disabledDate: function disabledDate(current, value) {
	                        var now = me.processTime(current.getTime());
	                        return now < from || now > to;
	                    }
	                }, others1)));
	                arr.push(React.createElement(
	                    'span',
	                    { key: 'split', className: 'kuma-uxform-split' },
	                    '-'
	                ));

	                arr.push(React.createElement(Calendar, _extends({
	                    key: 'calendar2',
	                    onSelect: me.handleCascadeChange.bind(me, 1),
	                    disabledDate: function disabledDate(current, value) {
	                        var now = me.processTime(current.getTime());
	                        var first = me.state.value ? me.state.value[0] : 0;
	                        first = me.processTime(first);
	                        return now < from || now > to || now < first;
	                    }
	                }, others2)));
	                return arr;
	            }
	        } else if (mode == Constants.MODE.VIEW) {
	            var _ret = function () {
	                var defautFormat = 'YYYY-MM-DD';
	                if (me.props.showTime || me.props.timePicker) {
	                    defautFormat = 'YYYY-MM-DD HH:mm:ss';
	                }
	                if (jsxtype == "single") {
	                    return {
	                        v: React.createElement(
	                            'span',
	                            null,
	                            !!me.state.value ? Formatter.date(me.state.value, me.props.format || defautFormat) : ""
	                        )
	                    };
	                } else {
	                    return {
	                        v: React.createElement(
	                            'span',
	                            null,
	                            !!me.state.value ? me.state.value.map(function (item) {
	                                return Formatter.date(item, me.props.format || defautFormat);
	                            }).join(" - ") : ""
	                        )
	                    };
	                }
	            }();

	            if ((typeof _ret === 'undefined' ? 'undefined' : _typeof(_ret)) === "object") return _ret.v;
	        }
	    };

	    return DateFormField;
	}(FormField);

	DateFormField.displayName = "DateFormField";
	DateFormField.propTypes = assign(FormField.propTypes, {
	    jsxtype: React.PropTypes.string
	});
	DateFormField.defaultProps = assign(FormField.defaultProps, {
	    locale: 'zh-cn',
	    hasTrigger: true,
	    jsxtype: "single"
	});
	module.exports = DateFormField;

/***/ },
/* 376 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	/**
	 * Calendar Component for uxcore
	 * @author 
	 *
	 * Copyright 2014-2015, Uxcore Team, Alinw.
	 * All rights reserved.
	 */

	module.exports = __webpack_require__(377);

/***/ },
/* 377 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var RcCalendar = __webpack_require__(378);
	var GregorianCalendar = __webpack_require__(379);
	var DateTimeFormat = __webpack_require__(409);
	var Datepicker = __webpack_require__(424);
	var RcMonthCalendar = __webpack_require__(452);
	var RcYearCalendar = __webpack_require__(453);
	var TimePicker = __webpack_require__(454);
	var util = __webpack_require__(491);
	var React = __webpack_require__(7);

	var defaultValueLocale = {};
	var CalendarLocale = {};
	var TimePickerLocale = {};
	defaultValueLocale['zh-cn'] = __webpack_require__(524);
	defaultValueLocale['en-us'] = __webpack_require__(382);
	CalendarLocale['zh-cn'] = __webpack_require__(525);
	CalendarLocale['en-us'] = __webpack_require__(422);
	TimePickerLocale['zh-cn'] = __webpack_require__(527);
	TimePickerLocale['en-us'] = __webpack_require__(484);

	function getGregorianCalendarDate(date, locale) {
	    defaultValueLocale[locale].timezoneOffset = -new Date().getTimezoneOffset();
	    var value = new GregorianCalendar(defaultValueLocale[locale]);
	    value.setTime(new Date(date).valueOf());
	    return value;
	}

	function getCalendarContainer() {
	    var c = document.createElement('div');
	    c.className = 'uxcore';
	    document.body.appendChild(c);
	    return c;
	}

	var Calendar = function (_React$Component) {
	    _inherits(Calendar, _React$Component);

	    function Calendar(props) {
	        _classCallCheck(this, Calendar);

	        var _this = _possibleConstructorReturn(this, _React$Component.call(this, props));

	        _this.state = {};
	        return _this;
	    }

	    Calendar.prototype.componentWillMount = function componentWillMount() {
	        var me = this;
	        me.TimePickerElement = React.createElement(TimePicker, { prefixCls: 'kuma-time-picker', locale: TimePickerLocale[me.props.locale] });
	    };

	    Calendar.prototype.render = function render() {
	        var _this2 = this;

	        var me = this;
	        var p = me.props;
	        var formatter = new DateTimeFormat(p.format);
	        var calendarOptions = {
	            className: p.className,
	            style: p.style,
	            contentRender: p.contentRender,
	            disabledDate: p.disabledDate,
	            showWeekNumber: p.showWeekNumber,
	            showToday: p.showToday,
	            timePicker: p.timePicker ? p.timePicker : p.showTime ? me.TimePickerElement : null,
	            showDateInput: p.showDateInput,
	            locale: CalendarLocale[p.locale],
	            prefixCls: 'kuma-calendar'
	        };
	        var pickerOptions = {
	            disabled: p.disabled,
	            formatter: formatter,
	            align: p.align,
	            transitionName: p.transitionName,
	            adjustOrientOnCalendarOverflow: false,
	            prefixCls: 'kuma-calendar-picker',
	            placement: 'bottomLeft',
	            getCalendarContainer: p.getPopupContainer || getCalendarContainer
	        };

	        if (p.value) {
	            var value = getGregorianCalendarDate(p.value, p.locale);
	            pickerOptions.value = calendarOptions.defaultValue = value;
	        } else {
	            pickerOptions.value = calendarOptions.defaultValue = null;
	        }

	        if (p.defaultValue) {
	            var value = getGregorianCalendarDate(p.defaultValue, p.locale);
	            calendarOptions.defaultValue = value;
	            pickerOptions.defaultValue = value;
	        } else {
	            var value = getGregorianCalendarDate(new Date().getTime(), p.locale);
	            calendarOptions.defaultValue = value;
	        }
	        if (p.hasTrigger) {
	            pickerOptions.trigger = React.createElement('i', { className: 'kuma-icon kuma-icon-calender' });
	        }

	        var calendar = React.createElement(RcCalendar, calendarOptions);

	        function _onChange(v) {
	            if (v) {
	                var date = v.getTime();
	                var value = getGregorianCalendarDate(date, p.locale);
	                this.props.onSelect(new Date(date), formatter.format(value));
	            } else {
	                this.props.onSelect(v, v);
	            }
	        }

	        return React.createElement(
	            Datepicker,
	            _extends({
	                calendar: calendar,
	                onChange: _onChange.bind(me)
	            }, pickerOptions),
	            function (_ref) {
	                var value = _ref.value;

	                return React.createElement(
	                    'span',
	                    { className: 'kuma-calendar-picker-input' },
	                    React.createElement('input', { value: value && formatter.format(value), readOnly: true, disabled: me.props.disabled, placeholder: _this2.props.placeholder, className: 'kuma-input' }),
	                    p.hasTrigger ? React.createElement('i', { className: 'kuma-icon kuma-icon-calender' }) : null
	                );
	            }
	        );
	    };

	    return Calendar;
	}(React.Component);

	Calendar.displayName = 'Calendar';
	Calendar.defaultProps = {
	    format: 'yyyy-MM-dd',
	    placeholder: '请选择日期',
	    onSelect: function onSelect() {},
	    locale: 'zh-cn',
	    align: {
	        offset: [0, 0]
	    },
	    showDateInput: false,
	    hasTrigger: true,
	    transitionName: 'slideUp'
	};
	Calendar.propTypes = {
	    format: React.PropTypes.string,
	    placeholder: React.PropTypes.string,
	    onSelect: React.PropTypes.func,
	    locale: React.PropTypes.string,
	    hasTrigger: React.PropTypes.bool,
	    getPopupContainer: React.PropTypes.func
	};

	var MonthCalendar = function (_React$Component2) {
	    _inherits(MonthCalendar, _React$Component2);

	    function MonthCalendar(props) {
	        _classCallCheck(this, MonthCalendar);

	        var _this3 = _possibleConstructorReturn(this, _React$Component2.call(this, props));

	        _this3.state = {};
	        return _this3;
	    }

	    MonthCalendar.prototype.render = function render() {
	        var _this4 = this;

	        var me = this;
	        var p = me.props;
	        var formatter = new DateTimeFormat(p.format);
	        var calendarOptions = {
	            className: p.className,
	            style: p.style,
	            locale: CalendarLocale[p.locale],
	            orient: ['top', 'left'],
	            prefixCls: 'kuma-calendar'
	        };
	        var pickerOptions = {
	            disabled: p.disabled,
	            align: p.align,
	            transitionName: p.transitionName,
	            formatter: formatter,
	            adjustOrientOnCalendarOverflow: false,
	            prefixCls: 'kuma-calendar-picker',
	            getCalendarContainer: p.getPopupContainer || getCalendarContainer
	        };

	        if (p.value) {
	            var value = getGregorianCalendarDate(p.value, p.locale);
	            pickerOptions.value = calendarOptions.defaultValue = value;
	        } else {
	            pickerOptions.value = calendarOptions.defaultValue = null;
	        }

	        if (p.defaultValue) {
	            var value = getGregorianCalendarDate(p.defaultValue, p.locale);
	            calendarOptions.defaultValue = value;
	        }
	        var calendar = React.createElement(RcMonthCalendar, calendarOptions);

	        function _onChange(v) {
	            var date = v.getTime();
	            var value = getGregorianCalendarDate(date, p.locale);
	            this.props.onSelect(new Date(date), formatter.format(value));
	        }

	        return React.createElement(
	            Datepicker,
	            _extends({
	                calendar: calendar,
	                onChange: _onChange.bind(me)
	            }, pickerOptions),
	            function (_ref2) {
	                var value = _ref2.value;

	                return React.createElement(
	                    'span',
	                    { className: 'kuma-calendar-picker-input' },
	                    React.createElement('input', { value: value && formatter.format(value), readOnly: true, disabled: me.props.disabled, placeholder: _this4.props.placeholder, className: 'kuma-input' }),
	                    p.hasTrigger ? React.createElement('i', { className: 'kuma-icon kuma-icon-calender' }) : null
	                );
	            }
	        );
	    };

	    return MonthCalendar;
	}(React.Component);

	MonthCalendar.displayName = 'MonthCalendar';
	MonthCalendar.defaultProps = {
	    format: 'yyyy-MM',
	    placeholder: '请选择月份',
	    onSelect: function onSelect() {},
	    locale: 'zh-cn',
	    transitionName: 'slideUp',
	    align: {
	        offset: [0, 0]
	    },
	    showDateInput: false,
	    hasTrigger: true
	};
	MonthCalendar.propTypes = {
	    format: React.PropTypes.string,
	    placeholder: React.PropTypes.string,
	    onSelect: React.PropTypes.func,
	    locale: React.PropTypes.string,
	    getPopupContainer: React.PropTypes.func
	};

	var YearCalendar = function (_React$Component3) {
	    _inherits(YearCalendar, _React$Component3);

	    function YearCalendar(props) {
	        _classCallCheck(this, YearCalendar);

	        var _this5 = _possibleConstructorReturn(this, _React$Component3.call(this, props));

	        _this5.state = {};
	        return _this5;
	    }

	    YearCalendar.prototype.render = function render() {
	        var _this6 = this;

	        var me = this;
	        var p = me.props;
	        var formatter = new DateTimeFormat(p.format);
	        var calendarOptions = {
	            className: p.className,
	            style: p.style,
	            locale: CalendarLocale[p.locale],
	            orient: ['top', 'left'],
	            prefixCls: 'kuma-calendar'
	        };
	        var pickerOptions = {
	            disabled: p.disabled,
	            align: p.align,
	            formatter: formatter,
	            transitionName: p.transitionName,
	            adjustOrientOnCalendarOverflow: false,
	            prefixCls: 'kuma-calendar-picker',
	            getCalendarContainer: p.getPopupContainer || getCalendarContainer
	        };

	        if (p.value) {
	            var value = getGregorianCalendarDate(p.value, p.locale);
	            pickerOptions.value = calendarOptions.defaultValue = value;
	        } else {
	            pickerOptions.value = calendarOptions.defaultValue = null;
	        }

	        if (p.defaultValue) {
	            var value = getGregorianCalendarDate(p.defaultValue, p.locale);
	            calendarOptions.defaultValue = value;
	        }
	        var calendar = React.createElement(RcYearCalendar, calendarOptions);

	        function _onChange(v) {
	            var date = v.getTime();
	            var value = getGregorianCalendarDate(date, p.locale);
	            this.props.onSelect(new Date(date), formatter.format(value));
	        }

	        return React.createElement(
	            Datepicker,
	            _extends({
	                calendar: calendar,
	                onChange: _onChange.bind(me)
	            }, pickerOptions),
	            function (_ref3) {
	                var value = _ref3.value;

	                return React.createElement(
	                    'span',
	                    { className: 'kuma-calendar-picker-input' },
	                    React.createElement('input', { value: value && formatter.format(value), readOnly: true, disabled: me.props.disabled, placeholder: _this6.props.placeholder, className: 'kuma-input' }),
	                    p.hasTrigger ? React.createElement('i', { className: 'kuma-icon kuma-icon-calender' }) : null
	                );
	            }
	        );
	    };

	    return YearCalendar;
	}(React.Component);

	YearCalendar.displayName = 'YearCalendar';
	YearCalendar.defaultProps = {
	    format: 'yyyy',
	    placeholder: '请选择年份',
	    onSelect: function onSelect() {},
	    locale: 'zh-cn',
	    transitionName: 'slideUp',
	    align: {
	        offset: [0, 0]
	    },
	    showDateInput: false,
	    hasTrigger: true
	};
	YearCalendar.propTypes = {
	    format: React.PropTypes.string,
	    placeholder: React.PropTypes.string,
	    onSelect: React.PropTypes.func,
	    locale: React.PropTypes.string,
	    getPopupContainer: React.PropTypes.func
	};

	Calendar.MonthCalendar = MonthCalendar;
	Calendar.YearCalendar = YearCalendar;
	Calendar.CalendarPanel = RcCalendar;
	Calendar.util = util;

	module.exports = Calendar;

/***/ },
/* 378 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _react = __webpack_require__(7);

	var _react2 = _interopRequireDefault(_react);

	var _gregorianCalendar = __webpack_require__(379);

	var _gregorianCalendar2 = _interopRequireDefault(_gregorianCalendar);

	var _rcUtil = __webpack_require__(383);

	var _DateTable = __webpack_require__(403);

	var _DateTable2 = _interopRequireDefault(_DateTable);

	var _CalendarHeader = __webpack_require__(412);

	var _CalendarHeader2 = _interopRequireDefault(_CalendarHeader);

	var _CalendarFooter = __webpack_require__(417);

	var _CalendarFooter2 = _interopRequireDefault(_CalendarFooter);

	var _CalendarMixin = __webpack_require__(420);

	var _CalendarMixin2 = _interopRequireDefault(_CalendarMixin);

	var _CommonMixin = __webpack_require__(421);

	var _CommonMixin2 = _interopRequireDefault(_CommonMixin);

	var _DateInput = __webpack_require__(423);

	var _DateInput2 = _interopRequireDefault(_DateInput);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

	function noop() {} // customized rc-calendar https://github.com/react-component/calendar/blob/master/src/Calendar.jsx

	function goStartMonth() {
	  var next = this.state.value.clone();
	  next.setDayOfMonth(1);
	  this.setValue(next);
	}

	function goEndMonth() {
	  var next = this.state.value.clone();
	  next.setDayOfMonth(next.getActualMaximum(_gregorianCalendar2["default"].MONTH));
	  this.setValue(next);
	}

	function goMonth(direction) {
	  var next = this.state.value.clone();
	  next.addMonth(direction);
	  this.setValue(next);
	}

	function goYear(direction) {
	  var next = this.state.value.clone();
	  next.addYear(direction);
	  this.setValue(next);
	}

	function goWeek(direction) {
	  var next = this.state.value.clone();
	  next.addWeekOfYear(direction);
	  this.setValue(next);
	}

	function goDay(direction) {
	  var next = this.state.value.clone();
	  next.addDayOfMonth(direction);
	  this.setValue(next);
	}

	var Calendar = _react2["default"].createClass({
	  displayName: 'Calendar',

	  propTypes: {
	    disabledDate: _react.PropTypes.func,
	    disabledTime: _react.PropTypes.any,
	    value: _react.PropTypes.object,
	    selectedValue: _react.PropTypes.object,
	    defaultValue: _react.PropTypes.object,
	    className: _react.PropTypes.string,
	    locale: _react.PropTypes.object,
	    showWeekNumber: _react.PropTypes.bool,
	    style: _react.PropTypes.object,
	    showToday: _react.PropTypes.bool,
	    showDateInput: _react.PropTypes.bool,
	    visible: _react.PropTypes.bool,
	    onSelect: _react.PropTypes.func,
	    onOk: _react.PropTypes.func,
	    showOk: _react.PropTypes.bool,
	    prefixCls: _react.PropTypes.string,
	    onKeyDown: _react.PropTypes.func,
	    timePicker: _react.PropTypes.element,
	    dateInputPlaceholder: _react.PropTypes.any,
	    onClear: _react.PropTypes.func,
	    onChange: _react.PropTypes.func
	  },

	  mixins: [_CommonMixin2["default"], _CalendarMixin2["default"]],

	  getDefaultProps: function getDefaultProps() {
	    return {
	      showToday: true,
	      showDateInput: true,
	      timePicker: null,
	      onOk: noop
	    };
	  },
	  getInitialState: function getInitialState() {
	    // bind methods
	    this.nextMonth = goMonth.bind(this, 1);
	    this.previousMonth = goMonth.bind(this, -1);
	    this.nextYear = goYear.bind(this, 1);
	    this.previousYear = goYear.bind(this, -1);
	    return {};
	  },
	  onKeyDown: function onKeyDown(event) {
	    if (event.target.nodeName.toLowerCase() === 'input') {
	      return undefined;
	    }
	    var keyCode = event.keyCode;
	    // mac
	    var ctrlKey = event.ctrlKey || event.metaKey;
	    switch (keyCode) {
	      case _rcUtil.KeyCode.DOWN:
	        goWeek.call(this, 1);
	        event.preventDefault();
	        return 1;
	      case _rcUtil.KeyCode.UP:
	        goWeek.call(this, -1);
	        event.preventDefault();
	        return 1;
	      case _rcUtil.KeyCode.LEFT:
	        if (ctrlKey) {
	          this.previousYear();
	        } else {
	          goDay.call(this, -1);
	        }
	        event.preventDefault();
	        return 1;
	      case _rcUtil.KeyCode.RIGHT:
	        if (ctrlKey) {
	          this.nextYear();
	        } else {
	          goDay.call(this, 1);
	        }
	        event.preventDefault();
	        return 1;
	      case _rcUtil.KeyCode.HOME:
	        goStartMonth.call(this);
	        event.preventDefault();
	        return 1;
	      case _rcUtil.KeyCode.END:
	        goEndMonth.call(this);
	        event.preventDefault();
	        return 1;
	      case _rcUtil.KeyCode.PAGE_DOWN:
	        this.nextMonth();
	        event.preventDefault();
	        return 1;
	      case _rcUtil.KeyCode.PAGE_UP:
	        this.previousMonth();
	        event.preventDefault();
	        return 1;
	      case _rcUtil.KeyCode.ENTER:
	        this.onSelect(this.state.value);
	        event.preventDefault();
	        return 1;
	      default:
	        this.props.onKeyDown(event);
	        return 1;
	    }
	  },
	  onClear: function onClear() {
	    this.onSelect(null);
	    this.props.onClear();
	  },
	  onOk: function onOk() {
	    var selectedValue = this.state.selectedValue;

	    if (this.isAllowedDate(selectedValue)) {
	      this.props.onOk(selectedValue);
	    }
	  },
	  onDateInputChange: function onDateInputChange(value) {
	    this.onSelect(value, {
	      source: 'dateInput'
	    });
	  },
	  onDateTableSelect: function onDateTableSelect(value) {
	    this.onSelect(value);
	  },
	  chooseToday: function chooseToday() {
	    var today = this.state.value.clone();
	    today.setTime(Date.now());
	    this.onSelect(today);
	  },
	  render: function render() {
	    var props = this.props;
	    var locale = props.locale;
	    var prefixCls = props.prefixCls;
	    var disabledDate = props.disabledDate;
	    var dateInputPlaceholder = props.dateInputPlaceholder;
	    var timePicker = props.timePicker;
	    var disabledTime = props.disabledTime;

	    var state = this.state;
	    var value = state.value;
	    var selectedValue = state.selectedValue;

	    var dateInputElement = props.showDateInput ? _react2["default"].createElement(_DateInput2["default"], {
	      formatter: this.getFormatter(),
	      key: 'date-input',
	      timePicker: timePicker,
	      gregorianCalendarLocale: value.locale,
	      locale: locale,
	      placeholder: dateInputPlaceholder,
	      showClear: true,
	      disabledTime: disabledTime,
	      disabledDate: disabledDate,
	      onClear: this.onClear,
	      prefixCls: prefixCls,
	      selectedValue: selectedValue,
	      onChange: this.onDateInputChange
	    }) : null;
	    var children = [dateInputElement, _react2["default"].createElement(
	      'div',
	      {
	        key: 'date-panel',
	        className: prefixCls + '-date-panel'
	      },
	      _react2["default"].createElement(_CalendarHeader2["default"], {
	        locale: locale,
	        onValueChange: this.setValue,
	        value: value,
	        prefixCls: prefixCls
	      }),
	      _react2["default"].createElement(
	        'div',
	        { className: prefixCls + '-calendar-body' },
	        _react2["default"].createElement(_DateTable2["default"], {
	          locale: locale,
	          value: value,
	          selectedValue: selectedValue,
	          prefixCls: prefixCls,
	          dateRender: props.dateRender,
	          contentRender: props.contentRender,
	          onSelect: this.onDateTableSelect,
	          disabledDate: disabledDate,
	          showWeekNumber: props.showWeekNumber
	        })
	      ),
	      _react2["default"].createElement(_CalendarFooter2["default"], {
	        showOk: props.showOk,
	        locale: locale,
	        prefixCls: prefixCls,
	        showToday: props.showToday,
	        disabledTime: disabledTime,
	        gregorianCalendarLocale: value.locale,
	        showDateInput: props.showDateInput,
	        timePicker: timePicker,
	        selectedValue: selectedValue,
	        value: value,
	        disabledDate: disabledDate,
	        onOk: this.onOk,
	        onSelect: this.onSelect,
	        onToday: this.chooseToday
	      })
	    )];

	    return this.renderRoot({
	      children: children,
	      className: props.showWeekNumber ? prefixCls + '-week-number' : ''
	    });
	  }
	});

	exports["default"] = Calendar;
	module.exports = exports['default'];

/***/ },
/* 379 */
/***/ function(module, exports, __webpack_require__) {

	/*
	 * GregorianCalendar class
	 * @ignore
	 * @author yiminghe@gmail.com
	 */
	'use strict';

	var toInt = parseInt;
	var Utils = __webpack_require__(380);
	var defaultLocale = __webpack_require__(382);
	var Const = __webpack_require__(381);

	/*
	 * GregorianCalendar class.
	 *
	 * - no arguments:
	 *   Constructs a default GregorianCalendar using the current time
	 *   in the default time zone with the default locale.
	 * - one argument locale:
	 *   Constructs a GregorianCalendar
	 *   based on the current time in the default time zone with the given locale.
	 *
	 * @class Date.Gregorian
	 */
	function GregorianCalendar(loc) {
	  var locale = loc || defaultLocale;

	  this.locale = locale;

	  this.fields = [];

	  /*
	   * The currently set time for this date.
	   * @protected
	   * @type Number|undefined
	   */
	  this.time = undefined;
	  /*
	   * The timezoneOffset in minutes used by this date.
	   * @type Number
	   * @protected
	   */

	  this.timezoneOffset = locale.timezoneOffset;

	  /*
	   * The first day of the week
	   * @type Number
	   * @protected
	   */
	  this.firstDayOfWeek = locale.firstDayOfWeek;

	  /*
	   * The number of days required for the first week in a month or year,
	   * with possible values from 1 to 7.
	   * @@protected
	   * @type Number
	   */
	  this.minimalDaysInFirstWeek = locale.minimalDaysInFirstWeek;

	  this.fieldsComputed = false;
	}

	Utils.mix(GregorianCalendar, Const);

	Utils.mix(GregorianCalendar, {
	  Utils: Utils,

	  defaultLocale: defaultLocale,

	  /*
	   * Determines if the given year is a leap year.
	   * Returns true if the given year is a leap year. To specify BC year numbers,
	   * 1 - year number must be given. For example, year BC 4 is specified as -3.
	   * @param {Number} year the given year.
	   * @returns {Boolean} true if the given year is a leap year; false otherwise.
	   * @static
	   * @method
	   */
	  isLeapYear: Utils.isLeapYear,

	  /*
	   * Enum indicating year field of date
	   * @type Number
	   */
	  YEAR: 1,
	  /*
	   * Enum indicating month field of date
	   * @type Number
	   */
	  MONTH: 2,
	  /*
	   * Enum indicating the day of the month
	   * @type Number
	   */
	  DAY_OF_MONTH: 3,
	  /*
	   * Enum indicating the hour (24).
	   * @type Number
	   */
	  HOUR_OF_DAY: 4,
	  /*
	   * Enum indicating the minute of the day
	   * @type Number
	   */
	  MINUTES: 5,
	  /*
	   * Enum indicating the second of the day
	   * @type Number
	   */
	  SECONDS: 6,
	  /*
	   * Enum indicating the millisecond of the day
	   * @type Number
	   */
	  MILLISECONDS: 7,
	  /*
	   * Enum indicating the week number within the current year
	   * @type Number
	   */
	  WEEK_OF_YEAR: 8,
	  /*
	   * Enum indicating the week number within the current month
	   * @type Number
	   */
	  WEEK_OF_MONTH: 9,

	  /*
	   * Enum indicating the day of the day number within the current year
	   * @type Number
	   */
	  DAY_OF_YEAR: 10,
	  /*
	   * Enum indicating the day of the week
	   * @type Number
	   */
	  DAY_OF_WEEK: 11,
	  /*
	   * Enum indicating the day of the ordinal number of the day of the week
	   * @type Number
	   */
	  DAY_OF_WEEK_IN_MONTH: 12,

	  /*
	   * Enum indicating am
	   * @type Number
	   */
	  AM: 0,
	  /*
	   * Enum indicating pm
	   * @type Number
	   */
	  PM: 1
	});

	var FIELDS = ['', 'Year', 'Month', 'DayOfMonth', 'HourOfDay', 'Minutes', 'Seconds', 'Milliseconds', 'WeekOfYear', 'WeekOfMonth', 'DayOfYear', 'DayOfWeek', 'DayOfWeekInMonth'];

	var YEAR = GregorianCalendar.YEAR;
	var MONTH = GregorianCalendar.MONTH;
	var DAY_OF_MONTH = GregorianCalendar.DAY_OF_MONTH;
	var HOUR_OF_DAY = GregorianCalendar.HOUR_OF_DAY;
	var MINUTE = GregorianCalendar.MINUTES;
	var SECONDS = GregorianCalendar.SECONDS;

	var MILLISECONDS = GregorianCalendar.MILLISECONDS;
	var DAY_OF_WEEK_IN_MONTH = GregorianCalendar.DAY_OF_WEEK_IN_MONTH;
	var DAY_OF_YEAR = GregorianCalendar.DAY_OF_YEAR;
	var DAY_OF_WEEK = GregorianCalendar.DAY_OF_WEEK;

	var WEEK_OF_MONTH = GregorianCalendar.WEEK_OF_MONTH;
	var WEEK_OF_YEAR = GregorianCalendar.WEEK_OF_YEAR;

	var MONTH_LENGTH = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]; // 0-based
	var LEAP_MONTH_LENGTH = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]; // 0-based

	var ONE_SECOND = 1000;
	var ONE_MINUTE = 60 * ONE_SECOND;
	var ONE_HOUR = 60 * ONE_MINUTE;
	var ONE_DAY = 24 * ONE_HOUR;
	var ONE_WEEK = ONE_DAY * 7;

	var EPOCH_OFFSET = 719163; // Fixed date of January 1, 1970 (Gregorian)

	var mod = Utils.mod;
	var _isLeapYear = Utils.isLeapYear;
	var floorDivide = Math.floor;

	var MIN_VALUES = [undefined, 1, // YEAR
	GregorianCalendar.JANUARY, // MONTH
	1, // DAY_OF_MONTH
	0, // HOUR_OF_DAY
	0, // MINUTE
	0, // SECONDS
	0, // MILLISECONDS

	1, // WEEK_OF_YEAR
	undefined, // WEEK_OF_MONTH

	1, // DAY_OF_YEAR
	GregorianCalendar.SUNDAY, // DAY_OF_WEEK
	1];

	// DAY_OF_WEEK_IN_MONTH
	var MAX_VALUES = [undefined, 292278994, // YEAR
	GregorianCalendar.DECEMBER, // MONTH
	undefined, // DAY_OF_MONTH
	23, // HOUR_OF_DAY
	59, // MINUTE
	59, // SECONDS
	999, // MILLISECONDS
	undefined, // WEEK_OF_YEAR
	undefined, // WEEK_OF_MONTH
	undefined, // DAY_OF_YEAR
	GregorianCalendar.SATURDAY, // DAY_OF_WEEK
	undefined];

	// ------------------- private start

	// DAY_OF_WEEK_IN_MONTH
	function getMonthLength(year, month) {
	  return _isLeapYear(year) ? LEAP_MONTH_LENGTH[month] : MONTH_LENGTH[month];
	}

	function getYearLength(year) {
	  return _isLeapYear(year) ? 366 : 365;
	}

	function adjustDayOfMonth(self) {
	  var fields = self.fields;
	  var year = fields[YEAR];
	  var month = fields[MONTH];
	  var monthLen = getMonthLength(year, month);
	  var dayOfMonth = fields[DAY_OF_MONTH];
	  if (dayOfMonth > monthLen) {
	    self.set(DAY_OF_MONTH, monthLen);
	  }
	}

	function getDayOfWeekDateOnOrBefore(fixedDate, dayOfWeek) {
	  // 1.1.1 is monday
	  // one week has 7 days
	  return fixedDate - mod(fixedDate - dayOfWeek, 7);
	}

	function getWeekNumber(self, fixedDay1, fixedDate) {
	  var fixedDay1st = getDayOfWeekDateOnOrBefore(fixedDay1 + 6, self.firstDayOfWeek);
	  var nDays = fixedDay1st - fixedDay1;
	  if (nDays >= self.minimalDaysInFirstWeek) {
	    fixedDay1st -= 7;
	  }
	  var normalizedDayOfPeriod = fixedDate - fixedDay1st;
	  return floorDivide(normalizedDayOfPeriod / 7) + 1;
	}

	// ------------------- private end

	GregorianCalendar.prototype = {
	  constructor: GregorianCalendar,

	  isGregorianCalendar: 1,

	  /*
	   * Determines if current year is a leap year.
	   * Returns true if the given year is a leap year. To specify BC year numbers,
	   * 1 - year number must be given. For example, year BC 4 is specified as -3.
	   * @returns {Boolean} true if the given year is a leap year; false otherwise.
	   * @method
	   * @member Date.Gregorian
	   */
	  isLeapYear: function isLeapYear() {
	    return _isLeapYear(this.getYear());
	  },

	  /*
	   * Return local info for current date instance
	   * @returns {Object}
	   */
	  getLocale: function getLocale() {
	    return this.locale;
	  },

	  /*
	   * Returns the minimum value for
	   * the given calendar field of this GregorianCalendar instance.
	   * The minimum value is defined as the smallest value
	   * returned by the get method for any possible time value,
	   * taking into consideration the current values of the getFirstDayOfWeek,
	   * getMinimalDaysInFirstWeek.
	   * @param field the calendar field.
	   * @returns {Number} the minimum value for the given calendar field.
	   */
	  getActualMinimum: function getActualMinimum(field) {
	    if (MIN_VALUES[field] !== undefined) {
	      return MIN_VALUES[field];
	    }
	    if (field === WEEK_OF_MONTH) {
	      var cal = this.clone();
	      cal.clear();
	      cal.set(this.fields[YEAR], this.fields[MONTH], 1);
	      return cal.get(WEEK_OF_MONTH);
	    }

	    throw new Error('minimum value not defined!');
	  },

	  /*
	   * Returns the maximum value for the given calendar field
	   * of this GregorianCalendar instance.
	   * The maximum value is defined as the largest value returned
	   * by the get method for any possible time value, taking into consideration
	   * the current values of the getFirstDayOfWeek, getMinimalDaysInFirstWeek methods.
	   * @param field the calendar field.
	   * @returns {Number} the maximum value for the given calendar field.
	   */
	  getActualMaximum: function getActualMaximum(field) {
	    if (MAX_VALUES[field] !== undefined) {
	      return MAX_VALUES[field];
	    }
	    var value = undefined;
	    var fields = this.fields;
	    switch (field) {
	      case DAY_OF_MONTH:
	        value = getMonthLength(fields[YEAR], fields[MONTH]);
	        break;

	      case WEEK_OF_YEAR:
	        var endOfYear = this.clone();
	        endOfYear.clear();
	        endOfYear.set(fields[YEAR], GregorianCalendar.DECEMBER, 31);
	        value = endOfYear.get(WEEK_OF_YEAR);
	        if (value === 1) {
	          value = 52;
	        }
	        break;

	      case WEEK_OF_MONTH:
	        var endOfMonth = this.clone();
	        endOfMonth.clear();
	        endOfMonth.set(fields[YEAR], fields[MONTH], getMonthLength(fields[YEAR], fields[MONTH]));
	        value = endOfMonth.get(WEEK_OF_MONTH);
	        break;

	      case DAY_OF_YEAR:
	        value = getYearLength(fields[YEAR]);
	        break;

	      case DAY_OF_WEEK_IN_MONTH:
	        value = toInt((getMonthLength(fields[YEAR], fields[MONTH]) - 1) / 7) + 1;
	        break;
	      default:
	        break;
	    }
	    if (value === undefined) {
	      throw new Error('maximum value not defined!');
	    }
	    return value;
	  },

	  /*
	   * Determines if the given calendar field has a value set,
	   * including cases that the value has been set by internal fields calculations
	   * triggered by a get method call.
	   * @param field the calendar field to be cleared.
	   * @returns {boolean} true if the given calendar field has a value set; false otherwise.
	   */
	  isSet: function isSet(field) {
	    return this.fields[field] !== undefined;
	  },

	  /*
	   * Converts the time value (millisecond offset from the Epoch)
	   * to calendar field values.
	   * @protected
	   */
	  computeFields: function computeFields() {
	    var time = this.time;
	    var timezoneOffset = this.timezoneOffset * ONE_MINUTE;
	    var fixedDate = toInt(timezoneOffset / ONE_DAY);
	    var timeOfDay = timezoneOffset % ONE_DAY;
	    fixedDate += toInt(time / ONE_DAY);
	    timeOfDay += time % ONE_DAY;
	    if (timeOfDay >= ONE_DAY) {
	      timeOfDay -= ONE_DAY;
	      fixedDate++;
	    } else {
	      while (timeOfDay < 0) {
	        timeOfDay += ONE_DAY;
	        fixedDate--;
	      }
	    }

	    fixedDate += EPOCH_OFFSET;

	    var date = Utils.getGregorianDateFromFixedDate(fixedDate);

	    var year = date.year;

	    var fields = this.fields;
	    fields[YEAR] = year;
	    fields[MONTH] = date.month;
	    fields[DAY_OF_MONTH] = date.dayOfMonth;
	    fields[DAY_OF_WEEK] = date.dayOfWeek;

	    if (timeOfDay !== 0) {
	      fields[HOUR_OF_DAY] = toInt(timeOfDay / ONE_HOUR);
	      var r = timeOfDay % ONE_HOUR;
	      fields[MINUTE] = toInt(r / ONE_MINUTE);
	      r %= ONE_MINUTE;
	      fields[SECONDS] = toInt(r / ONE_SECOND);
	      fields[MILLISECONDS] = r % ONE_SECOND;
	    } else {
	      fields[HOUR_OF_DAY] = fields[MINUTE] = fields[SECONDS] = fields[MILLISECONDS] = 0;
	    }

	    var fixedDateJan1 = Utils.getFixedDate(year, GregorianCalendar.JANUARY, 1);
	    var dayOfYear = fixedDate - fixedDateJan1 + 1;
	    var fixDateMonth1 = fixedDate - date.dayOfMonth + 1;

	    fields[DAY_OF_YEAR] = dayOfYear;
	    fields[DAY_OF_WEEK_IN_MONTH] = toInt((date.dayOfMonth - 1) / 7) + 1;

	    var weekOfYear = getWeekNumber(this, fixedDateJan1, fixedDate);

	    // 本周没有足够的时间在当前年
	    if (weekOfYear === 0) {
	      // If the date belongs to the last week of the
	      // previous year, use the week number of "12/31" of
	      // the "previous" year.
	      var fixedDec31 = fixedDateJan1 - 1;
	      var prevJan1 = fixedDateJan1 - getYearLength(year - 1);
	      weekOfYear = getWeekNumber(this, prevJan1, fixedDec31);
	    } else
	      // 本周是年末最后一周，可能有足够的时间在新的一年
	      if (weekOfYear >= 52) {
	        var nextJan1 = fixedDateJan1 + getYearLength(year);
	        var nextJan1st = getDayOfWeekDateOnOrBefore(nextJan1 + 6, this.firstDayOfWeek);
	        var nDays = nextJan1st - nextJan1;
	        // 本周有足够天数在新的一年
	        if (nDays >= this.minimalDaysInFirstWeek &&
	        // 当天确实在本周，weekOfYear === 53 时是不需要这个判断
	        fixedDate >= nextJan1st - 7) {
	          weekOfYear = 1;
	        }
	      }

	    fields[WEEK_OF_YEAR] = weekOfYear;
	    fields[WEEK_OF_MONTH] = getWeekNumber(this, fixDateMonth1, fixedDate);

	    this.fieldsComputed = true;
	  },

	  /*
	   * Converts calendar field values to the time value
	   * (millisecond offset from the Epoch).
	   * @protected
	   */
	  computeTime: function computeTime() {
	    var year = undefined;
	    var fields = this.fields;
	    if (this.isSet(YEAR)) {
	      year = fields[YEAR];
	    } else {
	      year = new Date().getFullYear();
	    }
	    var timeOfDay = 0;
	    if (this.isSet(HOUR_OF_DAY)) {
	      timeOfDay += fields[HOUR_OF_DAY];
	    }
	    timeOfDay *= 60;
	    timeOfDay += fields[MINUTE] || 0;
	    timeOfDay *= 60;
	    timeOfDay += fields[SECONDS] || 0;
	    timeOfDay *= 1000;
	    timeOfDay += fields[MILLISECONDS] || 0;
	    var fixedDate = 0;
	    fields[YEAR] = year;
	    fixedDate = fixedDate + this.getFixedDate();
	    // millis represents local wall-clock time in milliseconds.
	    var millis = (fixedDate - EPOCH_OFFSET) * ONE_DAY + timeOfDay;
	    millis -= this.timezoneOffset * ONE_MINUTE;
	    this.time = millis;
	    this.computeFields();
	  },

	  /*
	   * Fills in any unset fields in the calendar fields. First,
	   * the computeTime() method is called if the time value (millisecond offset from the Epoch)
	   * has not been calculated from calendar field values.
	   * Then, the computeFields() method is called to calculate all calendar field values.
	   * @protected
	   */
	  complete: function complete() {
	    if (this.time === undefined) {
	      this.computeTime();
	    }
	    if (!this.fieldsComputed) {
	      this.computeFields();
	    }
	  },

	  getFixedDate: function getFixedDate() {
	    var self = this;

	    var fields = self.fields;

	    var firstDayOfWeekCfg = self.firstDayOfWeek;

	    var year = fields[YEAR];

	    var month = GregorianCalendar.JANUARY;

	    if (self.isSet(MONTH)) {
	      month = fields[MONTH];
	      if (month > GregorianCalendar.DECEMBER) {
	        year += toInt(month / 12);
	        month %= 12;
	      } else if (month < GregorianCalendar.JANUARY) {
	        year += floorDivide(month / 12);
	        month = mod(month, 12);
	      }
	    }

	    // Get the fixed date since Jan 1, 1 (Gregorian). We are on
	    // the first day of either `month' or January in 'year'.
	    var fixedDate = Utils.getFixedDate(year, month, 1);
	    var firstDayOfWeek = undefined;
	    var dayOfWeek = self.firstDayOfWeek;

	    if (self.isSet(DAY_OF_WEEK)) {
	      dayOfWeek = fields[DAY_OF_WEEK];
	    }

	    if (self.isSet(MONTH)) {
	      if (self.isSet(DAY_OF_MONTH)) {
	        fixedDate += fields[DAY_OF_MONTH] - 1;
	      } else {
	        if (self.isSet(WEEK_OF_MONTH)) {
	          firstDayOfWeek = getDayOfWeekDateOnOrBefore(fixedDate + 6, firstDayOfWeekCfg);

	          // If we have enough days in the first week, then
	          // move to the previous week.
	          if (firstDayOfWeek - fixedDate >= self.minimalDaysInFirstWeek) {
	            firstDayOfWeek -= 7;
	          }

	          if (dayOfWeek !== firstDayOfWeekCfg) {
	            firstDayOfWeek = getDayOfWeekDateOnOrBefore(firstDayOfWeek + 6, dayOfWeek);
	          }

	          fixedDate = firstDayOfWeek + 7 * (fields[WEEK_OF_MONTH] - 1);
	        } else {
	          var dowim = undefined;
	          if (self.isSet(DAY_OF_WEEK_IN_MONTH)) {
	            dowim = fields[DAY_OF_WEEK_IN_MONTH];
	          } else {
	            dowim = 1;
	          }
	          var lastDate = 7 * dowim;
	          if (dowim < 0) {
	            lastDate = getMonthLength(year, month) + 7 * (dowim + 1);
	          }
	          fixedDate = getDayOfWeekDateOnOrBefore(fixedDate + lastDate - 1, dayOfWeek);
	        }
	      }
	    } else {
	      // We are on the first day of the year.
	      if (self.isSet(DAY_OF_YEAR)) {
	        fixedDate += fields[DAY_OF_YEAR] - 1;
	      } else if (self.isSet(WEEK_OF_YEAR)) {
	        firstDayOfWeek = getDayOfWeekDateOnOrBefore(fixedDate + 6, firstDayOfWeekCfg);
	        // If we have enough days in the first week, then move
	        // to the previous week.
	        if (firstDayOfWeek - fixedDate >= self.minimalDaysInFirstWeek) {
	          firstDayOfWeek -= 7;
	        }
	        if (dayOfWeek !== firstDayOfWeekCfg) {
	          firstDayOfWeek = getDayOfWeekDateOnOrBefore(firstDayOfWeek + 6, dayOfWeek);
	        }
	        fixedDate = firstDayOfWeek + 7 * (fields[WEEK_OF_YEAR] - 1);
	      }
	    }

	    return fixedDate;
	  },

	  /*
	   * Returns this Calendar's time value in milliseconds
	   * @member Date.Gregorian
	   * @returns {Number} the current time as UTC milliseconds from the epoch.
	   */
	  getTime: function getTime() {
	    if (this.time === undefined) {
	      this.computeTime();
	    }
	    return this.time;
	  },

	  /*
	   * Sets this Calendar's current time from the given long value.
	   * @param time the new time in UTC milliseconds from the epoch.
	   */
	  setTime: function setTime(time) {
	    this.time = time;
	    this.fieldsComputed = false;
	    this.complete();
	  },

	  /*
	   * Returns the value of the given calendar field.
	   * @param field the given calendar field.
	   * @returns {Number} the value for the given calendar field.
	   */
	  get: function get(field) {
	    this.complete();
	    return this.fields[field];
	  },

	  /*
	   * Returns the year of the given calendar field.
	   * @method getYear
	   * @returns {Number} the year for the given calendar field.
	   */

	  /*
	   * Returns the month of the given calendar field.
	   * @method getMonth
	   * @returns {Number} the month for the given calendar field.
	   */

	  /*
	   * Returns the day of month of the given calendar field.
	   * @method getDayOfMonth
	   * @returns {Number} the day of month for the given calendar field.
	   */

	  /*
	   * Returns the hour of day of the given calendar field.
	   * @method getHourOfDay
	   * @returns {Number} the hour of day for the given calendar field.
	   */

	  /*
	   * Returns the minute of the given calendar field.
	   * @method getMinute
	   * @returns {Number} the minute for the given calendar field.
	   */

	  /*
	   * Returns the second of the given calendar field.
	   * @method getSecond
	   * @returns {Number} the second for the given calendar field.
	   */

	  /*
	   * Returns the millisecond of the given calendar field.
	   * @method getMilliSecond
	   * @returns {Number} the millisecond for the given calendar field.
	   */

	  /*
	   * Returns the week of year of the given calendar field.
	   * @method getWeekOfYear
	   * @returns {Number} the week of year for the given calendar field.
	   */

	  /*
	   * Returns the week of month of the given calendar field.
	   * @method getWeekOfMonth
	   * @returns {Number} the week of month for the given calendar field.
	   */

	  /*
	   * Returns the day of year of the given calendar field.
	   * @method getDayOfYear
	   * @returns {Number} the day of year for the given calendar field.
	   */

	  /*
	   * Returns the day of week of the given calendar field.
	   * @method getDayOfWeek
	   * @returns {Number} the day of week for the given calendar field.
	   */

	  /*
	   * Returns the day of week in month of the given calendar field.
	   * @method getDayOfWeekInMonth
	   * @returns {Number} the day of week in month for the given calendar field.
	   */

	  /*
	   * Sets the given calendar field to the given value.
	   * @param field the given calendar field.
	   * @param v the value to be set for the given calendar field.
	   */
	  set: function set(field, v) {
	    var len = arguments.length;
	    if (len === 2) {
	      this.fields[field] = v;
	    } else if (len < MILLISECONDS + 1) {
	      for (var i = 0; i < len; i++) {
	        this.fields[YEAR + i] = arguments[i];
	      }
	    } else {
	      throw new Error('illegal arguments for GregorianCalendar set');
	    }
	    this.time = undefined;
	  },

	  /*
	   * Set the year of the given calendar field.
	   * @method setYear
	   */

	  /*
	   * Set the month of the given calendar field.
	   * @method setMonth
	   */

	  /*
	   * Set the day of month of the given calendar field.
	   * @method setDayOfMonth
	   */

	  /*
	   * Set the hour of day of the given calendar field.
	   * @method setHourOfDay
	   */

	  /*
	   * Set the minute of the given calendar field.
	   * @method setMinute
	   */

	  /*
	   * Set the second of the given calendar field.
	   * @method setSecond
	   */

	  /*
	   * Set the millisecond of the given calendar field.
	   * @method setMilliSecond
	   */

	  /*
	   * Set the week of year of the given calendar field.
	   * @method setWeekOfYear
	   */

	  /*
	   * Set the week of month of the given calendar field.
	   * @method setWeekOfMonth
	   */

	  /*
	   * Set the day of year of the given calendar field.
	   * @method setDayOfYear
	   */

	  /*
	   * Set the day of week of the given calendar field.
	   * @method setDayOfWeek
	   */

	  /*
	   * Set the day of week in month of the given calendar field.
	   * @method setDayOfWeekInMonth
	   */

	  /*
	   * add for specified field based on two rules:
	   *
	   *  - Add rule 1. The value of field after the call minus the value of field before the
	   *  call is amount, modulo any overflow that has occurred in field
	   *  Overflow occurs when a field value exceeds its range and,
	   *  as a result, the next larger field is incremented or
	   *  decremented and the field value is adjusted back into its range.
	   *
	   *  - Add rule 2. If a smaller field is expected to be invariant,
	   *  but it is impossible for it to be equal to its
	   *  prior value because of changes in its minimum or maximum after
	   *  field is changed, then its value is adjusted to be as close
	   *  as possible to its expected value. A smaller field represents a
	   *  smaller unit of time. HOUR_OF_DAY is a smaller field than
	   *  DAY_OF_MONTH. No adjustment is made to smaller fields
	   *  that are not expected to be invariant. The calendar system
	   *  determines what fields are expected to be invariant.
	   *
	   *
	   *      @example
	   *      use('date/gregorian',function(S, GregorianCalendar){
	   *          const d = new GregorianCalendar();
	   *          d.set(2012, GregorianCalendar.JANUARY, 31);
	   *          d.add(Gregorian.MONTH,1);
	   *          // 2012-2-29
	   *          document.writeln('<p>'+d.getYear()+'-'+d.getMonth()+'-'+d.getDayOfWeek())
	   *          d.add(Gregorian.MONTH,12);
	   *          // 2013-2-28
	   *          document.writeln('<p>'+d.getYear()+'-'+d.getMonth()+'-'+d.getDayOfWeek())
	   *      });
	   *
	   * @param field the calendar field.
	   * @param {Number} amount he amount of date or time to be added to the field.
	   */
	  add: function add(field, a) {
	    if (!a) {
	      return;
	    }
	    var amount = a;
	    var self = this;
	    var fields = self.fields;
	    // computer and retrieve original value
	    var value = self.get(field);
	    if (field === YEAR) {
	      value += amount;
	      self.set(YEAR, value);
	      adjustDayOfMonth(self);
	    } else if (field === MONTH) {
	      value += amount;
	      var yearAmount = floorDivide(value / 12);
	      value = mod(value, 12);
	      if (yearAmount) {
	        self.set(YEAR, fields[YEAR] + yearAmount);
	      }
	      self.set(MONTH, value);
	      adjustDayOfMonth(self);
	    } else {
	      switch (field) {
	        case HOUR_OF_DAY:
	          amount *= ONE_HOUR;
	          break;
	        case MINUTE:
	          amount *= ONE_MINUTE;
	          break;
	        case SECONDS:
	          amount *= ONE_SECOND;
	          break;
	        case MILLISECONDS:
	          break;
	        case WEEK_OF_MONTH:
	        case WEEK_OF_YEAR:
	        case DAY_OF_WEEK_IN_MONTH:
	          amount *= ONE_WEEK;
	          break;
	        case DAY_OF_WEEK:
	        case DAY_OF_YEAR:
	        case DAY_OF_MONTH:
	          amount *= ONE_DAY;
	          break;
	        default:
	          throw new Error('illegal field for add');
	      }
	      self.setTime(self.time + amount);
	    }
	  },

	  /*
	   * add the year of the given calendar field.
	   * @method addYear
	   * @param {Number} amount the signed amount to add to field.
	   */

	  /*
	   * add the month of the given calendar field.
	   * @method addMonth
	   * @param {Number} amount the signed amount to add to field.
	   */

	  /*
	   * add the day of month of the given calendar field.
	   * @method addDayOfMonth
	   * @param {Number} amount the signed amount to add to field.
	   */

	  /*
	   * add the hour of day of the given calendar field.
	   * @method addHourOfDay
	   * @param {Number} amount the signed amount to add to field.
	   */

	  /*
	   * add the minute of the given calendar field.
	   * @method addMinute
	   * @param {Number} amount the signed amount to add to field.
	   */

	  /*
	   * add the second of the given calendar field.
	   * @method addSecond
	   * @param {Number} amount the signed amount to add to field.
	   */

	  /*
	   * add the millisecond of the given calendar field.
	   * @method addMilliSecond
	   * @param {Number} amount the signed amount to add to field.
	   */

	  /*
	   * add the week of year of the given calendar field.
	   * @method addWeekOfYear
	   * @param {Number} amount the signed amount to add to field.
	   */

	  /*
	   * add the week of month of the given calendar field.
	   * @method addWeekOfMonth
	   * @param {Number} amount the signed amount to add to field.
	   */

	  /*
	   * add the day of year of the given calendar field.
	   * @method addDayOfYear
	   * @param {Number} amount the signed amount to add to field.
	   */

	  /*
	   * add the day of week of the given calendar field.
	   * @method addDayOfWeek
	   * @param {Number} amount the signed amount to add to field.
	   */

	  /*
	   * add the day of week in month of the given calendar field.
	   * @method addDayOfWeekInMonth
	   * @param {Number} amount the signed amount to add to field.
	   */

	  /*
	   * Get rolled value for the field
	   * @protected
	   */
	  getRolledValue: function getRolledValue(value, a, min, max) {
	    var amount = a;
	    var diff = value - min;
	    var range = max - min + 1;
	    amount %= range;
	    return min + (diff + amount + range) % range;
	  },

	  /*
	   * Adds a signed amount to the specified calendar field without changing larger fields.
	   * A negative roll amount means to subtract from field without changing
	   * larger fields. If the specified amount is 0, this method performs nothing.
	   *
	   *
	   *
	   *      @example
	   *      const d = new GregorianCalendar();
	   *      d.set(1999, GregorianCalendar.AUGUST, 31);
	   *      // 1999-4-30
	   *      // Tuesday June 1, 1999
	   *      d.set(1999, GregorianCalendar.JUNE, 1);
	   *      d.add(Gregorian.WEEK_OF_MONTH,-1); // === d.add(Gregorian.WEEK_OF_MONTH,
	   *      d.get(Gregorian.WEEK_OF_MONTH));
	   *      // 1999-06-29
	   *
	   *
	   * @param field the calendar field.
	   * @param {Number} amount the signed amount to add to field.
	   */
	  roll: function roll(field, amount) {
	    if (!amount) {
	      return;
	    }
	    var self = this;
	    // computer and retrieve original value
	    var value = self.get(field);
	    var min = self.getActualMinimum(field);
	    var max = self.getActualMaximum(field);
	    value = self.getRolledValue(value, amount, min, max);

	    self.set(field, value);

	    // consider compute time priority
	    switch (field) {
	      case MONTH:
	        adjustDayOfMonth(self);
	        break;
	      default:
	        // other fields are set already when get
	        self.updateFieldsBySet(field);
	        break;
	    }
	  },

	  /*
	   * keep field stable.
	   *
	   * 2015-09-29 setMonth 2 vs rollSetMonth 2
	   *
	   */
	  rollSet: function rollSet(field, v) {
	    this.set(field, v);
	    switch (field) {
	      case MONTH:
	        adjustDayOfMonth(this);
	        break;
	      default:
	        // other fields are set already when get
	        this.updateFieldsBySet(field);
	        break;
	    }
	  },

	  /*
	   * roll the year of the given calendar field.
	   * @method rollYear
	   * @param {Number} amount the signed amount to add to field.
	   */

	  /*
	   * roll the month of the given calendar field.
	   * @param {Number} amount the signed amount to add to field.
	   * @method rollMonth
	   */

	  /*
	   * roll the day of month of the given calendar field.
	   * @method rollDayOfMonth
	   * @param {Number} amount the signed amount to add to field.
	   */

	  /*
	   * roll the hour of day of the given calendar field.
	   * @method rollHourOfDay
	   * @param {Number} amount the signed amount to add to field.
	   */

	  /*
	   * roll the minute of the given calendar field.
	   * @method rollMinute
	   * @param {Number} amount the signed amount to add to field.
	   */

	  /*
	   * roll the second of the given calendar field.
	   * @method rollSecond
	   * @param {Number} amount the signed amount to add to field.
	   */

	  /*
	   * roll the millisecond of the given calendar field.
	   * @method rollMilliSecond
	   * @param {Number} amount the signed amount to add to field.
	   */

	  /*
	   * roll the week of year of the given calendar field.
	   * @method rollWeekOfYear
	   * @param {Number} amount the signed amount to add to field.
	   */

	  /*
	   * roll the week of month of the given calendar field.
	   * @method rollWeekOfMonth
	   * @param {Number} amount the signed amount to add to field.
	   */

	  /*
	   * roll the day of year of the given calendar field.
	   * @method rollDayOfYear
	   * @param {Number} amount the signed amount to add to field.
	   */

	  /*
	   * roll the day of week of the given calendar field.
	   * @method rollDayOfWeek
	   * @param {Number} amount the signed amount to add to field.
	   */

	  /*
	   * remove other priority fields when call getFixedDate
	   * precondition: other fields are all set or computed
	   * @protected
	   */
	  updateFieldsBySet: function updateFieldsBySet(field) {
	    var fields = this.fields;
	    switch (field) {
	      case WEEK_OF_MONTH:
	        fields[DAY_OF_MONTH] = undefined;
	        break;
	      case DAY_OF_YEAR:
	        fields[MONTH] = undefined;
	        break;
	      case DAY_OF_WEEK:
	        fields[DAY_OF_MONTH] = undefined;
	        break;
	      case WEEK_OF_YEAR:
	        fields[DAY_OF_YEAR] = undefined;
	        fields[MONTH] = undefined;
	        break;
	      default:
	        break;
	    }
	  },

	  /*
	   * get current date instance's timezone offset
	   * @returns {Number}
	   */
	  getTimezoneOffset: function getTimezoneOffset() {
	    return this.timezoneOffset;
	  },

	  /*
	   * set current date instance's timezone offset
	   */
	  setTimezoneOffset: function setTimezoneOffset(timezoneOffset) {
	    if (this.timezoneOffset !== timezoneOffset) {
	      this.fieldsComputed = undefined;
	      this.timezoneOffset = timezoneOffset;
	    }
	  },

	  /*
	   * set first day of week for current date instance
	   */
	  setFirstDayOfWeek: function setFirstDayOfWeek(firstDayOfWeek) {
	    if (this.firstDayOfWeek !== firstDayOfWeek) {
	      this.firstDayOfWeek = firstDayOfWeek;
	      this.fieldsComputed = false;
	    }
	  },

	  /*
	   * Gets what the first day of the week is; e.g., SUNDAY in the U.S., MONDAY in France.
	   * @returns {Number} the first day of the week.
	   */
	  getFirstDayOfWeek: function getFirstDayOfWeek() {
	    return this.firstDayOfWeek;
	  },

	  /*
	   * Sets what the minimal days required in the first week of the year are; For example,
	   * if the first week is defined as one that contains the first day of the first month of a year,
	   * call this method with value 1.
	   * If it must be a full week, use value 7.
	   * @param minimalDaysInFirstWeek the given minimal days required in the first week of the year.
	   */
	  setMinimalDaysInFirstWeek: function setMinimalDaysInFirstWeek(minimalDaysInFirstWeek) {
	    if (this.minimalDaysInFirstWeek !== minimalDaysInFirstWeek) {
	      this.minimalDaysInFirstWeek = minimalDaysInFirstWeek;
	      this.fieldsComputed = false;
	    }
	  },

	  /*
	   * Gets what the minimal days required in the first week of the year are; e.g.,
	   * if the first week is defined as one that contains the first day of the first month of a year,
	   * this method returns 1.
	   * If the minimal days required must be a full week, this method returns 7.
	   * @returns {Number} the minimal days required in the first week of the year.
	   */
	  getMinimalDaysInFirstWeek: function getMinimalDaysInFirstWeek() {
	    return this.minimalDaysInFirstWeek;
	  },

	  /*
	   * Returns the number of weeks in the week year
	   * represented by this GregorianCalendar.
	   *
	   * For example, if this GregorianCalendar's date is
	   * December 31, 2008 with the ISO
	   * 8601 compatible setting, this method will return 53 for the
	   * period: December 29, 2008 to January 3, 2010
	   * while getActualMaximum(WEEK_OF_YEAR) will return
	   * 52 for the period: December 31, 2007 to December 28, 2008.
	   *
	   * @return {Number} the number of weeks in the week year.
	   */
	  getWeeksInWeekYear: function getWeeksInWeekYear() {
	    var weekYear = this.getWeekYear();
	    if (weekYear === this.get(YEAR)) {
	      return this.getActualMaximum(WEEK_OF_YEAR);
	    }
	    // Use the 2nd week for calculating the max of WEEK_OF_YEAR
	    var gc = this.clone();
	    gc.clear();
	    gc.setWeekDate(weekYear, 2, this.get(DAY_OF_WEEK));
	    return gc.getActualMaximum(WEEK_OF_YEAR);
	  },

	  /*
	   * Returns the week year represented by this GregorianCalendar.
	   * The dates in the weeks between 1 and the
	   * maximum week number of the week year have the same week year value
	   * that may be one year before or after the calendar year value.
	   *
	   * @return {Number} the week year represented by this GregorianCalendar.
	   */
	  getWeekYear: function getWeekYear() {
	    var year = this.get(YEAR); // implicitly  complete
	    var weekOfYear = this.get(WEEK_OF_YEAR);
	    var month = this.get(MONTH);
	    if (month === GregorianCalendar.JANUARY) {
	      if (weekOfYear >= 52) {
	        --year;
	      }
	    } else if (month === GregorianCalendar.DECEMBER) {
	      if (weekOfYear === 1) {
	        ++year;
	      }
	    }
	    return year;
	  },
	  /*
	   * Sets this GregorianCalendar to the date given by the date specifiers - weekYear,
	   * weekOfYear, and dayOfWeek. weekOfYear follows the WEEK_OF_YEAR numbering.
	   * The dayOfWeek value must be one of the DAY_OF_WEEK values: SUNDAY to SATURDAY.
	   *
	   * @param weekYear    the week year
	   * @param weekOfYear  the week number based on weekYear
	   * @param dayOfWeek   the day of week value
	   */
	  setWeekDate: function setWeekDate(weekYear, weekOfYear, dayOfWeek) {
	    if (dayOfWeek < GregorianCalendar.SUNDAY || dayOfWeek > GregorianCalendar.SATURDAY) {
	      throw new Error('invalid dayOfWeek: ' + dayOfWeek);
	    }
	    var fields = this.fields;
	    // To avoid changing the time of day fields by date
	    // calculations, use a clone with the GMT time zone.
	    var gc = this.clone();
	    gc.clear();
	    gc.setTimezoneOffset(0);
	    gc.set(YEAR, weekYear);
	    gc.set(WEEK_OF_YEAR, 1);
	    gc.set(DAY_OF_WEEK, this.getFirstDayOfWeek());
	    var days = dayOfWeek - this.getFirstDayOfWeek();
	    if (days < 0) {
	      days += 7;
	    }
	    days += 7 * (weekOfYear - 1);
	    if (days !== 0) {
	      gc.add(DAY_OF_YEAR, days);
	    } else {
	      gc.complete();
	    }
	    fields[YEAR] = gc.get(YEAR);
	    fields[MONTH] = gc.get(MONTH);
	    fields[DAY_OF_MONTH] = gc.get(DAY_OF_MONTH);
	    this.complete();
	  },
	  /*
	   * Creates and returns a copy of this object.
	   * @returns {Date.Gregorian}
	   */
	  clone: function clone() {
	    if (this.time === undefined) {
	      this.computeTime();
	    }
	    var cal = new GregorianCalendar(this.locale);
	    cal.setTimezoneOffset(cal.getTimezoneOffset());
	    cal.setFirstDayOfWeek(cal.getFirstDayOfWeek());
	    cal.setMinimalDaysInFirstWeek(cal.getMinimalDaysInFirstWeek());
	    cal.setTime(this.time);
	    return cal;
	  },

	  /*
	   * Compares this GregorianCalendar to the specified Object.
	   * The result is true if and only if the argument is a GregorianCalendar object
	   * that represents the same time value (millisecond offset from the Epoch)
	   * under the same Calendar parameters and Gregorian change date as this object.
	   * @param {Date.Gregorian} obj the object to compare with.
	   * @returns {boolean} true if this object is equal to obj; false otherwise.
	   */
	  equals: function equals(obj) {
	    return this.getTime() === obj.getTime() && this.firstDayOfWeek === obj.firstDayOfWeek && this.timezoneOffset === obj.timezoneOffset && this.minimalDaysInFirstWeek === obj.minimalDaysInFirstWeek;
	  },

	  compareToDay: function compareToDay(d2) {
	    var d1Year = this.getYear();
	    var d2Year = d2.getYear();
	    var d1Month = this.getMonth();
	    var d2Month = d2.getMonth();
	    var d1Day = this.getDayOfMonth();
	    var d2Day = d2.getDayOfMonth();
	    if (d1Year !== d2Year) {
	      return d1Year - d2Year;
	    }
	    if (d1Month !== d2Month) {
	      return d1Month - d2Month;
	    }
	    return d1Day - d2Day;
	  },

	  /*
	   * Sets all the calendar field values or specified field and the time value
	   * (millisecond offset from the Epoch) of this Calendar undefined.
	   * This means that isSet() will return false for all the calendar fields,
	   * and the date and time calculations will treat the fields as if they had never been set.
	   * @param [field] the calendar field to be cleared.
	   */
	  clear: function clear(field) {
	    if (field === undefined) {
	      this.field = [];
	    } else {
	      this.fields[field] = undefined;
	    }
	    this.time = undefined;
	    this.fieldsComputed = false;
	  },

	  toString: function toString() {
	    // for debug
	    var v = this;
	    return '[GregorianCalendar]: ' + v.getYear() + '/' + v.getMonth() + '/' + v.getDayOfMonth() + ' ' + v.getHourOfDay() + ':' + v.getMinutes() + ':' + v.getSeconds();
	  }
	};

	var GregorianCalendarProto = GregorianCalendar.prototype;

	Utils.each(FIELDS, function (f, index) {
	  if (f) {
	    GregorianCalendarProto['get' + f] = function get() {
	      return this.get(index);
	    };

	    GregorianCalendarProto['isSet' + f] = function isSet() {
	      return this.isSet(index);
	    };

	    GregorianCalendarProto['set' + f] = function set(v) {
	      return this.set(index, v);
	    };

	    GregorianCalendarProto['add' + f] = function add(v) {
	      return this.add(index, v);
	    };

	    GregorianCalendarProto['roll' + f] = function roll(v) {
	      return this.roll(index, v);
	    };

	    GregorianCalendarProto['rollSet' + f] = function rollSet(v) {
	      return this.rollSet(index, v);
	    };
	  }
	});

	module.exports = GregorianCalendar;
	/*
	 http://docs.oracle.com/javase/7/docs/api/java/util/GregorianCalendar.html

	 TODO
	 - day saving time
	 - i18n
	 - julian calendar
	 */

/***/ },
/* 380 */
/***/ function(module, exports, __webpack_require__) {

	/*
	 * utils for gregorian date
	 * @ignore
	 * @author yiminghe@gmail.com
	 */

	'use strict';

	var Const = __webpack_require__(381);
	var floor = Math.floor;
	var ACCUMULATED_DAYS_IN_MONTH
	//   1/1 2/1 3/1 4/1 5/1 6/1 7/1 8/1 9/1 10/1 11/1 12/1
	= [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];

	var ACCUMULATED_DAYS_IN_MONTH_LEAP
	//   1/1 2/1   3/1   4/1   5/1   6/1   7/1   8/1   9/1
	// 10/1   11/1   12/1
	= [0, 31, 59 + 1, 90 + 1, 120 + 1, 151 + 1, 181 + 1, 212 + 1, 243 + 1, 273 + 1, 304 + 1, 334 + 1];

	var DAYS_OF_YEAR = 365;
	var DAYS_OF_4YEAR = 365 * 4 + 1;
	var DAYS_OF_100YEAR = DAYS_OF_4YEAR * 25 - 1;
	var DAYS_OF_400YEAR = DAYS_OF_100YEAR * 4 + 1;
	var _exports = {};

	function getDayOfYear(year, month, dayOfMonth) {
	  return dayOfMonth + (_exports.isLeapYear(year) ? ACCUMULATED_DAYS_IN_MONTH_LEAP[month] : ACCUMULATED_DAYS_IN_MONTH[month]);
	}

	function getDayOfWeekFromFixedDate(fixedDate) {
	  // The fixed day 1 (January 1, 1 Gregorian) is Monday.
	  if (fixedDate >= 0) {
	    return fixedDate % 7;
	  }
	  return _exports.mod(fixedDate, 7);
	}

	function getGregorianYearFromFixedDate(fixedDate) {
	  var d0 = undefined;
	  var d1 = undefined;
	  var d2 = undefined;
	  var d3 = undefined;
	  var n400 = undefined;
	  var n100 = undefined;
	  var n4 = undefined;
	  var n1 = undefined;
	  var year = undefined;
	  d0 = fixedDate - 1;

	  n400 = floor(d0 / DAYS_OF_400YEAR);
	  d1 = _exports.mod(d0, DAYS_OF_400YEAR);
	  n100 = floor(d1 / DAYS_OF_100YEAR);
	  d2 = _exports.mod(d1, DAYS_OF_100YEAR);
	  n4 = floor(d2 / DAYS_OF_4YEAR);
	  d3 = _exports.mod(d2, DAYS_OF_4YEAR);
	  n1 = floor(d3 / DAYS_OF_YEAR);

	  year = 400 * n400 + 100 * n100 + 4 * n4 + n1;

	  // ?
	  if (!(n100 === 4 || n1 === 4)) {
	    ++year;
	  }

	  return year;
	}

	_exports = module.exports = {
	  each: function each(arr, fn) {
	    for (var i = 0, len = arr.length; i < len; i++) {
	      if (fn(arr[i], i, arr) === false) {
	        break;
	      }
	    }
	  },

	  mix: function mix(t, s) {
	    for (var p in s) {
	      if (s.hasOwnProperty(p)) {
	        t[p] = s[p];
	      }
	    }
	  },

	  isLeapYear: function isLeapYear(year) {
	    if ((year & 3) !== 0) {
	      return false;
	    }
	    return year % 100 !== 0 || year % 400 === 0;
	  },

	  mod: function mod(x, y) {
	    // 负数时不是镜像关系
	    return x - y * floor(x / y);
	  },

	  // month: 0 based
	  getFixedDate: function getFixedDate(year, month, dayOfMonth) {
	    var prevYear = year - 1;
	    // 考虑公元前
	    return DAYS_OF_YEAR * prevYear + floor(prevYear / 4) - floor(prevYear / 100) + floor(prevYear / 400) + getDayOfYear(year, month, dayOfMonth);
	  },

	  getGregorianDateFromFixedDate: function getGregorianDateFromFixedDate(fixedDate) {
	    var year = getGregorianYearFromFixedDate(fixedDate);
	    var jan1 = _exports.getFixedDate(year, Const.JANUARY, 1);
	    var isLeap = _exports.isLeapYear(year);
	    var ACCUMULATED_DAYS = isLeap ? ACCUMULATED_DAYS_IN_MONTH_LEAP : ACCUMULATED_DAYS_IN_MONTH;
	    var daysDiff = fixedDate - jan1;
	    var month = undefined;

	    for (var i = 0; i < ACCUMULATED_DAYS.length; i++) {
	      if (ACCUMULATED_DAYS[i] <= daysDiff) {
	        month = i;
	      } else {
	        break;
	      }
	    }

	    var dayOfMonth = fixedDate - jan1 - ACCUMULATED_DAYS[month] + 1;
	    var dayOfWeek = getDayOfWeekFromFixedDate(fixedDate);

	    return {
	      year: year,
	      month: month,
	      dayOfMonth: dayOfMonth,
	      dayOfWeek: dayOfWeek,
	      isLeap: isLeap
	    };
	  }
	};

/***/ },
/* 381 */
/***/ function(module, exports) {

	/*
	 * @ignore
	 * const for gregorian date
	 * @author yiminghe@gmail.com
	 */

	"use strict";

	module.exports = {
	  /*
	   * Enum indicating sunday
	   * @type Number
	   * @member Date.Gregorian
	   */
	  SUNDAY: 0,
	  /*
	   * Enum indicating monday
	   * @type Number
	   * @member Date.Gregorian
	   */
	  MONDAY: 1,
	  /*
	   * Enum indicating tuesday
	   * @type Number
	   * @member Date.Gregorian
	   */
	  TUESDAY: 2,
	  /*
	   * Enum indicating wednesday
	   * @type Number
	   * @member Date.Gregorian
	   */
	  WEDNESDAY: 3,
	  /*
	   * Enum indicating thursday
	   * @type Number
	   * @member Date.Gregorian
	   */
	  THURSDAY: 4,
	  /*
	   * Enum indicating friday
	   * @type Number
	   * @member Date.Gregorian
	   */
	  FRIDAY: 5,
	  /*
	   * Enum indicating saturday
	   * @type Number
	   * @member Date.Gregorian
	   */
	  SATURDAY: 6,
	  /*
	   * Enum indicating january
	   * @type Number
	   * @member Date.Gregorian
	   */
	  JANUARY: 0,
	  /*
	   * Enum indicating february
	   * @type Number
	   * @member Date.Gregorian
	   */
	  FEBRUARY: 1,
	  /*
	   * Enum indicating march
	   * @type Number
	   * @member Date.Gregorian
	   */
	  MARCH: 2,
	  /*
	   * Enum indicating april
	   * @type Number
	   * @member Date.Gregorian
	   */
	  APRIL: 3,
	  /*
	   * Enum indicating may
	   * @type Number
	   * @member Date.Gregorian
	   */
	  MAY: 4,
	  /*
	   * Enum indicating june
	   * @type Number
	   * @member Date.Gregorian
	   */
	  JUNE: 5,
	  /*
	   * Enum indicating july
	   * @type Number
	   * @member Date.Gregorian
	   */
	  JULY: 6,
	  /*
	   * Enum indicating august
	   * @type Number
	   * @member Date.Gregorian
	   */
	  AUGUST: 7,
	  /*
	   * Enum indicating september
	   * @type Number
	   * @member Date.Gregorian
	   */
	  SEPTEMBER: 8,
	  /*
	   * Enum indicating october
	   * @type Number
	   * @member Date.Gregorian
	   */
	  OCTOBER: 9,
	  /*
	   * Enum indicating november
	   * @type Number
	   * @member Date.Gregorian
	   */
	  NOVEMBER: 10,
	  /*
	   * Enum indicating december
	   * @type Number
	   * @member Date.Gregorian
	   */
	  DECEMBER: 11
	};

/***/ },
/* 382 */
/***/ function(module, exports) {

	/*
	 * en-us locale
	 * @ignore
	 * @author yiminghe@gmail.com
	 */
	"use strict";

	module.exports = {
	  // in minutes
	  timezoneOffset: -8 * 60,
	  firstDayOfWeek: 0,
	  minimalDaysInFirstWeek: 1
	};

/***/ },
/* 383 */
[543, 384, 385, 387, 388, 389, 390, 395, 396, 400, 401, 402],
/* 384 */
16,
/* 385 */
[544, 386],
/* 386 */
18,
/* 387 */
[545, 386],
/* 388 */
21,
/* 389 */
[546, 390],
/* 390 */
[547, 391],
/* 391 */
[548, 392, 393, 394],
/* 392 */
25,
/* 393 */
26,
/* 394 */
27,
/* 395 */
28,
/* 396 */
[549, 397],
/* 397 */
[550, 398],
/* 398 */
[551, 399, 284],
/* 399 */
32,
/* 400 */
33,
/* 401 */
34,
/* 402 */
35,
/* 403 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _react = __webpack_require__(7);

	var _react2 = _interopRequireDefault(_react);

	var _DateTHead = __webpack_require__(404);

	var _DateTHead2 = _interopRequireDefault(_DateTHead);

	var _DateTBody = __webpack_require__(406);

	var _DateTBody2 = _interopRequireDefault(_DateTBody);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } // customized rc-calendar https://github.com/react-component/calendar/blob/master/

	var DateTable = function (_React$Component) {
	  _inherits(DateTable, _React$Component);

	  function DateTable() {
	    _classCallCheck(this, DateTable);

	    return _possibleConstructorReturn(this, _React$Component.apply(this, arguments));
	  }

	  DateTable.prototype.render = function render() {
	    var props = this.props;
	    var prefixCls = props.prefixCls;
	    return _react2["default"].createElement(
	      'table',
	      { className: prefixCls + '-table', cellSpacing: '0', role: 'grid' },
	      _react2["default"].createElement(_DateTHead2["default"], props),
	      _react2["default"].createElement(_DateTBody2["default"], props)
	    );
	  };

	  return DateTable;
	}(_react2["default"].Component);

	exports["default"] = DateTable;
	module.exports = exports['default'];

/***/ },
/* 404 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _react = __webpack_require__(7);

	var _react2 = _interopRequireDefault(_react);

	var _DateConstants = __webpack_require__(405);

	var _DateConstants2 = _interopRequireDefault(_DateConstants);

	var _classnames2 = __webpack_require__(19);

	var _classnames3 = _interopRequireDefault(_classnames2);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var DateTHead = function (_React$Component) {
	  _inherits(DateTHead, _React$Component);

	  function DateTHead() {
	    _classCallCheck(this, DateTHead);

	    return _possibleConstructorReturn(this, _React$Component.apply(this, arguments));
	  }

	  DateTHead.prototype.render = function render() {
	    var props = this.props;
	    var value = props.value;
	    var locale = props.locale;
	    var prefixCls = props.prefixCls;
	    var veryShortWeekdays = [];
	    var weekDays = [];
	    var firstDayOfWeek = value.getFirstDayOfWeek();
	    var showWeekNumberEl = undefined;

	    for (var dateColIndex = 0; dateColIndex < _DateConstants2["default"].DATE_COL_COUNT; dateColIndex++) {
	      var index = (firstDayOfWeek + dateColIndex) % _DateConstants2["default"].DATE_COL_COUNT;
	      veryShortWeekdays[dateColIndex] = locale.format.veryShortWeekdays[index];
	      weekDays[dateColIndex] = locale.format.weekdays[index];
	    }

	    if (props.showWeekNumber) {
	      showWeekNumberEl = _react2["default"].createElement(
	        'th',
	        {
	          role: 'columnheader',
	          className: prefixCls + '-column-header ' + prefixCls + '-week-number-header'
	        },
	        _react2["default"].createElement(
	          'span',
	          { className: prefixCls + '-column-header-inner' },
	          'x'
	        )
	      );
	    }
	    var weekDaysEls = weekDays.map(function (day, xindex) {
	      var _classnames;

	      var spanCls = (0, _classnames3["default"])((_classnames = {}, _classnames[prefixCls + '-column-header-inner'] = true, _classnames.weekend = xindex === 0 || xindex === 6, _classnames));
	      return _react2["default"].createElement(
	        'th',
	        {
	          key: xindex,
	          role: 'columnheader',
	          title: day,
	          className: prefixCls + '-column-header'
	        },
	        _react2["default"].createElement(
	          'span',
	          { className: spanCls },
	          veryShortWeekdays[xindex]
	        )
	      );
	    });
	    return _react2["default"].createElement(
	      'thead',
	      null,
	      _react2["default"].createElement(
	        'tr',
	        { role: 'row' },
	        showWeekNumberEl,
	        weekDaysEls
	      )
	    );
	  };

	  return DateTHead;
	}(_react2["default"].Component);

	exports["default"] = DateTHead;
	module.exports = exports['default'];

/***/ },
/* 405 */
/***/ function(module, exports) {

	"use strict";

	exports.__esModule = true;
	exports["default"] = {
	  DATE_ROW_COUNT: 6,
	  DATE_COL_COUNT: 7
	};
	module.exports = exports['default'];

/***/ },
/* 406 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _react = __webpack_require__(7);

	var _react2 = _interopRequireDefault(_react);

	var _DateConstants = __webpack_require__(407);

	var _DateConstants2 = _interopRequireDefault(_DateConstants);

	var _util = __webpack_require__(408);

	var _classnames2 = __webpack_require__(19);

	var _classnames3 = _interopRequireDefault(_classnames2);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

	// customized rc-calendar https://github.com/react-component/calendar/blob/master/

	function isSameDay(one, two) {
	  return one && two && one.compareToDay(two) === 0;
	}

	function beforeCurrentMonthYear(current, today) {
	  if (current.getYear() < today.getYear()) {
	    return 1;
	  }
	  return current.getYear() === today.getYear() && current.getMonth() < today.getMonth();
	}

	function afterCurrentMonthYear(current, today) {
	  if (current.getYear() > today.getYear()) {
	    return 1;
	  }
	  return current.getYear() === today.getYear() && current.getMonth() > today.getMonth();
	}

	function getIdFromDate(date) {
	  return 'rc-calendar-' + date.getYear() + '-' + date.getMonth() + '-' + date.getDayOfMonth();
	}

	function noop() {}

	function handleDayClick(current) {
	  this.props.onSelect(current);
	}

	function handleCellMouseEnter(current) {
	  this.props.onDayHover(current);
	}

	var DateTBody = _react2["default"].createClass({
	  displayName: 'DateTBody',

	  propTypes: {
	    contentRender: _react.PropTypes.func,
	    dateRender: _react.PropTypes.func,
	    disabledDate: _react.PropTypes.func,
	    prefixCls: _react.PropTypes.string,
	    selectedValue: _react.PropTypes.object,
	    value: _react.PropTypes.object,
	    showWeekNumber: _react.PropTypes.bool
	  },

	  getDefaultProps: function getDefaultProps() {
	    return {
	      onDayHover: noop
	    };
	  },
	  render: function render() {
	    var props = this.props;
	    var contentRender = props.contentRender;
	    var prefixCls = props.prefixCls;
	    var selectedValue = props.selectedValue;
	    var value = props.value;
	    var showWeekNumber = props.showWeekNumber;
	    var dateRender = props.dateRender;
	    var disabledDate = props.disabledDate;

	    var iIndex = undefined;
	    var jIndex = undefined;
	    var current = undefined;
	    var dateTable = [];
	    var today = value.clone();
	    var cellClass = prefixCls + '-cell';
	    var weekNumberCellClass = prefixCls + '-week-number-cell';
	    var dateClass = prefixCls + '-date';
	    var todayClass = prefixCls + '-today';
	    var selectedClass = prefixCls + '-selected-day';
	    var inRangeClass = prefixCls + '-in-range-cell';
	    var lastMonthDayClass = prefixCls + '-last-month-cell';
	    var nextMonthDayClass = prefixCls + '-next-month-btn-day';
	    var disabledClass = prefixCls + '-disabled-cell';
	    var firstDisableClass = prefixCls + '-disabled-cell-first-of-row';
	    var lastDisableClass = prefixCls + '-disabled-cell-last-of-row';
	    today.setTime(Date.now());
	    var month1 = value.clone();
	    month1.set(value.getYear(), value.getMonth(), 1);
	    var day = month1.getDayOfWeek();
	    var lastMonthDiffDay = (day + 7 - value.getFirstDayOfWeek()) % 7;
	    // calculate last month
	    var lastMonth1 = month1.clone();
	    lastMonth1.addDayOfMonth(0 - lastMonthDiffDay);
	    var passed = 0;
	    for (iIndex = 0; iIndex < _DateConstants2["default"].DATE_ROW_COUNT; iIndex++) {
	      for (jIndex = 0; jIndex < _DateConstants2["default"].DATE_COL_COUNT; jIndex++) {
	        current = lastMonth1;
	        if (passed) {
	          current = current.clone();
	          current.addDayOfMonth(passed);
	        }
	        dateTable.push(current);
	        passed++;
	      }
	    }
	    var tableHtml = [];
	    passed = 0;
	    for (iIndex = 0; iIndex < _DateConstants2["default"].DATE_ROW_COUNT; iIndex++) {
	      var weekNumberCell = undefined;
	      var dateCells = [];
	      if (showWeekNumber) {
	        weekNumberCell = _react2["default"].createElement(
	          'td',
	          {
	            key: dateTable[passed].getWeekOfYear(),
	            role: 'gridcell',
	            className: weekNumberCellClass
	          },
	          dateTable[passed].getWeekOfYear()
	        );
	      }
	      for (jIndex = 0; jIndex < _DateConstants2["default"].DATE_COL_COUNT; jIndex++) {
	        var next = null;
	        var last = null;
	        current = dateTable[passed];
	        if (jIndex < _DateConstants2["default"].DATE_COL_COUNT - 1) {
	          next = dateTable[passed + 1];
	        }
	        if (jIndex > 0) {
	          last = dateTable[passed - 1];
	        }
	        var cls = cellClass;
	        var disabled = false;
	        var selected = false;

	        if (isSameDay(current, today)) {
	          cls += ' ' + todayClass;
	        }

	        var isBeforeCurrentMonthYear = beforeCurrentMonthYear(current, value);
	        var isAfterCurrentMonthYear = afterCurrentMonthYear(current, value);

	        if (selectedValue && Array.isArray(selectedValue)) {
	          if (!isBeforeCurrentMonthYear && !isAfterCurrentMonthYear) {
	            var startValue = selectedValue[0];
	            var endValue = selectedValue[1];
	            if (startValue) {
	              if (isSameDay(current, startValue)) {
	                selected = true;
	              }
	            }
	            if (startValue && endValue) {
	              if (isSameDay(current, endValue) && !selectedValue.hovering) {
	                selected = true;
	              } else if (current.compareToDay(startValue) > 0 && current.compareToDay(endValue) < 0) {
	                cls += ' ' + inRangeClass;
	              }
	            }
	          }
	        } else if (isSameDay(current, selectedValue)) {
	          selected = true;
	        }
	        if (isBeforeCurrentMonthYear) {
	          cls += ' ' + lastMonthDayClass;
	        }
	        if (isAfterCurrentMonthYear) {
	          cls += ' ' + nextMonthDayClass;
	        }

	        if (disabledDate) {
	          if (disabledDate(current, value)) {
	            disabled = true;

	            if (!last || !disabledDate(last, value)) {
	              cls += ' ' + firstDisableClass;
	            }

	            if (!next || !disabledDate(next, value)) {
	              cls += ' ' + lastDisableClass;
	            }
	          }
	        }

	        if (selected) {
	          cls += ' ' + selectedClass;
	        }

	        if (disabled) {
	          cls += ' ' + disabledClass;
	        }

	        var dateHtml = undefined;
	        if (dateRender) {
	          dateHtml = dateRender(current, value);
	        } else {
	          var _classnames;

	          var content = contentRender ? contentRender(current, value) : current.getDayOfMonth();
	          var dayOfWeek = current.getDayOfWeek();
	          dateHtml = _react2["default"].createElement(
	            'div',
	            {
	              key: getIdFromDate(current),
	              className: (0, _classnames3["default"])((_classnames = {}, _classnames[dateClass] = true, _classnames.weekend = dayOfWeek == 0 || dayOfWeek == 6, _classnames)),
	              'aria-selected': selected,
	              'aria-disabled': disabled
	            },
	            content
	          );
	        }

	        dateCells.push(_react2["default"].createElement(
	          'td',
	          {
	            key: passed,
	            onClick: disabled ? noop : handleDayClick.bind(this, current),
	            onMouseEnter: disabled ? noop : handleCellMouseEnter.bind(this, current),
	            role: 'gridcell',
	            title: (0, _util.getTitleString)(current), className: cls
	          },
	          dateHtml
	        ));

	        passed++;
	      }
	      tableHtml.push(_react2["default"].createElement(
	        'tr',
	        {
	          key: iIndex,
	          role: 'row'
	        },
	        weekNumberCell,
	        dateCells
	      ));
	    }
	    return _react2["default"].createElement(
	      'tbody',
	      { className: prefixCls + 'tbody' },
	      tableHtml
	    );
	  }
	});

	exports["default"] = DateTBody;
	module.exports = exports['default'];

/***/ },
/* 407 */
/***/ function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports["default"] = {
	  DATE_ROW_COUNT: 6,
	  DATE_COL_COUNT: 7
	};
	module.exports = exports['default'];

/***/ },
/* 408 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

	exports.getTodayTime = getTodayTime;
	exports.getTitleString = getTitleString;
	exports.getTodayTimeStr = getTodayTimeStr;
	exports.getFormatter = getFormatter;
	exports.syncTime = syncTime;
	exports.getTimeConfig = getTimeConfig;
	exports.isTimeValidByConfig = isTimeValidByConfig;
	exports.isTimeValid = isTimeValid;
	exports.isAllowedDate = isAllowedDate;

	var _gregorianCalendarFormat = __webpack_require__(409);

	var _gregorianCalendarFormat2 = _interopRequireDefault(_gregorianCalendarFormat);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

	var defaultDisabledTime = {
	  disabledHours: function disabledHours() {
	    return [];
	  },
	  disabledMinutes: function disabledMinutes() {
	    return [];
	  },
	  disabledSeconds: function disabledSeconds() {
	    return [];
	  }
	};

	function getTodayTime(value) {
	  var today = value.clone();
	  today.setTime(Date.now());
	  return today;
	}

	function getTitleString(value) {
	  return value.getYear() + '-' + (value.getMonth() + 1) + '-' + value.getDayOfMonth();
	}

	function getTodayTimeStr(value) {
	  var today = getTodayTime(value);
	  return getTitleString(today);
	}

	function getFormatter(format, locale) {
	  if (typeof format === 'string') {
	    return new _gregorianCalendarFormat2["default"](format, locale.format);
	  }
	  return format;
	}

	function syncTime(from, to) {
	  to.setHourOfDay(from.getHourOfDay());
	  to.setMinutes(from.getMinutes());
	  to.setSeconds(from.getSeconds());
	}

	function getTimeConfig(value, disabledTime) {
	  var disabledTimeConfig = disabledTime ? disabledTime(value) : {};
	  disabledTimeConfig = _extends({}, defaultDisabledTime, disabledTimeConfig);
	  return disabledTimeConfig;
	}

	function isTimeValidByConfig(value, disabledTimeConfig) {
	  var invalidTime = false;
	  if (value) {
	    var hour = value.getHourOfDay();
	    var minutes = value.getMinutes();
	    var seconds = value.getSeconds();
	    var disabledHours = disabledTimeConfig.disabledHours();
	    if (disabledHours.indexOf(hour) === -1) {
	      var disabledMinutes = disabledTimeConfig.disabledMinutes(hour);
	      if (disabledMinutes.indexOf(minutes) === -1) {
	        var disabledSeconds = disabledTimeConfig.disabledSeconds(hour, minutes);
	        invalidTime = disabledSeconds.indexOf(seconds) !== -1;
	      } else {
	        invalidTime = true;
	      }
	    } else {
	      invalidTime = true;
	    }
	  }
	  return !invalidTime;
	}

	function isTimeValid(value, disabledTime) {
	  var disabledTimeConfig = getTimeConfig(value, disabledTime);
	  return isTimeValidByConfig(value, disabledTimeConfig);
	}

	function isAllowedDate(value, disabledDate, disabledTime) {
	  if (disabledDate) {
	    if (disabledDate(value)) {
	      return false;
	    }
	  }
	  if (disabledTime) {
	    if (!isTimeValid(value, disabledTime)) {
	      return false;
	    }
	  }
	  return true;
	}

/***/ },
/* 409 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @ignore
	 * DateTimeFormat for
	 * Inspired by DateTimeFormat from JDK.
	 * @author yiminghe@gmail.com
	 */

	'use strict';

	var GregorianCalendar = __webpack_require__(379);
	var enUsLocale = __webpack_require__(410);
	var MAX_VALUE = Number.MAX_VALUE;
	var warning = __webpack_require__(411);

	/**
	 * date or time style enum
	 * @enum {Number} Date.Formatter.Style
	 */
	var DateTimeStyle = {
	  /**
	   * full style
	   */
	  FULL: 0,
	  /**
	   * long style
	   */
	  LONG: 1,
	  /**
	   * medium style
	   */
	  MEDIUM: 2,
	  /**
	   * short style
	   */
	  SHORT: 3
	};

	/*
	 Letter    Date or Time Component    Presentation    Examples
	 G    Era designator    Text    AD
	 y    Year    Year    1996; 96
	 Y    WeekYear    WeekYear    1996; 96
	 M    Month in year    Month    July; Jul; 07
	 w    Week in year    Number    27
	 W    Week in month    Number    2
	 D    Day in year    Number    189
	 d    Day in month    Number    10
	 F    Day of week in month    Number    2
	 E    Day in week    Text    Tuesday; Tue
	 a    Am/pm marker    Text    PM
	 H    Hour in day (0-23)    Number    0
	 k    Hour in day (1-24)    Number    24
	 K    Hour in am/pm (0-11)    Number    0
	 h    Hour in am/pm (1-12)    Number    12
	 m    Minute in hour    Number    30
	 s    Second in minute    Number    55
	 S    Millisecond    Number    978
	 x z    Time zone    General time zone    Pacific Standard Time; PST; GMT-08:00
	 Z    Time zone    RFC 822 time zone    -0800
	 */

	var patternChars = new Array(GregorianCalendar.DAY_OF_WEEK_IN_MONTH + 2).join('1');
	var ERA = 0;
	var calendarIndexMap = {};

	patternChars = patternChars.split('');
	patternChars[ERA] = 'G';
	patternChars[GregorianCalendar.YEAR] = 'y';
	patternChars[GregorianCalendar.MONTH] = 'M';
	patternChars[GregorianCalendar.DAY_OF_MONTH] = 'd';
	patternChars[GregorianCalendar.HOUR_OF_DAY] = 'H';
	patternChars[GregorianCalendar.MINUTES] = 'm';
	patternChars[GregorianCalendar.SECONDS] = 's';
	patternChars[GregorianCalendar.MILLISECONDS] = 'S';
	patternChars[GregorianCalendar.WEEK_OF_YEAR] = 'w';
	patternChars[GregorianCalendar.WEEK_OF_MONTH] = 'W';
	patternChars[GregorianCalendar.DAY_OF_YEAR] = 'D';
	patternChars[GregorianCalendar.DAY_OF_WEEK_IN_MONTH] = 'F';
	patternChars.push('Y');

	patternChars.forEach(function (v, key) {
	  var k = key;
	  if (v === 'Y') {
	    k = GregorianCalendar.YEAR;
	  }
	  if (v) {
	    calendarIndexMap[v] = k;
	  }
	});

	function mix(t, s) {
	  for (var p in s) {
	    if (s.hasOwnProperty(p)) {
	      t[p] = s[p];
	    }
	  }
	}

	var SUBSTITUTE_REG = /\\?\{([^{}]+)\}/g;
	var EMPTY = '';

	function substitute(str, o, regexp) {
	  if (typeof str !== 'string' || !o) {
	    return str;
	  }

	  return str.replace(regexp || SUBSTITUTE_REG, function (match, name) {
	    if (match.charAt(0) === '\\') {
	      return match.slice(1);
	    }
	    return o[name] === undefined ? EMPTY : o[name];
	  });
	}

	patternChars = patternChars.join('') + 'ahkKZE';

	function encode(lastField, count, compiledPattern) {
	  compiledPattern.push({
	    field: lastField,
	    count: count
	  });
	}

	function compile(pattern) {
	  var length = pattern.length;
	  var inQuote = false;
	  var compiledPattern = [];
	  var tmpBuffer = null;
	  var count = 0;
	  var lastField = -1;

	  for (var i = 0; i < length; i++) {
	    var c = pattern.charAt(i);

	    if (c === '\'') {
	      // '' is treated as a single quote regardless of being
	      // in a quoted section.
	      if (i + 1 < length) {
	        c = pattern.charAt(i + 1);
	        if (c === '\'') {
	          i++;
	          if (count !== 0) {
	            encode(lastField, count, compiledPattern);
	            lastField = -1;
	            count = 0;
	          }
	          if (inQuote) {
	            tmpBuffer += c;
	          }
	          continue;
	        }
	      }
	      if (!inQuote) {
	        if (count !== 0) {
	          encode(lastField, count, compiledPattern);
	          lastField = -1;
	          count = 0;
	        }
	        tmpBuffer = '';
	        inQuote = true;
	      } else {
	        compiledPattern.push({
	          text: tmpBuffer
	        });
	        inQuote = false;
	      }
	      continue;
	    }
	    if (inQuote) {
	      tmpBuffer += c;
	      continue;
	    }
	    if (!(c >= 'a' && c <= 'z' || c >= 'A' && c <= 'Z')) {
	      if (count !== 0) {
	        encode(lastField, count, compiledPattern);
	        lastField = -1;
	        count = 0;
	      }
	      compiledPattern.push({
	        text: c
	      });
	      continue;
	    }

	    if (patternChars.indexOf(c) === -1) {
	      throw new Error('Illegal pattern character "' + c + '"');
	    }

	    if (lastField === -1 || lastField === c) {
	      lastField = c;
	      count++;
	      continue;
	    }
	    encode(lastField, count, compiledPattern);
	    lastField = c;
	    count = 1;
	  }

	  if (inQuote) {
	    throw new Error('Unterminated quote');
	  }

	  if (count !== 0) {
	    encode(lastField, count, compiledPattern);
	  }

	  return compiledPattern;
	}

	var zeroDigit = '0';

	// TODO zeroDigit localization??
	function zeroPaddingNumber(_x, _x2, _x3, _x4) {
	  var _again = true;

	  _function: while (_again) {
	    var value = _x,
	        minDigits = _x2,
	        maxDigits_ = _x3,
	        b = _x4;
	    _again = false;

	    // Optimization for 1, 2 and 4 digit numbers. This should
	    // cover most cases of formatting date/time related items.
	    // Note: This optimization code assumes that maxDigits is
	    // either 2 or Integer.MAX_VALUE (maxIntCount in format()).
	    var buffer = b || [];
	    var maxDigits = maxDigits_ || MAX_VALUE;
	    if (value >= 0) {
	      if (value < 100 && minDigits >= 1 && minDigits <= 2) {
	        if (value < 10 && minDigits === 2) {
	          buffer.push(zeroDigit);
	        }
	        buffer.push(value);
	        return buffer.join('');
	      } else if (value >= 1000 && value < 10000) {
	        if (minDigits === 4) {
	          buffer.push(value);
	          return buffer.join('');
	        }
	        if (minDigits === 2 && maxDigits === 2) {
	          _x = value % 100;
	          _x2 = 2;
	          _x3 = 2;
	          _x4 = buffer;
	          _again = true;
	          buffer = maxDigits = undefined;
	          continue _function;
	        }
	      }
	    }
	    buffer.push(value + '');
	    return buffer.join('');
	  }
	}

	/**
	 *
	 * date time formatter for GregorianCalendar
	 *
	 *      @example
	 *
	 *          const calendar = new GregorianCalendar(2013,9,24);
	 *          // ' to escape
	 *          const formatter = new GregorianCalendarFormat("'today is' ''yyyy/MM/dd a''");
	 *          document.write(formatter.format(calendar));
	 *
	 * @class GregorianCalendarFormat
	 * @param {String} pattern patter string of date formatter
	 *
	 * <table border="1">
	 * <thead valign="bottom">
	 * <tr><th class="head">Letter</th>
	 * <th class="head">Date or Time Component</th>
	 * <th class="head">Presentation</th>
	 * <th class="head">Examples</th>
	 * </tr>
	 * </thead>
	 * <tbody valign="top">
	 * <tr><td>G</td>
	 * <td>Era designator</td>
	 * <td>Text</td>
	 * <td>AD</td>
	 * </tr>
	 * <tr><td>y</td>
	 * <td>Year</td>
	 * <td>Year</td>
	 * <td>1996; 96</td>
	 * </tr>
	 * <tr><td>M</td>
	 * <td>Month in year</td>
	 * <td>Month</td>
	 * <td>July; Jul; 07</td>
	 * </tr>
	 * <tr><td>w</td>
	 * <td>Week in year</td>
	 * <td>Number</td>
	 * <td>27</td>
	 * </tr>
	 * <tr><td>W</td>
	 * <td>Week in month</td>
	 * <td>Number</td>
	 * <td>2</td>
	 * </tr>
	 * <tr><td>D</td>
	 * <td>Day in year</td>
	 * <td>Number</td>
	 * <td>189</td>
	 * </tr>
	 * <tr><td>d</td>
	 * <td>Day in month</td>
	 * <td>Number</td>
	 * <td>10</td>
	 * </tr>
	 * <tr><td>F</td>
	 * <td>Day of week in month</td>
	 * <td>Number</td>
	 * <td>2</td>
	 * </tr>
	 * <tr><td>E</td>
	 * <td>Day in week</td>
	 * <td>Text</td>
	 * <td>Tuesday; Tue</td>
	 * </tr>
	 * <tr><td>a</td>
	 * <td>Am/pm marker</td>
	 * <td>Text</td>
	 * <td>PM</td>
	 * </tr>
	 * <tr><td>H</td>
	 *       <td>Hour in day (0-23)</td>
	 * <td>Number</td>
	 * <td>0</td>
	 * </tr>
	 * <tr><td>k</td>
	 *       <td>Hour in day (1-24)</td>
	 * <td>Number</td>
	 * <td>24</td>
	 * </tr>
	 * <tr><td>K</td>
	 * <td>Hour in am/pm (0-11)</td>
	 * <td>Number</td>
	 * <td>0</td>
	 * </tr>
	 * <tr><td>h</td>
	 * <td>Hour in am/pm (1-12)</td>
	 * <td>Number</td>
	 * <td>12</td>
	 * </tr>
	 * <tr><td>m</td>
	 * <td>Minute in hour</td>
	 * <td>Number</td>
	 * <td>30</td>
	 * </tr>
	 * <tr><td>s</td>
	 * <td>Second in minute</td>
	 * <td>Number</td>
	 * <td>55</td>
	 * </tr>
	 * <tr><td>S</td>
	 * <td>Millisecond</td>
	 * <td>Number</td>
	 * <td>978</td>
	 * </tr>
	 * <tr><td>x/z</td>
	 * <td>Time zone</td>
	 * <td>General time zone</td>
	 * <td>Pacific Standard Time; PST; GMT-08:00</td>
	 * </tr>
	 * <tr><td>Z</td>
	 * <td>Time zone</td>
	 * <td>RFC 822 time zone</td>
	 * <td>-0800</td>
	 * </tr>
	 * </tbody>
	 * </table>

	 * @param {Object} locale format locale
	 */
	function DateTimeFormat(pattern, locale) {
	  this.locale = locale || enUsLocale;
	  this.originalPattern = pattern;
	  this.pattern = compile(pattern);
	}

	function formatField(field, count, locale, calendar) {
	  var current = undefined;
	  var value = undefined;
	  switch (field) {
	    case 'G':
	      value = calendar.getYear() > 0 ? 1 : 0;
	      current = locale.eras[value];
	      break;
	    case 'Y':
	      value = calendar.getWeekYear();
	      if (value <= 0) {
	        value = 1 - value;
	      }
	      current = zeroPaddingNumber(value, 2, count !== 2 ? MAX_VALUE : 2);
	      break;
	    case 'y':
	      value = calendar.getYear();
	      if (value <= 0) {
	        value = 1 - value;
	      }
	      current = zeroPaddingNumber(value, 2, count !== 2 ? MAX_VALUE : 2);
	      break;
	    case 'M':
	      value = calendar.getMonth();
	      if (count >= 4) {
	        current = locale.months[value];
	      } else if (count === 3) {
	        current = locale.shortMonths[value];
	      } else {
	        current = zeroPaddingNumber(value + 1, count);
	      }
	      break;
	    case 'k':
	      current = zeroPaddingNumber(calendar.getHourOfDay() || 24, count);
	      break;
	    case 'E':
	      value = calendar.getDayOfWeek();
	      current = count >= 4 ? locale.weekdays[value] : locale.shortWeekdays[value];
	      break;
	    case 'a':
	      current = locale.ampms[calendar.getHourOfDay() >= 12 ? 1 : 0];
	      break;
	    case 'h':
	      current = zeroPaddingNumber(calendar.getHourOfDay() % 12 || 12, count);
	      break;
	    case 'K':
	      current = zeroPaddingNumber(calendar.getHourOfDay() % 12, count);
	      break;
	    case 'Z':
	      var offset = calendar.getTimezoneOffset();
	      var parts = [offset < 0 ? '-' : '+'];
	      offset = Math.abs(offset);
	      parts.push(zeroPaddingNumber(Math.floor(offset / 60) % 100, 2), zeroPaddingNumber(offset % 60, 2));
	      current = parts.join('');
	      break;
	    default:
	      // case 'd':
	      // case 'H':
	      // case 'm':
	      // case 's':
	      // case 'S':
	      // case 'D':
	      // case 'F':
	      // case 'w':
	      // case 'W':
	      var index = calendarIndexMap[field];
	      value = calendar.get(index);
	      current = zeroPaddingNumber(value, count);
	  }
	  return current;
	}

	function matchPartString(dateStr, startIndex, match, mLen) {
	  for (var i = 0; i < mLen; i++) {
	    if (dateStr.charAt(startIndex + i) !== match.charAt(i)) {
	      return false;
	    }
	  }
	  return true;
	}

	function matchField(dateStr, startIndex, matches) {
	  var matchedLen = -1;
	  var index = -1;
	  var i = undefined;
	  var len = matches.length;
	  for (i = 0; i < len; i++) {
	    var m = matches[i];
	    var mLen = m.length;
	    if (mLen > matchedLen && matchPartString(dateStr, startIndex, m, mLen)) {
	      matchedLen = mLen;
	      index = i;
	    }
	  }
	  return index >= 0 ? {
	    value: index,
	    startIndex: startIndex + matchedLen
	  } : null;
	}

	function getLeadingNumberLen(str) {
	  var i = undefined;
	  var c = undefined;
	  var len = str.length;
	  for (i = 0; i < len; i++) {
	    c = str.charAt(i);
	    if (c < '0' || c > '9') {
	      break;
	    }
	  }
	  return i;
	}

	function matchNumber(dateStr, startIndex, count, obeyCount) {
	  var str = dateStr;
	  var n = undefined;
	  if (obeyCount) {
	    if (dateStr.length < startIndex + count) {
	      return null;
	    }
	    str = dateStr.slice(startIndex, startIndex + count);
	    if (!str.match(/^\d+$/)) {
	      throw new Error('GregorianCalendarFormat parse error, dateStr: ' + dateStr + ', patter: ' + this.originalPattern);
	    }
	  } else {
	    str = str.slice(startIndex);
	  }
	  n = parseInt(str, 10);
	  if (isNaN(n)) {
	    throw new Error('GregorianCalendarFormat parse error, dateStr: ' + dateStr + ', patter: ' + this.originalPattern);
	  }
	  return {
	    value: n,
	    startIndex: startIndex + getLeadingNumberLen(str)
	  };
	}

	function parseField(calendar, dateStr, startIndex_, field, count, obeyCount, tmp) {
	  var match = undefined;
	  var year = undefined;
	  var hour = undefined;
	  var startIndex = startIndex_;
	  if (dateStr.length <= startIndex) {
	    return startIndex;
	  }
	  var locale = this.locale;
	  switch (field) {
	    case 'G':
	      match = matchField(dateStr, startIndex, locale.eras);
	      if (match) {
	        if (calendar.isSetYear()) {
	          if (match.value === 0) {
	            year = calendar.getYear();
	            calendar.setYear(1 - year);
	          }
	        } else {
	          tmp.era = match.value;
	        }
	      }
	      break;
	    case 'y':
	      match = matchNumber.call(this, dateStr, startIndex, count, obeyCount);
	      if (match) {
	        year = match.value;
	        if ('era' in tmp) {
	          if (tmp.era === 0) {
	            year = 1 - year;
	          }
	        }
	        calendar.setYear(year);
	      }
	      break;
	    case 'M':
	      var month = undefined;
	      if (count >= 3) {
	        match = matchField(dateStr, startIndex, locale[count === 3 ? 'shortMonths' : 'months']);
	        if (match) {
	          month = match.value;
	        }
	      } else {
	        match = matchNumber.call(this, dateStr, startIndex, count, obeyCount);
	        if (match) {
	          month = match.value - 1;
	        }
	      }
	      if (match) {
	        calendar.setMonth(month);
	      }
	      break;
	    case 'k':
	      match = matchNumber.call(this, dateStr, startIndex, count, obeyCount);
	      if (match) {
	        calendar.setHourOfDay(match.value % 24);
	      }
	      break;
	    case 'E':
	      match = matchField(dateStr, startIndex, locale[count > 3 ? 'weekdays' : 'shortWeekdays']);
	      if (match) {
	        calendar.setDayOfWeek(match.value);
	      }
	      break;
	    case 'a':
	      match = matchField(dateStr, startIndex, locale.ampms);
	      if (match) {
	        if (calendar.isSetHourOfDay()) {
	          if (match.value) {
	            hour = calendar.getHourOfDay();
	            if (hour < 12) {
	              calendar.setHourOfDay((hour + 12) % 24);
	            }
	          }
	        } else {
	          tmp.ampm = match.value;
	        }
	      }
	      break;
	    case 'h':
	      match = matchNumber.call(this, dateStr, startIndex, count, obeyCount);
	      if (match) {
	        hour = match.value %= 12;
	        if (tmp.ampm) {
	          hour += 12;
	        }
	        calendar.setHourOfDay(hour);
	      }
	      break;
	    case 'K':
	      match = matchNumber.call(this, dateStr, startIndex, count, obeyCount);
	      if (match) {
	        hour = match.value;
	        if (tmp.ampm) {
	          hour += 12;
	        }
	        calendar.setHourOfDay(hour);
	      }
	      break;
	    case 'Z':
	      // let sign = 1;
	      var zoneChar = dateStr.charAt(startIndex);
	      if (zoneChar === '-') {
	        // sign = -1;
	        startIndex++;
	      } else if (zoneChar === '+') {
	        startIndex++;
	      } else {
	        break;
	      }
	      match = matchNumber.call(this, dateStr, startIndex, 2, true);
	      if (match) {
	        var zoneOffset = match.value * 60;
	        startIndex = match.startIndex;
	        match = matchNumber.call(this, dateStr, startIndex, 2, true);
	        if (match) {
	          zoneOffset += match.value;
	        }
	        calendar.setTimezoneOffset(zoneOffset);
	      }
	      break;
	    default:
	      // case 'd':
	      // case 'H':
	      // case 'm':
	      // case 's':
	      // case 'S':
	      // case 'D':
	      // case 'F':
	      // case 'w':
	      // case 'W'
	      match = matchNumber.call(this, dateStr, startIndex, count, obeyCount);
	      if (match) {
	        var index = calendarIndexMap[field];
	        calendar.set(index, match.value);
	      }
	  }
	  if (match) {
	    startIndex = match.startIndex;
	  }
	  return startIndex;
	}

	mix(DateTimeFormat.prototype, {
	  /*
	   * format a GregorianDate instance according to specified pattern
	   * @param {GregorianCalendar} calendar GregorianDate instance
	   * @returns {string} formatted string of GregorianDate instance
	   */
	  format: function format(calendar) {
	    if (!calendar.isGregorianCalendar) {
	      throw new Error('calendar must be type of GregorianCalendar');
	    }
	    var i = undefined;
	    var ret = [];
	    var pattern = this.pattern;
	    var len = pattern.length;
	    for (i = 0; i < len; i++) {
	      var comp = pattern[i];
	      if (comp.text) {
	        ret.push(comp.text);
	      } else if ('field' in comp) {
	        ret.push(formatField(comp.field, comp.count, this.locale, calendar));
	      }
	    }
	    return ret.join('');
	  },

	  /*
	   * parse a formatted string of GregorianDate instance according to specified pattern
	   * @param {String} dateStr formatted string of GregorianDate
	   * @returns {GregorianCalendar}
	   */
	  parse: function parse(dateStr, option_) {
	    var option = option_ || {};
	    var calendarLocale = option.locale;
	    var calendar = new GregorianCalendar(calendarLocale);
	    var i = undefined;
	    var j = undefined;
	    var tmp = {};
	    var obeyCount = option.obeyCount || false;
	    var dateStrLen = dateStr.length;
	    var errorIndex = -1;
	    var startIndex = 0;
	    var oldStartIndex = 0;
	    var pattern = this.pattern;
	    var len = pattern.length;
	    /* eslint no-labels: 0 no-empty-label:0 */
	    loopPattern: {
	      for (i = 0; errorIndex < 0 && i < len; i++) {
	        var comp = pattern[i];
	        var text = undefined;
	        var textLen = undefined;
	        oldStartIndex = startIndex;
	        text = comp.text;
	        if (text) {
	          textLen = text.length;
	          if (textLen + startIndex > dateStrLen) {
	            errorIndex = startIndex;
	          } else {
	            for (j = 0; j < textLen; j++) {
	              if (text.charAt(j) !== dateStr.charAt(j + startIndex)) {
	                errorIndex = startIndex;
	                break loopPattern;
	              }
	            }
	            startIndex += textLen;
	          }
	        } else if ('field' in comp) {
	          if (!option.obeyCount) {
	            var nextComp = pattern[i + 1];
	            obeyCount = false;
	            if (nextComp) {
	              if ('field' in nextComp) {
	                obeyCount = true;
	              } else {
	                var c = nextComp.text.charAt(0);
	                if (c >= '0' && c <= '9') {
	                  obeyCount = true;
	                }
	              }
	            }
	          }
	          startIndex = parseField.call(this, calendar, dateStr, startIndex, comp.field, comp.count, obeyCount, tmp);
	          if (startIndex === oldStartIndex) {
	            errorIndex = startIndex;
	          }
	        }
	      }
	    }

	    if (errorIndex >= 0) {
	      warning(false, 'error when parsing date: ' + dateStr + ', position: ' + dateStr.slice(0, errorIndex) + '^');
	      return undefined;
	    }
	    return calendar;
	  }
	});

	mix(DateTimeFormat, {
	  Style: DateTimeStyle,

	  /*
	   * get a formatter instance of short style pattern.
	   * en-us: M/d/yy h:mm a
	   * zh-cn: yy-M-d ah:mm
	   * @param {Object} locale locale object
	   * @returns {GregorianCalendar}
	   * @static
	   */
	  getInstance: function getInstance(locale) {
	    return this.getDateTimeInstance(DateTimeStyle.SHORT, DateTimeStyle.SHORT, locale);
	  },

	  /*
	   * get a formatter instance of specified date style.
	   * @param {Date.Formatter.Style} dateStyle date format style
	   * @param {Object} locale
	   * @returns {GregorianCalendar}
	   * @static
	   */
	  getDateInstance: function getDateInstance(dateStyle, locale) {
	    return this.getDateTimeInstance(dateStyle, undefined, locale);
	  },

	  /*
	   * get a formatter instance of specified date style and time style.
	   * @param {Date.Formatter.Style} dateStyle date format style
	   * @param {Date.Formatter.Style} timeStyle time format style
	   * @param {Object} locale
	   * @returns {GregorianCalendar}
	   * @static
	   */
	  getDateTimeInstance: function getDateTimeInstance(dateStyle, timeStyle, locale_) {
	    var locale = locale_ || enUsLocale;
	    var datePattern = '';
	    if (dateStyle !== undefined) {
	      datePattern = locale.datePatterns[dateStyle];
	    }
	    var timePattern = '';
	    if (timeStyle !== undefined) {
	      timePattern = locale.timePatterns[timeStyle];
	    }
	    var pattern = datePattern;
	    if (timePattern) {
	      if (datePattern) {
	        pattern = substitute(locale.dateTimePattern, {
	          date: datePattern,
	          time: timePattern
	        });
	      } else {
	        pattern = timePattern;
	      }
	    }
	    return new DateTimeFormat(pattern, locale);
	  },

	  /*
	   * get a formatter instance of specified time style.
	   * @param {Date.Formatter.Style} timeStyle time format style
	   * @param {Object} locale
	   * @returns {GregorianCalendar}
	   * @static
	   */
	  getTimeInstance: function getTimeInstance(timeStyle, locale) {
	    return this.getDateTimeInstance(undefined, timeStyle, locale);
	  }
	});

	module.exports = DateTimeFormat;

	DateTimeFormat.version = '@VERSION@';

	// gc_format@163.com

/***/ },
/* 410 */
/***/ function(module, exports) {

	'use strict';

	module.exports = {
	  eras: ['BC', 'AD'],
	  months: ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'],
	  shortMonths: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],
	  weekdays: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'],
	  shortWeekdays: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],
	  veryShortWeekdays: ['Su', 'Mo', 'Tu', 'We', 'Th', 'Fr', 'Sa'],
	  ampms: ['AM', 'PM'],
	  datePatterns: ['EEEE, MMMM d, yyyy', 'MMMM d, yyyy', 'MMM d, yyyy', 'M/d/yy'],
	  timePatterns: ['h:mm:ss a \'GMT\'Z', 'h:mm:ss a', 'h:mm:ss a', 'h:mm a'],
	  dateTimePattern: '{date} {time}'
	};

/***/ },
/* 411 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2014-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 */

	'use strict';

	/**
	 * Similar to invariant but only logs a warning if the condition is not met.
	 * This can be used to log issues in development environments in critical
	 * paths. Removing the logging code for production environments will keep the
	 * same logic and follow the same code paths.
	 */

	var warning = function() {};

	if (process.env.NODE_ENV !== 'production') {
	  warning = function(condition, format, args) {
	    var len = arguments.length;
	    args = new Array(len > 2 ? len - 2 : 0);
	    for (var key = 2; key < len; key++) {
	      args[key - 2] = arguments[key];
	    }
	    if (format === undefined) {
	      throw new Error(
	        '`warning(condition, format, ...args)` requires a warning ' +
	        'message argument'
	      );
	    }

	    if (format.length < 10 || (/^[s\W]*$/).test(format)) {
	      throw new Error(
	        'The warning format should be able to uniquely identify this ' +
	        'warning. Please, use a more descriptive format than: ' + format
	      );
	    }

	    if (!condition) {
	      var argIndex = 0;
	      var message = 'Warning: ' +
	        format.replace(/%s/g, function() {
	          return args[argIndex++];
	        });
	      if (typeof console !== 'undefined') {
	        console.error(message);
	      }
	      try {
	        // This error was thrown as a convenience so that you can use this stack
	        // to find the callsite that caused this warning to fire.
	        throw new Error(message);
	      } catch(x) {}
	    }
	  };
	}

	module.exports = warning;

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(243)))

/***/ },
/* 412 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _react = __webpack_require__(7);

	var _react2 = _interopRequireDefault(_react);

	var _MonthPanel = __webpack_require__(413);

	var _MonthPanel2 = _interopRequireDefault(_MonthPanel);

	var _index = __webpack_require__(408);

	var _YearPanel = __webpack_require__(414);

	var _YearPanel2 = _interopRequireDefault(_YearPanel);

	var _rcUtil = __webpack_require__(383);

	var _rcUtil2 = _interopRequireDefault(_rcUtil);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

	var toFragment = _rcUtil2["default"].Children.mapSelf;

	function goMonth(direction) {
	  var next = this.props.value.clone();
	  next.addMonth(direction);
	  this.props.onValueChange(next);
	}

	function goYear(direction) {
	  var next = this.props.value.clone();
	  next.addYear(direction);
	  this.props.onValueChange(next);
	}

	var CalendarHeader = _react2["default"].createClass({
	  displayName: 'CalendarHeader',

	  propTypes: {
	    enablePrev: _react.PropTypes.any,
	    enableNext: _react.PropTypes.any,
	    prefixCls: _react.PropTypes.string,
	    locale: _react.PropTypes.object,
	    value: _react.PropTypes.object,
	    onValueChange: _react.PropTypes.func
	  },

	  getDefaultProps: function getDefaultProps() {
	    return {
	      enableNext: 1,
	      enablePrev: 1
	    };
	  },
	  getInitialState: function getInitialState() {
	    var props = this.props;
	    this.yearFormatter = (0, _index.getFormatter)(props.locale.yearFormat, props.locale);
	    this.monthFormatter = (0, _index.getFormatter)(props.locale.monthFormat, props.locale);
	    this.nextMonth = goMonth.bind(this, 1);
	    this.previousMonth = goMonth.bind(this, -1);
	    this.nextYear = goYear.bind(this, 1);
	    this.previousYear = goYear.bind(this, -1);
	    return {};
	  },
	  componentWillReceiveProps: function componentWillReceiveProps(nextProps) {
	    var locale = this.props.locale;
	    var nextLocale = nextProps.locale;

	    if (nextLocale !== locale) {
	      this.yearFormatter = (0, _index.getFormatter)(nextLocale.yearFormat, nextLocale);
	      this.monthFormatter = (0, _index.getFormatter)(nextLocale.monthFormat, nextLocale);
	    }
	  },
	  onSelect: function onSelect(value) {
	    this.setState({
	      showMonthPanel: 0,
	      showYearPanel: 0
	    });
	    this.props.onValueChange(value);
	  },
	  getMonthYearElement: function getMonthYearElement() {
	    var props = this.props;
	    var prefixCls = props.prefixCls;
	    var locale = props.locale;
	    var value = this.props.value;
	    var monthBeforeYear = locale.monthBeforeYear;
	    var selectClassName = prefixCls + '-' + (monthBeforeYear ? 'my-select' : 'ym-select');
	    var year = _react2["default"].createElement(
	      'a',
	      {
	        className: prefixCls + '-year-select',
	        role: 'button',
	        onClick: this.showYearPanel,
	        title: locale.monthSelect
	      },
	      this.yearFormatter.format(value)
	    );
	    var month = _react2["default"].createElement(
	      'a',
	      {
	        className: prefixCls + '-month-select',
	        role: 'button',
	        onClick: this.showMonthPanel,
	        title: locale.monthSelect
	      },
	      this.monthFormatter.format(value)
	    );
	    var my = [];
	    if (monthBeforeYear) {
	      my = [month, year];
	    } else {
	      my = [year, month];
	    }
	    return _react2["default"].createElement(
	      'span',
	      { className: selectClassName },
	      toFragment(my)
	    );
	  },
	  showIf: function showIf(condition, el) {
	    return condition ? el : null;
	  },
	  showMonthPanel: function showMonthPanel() {
	    this.setState({
	      showMonthPanel: 1,
	      showYearPanel: 0
	    });
	  },
	  showYearPanel: function showYearPanel() {
	    this.setState({
	      showMonthPanel: 0,
	      showYearPanel: 1
	    });
	  },
	  render: function render() {
	    var props = this.props;
	    var enableNext = props.enableNext;
	    var enablePrev = props.enablePrev;
	    var prefixCls = props.prefixCls;
	    var locale = props.locale;
	    var value = props.value;

	    var state = this.state;
	    var PanelClass = null;
	    if (state.showMonthPanel) {
	      PanelClass = _MonthPanel2["default"];
	    } else if (state.showYearPanel) {
	      PanelClass = _YearPanel2["default"];
	    }
	    var panel = undefined;
	    if (PanelClass) {
	      panel = _react2["default"].createElement(PanelClass, {
	        locale: locale,
	        defaultValue: value,
	        rootPrefixCls: prefixCls,
	        onSelect: this.onSelect
	      });
	    }
	    return _react2["default"].createElement(
	      'div',
	      { className: prefixCls + '-header' },
	      _react2["default"].createElement(
	        'div',
	        { style: { position: 'relative' } },
	        this.showIf(enablePrev, _react2["default"].createElement(
	          'a',
	          {
	            className: prefixCls + '-prev-year-btn',
	            role: 'button',
	            onClick: this.previousYear,
	            title: locale.previousYear
	          },
	          '«'
	        )),
	        this.showIf(enablePrev, _react2["default"].createElement(
	          'a',
	          {
	            className: prefixCls + '-prev-month-btn',
	            role: 'button',
	            onClick: this.previousMonth,
	            title: locale.previousMonth
	          },
	          '‹'
	        )),
	        this.getMonthYearElement(),
	        this.showIf(enableNext, _react2["default"].createElement(
	          'a',
	          {
	            className: prefixCls + '-next-month-btn',
	            onClick: this.nextMonth,
	            title: locale.nextMonth
	          },
	          '›'
	        )),
	        this.showIf(enableNext, _react2["default"].createElement(
	          'a',
	          {
	            className: prefixCls + '-next-year-btn',
	            onClick: this.nextYear,
	            title: locale.nextYear
	          },
	          '»'
	        ))
	      ),
	      panel
	    );
	  }
	});

	exports["default"] = CalendarHeader;
	module.exports = exports['default'];

/***/ },
/* 413 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _react = __webpack_require__(7);

	var _react2 = _interopRequireDefault(_react);

	var _YearPanel = __webpack_require__(414);

	var _YearPanel2 = _interopRequireDefault(_YearPanel);

	var _MonthTable = __webpack_require__(416);

	var _MonthTable2 = _interopRequireDefault(_MonthTable);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

	function goYear(direction) {
	  var next = this.state.value.clone();
	  next.addYear(direction);
	  this.setAndChangeValue(next);
	}

	function noop() {}

	var MonthPanel = _react2["default"].createClass({
	  displayName: 'MonthPanel',

	  propTypes: {
	    onChange: _react.PropTypes.func,
	    disabledDate: _react.PropTypes.func,
	    onSelect: _react.PropTypes.func
	  },

	  getDefaultProps: function getDefaultProps() {
	    return {
	      onChange: noop,
	      onSelect: noop
	    };
	  },
	  getInitialState: function getInitialState() {
	    var props = this.props;
	    // bind methods
	    this.nextYear = goYear.bind(this, 1);
	    this.previousYear = goYear.bind(this, -1);
	    this.prefixCls = props.rootPrefixCls + '-month-panel';
	    return {
	      value: props.value || props.defaultValue
	    };
	  },
	  componentWillReceiveProps: function componentWillReceiveProps(nextProps) {
	    if ('value' in nextProps) {
	      this.setState({
	        value: nextProps.value
	      });
	    }
	  },
	  onYearPanelSelect: function onYearPanelSelect(current) {
	    this.setState({
	      showYearPanel: 0
	    });
	    this.setAndChangeValue(current);
	  },
	  setAndChangeValue: function setAndChangeValue(value) {
	    this.setValue(value);
	    this.props.onChange(value);
	  },
	  setAndSelectValue: function setAndSelectValue(value) {
	    this.setValue(value);
	    this.props.onSelect(value);
	  },
	  setValue: function setValue(value) {
	    if (!('value' in this.props)) {
	      this.setState({
	        value: value
	      });
	    }
	  },
	  showYearPanel: function showYearPanel() {
	    this.setState({
	      showYearPanel: 1
	    });
	  },
	  render: function render() {
	    var props = this.props;
	    var value = this.state.value;
	    var locale = props.locale;
	    var year = value.getYear();
	    var prefixCls = this.prefixCls;
	    var yearPanel = undefined;
	    if (this.state.showYearPanel) {
	      yearPanel = _react2["default"].createElement(_YearPanel2["default"], {
	        locale: locale,
	        value: value,
	        rootPrefixCls: props.rootPrefixCls,
	        onSelect: this.onYearPanelSelect
	      });
	    }
	    return _react2["default"].createElement(
	      'div',
	      { className: prefixCls, style: props.style },
	      _react2["default"].createElement(
	        'div',
	        null,
	        _react2["default"].createElement(
	          'div',
	          { className: prefixCls + '-header' },
	          _react2["default"].createElement(
	            'a',
	            {
	              className: prefixCls + '-prev-year-btn',
	              role: 'button',
	              onClick: this.previousYear,
	              title: locale.previousYear
	            },
	            '«'
	          ),
	          _react2["default"].createElement(
	            'a',
	            {
	              className: prefixCls + '-year-select',
	              role: 'button',
	              onClick: this.showYearPanel,
	              title: locale.yearSelect
	            },
	            _react2["default"].createElement(
	              'span',
	              { className: prefixCls + '-year-select-content' },
	              year
	            ),
	            _react2["default"].createElement(
	              'span',
	              { className: prefixCls + '-year-select-arrow' },
	              'x'
	            )
	          ),
	          _react2["default"].createElement(
	            'a',
	            {
	              className: prefixCls + '-next-year-btn',
	              role: 'button',
	              onClick: this.nextYear,
	              title: locale.nextYear
	            },
	            '»'
	          )
	        ),
	        _react2["default"].createElement(
	          'div',
	          { className: prefixCls + '-body' },
	          _react2["default"].createElement(_MonthTable2["default"], {
	            disabledDate: props.disabledDate,
	            onSelect: this.setAndSelectValue,
	            locale: locale,
	            value: value,
	            prefixCls: prefixCls
	          })
	        )
	      ),
	      yearPanel
	    );
	  }
	});

	exports["default"] = MonthPanel;
	module.exports = exports['default'];

/***/ },
/* 414 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _react = __webpack_require__(7);

	var _react2 = _interopRequireDefault(_react);

	var _classnames = __webpack_require__(19);

	var _classnames2 = _interopRequireDefault(_classnames);

	var _DecadePanel = __webpack_require__(415);

	var _DecadePanel2 = _interopRequireDefault(_DecadePanel);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

	function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

	function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

	var ROW = 4;
	var COL = 3;

	function goYear(direction) {
	  var value = this.state.value.clone();
	  value.addYear(direction);
	  this.setState({
	    value: value
	  });
	}

	function chooseYear(year) {
	  var value = this.state.value.clone();
	  value.setYear(year);
	  value.rollSetMonth(this.state.value.getMonth());
	  this.props.onSelect(value);
	}

	var YearPanel = function (_React$Component) {
	  _inherits(YearPanel, _React$Component);

	  function YearPanel(props) {
	    _classCallCheck(this, YearPanel);

	    var _this = _possibleConstructorReturn(this, _React$Component.call(this, props));

	    _this.prefixCls = props.rootPrefixCls + '-year-panel';
	    _this.state = {
	      value: props.value || props.defaultValue
	    };
	    _this.nextDecade = goYear.bind(_this, 10);
	    _this.previousDecade = goYear.bind(_this, -10);
	    ['showDecadePanel', 'onDecadePanelSelect'].forEach(function (method) {
	      _this[method] = _this[method].bind(_this);
	    });
	    return _this;
	  }

	  YearPanel.prototype.onDecadePanelSelect = function onDecadePanelSelect(current) {
	    this.setState({
	      value: current,
	      showDecadePanel: 0
	    });
	  };

	  YearPanel.prototype.getYears = function getYears() {
	    var value = this.state.value;
	    var currentYear = value.getYear();
	    var startYear = parseInt(currentYear / 10, 10) * 10;
	    var previousYear = startYear - 1;
	    var endYear = startYear + 9;
	    var years = [];
	    var index = 0;
	    for (var rowIndex = 0; rowIndex < ROW; rowIndex++) {
	      years[rowIndex] = [];
	      for (var colIndex = 0; colIndex < COL; colIndex++) {
	        var year = previousYear + index;
	        var content = undefined;
	        if (year < startYear) {
	          content = '';
	        } else if (year > endYear) {
	          content = '';
	        } else {
	          content = String(year);
	        }
	        years[rowIndex][colIndex] = {
	          content: content,
	          year: year,
	          title: content
	        };
	        index++;
	      }
	    }
	    return years;
	  };

	  YearPanel.prototype.showDecadePanel = function showDecadePanel() {
	    this.setState({
	      showDecadePanel: 1
	    });
	  };

	  YearPanel.prototype.render = function render() {
	    var _this2 = this;

	    var props = this.props;
	    var value = this.state.value;
	    var locale = props.locale;
	    var years = this.getYears();
	    var currentYear = value.getYear();
	    var startYear = parseInt(currentYear / 10, 10) * 10;
	    var endYear = startYear + 9;
	    var prefixCls = this.prefixCls;

	    var yeasEls = years.map(function (row, index) {
	      var tds = row.map(function (yearData) {
	        var _classNameMap;

	        var classNameMap = (_classNameMap = {}, _defineProperty(_classNameMap, prefixCls + '-cell', 1), _defineProperty(_classNameMap, prefixCls + '-selected-cell', yearData.year === currentYear), _defineProperty(_classNameMap, prefixCls + '-last-decade-cell', yearData.year < startYear), _defineProperty(_classNameMap, prefixCls + '-next-decade-cell', yearData.year > endYear), _classNameMap);
	        var clickHandler = undefined;
	        if (yearData.year < startYear) {
	          clickHandler = _this2.previousDecade;
	        } else if (yearData.year > endYear) {
	          clickHandler = _this2.nextDecade;
	        } else {
	          clickHandler = chooseYear.bind(_this2, yearData.year);
	        }
	        return _react2["default"].createElement(
	          'td',
	          {
	            role: 'gridcell',
	            title: yearData.title,
	            key: yearData.content,
	            onClick: clickHandler,
	            className: (0, _classnames2["default"])(classNameMap)
	          },
	          _react2["default"].createElement(
	            'a',
	            {
	              className: prefixCls + '-year'
	            },
	            yearData.content
	          )
	        );
	      });
	      return _react2["default"].createElement(
	        'tr',
	        { key: index, role: 'row' },
	        tds
	      );
	    });

	    var decadePanel = undefined;
	    if (this.state.showDecadePanel) {
	      decadePanel = _react2["default"].createElement(_DecadePanel2["default"], {
	        locale: locale,
	        value: value,
	        rootPrefixCls: props.rootPrefixCls,
	        onSelect: this.onDecadePanelSelect
	      });
	    }

	    return _react2["default"].createElement(
	      'div',
	      { className: this.prefixCls },
	      _react2["default"].createElement(
	        'div',
	        null,
	        _react2["default"].createElement(
	          'div',
	          { className: prefixCls + '-header' },
	          _react2["default"].createElement(
	            'a',
	            {
	              className: prefixCls + '-prev-decade-btn',
	              role: 'button',
	              onClick: this.previousDecade,
	              title: locale.previousDecade
	            },
	            '«'
	          ),
	          _react2["default"].createElement(
	            'a',
	            {
	              className: prefixCls + '-decade-select',
	              role: 'button',
	              onClick: this.showDecadePanel,
	              title: locale.decadeSelect
	            },
	            _react2["default"].createElement(
	              'span',
	              { className: prefixCls + '-decade-select-content' },
	              startYear,
	              '-',
	              endYear
	            ),
	            _react2["default"].createElement(
	              'span',
	              { className: prefixCls + '-decade-select-arrow' },
	              'x'
	            )
	          ),
	          _react2["default"].createElement(
	            'a',
	            {
	              className: prefixCls + '-next-decade-btn',
	              role: 'button',
	              onClick: this.nextDecade,
	              title: locale.nextDecade
	            },
	            '»'
	          )
	        ),
	        _react2["default"].createElement(
	          'div',
	          { className: prefixCls + '-body' },
	          _react2["default"].createElement(
	            'table',
	            { className: prefixCls + '-table', cellSpacing: '0', role: 'grid' },
	            _react2["default"].createElement(
	              'tbody',
	              { className: prefixCls + '-tbody' },
	              yeasEls
	            )
	          )
	        )
	      ),
	      decadePanel
	    );
	  };

	  return YearPanel;
	}(_react2["default"].Component);

	exports["default"] = YearPanel;


	YearPanel.propTypes = {
	  rootPrefixCls: _react.PropTypes.string,
	  value: _react.PropTypes.object,
	  defaultValue: _react.PropTypes.object
	};

	YearPanel.defaultProps = {
	  onSelect: function onSelect() {}
	};
	module.exports = exports['default'];

/***/ },
/* 415 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _react = __webpack_require__(7);

	var _react2 = _interopRequireDefault(_react);

	var _classnames = __webpack_require__(19);

	var _classnames2 = _interopRequireDefault(_classnames);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

	function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

	function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

	var ROW = 4;
	var COL = 3;


	function goYear(direction) {
	  var next = this.state.value.clone();
	  next.addYear(direction);
	  this.setState({
	    value: next
	  });
	}

	function chooseDecade(year, event) {
	  var next = this.state.value.clone();
	  next.setYear(year);
	  next.rollSetMonth(this.state.value.getMonth());
	  this.props.onSelect(next);
	  event.preventDefault();
	}

	var DecadePanel = function (_React$Component) {
	  _inherits(DecadePanel, _React$Component);

	  function DecadePanel(props) {
	    _classCallCheck(this, DecadePanel);

	    var _this = _possibleConstructorReturn(this, _React$Component.call(this, props));

	    _this.state = {
	      value: props.value || props.defaultValue
	    };

	    // bind methods
	    _this.prefixCls = props.rootPrefixCls + '-decade-panel';
	    _this.nextCentury = goYear.bind(_this, 100);
	    _this.previousCentury = goYear.bind(_this, -100);
	    return _this;
	  }

	  DecadePanel.prototype.render = function render() {
	    var _this2 = this;

	    var value = this.state.value;
	    var locale = this.props.locale;
	    var currentYear = value.getYear();
	    var startYear = parseInt(currentYear / 100, 10) * 100;
	    var preYear = startYear - 10;
	    var endYear = startYear + 99;
	    var decades = [];
	    var index = 0;
	    var prefixCls = this.prefixCls;

	    for (var rowIndex = 0; rowIndex < ROW; rowIndex++) {
	      decades[rowIndex] = [];
	      for (var colIndex = 0; colIndex < COL; colIndex++) {
	        var startDecade = preYear + index * 10;
	        var endDecade = preYear + index * 10 + 9;
	        decades[rowIndex][colIndex] = {
	          startDecade: startDecade,
	          endDecade: endDecade
	        };
	        index++;
	      }
	    }

	    var decadesEls = decades.map(function (row, decadeIndex) {
	      var tds = row.map(function (decadeData) {
	        var _classNameMap;

	        var dStartDecade = decadeData.startDecade;
	        var dEndDecade = decadeData.endDecade;
	        var isLast = dStartDecade < startYear;
	        var isNext = dEndDecade > endYear;
	        var classNameMap = (_classNameMap = {}, _defineProperty(_classNameMap, prefixCls + '-cell', 1), _defineProperty(_classNameMap, prefixCls + '-selected-cell', dStartDecade <= currentYear && currentYear <= dEndDecade), _defineProperty(_classNameMap, prefixCls + '-last-century-cell', isLast), _defineProperty(_classNameMap, prefixCls + '-next-century-cell', isNext), _classNameMap);
	        var content = undefined;
	        var clickHandler = undefined;
	        if (isLast) {
	          clickHandler = _this2.previousCentury;
	        } else if (isNext) {
	          clickHandler = _this2.nextCentury;
	        } else {
	          content = dStartDecade + '-' + dEndDecade;
	          clickHandler = chooseDecade.bind(_this2, dStartDecade);
	        }
	        return _react2["default"].createElement(
	          'td',
	          {
	            key: dStartDecade,
	            onClick: clickHandler,
	            role: 'gridcell',
	            className: (0, _classnames2["default"])(classNameMap)
	          },
	          _react2["default"].createElement(
	            'a',
	            {
	              className: prefixCls + '-decade'
	            },
	            content
	          )
	        );
	      });
	      return _react2["default"].createElement(
	        'tr',
	        { key: decadeIndex, role: 'row' },
	        tds
	      );
	    });

	    return _react2["default"].createElement(
	      'div',
	      { className: this.prefixCls },
	      _react2["default"].createElement(
	        'div',
	        { className: prefixCls + '-header' },
	        _react2["default"].createElement(
	          'a',
	          {
	            className: prefixCls + '-prev-century-btn',
	            role: 'button',
	            onClick: this.previousCentury,
	            title: locale.previousCentury
	          },
	          '«'
	        ),
	        _react2["default"].createElement(
	          'div',
	          { className: prefixCls + '-century' },
	          startYear,
	          '-',
	          endYear
	        ),
	        _react2["default"].createElement(
	          'a',
	          {
	            className: prefixCls + '-next-century-btn',
	            role: 'button',
	            onClick: this.nextCentury,
	            title: locale.nextCentury
	          },
	          '»'
	        )
	      ),
	      _react2["default"].createElement(
	        'div',
	        { className: prefixCls + '-body' },
	        _react2["default"].createElement(
	          'table',
	          { className: prefixCls + '-table', cellSpacing: '0', role: 'grid' },
	          _react2["default"].createElement(
	            'tbody',
	            { className: prefixCls + '-tbody' },
	            decadesEls
	          )
	        )
	      )
	    );
	  };

	  return DecadePanel;
	}(_react2["default"].Component);

	exports["default"] = DecadePanel;


	DecadePanel.propTypes = {
	  locale: _react.PropTypes.object,
	  value: _react.PropTypes.object,
	  defaultValue: _react.PropTypes.object,
	  rootPrefixCls: _react.PropTypes.string
	};

	DecadePanel.defaultProps = {
	  onSelect: function onSelect() {}
	};
	module.exports = exports['default'];

/***/ },
/* 416 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _react = __webpack_require__(7);

	var _react2 = _interopRequireDefault(_react);

	var _classnames = __webpack_require__(19);

	var _classnames2 = _interopRequireDefault(_classnames);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

	function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

	function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

	var ROW = 4;
	var COL = 3;

	function chooseMonth(month) {
	  var next = this.state.value.clone();
	  next.rollSetMonth(month);
	  this.setAndSelectValue(next);
	}

	function noop() {}

	var MonthTable = function (_Component) {
	  _inherits(MonthTable, _Component);

	  function MonthTable(props) {
	    _classCallCheck(this, MonthTable);

	    var _this = _possibleConstructorReturn(this, _Component.call(this, props));

	    _this.state = {
	      value: props.value
	    };
	    return _this;
	  }

	  MonthTable.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
	    if ('value' in nextProps) {
	      this.setState({
	        value: nextProps.value
	      });
	    }
	  };

	  MonthTable.prototype.getMonths = function getMonths() {
	    var props = this.props;
	    var value = this.state.value;
	    var current = value.clone();
	    var locale = props.locale;
	    var months = [];
	    var shortMonths = locale.format.shortMonths;
	    var index = 0;
	    for (var rowIndex = 0; rowIndex < ROW; rowIndex++) {
	      months[rowIndex] = [];
	      for (var colIndex = 0; colIndex < COL; colIndex++) {
	        current.rollSetMonth(index);
	        months[rowIndex][colIndex] = {
	          value: index,
	          content: shortMonths[index],
	          title: shortMonths[index]
	        };
	        index++;
	      }
	    }
	    return months;
	  };

	  MonthTable.prototype.setAndSelectValue = function setAndSelectValue(value) {
	    this.setState({
	      value: value
	    });
	    this.props.onSelect(value);
	  };

	  MonthTable.prototype.render = function render() {
	    var _this2 = this;

	    var props = this.props;
	    var value = this.state.value;
	    var today = value.clone();
	    today.setTime(Date.now());
	    var months = this.getMonths();
	    var currentMonth = value.getMonth();
	    var prefixCls = props.prefixCls;
	    var locale = props.locale;
	    var contentRender = props.contentRender;
	    var cellRender = props.cellRender;

	    var monthsEls = months.map(function (month, index) {
	      var tds = month.map(function (monthData) {
	        var _classNameMap;

	        var disabled = false;
	        if (props.disabledDate) {
	          var testValue = value.clone();
	          testValue.rollSetMonth(monthData.value);
	          disabled = props.disabledDate(testValue);
	        }
	        var classNameMap = (_classNameMap = {}, _defineProperty(_classNameMap, prefixCls + '-cell', 1), _defineProperty(_classNameMap, prefixCls + '-cell-disabled', disabled), _defineProperty(_classNameMap, prefixCls + '-selected-cell', monthData.value === currentMonth), _defineProperty(_classNameMap, prefixCls + '-current-cell', today.getYear() === value.getYear() && monthData.value === today.getMonth()), _classNameMap);
	        var cellEl = undefined;
	        if (cellRender) {
	          var currentValue = value.clone();
	          currentValue.rollSetMonth(monthData.value);
	          cellEl = cellRender(currentValue, locale);
	        } else {
	          var content = undefined;
	          if (contentRender) {
	            var _currentValue = value.clone();
	            _currentValue.rollSetMonth(monthData.value);
	            content = contentRender(_currentValue, locale);
	          } else {
	            content = monthData.content;
	          }
	          cellEl = _react2["default"].createElement(
	            'div',
	            { className: prefixCls + '-month' },
	            content
	          );
	        }
	        return _react2["default"].createElement(
	          'td',
	          {
	            role: 'gridcell',
	            key: monthData.value,
	            onClick: disabled ? null : chooseMonth.bind(_this2, monthData.value),
	            title: monthData.title,
	            className: (0, _classnames2["default"])(classNameMap)
	          },
	          cellEl
	        );
	      });
	      return _react2["default"].createElement(
	        'tr',
	        { key: index, role: 'row' },
	        tds
	      );
	    });

	    return _react2["default"].createElement(
	      'table',
	      { className: prefixCls + '-table', cellSpacing: '0', role: 'grid' },
	      _react2["default"].createElement(
	        'tbody',
	        { className: prefixCls + '-tbody' },
	        monthsEls
	      )
	    );
	  };

	  return MonthTable;
	}(_react.Component);

	MonthTable.defaultProps = {
	  onSelect: noop
	};
	MonthTable.propTypes = {
	  onSelect: _react.PropTypes.func,
	  cellRender: _react.PropTypes.func,
	  prefixCls: _react.PropTypes.string,
	  value: _react.PropTypes.object
	};
	exports["default"] = MonthTable;
	module.exports = exports['default'];

/***/ },
/* 417 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

	var _react = __webpack_require__(7);

	var _react2 = _interopRequireDefault(_react);

	var _reactDom = __webpack_require__(8);

	var _reactDom2 = _interopRequireDefault(_reactDom);

	var _rcUtil = __webpack_require__(383);

	var _rcUtil2 = _interopRequireDefault(_rcUtil);

	var _TodayButton = __webpack_require__(418);

	var _TodayButton2 = _interopRequireDefault(_TodayButton);

	var _OkButton = __webpack_require__(419);

	var _OkButton2 = _interopRequireDefault(_OkButton);

	var _index = __webpack_require__(408);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

	var toFragment = _rcUtil2["default"].Children.mapSelf;


	var CalendarFooter = _react2["default"].createClass({
	  displayName: 'CalendarFooter',

	  propTypes: {
	    prefixCls: _react.PropTypes.string,
	    showDateInput: _react.PropTypes.bool,
	    disabledTime: _react.PropTypes.any,
	    gregorianCalendarLocale: _react.PropTypes.object,
	    selectedValue: _react.PropTypes.any,
	    showOk: _react.PropTypes.bool,
	    onSelect: _react.PropTypes.func,
	    value: _react.PropTypes.object,
	    defaultValue: _react.PropTypes.object
	  },

	  onSelect: function onSelect(value) {
	    this.props.onSelect(value);
	  },
	  getRootDOMNode: function getRootDOMNode() {
	    return _reactDom2["default"].findDOMNode(this);
	  },
	  render: function render() {
	    var props = this.props;
	    var value = props.value;
	    var prefixCls = props.prefixCls;
	    var showDateInput = props.showDateInput;
	    var disabledTime = props.disabledTime;
	    var gregorianCalendarLocale = props.gregorianCalendarLocale;
	    var selectedValue = props.selectedValue;
	    var showOk = props.showOk;

	    var timePicker = !showDateInput && props.timePicker || null;
	    var disabledTimeConfig = disabledTime && timePicker ? (0, _index.getTimeConfig)(selectedValue, disabledTime) : null;
	    var footerEl = null;
	    if (props.showToday || timePicker) {
	      var nowEl = undefined;
	      if (props.showToday) {
	        nowEl = _react2["default"].createElement(_TodayButton2["default"], _extends({}, props, { value: value }));
	      }
	      var okBtn = undefined;
	      if (showOk === true || showOk !== false && !!props.timePicker) {
	        okBtn = _react2["default"].createElement(_OkButton2["default"], props);
	      }
	      var footerBtn = undefined;
	      if (nowEl || okBtn) {
	        footerBtn = _react2["default"].createElement(
	          'span',
	          { className: prefixCls + '-footer-btn' },
	          toFragment([nowEl, okBtn])
	        );
	      }
	      if (timePicker) {
	        timePicker = _react2["default"].cloneElement(timePicker, _extends({
	          onChange: this.onSelect,
	          allowEmpty: false,
	          gregorianCalendarLocale: gregorianCalendarLocale
	        }, disabledTimeConfig, {
	          getPopupContainer: this.getRootDOMNode,
	          value: selectedValue
	        }));
	      }
	      footerEl = _react2["default"].createElement(
	        'div',
	        { className: prefixCls + '-footer' },
	        timePicker,
	        footerBtn
	      );
	    }
	    return footerEl;
	  }
	});

	exports["default"] = CalendarFooter;
	module.exports = exports['default'];

/***/ },
/* 418 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports["default"] = TodayButton;

	var _react = __webpack_require__(7);

	var _react2 = _interopRequireDefault(_react);

	var _util = __webpack_require__(408);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

	function TodayButton(_ref) {
	  var prefixCls = _ref.prefixCls;
	  var locale = _ref.locale;
	  var value = _ref.value;
	  var timePicker = _ref.timePicker;
	  var disabledDate = _ref.disabledDate;
	  var disabledTime = _ref.disabledTime;
	  var onToday = _ref.onToday;
	  var text = _ref.text;

	  var disabledToday = false;
	  var localeNow = text;
	  if (!localeNow && timePicker) {
	    localeNow = locale.now;
	  }
	  localeNow = localeNow || locale.today;
	  var disabledTodayClass = '';
	  if (disabledDate) {
	    disabledToday = !(0, _util.isAllowedDate)((0, _util.getTodayTime)(value), disabledDate, disabledTime);
	    if (disabledToday) {
	      disabledTodayClass = prefixCls + '-today-btn-disabled';
	    }
	  }
	  return _react2["default"].createElement(
	    'a',
	    {
	      className: prefixCls + '-today-btn ' + disabledTodayClass,
	      role: 'button',
	      onClick: disabledToday ? null : onToday,
	      title: (0, _util.getTodayTimeStr)(value)
	    },
	    localeNow
	  );
	}
	module.exports = exports['default'];

/***/ },
/* 419 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports["default"] = OkButton;

	var _react = __webpack_require__(7);

	var _react2 = _interopRequireDefault(_react);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

	function OkButton(_ref) {
	  var prefixCls = _ref.prefixCls;
	  var locale = _ref.locale;
	  var okDisabled = _ref.okDisabled;
	  var onOk = _ref.onOk;

	  var className = prefixCls + "-ok-btn";
	  if (okDisabled) {
	    className += " " + prefixCls + "-ok-btn-disabled";
	  }
	  return _react2["default"].createElement(
	    "a",
	    {
	      className: className,
	      role: "button",
	      onClick: okDisabled ? null : onOk
	    },
	    locale.ok
	  );
	}
	module.exports = exports['default'];

/***/ },
/* 420 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _react = __webpack_require__(7);

	var _react2 = _interopRequireDefault(_react);

	var _classnames = __webpack_require__(19);

	var _classnames2 = _interopRequireDefault(_classnames);

	var _gregorianCalendar = __webpack_require__(379);

	var _gregorianCalendar2 = _interopRequireDefault(_gregorianCalendar);

	var _index = __webpack_require__(408);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

	function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

	function noop() {}

	function getNow() {
	  var value = new _gregorianCalendar2["default"]();
	  value.setTime(Date.now());
	  return value;
	}

	function getNowByCurrentStateValue(value) {
	  var ret = undefined;
	  if (value) {
	    ret = value.clone();
	    ret.setTime(Date.now());
	  } else {
	    ret = getNow();
	  }
	  return ret;
	}

	var CalendarMixin = {
	  propTypes: {
	    value: _react.PropTypes.object,
	    defaultValue: _react.PropTypes.object,
	    onKeyDown: _react.PropTypes.func
	  },

	  getDefaultProps: function getDefaultProps() {
	    return {
	      onKeyDown: noop
	    };
	  },
	  getInitialState: function getInitialState() {
	    var props = this.props;
	    var value = props.value || props.defaultValue || getNow();
	    return {
	      value: value,
	      selectedValue: props.selectedValue || props.defaultSelectedValue
	    };
	  },
	  componentWillReceiveProps: function componentWillReceiveProps(nextProps) {
	    var value = nextProps.value;
	    var selectedValue = nextProps.selectedValue;

	    if ('value' in nextProps) {
	      value = value || nextProps.defaultValue || getNowByCurrentStateValue(this.state.value);
	      this.setState({
	        value: value
	      });
	    }
	    if ('selectedValue' in nextProps) {
	      this.setState({
	        selectedValue: selectedValue
	      });
	    }
	  },
	  onSelect: function onSelect(value, cause) {
	    if (value) {
	      this.setValue(value);
	    }
	    this.setSelectedValue(value, cause);
	  },
	  renderRoot: function renderRoot(newProps) {
	    var _className;

	    var props = this.props;
	    var prefixCls = props.prefixCls;

	    var className = (_className = {}, _defineProperty(_className, prefixCls, 1), _defineProperty(_className, prefixCls + '-hidden', !props.visible), _defineProperty(_className, props.className, !!props.className), _defineProperty(_className, newProps.className, !!newProps.className), _className);

	    return _react2["default"].createElement(
	      'div',
	      {
	        className: '' + (0, _classnames2["default"])(className),
	        style: this.props.style,
	        tabIndex: '0', onKeyDown: this.onKeyDown
	      },
	      newProps.children
	    );
	  },
	  setSelectedValue: function setSelectedValue(selectedValue, cause) {
	    if (this.isAllowedDate(selectedValue)) {
	      if (!('selectedValue' in this.props)) {
	        this.setState({
	          selectedValue: selectedValue
	        });
	      }
	      this.props.onSelect(selectedValue, cause);
	    }
	  },
	  setValue: function setValue(value) {
	    var originalValue = this.state.value;
	    if (!('value' in this.props)) {
	      this.setState({
	        value: value
	      });
	    }
	    if (originalValue && value && originalValue.getTime() !== value.getTime() || !originalValue && value || originalValue && !value) {
	      this.props.onChange(value);
	    }
	  },
	  isAllowedDate: function isAllowedDate(value) {
	    var disabledDate = this.props.disabledDate;
	    var disabledTime = this.props.disabledTime;
	    return (0, _index.isAllowedDate)(value, disabledDate, disabledTime);
	  }
	};

	exports["default"] = CalendarMixin;
	module.exports = exports['default'];

/***/ },
/* 421 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _react = __webpack_require__(7);

	var _en_US = __webpack_require__(422);

	var _en_US2 = _interopRequireDefault(_en_US);

	var _index = __webpack_require__(408);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

	function noop() {}

	exports["default"] = {
	  propTypes: {
	    className: _react.PropTypes.string,
	    locale: _react.PropTypes.object,
	    style: _react.PropTypes.object,
	    visible: _react.PropTypes.bool,
	    onSelect: _react.PropTypes.func,
	    prefixCls: _react.PropTypes.string,
	    onChange: _react.PropTypes.func,
	    onOk: _react.PropTypes.func
	  },

	  getDefaultProps: function getDefaultProps() {
	    return {
	      locale: _en_US2["default"],
	      style: {},
	      visible: true,
	      prefixCls: 'rc-calendar',
	      formatter: 'yyyy-MM-dd',
	      className: '',
	      onSelect: noop,
	      onChange: noop,
	      onClear: noop
	    };
	  },
	  shouldComponentUpdate: function shouldComponentUpdate(nextProps) {
	    return this.props.visible || nextProps.visible;
	  },
	  getFormatter: function getFormatter() {
	    var formatter = this.props.formatter;
	    var locale = this.props.locale;
	    if (this.normalFormatter && formatter === this.lastFormatter) {
	      return this.normalFormatter;
	    }
	    this.normalFormatter = (0, _index.getFormatter)(formatter, locale);
	    this.lastFormatter = formatter;
	    return this.normalFormatter;
	  }
	};
	module.exports = exports['default'];

/***/ },
/* 422 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _en_US = __webpack_require__(410);

	var _en_US2 = _interopRequireDefault(_en_US);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

	exports["default"] = {
	  today: 'Today',
	  now: 'Now',
	  backToToday: 'Back to today',
	  ok: 'Ok',
	  clear: 'Clear',
	  month: 'Month',
	  year: 'Year',
	  monthSelect: 'Choose a month',
	  yearSelect: 'Choose a year',
	  decadeSelect: 'Choose a decade',
	  yearFormat: 'yyyy',
	  dateFormat: 'M/d/yyyy',
	  monthFormat: 'MMMM',
	  monthBeforeYear: true,
	  previousMonth: 'Previous month (PageUp)',
	  nextMonth: 'Next month (PageDown)',
	  previousYear: 'Last year (Control + left)',
	  nextYear: 'Next year (Control + right)',
	  previousDecade: 'Last decade',
	  nextDecade: 'Next decade',
	  previousCentury: 'Last century',
	  nextCentury: 'Next century',
	  format: _en_US2["default"]
	};
	module.exports = exports['default'];

/***/ },
/* 423 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

	var _react = __webpack_require__(7);

	var _react2 = _interopRequireDefault(_react);

	var _reactDom = __webpack_require__(8);

	var _reactDom2 = _interopRequireDefault(_reactDom);

	var _index = __webpack_require__(408);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

	function copyTime(target, source) {
	  if (source) {
	    target.setHourOfDay(source.getHourOfDay());
	    target.setMinutes(source.getMinutes());
	    target.setSeconds(source.getSeconds());
	  }
	  return target;
	}

	var DateInput = _react2["default"].createClass({
	  displayName: 'DateInput',

	  propTypes: {
	    prefixCls: _react.PropTypes.string,
	    timePicker: _react.PropTypes.object,
	    disabledTime: _react.PropTypes.any,
	    formatter: _react.PropTypes.object,
	    locale: _react.PropTypes.object,
	    gregorianCalendarLocale: _react.PropTypes.object,
	    disabledDate: _react.PropTypes.func,
	    onChange: _react.PropTypes.func,
	    onClear: _react.PropTypes.func,
	    placeholder: _react.PropTypes.string,
	    onSelect: _react.PropTypes.func,
	    selectedValue: _react.PropTypes.object
	  },

	  getInitialState: function getInitialState() {
	    var selectedValue = this.props.selectedValue;
	    return {
	      str: selectedValue && this.props.formatter.format(selectedValue) || '',
	      invalid: false
	    };
	  },
	  componentWillReceiveProps: function componentWillReceiveProps(nextProps) {
	    // when popup show, click body will call this, bug!
	    var selectedValue = nextProps.selectedValue;
	    this.setState({
	      str: selectedValue && nextProps.formatter.format(selectedValue) || '',
	      invalid: false
	    });
	  },
	  onInputChange: function onInputChange(event) {
	    var str = event.target.value;
	    this.setState({
	      str: str
	    });
	    var value = undefined;
	    var _props = this.props;
	    var disabledDate = _props.disabledDate;
	    var formatter = _props.formatter;
	    var gregorianCalendarLocale = _props.gregorianCalendarLocale;
	    var onChange = _props.onChange;

	    if (str) {
	      try {
	        value = copyTime(formatter.parse(str, {
	          locale: gregorianCalendarLocale,
	          obeyCount: true
	        }), this.props.selectedValue);
	      } catch (ex) {
	        this.setState({
	          invalid: true
	        });
	        return;
	      }
	      if (value && (!disabledDate || !disabledDate(value))) {
	        var originalValue = this.props.selectedValue;
	        if (originalValue && value) {
	          if (originalValue.getTime() !== value.getTime()) {
	            onChange(value);
	          }
	        } else if (originalValue !== value) {
	          onChange(value);
	        }
	      } else {
	        this.setState({
	          invalid: true
	        });
	        return;
	      }
	    } else {
	      onChange(null);
	    }
	    this.setState({
	      invalid: false
	    });
	  },
	  onClear: function onClear() {
	    this.setState({
	      str: ''
	    });
	    this.props.onClear(null);
	  },
	  getRootDOMNode: function getRootDOMNode() {
	    return _reactDom2["default"].findDOMNode(this);
	  },
	  render: function render() {
	    var props = this.props;
	    var _state = this.state;
	    var invalid = _state.invalid;
	    var str = _state.str;
	    var selectedValue = props.selectedValue;
	    var locale = props.locale;
	    var prefixCls = props.prefixCls;
	    var placeholder = props.placeholder;
	    var onChange = props.onChange;
	    var timePicker = props.timePicker;
	    var disabledTime = props.disabledTime;
	    var gregorianCalendarLocale = props.gregorianCalendarLocale;

	    var invalidClass = invalid ? prefixCls + '-input-invalid' : '';
	    var disabledTimeConfig = disabledTime && timePicker ? (0, _index.getTimeConfig)(selectedValue, disabledTime) : null;
	    return _react2["default"].createElement(
	      'div',
	      { className: prefixCls + '-input-wrap' },
	      _react2["default"].createElement(
	        'div',
	        { className: prefixCls + '-time-picker-wrap' },
	        timePicker ? _react2["default"].cloneElement(timePicker, _extends({
	          showClear: false,
	          allowEmpty: false,
	          getPopupContainer: this.getRootDOMNode,
	          gregorianCalendarLocale: gregorianCalendarLocale,
	          value: selectedValue,
	          onChange: onChange
	        }, disabledTimeConfig)) : null
	      ),
	      _react2["default"].createElement(
	        'div',
	        { className: prefixCls + '-date-input-wrap' },
	        _react2["default"].createElement('input', {
	          className: prefixCls + '-input  ' + invalidClass,
	          value: str,
	          placeholder: placeholder,
	          onChange: this.onInputChange
	        })
	      ),
	      props.showClear ? _react2["default"].createElement('a', {
	        className: prefixCls + '-clear-btn',
	        role: 'button',
	        title: locale.clear,
	        onClick: this.onClear
	      }) : null
	    );
	  }
	});

	exports["default"] = DateInput;
	module.exports = exports['default'];

/***/ },
/* 424 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _react = __webpack_require__(7);

	var _react2 = _interopRequireDefault(_react);

	var _reactDom = __webpack_require__(8);

	var _reactDom2 = _interopRequireDefault(_reactDom);

	var _rcUtil = __webpack_require__(383);

	var _placements = __webpack_require__(425);

	var _placements2 = _interopRequireDefault(_placements);

	var _rcTrigger = __webpack_require__(426);

	var _rcTrigger2 = _interopRequireDefault(_rcTrigger);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

	function noop() {}

	function refFn(field, component) {
	  this[field] = component;
	}

	var Picker = _react2["default"].createClass({
	  displayName: 'Picker',

	  propTypes: {
	    animation: _react.PropTypes.oneOfType([_react.PropTypes.func, _react.PropTypes.string]),
	    disabled: _react.PropTypes.bool,
	    transitionName: _react.PropTypes.string,
	    onChange: _react.PropTypes.func,
	    onOpen: _react.PropTypes.func,
	    onClose: _react.PropTypes.func,
	    children: _react.PropTypes.func,
	    getCalendarContainer: _react.PropTypes.func,
	    calendar: _react.PropTypes.element,
	    style: _react.PropTypes.object,
	    open: _react.PropTypes.bool,
	    defaultOpen: _react.PropTypes.bool,
	    prefixCls: _react.PropTypes.string,
	    placement: _react.PropTypes.any,
	    value: _react.PropTypes.oneOfType([_react.PropTypes.object, _react.PropTypes.array]),
	    defaultValue: _react.PropTypes.oneOfType([_react.PropTypes.object, _react.PropTypes.array]),
	    align: _react.PropTypes.object
	  },

	  getDefaultProps: function getDefaultProps() {
	    return {
	      prefixCls: 'rc-calendar-picker',
	      style: {},
	      align: {},
	      placement: 'bottomLeft',
	      defaultOpen: false,
	      onChange: noop,
	      onOpen: noop,
	      onClose: noop
	    };
	  },
	  getInitialState: function getInitialState() {
	    var props = this.props;
	    var open = undefined;
	    if ('open' in props) {
	      open = props.open;
	    } else {
	      open = props.defaultOpen;
	    }
	    var value = props.value || props.defaultValue;
	    this.saveCalendarRef = refFn.bind(this, 'calendarInstance');
	    return {
	      open: open,
	      value: value
	    };
	  },
	  componentWillReceiveProps: function componentWillReceiveProps(nextProps) {
	    var value = nextProps.value;
	    var open = nextProps.open;

	    if ('value' in nextProps) {
	      this.setState({
	        value: value
	      });
	    }
	    if (open !== undefined) {
	      this.setState({
	        open: open
	      });
	    }
	  },
	  onCalendarKeyDown: function onCalendarKeyDown(event) {
	    if (event.keyCode === _rcUtil.KeyCode.ESC) {
	      event.stopPropagation();
	      this.close(this.focus);
	    }
	  },
	  onCalendarSelect: function onCalendarSelect(value) {
	    var cause = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

	    var props = this.props;
	    if (!('value' in props)) {
	      this.setState({
	        value: value
	      });
	    }
	    if (!props.calendar.props.timePicker && cause.source !== 'dateInput' || cause.source === 'todayButton') {
	      this.close(this.focus);
	    }
	    props.onChange(value);
	  },
	  onCalendarOk: function onCalendarOk() {
	    this.close(this.focus);
	  },
	  onCalendarClear: function onCalendarClear() {
	    this.close(this.focus);
	  },
	  onVisibleChange: function onVisibleChange(open) {
	    var _this = this;

	    this.setOpen(open, function () {
	      if (open) {
	        _reactDom2["default"].findDOMNode(_this.calendarInstance).focus();
	      }
	    });
	  },
	  getCalendarElement: function getCalendarElement() {
	    var props = this.props;
	    var state = this.state;
	    var calendarProp = props.calendar;
	    var value = state.value;

	    var defaultValue = undefined;
	    // RangeCalendar
	    if (Array.isArray(value)) {
	      defaultValue = value[0];
	    } else {
	      defaultValue = value;
	    }
	    var extraProps = {
	      ref: this.saveCalendarRef,
	      defaultValue: defaultValue || calendarProp.props.defaultValue,
	      defaultSelectedValue: value,
	      onKeyDown: this.onCalendarKeyDown,
	      onOk: (0, _rcUtil.createChainedFunction)(calendarProp.props.onOk, this.onCalendarOk),
	      onSelect: (0, _rcUtil.createChainedFunction)(calendarProp.props.onSelect, this.onCalendarSelect),
	      onClear: (0, _rcUtil.createChainedFunction)(calendarProp.props.onClear, this.onCalendarClear)
	    };

	    return _react2["default"].cloneElement(calendarProp, extraProps);
	  },
	  setOpen: function setOpen(open, callback) {
	    var _props = this.props;
	    var onOpen = _props.onOpen;
	    var onClose = _props.onClose;

	    if (this.state.open !== open) {
	      this.setState({
	        open: open
	      }, callback);
	      var event = {
	        open: open
	      };
	      if (open) {
	        onOpen(event);
	      } else {
	        onClose(event);
	      }
	    }
	  },
	  open: function open(callback) {
	    this.setOpen(true, callback);
	  },
	  close: function close(callback) {
	    this.setOpen(false, callback);
	  },
	  focus: function focus() {
	    if (!this.state.open) {
	      _reactDom2["default"].findDOMNode(this).focus();
	    }
	  },
	  render: function render() {
	    var props = this.props;
	    var prefixCls = props.prefixCls;
	    var placement = props.placement;
	    var style = props.style;
	    var getCalendarContainer = props.getCalendarContainer;
	    var align = props.align;
	    var animation = props.animation;
	    var disabled = props.disabled;
	    var transitionName = props.transitionName;
	    var children = props.children;

	    var state = this.state;
	    return _react2["default"].createElement(
	      _rcTrigger2["default"],
	      {
	        popup: this.getCalendarElement(),
	        popupAlign: align,
	        builtinPlacements: _placements2["default"],
	        popupPlacement: placement,
	        action: disabled ? [] : ['click'],
	        destroyPopupOnHide: true,
	        getPopupContainer: getCalendarContainer,
	        popupStyle: style,
	        popupAnimation: animation,
	        popupTransitionName: transitionName,
	        popupVisible: state.open,
	        onPopupVisibleChange: this.onVisibleChange,
	        prefixCls: prefixCls
	      },
	      children(state, props)
	    );
	  }
	});

	exports["default"] = Picker;
	module.exports = exports['default'];

/***/ },
/* 425 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var autoAdjustOverflow = {
	  adjustX: 1,
	  adjustY: 1
	};

	var targetOffset = [0, 0];

	var placements = {
	  bottomLeft: {
	    points: ['tl', 'tl'],
	    overflow: autoAdjustOverflow,
	    offset: [0, -3],
	    targetOffset: targetOffset
	  },
	  bottomRight: {
	    points: ['tr', 'tr'],
	    overflow: autoAdjustOverflow,
	    offset: [0, -3],
	    targetOffset: targetOffset
	  },
	  topRight: {
	    points: ['br', 'br'],
	    overflow: autoAdjustOverflow,
	    offset: [0, 3],
	    targetOffset: targetOffset
	  },
	  topLeft: {
	    points: ['bl', 'bl'],
	    overflow: autoAdjustOverflow,
	    offset: [0, 3],
	    targetOffset: targetOffset
	  }
	};

	exports["default"] = placements;
	module.exports = exports['default'];

/***/ },
/* 426 */
[559, 427],
/* 427 */
[560, 383, 428, 451],
/* 428 */
[561, 429, 440, 449, 450],
/* 429 */
[562, 430],
/* 430 */
[563, 431, 383, 439],
/* 431 */
[564, 432, 433, 434, 435, 436, 437],
/* 432 */
86,
/* 433 */
[565, 432],
/* 434 */
[566, 432, 433],
/* 435 */
[567, 432],
/* 436 */
[568, 432],
/* 437 */
[569, 438],
/* 438 */
92,
/* 439 */
93,
/* 440 */
[554, 441],
/* 441 */
[555, 442, 443, 448],
/* 442 */
45,
/* 443 */
[556, 444, 448],
/* 444 */
[557, 445, 446],
/* 445 */
48,
/* 446 */
[558, 447, 447],
/* 447 */
50,
/* 448 */
51,
/* 449 */
[570, 450],
/* 450 */
104,
/* 451 */
105,
/* 452 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _react = __webpack_require__(7);

	var _react2 = _interopRequireDefault(_react);

	var _MonthPanel = __webpack_require__(413);

	var _MonthPanel2 = _interopRequireDefault(_MonthPanel);

	var _CalendarMixin = __webpack_require__(420);

	var _CalendarMixin2 = _interopRequireDefault(_CalendarMixin);

	var _CommonMixin = __webpack_require__(421);

	var _CommonMixin2 = _interopRequireDefault(_CommonMixin);

	var _rcUtil = __webpack_require__(383);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

	var MonthCalendar = _react2["default"].createClass({
	  displayName: 'MonthCalendar',

	  mixins: [_CommonMixin2["default"], _CalendarMixin2["default"]],

	  onKeyDown: function onKeyDown(event) {
	    var keyCode = event.keyCode;
	    var ctrlKey = event.ctrlKey || event.metaKey;
	    var stateValue = this.state.value;
	    var value = stateValue;
	    switch (keyCode) {
	      case _rcUtil.KeyCode.DOWN:
	        value = stateValue.clone();
	        value.addMonth(3);
	        break;
	      case _rcUtil.KeyCode.UP:
	        value = stateValue.clone();
	        value.addMonth(-3);
	        break;
	      case _rcUtil.KeyCode.LEFT:
	        value = stateValue.clone();
	        if (ctrlKey) {
	          value.addYear(-1);
	        } else {
	          value.addMonth(-1);
	        }
	        break;
	      case _rcUtil.KeyCode.RIGHT:
	        value = stateValue.clone();
	        if (ctrlKey) {
	          value.addYear(1);
	        } else {
	          value.addMonth(1);
	        }
	        break;
	      case _rcUtil.KeyCode.ENTER:
	        this.onSelect(stateValue);
	        event.preventDefault();
	        return 1;
	      default:
	        return undefined;
	    }
	    if (value !== stateValue) {
	      this.setValue(value);
	      event.preventDefault();
	      return 1;
	    }
	  },
	  render: function render() {
	    var props = this.props;
	    var children = _react2["default"].createElement(_MonthPanel2["default"], {
	      locale: props.locale,
	      disabledDate: props.disabledDate,
	      style: { position: 'relative' },
	      value: this.state.value,
	      rootPrefixCls: props.prefixCls,
	      onChange: this.setValue,
	      onSelect: this.onSelect
	    });
	    return this.renderRoot({
	      children: children
	    });
	  }
	});

	exports["default"] = MonthCalendar;
	module.exports = exports['default'];

/***/ },
/* 453 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _YearPanel = __webpack_require__(414);

	var _YearPanel2 = _interopRequireDefault(_YearPanel);

	var _CalendarMixin = __webpack_require__(420);

	var _CalendarMixin2 = _interopRequireDefault(_CalendarMixin);

	var _CommonMixin = __webpack_require__(421);

	var _CommonMixin2 = _interopRequireDefault(_CommonMixin);

	var _rcUtil = __webpack_require__(383);

	var _react = __webpack_require__(7);

	var _react2 = _interopRequireDefault(_react);

	var _reactDom = __webpack_require__(8);

	var _reactDom2 = _interopRequireDefault(_reactDom);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

	var YearCalendar = _react2["default"].createClass({
	    displayName: 'YearCalendar',

	    mixins: [_CalendarMixin2["default"], _CommonMixin2["default"]],

	    onKeyDown: function onKeyDown(e) {
	        var keyCode = e.keyCode;
	        var ctrlKey = e.ctrlKey || e.metaKey;
	        var stateValue = this.state.value;
	        var value = stateValue;
	        switch (keyCode) {
	            case _rcUtil.KeyCode.DOWN:
	                value = stateValue.clone();
	                value.addMonth(3);
	                break;
	            case _rcUtil.KeyCode.UP:
	                value = stateValue.clone();
	                value.addMonth(-3);
	                break;
	            case _rcUtil.KeyCode.LEFT:
	                value = stateValue.clone();
	                if (ctrlKey) {
	                    value.addYear(-1);
	                } else {
	                    value.addMonth(-1);
	                }
	                break;
	            case _rcUtil.KeyCode.RIGHT:
	                value = stateValue.clone();
	                if (ctrlKey) {
	                    value.addYear(1);
	                } else {
	                    value.addMonth(1);
	                }
	                break;
	            case _rcUtil.KeyCode.ENTER:
	                this.onSelect(stateValue);
	                e.preventDefault();
	                return 1;
	            default:
	                return undefined;
	        }
	        if (value !== stateValue) {
	            this.setValue(value);
	            e.preventDefault();
	            return 1;
	        }
	    },
	    render: function render() {
	        var props = this.props;
	        var children = _react2["default"].createElement(_YearPanel2["default"], { locale: props.locale,
	            disabledDate: props.disabledDate,
	            value: this.state.value,
	            rootPrefixCls: props.prefixCls,
	            onChange: this.setValue,
	            onSelect: this.onSelect });
	        return this.renderRoot({
	            children: children,
	            className: props.prefixCls + '-year-calendar-container'

	        });
	    }
	});

	exports["default"] = YearCalendar;
	module.exports = exports['default'];

/***/ },
/* 454 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	  value: true
	});

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var _TimePicker = __webpack_require__(455);

	var _TimePicker2 = _interopRequireDefault(_TimePicker);

	exports['default'] = _TimePicker2['default'];
	module.exports = exports['default'];

/***/ },
/* 455 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	  value: true
	});

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var _react = __webpack_require__(7);

	var _react2 = _interopRequireDefault(_react);

	var _rcTrigger = __webpack_require__(456);

	var _rcTrigger2 = _interopRequireDefault(_rcTrigger);

	var _modulePanel = __webpack_require__(482);

	var _modulePanel2 = _interopRequireDefault(_modulePanel);

	var _utilPlacements = __webpack_require__(489);

	var _utilPlacements2 = _interopRequireDefault(_utilPlacements);

	var _mixinCommonMixin = __webpack_require__(483);

	var _mixinCommonMixin2 = _interopRequireDefault(_mixinCommonMixin);

	var _utilIndex = __webpack_require__(490);

	function noop() {}

	function refFn(field, component) {
	  this[field] = component;
	}

	var Picker = _react2['default'].createClass({
	  displayName: 'Picker',

	  propTypes: {
	    prefixCls: _react.PropTypes.string,
	    locale: _react.PropTypes.object,
	    value: _react.PropTypes.object,
	    disabled: _react.PropTypes.bool,
	    allowEmpty: _react.PropTypes.bool,
	    defaultValue: _react.PropTypes.object,
	    open: _react.PropTypes.bool,
	    defaultOpen: _react.PropTypes.bool,
	    align: _react.PropTypes.object,
	    placement: _react.PropTypes.any,
	    transitionName: _react.PropTypes.string,
	    getPopupContainer: _react.PropTypes.func,
	    placeholder: _react.PropTypes.string,
	    formatter: _react.PropTypes.any,
	    showHour: _react.PropTypes.bool,
	    style: _react.PropTypes.object,
	    className: _react.PropTypes.string,
	    showSecond: _react.PropTypes.bool,
	    disabledHours: _react.PropTypes.func,
	    disabledMinutes: _react.PropTypes.func,
	    disabledSeconds: _react.PropTypes.func,
	    hideDisabledOptions: _react.PropTypes.bool,
	    onChange: _react.PropTypes.func,
	    onOpen: _react.PropTypes.func,
	    onClose: _react.PropTypes.func
	  },

	  mixins: [_mixinCommonMixin2['default']],

	  getDefaultProps: function getDefaultProps() {
	    return {
	      defaultOpen: false,
	      style: {},
	      className: '',
	      align: {},
	      allowEmpty: true,
	      showHour: true,
	      showSecond: true,
	      disabledHours: noop,
	      disabledMinutes: noop,
	      disabledSeconds: noop,
	      hideDisabledOptions: false,
	      placement: 'bottomLeft',
	      onChange: noop,
	      onOpen: noop,
	      onClose: noop
	    };
	  },

	  getInitialState: function getInitialState() {
	    this.savePanelRef = refFn.bind(this, 'panelInstance');
	    var _props = this.props;
	    var defaultOpen = _props.defaultOpen;
	    var defaultValue = _props.defaultValue;
	    var _props$open = _props.open;
	    var open = _props$open === undefined ? defaultOpen : _props$open;
	    var _props$value = _props.value;
	    var value = _props$value === undefined ? defaultValue : _props$value;

	    return {
	      open: open,
	      value: value
	    };
	  },

	  componentWillReceiveProps: function componentWillReceiveProps(nextProps) {
	    var value = nextProps.value;
	    var open = nextProps.open;

	    if ('value' in nextProps) {
	      this.setState({
	        value: value
	      });
	    }
	    if (open !== undefined) {
	      this.setState({ open: open });
	    }
	  },

	  onPanelChange: function onPanelChange(value) {
	    this.setValue(value);
	  },

	  onPanelClear: function onPanelClear() {
	    this.setValue(null);
	    this.setOpen(false);
	  },

	  onVisibleChange: function onVisibleChange(open) {
	    this.setOpen(open);
	  },

	  onEsc: function onEsc() {
	    this.setOpen(false);
	    this.refs.picker.focus();
	  },

	  onKeyDown: function onKeyDown(e) {
	    if (e.keyCode === 40) {
	      this.setOpen(true);
	    }
	  },

	  setValue: function setValue(value) {
	    if (!('value' in this.props)) {
	      this.setState({
	        value: value
	      });
	    }
	    this.props.onChange(value);
	  },

	  getFormatter: function getFormatter() {
	    var formatter = this.props.formatter;
	    var locale = this.props.locale;
	    if (formatter) {
	      if (formatter === this.lastFormatter) {
	        return this.normalFormatter;
	      }
	      this.normalFormatter = (0, _utilIndex.getFormatter)(formatter, locale);
	      this.lastFormatter = formatter;
	      return this.normalFormatter;
	    }
	    if (!this.props.showSecond) {
	      if (!this.notShowSecondFormatter) {
	        this.notShowSecondFormatter = (0, _utilIndex.getFormatter)('HH:mm', locale);
	      }
	      return this.notShowSecondFormatter;
	    }
	    if (!this.props.showHour) {
	      if (!this.notShowHourFormatter) {
	        this.notShowHourFormatter = (0, _utilIndex.getFormatter)('mm:ss', locale);
	      }
	      return this.notShowHourFormatter;
	    }
	    if (!this.normalFormatter) {
	      this.normalFormatter = (0, _utilIndex.getFormatter)('HH:mm:ss', locale);
	    }
	    return this.normalFormatter;
	  },

	  getPanelElement: function getPanelElement() {
	    var _props2 = this.props;
	    var prefixCls = _props2.prefixCls;
	    var defaultValue = _props2.defaultValue;
	    var locale = _props2.locale;
	    var placeholder = _props2.placeholder;
	    var disabledHours = _props2.disabledHours;
	    var disabledMinutes = _props2.disabledMinutes;
	    var disabledSeconds = _props2.disabledSeconds;
	    var hideDisabledOptions = _props2.hideDisabledOptions;
	    var allowEmpty = _props2.allowEmpty;
	    var showHour = _props2.showHour;
	    var showSecond = _props2.showSecond;

	    return _react2['default'].createElement(_modulePanel2['default'], {
	      prefixCls: prefixCls + '-panel',
	      ref: this.savePanelRef,
	      value: this.state.value,
	      onChange: this.onPanelChange,
	      gregorianCalendarLocale: locale.calendar,
	      onClear: this.onPanelClear,
	      defaultValue: defaultValue,
	      showHour: showHour,
	      onEsc: this.onEsc,
	      showSecond: showSecond,
	      locale: locale,
	      allowEmpty: allowEmpty,
	      formatter: this.getFormatter(),
	      placeholder: placeholder,
	      disabledHours: disabledHours,
	      disabledMinutes: disabledMinutes,
	      disabledSeconds: disabledSeconds,
	      hideDisabledOptions: hideDisabledOptions
	    });
	  },

	  setOpen: function setOpen(open, callback) {
	    var _props3 = this.props;
	    var onOpen = _props3.onOpen;
	    var onClose = _props3.onClose;

	    if (this.state.open !== open) {
	      this.setState({
	        open: open
	      }, callback);
	      var _event = {
	        open: open
	      };
	      if (open) {
	        onOpen(_event);
	      } else {
	        onClose(_event);
	      }
	    }
	  },

	  render: function render() {
	    var _props4 = this.props;
	    var prefixCls = _props4.prefixCls;
	    var placeholder = _props4.placeholder;
	    var placement = _props4.placement;
	    var align = _props4.align;
	    var disabled = _props4.disabled;
	    var transitionName = _props4.transitionName;
	    var style = _props4.style;
	    var className = _props4.className;
	    var showHour = _props4.showHour;
	    var showSecond = _props4.showSecond;
	    var getPopupContainer = _props4.getPopupContainer;
	    var _state = this.state;
	    var open = _state.open;
	    var value = _state.value;

	    var popupClassName = undefined;
	    if (!showHour || !showSecond) {
	      popupClassName = prefixCls + '-panel-narrow';
	    }
	    return _react2['default'].createElement(
	      _rcTrigger2['default'],
	      {
	        prefixCls: prefixCls + '-panel',
	        popupClassName: popupClassName,
	        popup: this.getPanelElement(),
	        popupAlign: align,
	        builtinPlacements: _utilPlacements2['default'],
	        popupPlacement: placement,
	        action: disabled ? [] : ['click'],
	        destroyPopupOnHide: true,
	        getPopupContainer: getPopupContainer,
	        popupTransitionName: transitionName,
	        popupVisible: open,
	        onPopupVisibleChange: this.onVisibleChange
	      },
	      _react2['default'].createElement(
	        'span',
	        { className: prefixCls + ' ' + className, style: style },
	        _react2['default'].createElement('input', {
	          className: prefixCls + '-input',
	          ref: 'picker', type: 'text', placeholder: placeholder,
	          readOnly: true,
	          onKeyDown: this.onKeyDown,
	          disabled: disabled, value: value && this.getFormatter().format(value) || ''
	        }),
	        _react2['default'].createElement('span', { className: prefixCls + '-icon' })
	      )
	    );
	  }
	});

	exports['default'] = Picker;
	module.exports = exports['default'];

/***/ },
/* 456 */
[559, 457],
/* 457 */
[560, 383, 458, 481],
/* 458 */
[561, 459, 470, 479, 480],
/* 459 */
[562, 460],
/* 460 */
[563, 461, 383, 469],
/* 461 */
[564, 462, 463, 464, 465, 466, 467],
/* 462 */
86,
/* 463 */
[565, 462],
/* 464 */
[566, 462, 463],
/* 465 */
[567, 462],
/* 466 */
[568, 462],
/* 467 */
[569, 468],
/* 468 */
92,
/* 469 */
93,
/* 470 */
[554, 471],
/* 471 */
[555, 472, 473, 478],
/* 472 */
45,
/* 473 */
[556, 474, 478],
/* 474 */
[557, 475, 476],
/* 475 */
48,
/* 476 */
[558, 477, 477],
/* 477 */
50,
/* 478 */
51,
/* 479 */
[570, 480],
/* 480 */
104,
/* 481 */
105,
/* 482 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	  value: true
	});

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var _react = __webpack_require__(7);

	var _react2 = _interopRequireDefault(_react);

	var _mixinCommonMixin = __webpack_require__(483);

	var _mixinCommonMixin2 = _interopRequireDefault(_mixinCommonMixin);

	var _Header = __webpack_require__(485);

	var _Header2 = _interopRequireDefault(_Header);

	var _Combobox = __webpack_require__(487);

	var _Combobox2 = _interopRequireDefault(_Combobox);

	function noop() {}

	function generateOptions(length, disabledOptions, hideDisabledOptions) {
	  var arr = [];
	  for (var value = 0; value < length; value++) {
	    if (!disabledOptions || disabledOptions.indexOf(value) < 0 || !hideDisabledOptions) {
	      arr.push(value);
	    }
	  }
	  return arr;
	}

	var Panel = _react2['default'].createClass({
	  displayName: 'Panel',

	  propTypes: {
	    prefixCls: _react.PropTypes.string,
	    value: _react.PropTypes.object,
	    locale: _react.PropTypes.object,
	    placeholder: _react.PropTypes.string,
	    gregorianCalendarLocale: _react.PropTypes.object,
	    formatter: _react.PropTypes.object,
	    disabledHours: _react.PropTypes.func,
	    disabledMinutes: _react.PropTypes.func,
	    disabledSeconds: _react.PropTypes.func,
	    hideDisabledOptions: _react.PropTypes.bool,
	    onChange: _react.PropTypes.func,
	    onEsc: _react.PropTypes.func,
	    allowEmpty: _react.PropTypes.bool,
	    showHour: _react.PropTypes.bool,
	    showSecond: _react.PropTypes.bool,
	    onClear: _react.PropTypes.func
	  },

	  mixins: [_mixinCommonMixin2['default']],

	  getDefaultProps: function getDefaultProps() {
	    return {
	      onChange: noop,
	      onClear: noop
	    };
	  },

	  getInitialState: function getInitialState() {
	    return {
	      value: this.props.value,
	      selectionRange: []
	    };
	  },

	  componentWillReceiveProps: function componentWillReceiveProps(nextProps) {
	    var value = nextProps.value;
	    if (value) {
	      this.setState({
	        value: value
	      });
	    }
	  },

	  onChange: function onChange(newValue) {
	    this.setState({ value: newValue });
	    this.props.onChange(newValue);
	  },

	  onClear: function onClear() {
	    this.props.onClear();
	  },

	  onCurrentSelectPanelChange: function onCurrentSelectPanelChange(currentSelectPanel) {
	    this.setState({ currentSelectPanel: currentSelectPanel });
	  },

	  render: function render() {
	    var _props = this.props;
	    var locale = _props.locale;
	    var prefixCls = _props.prefixCls;
	    var placeholder = _props.placeholder;
	    var disabledHours = _props.disabledHours;
	    var disabledMinutes = _props.disabledMinutes;
	    var disabledSeconds = _props.disabledSeconds;
	    var hideDisabledOptions = _props.hideDisabledOptions;
	    var allowEmpty = _props.allowEmpty;
	    var showHour = _props.showHour;
	    var showSecond = _props.showSecond;
	    var formatter = _props.formatter;
	    var gregorianCalendarLocale = _props.gregorianCalendarLocale;

	    var value = this.state.value;
	    var disabledHourOptions = disabledHours();
	    var disabledMinuteOptions = disabledMinutes(value ? value.getHourOfDay() : null);
	    var disabledSecondOptions = disabledSeconds(value ? value.getHourOfDay() : null, value ? value.getMinutes() : null);
	    var hourOptions = generateOptions(24, disabledHourOptions, hideDisabledOptions);
	    var minuteOptions = generateOptions(60, disabledMinuteOptions, hideDisabledOptions);
	    var secondOptions = generateOptions(60, disabledSecondOptions, hideDisabledOptions);

	    return _react2['default'].createElement(
	      'div',
	      { className: prefixCls + '-inner' },
	      _react2['default'].createElement(_Header2['default'], {
	        prefixCls: prefixCls,
	        gregorianCalendarLocale: gregorianCalendarLocale,
	        locale: locale,
	        value: value,
	        currentSelectPanel: this.state.currentSelectPanel,
	        onEsc: this.props.onEsc,
	        formatter: formatter,
	        placeholder: placeholder,
	        hourOptions: hourOptions,
	        minuteOptions: minuteOptions,
	        secondOptions: secondOptions,
	        disabledHours: disabledHours,
	        disabledMinutes: disabledMinutes,
	        disabledSeconds: disabledSeconds,
	        onChange: this.onChange,
	        onClear: this.onClear,
	        allowEmpty: allowEmpty
	      }),
	      _react2['default'].createElement(_Combobox2['default'], {
	        prefixCls: prefixCls,
	        value: value,
	        gregorianCalendarLocale: gregorianCalendarLocale,
	        formatter: formatter,
	        onChange: this.onChange,
	        showHour: showHour,
	        showSecond: showSecond,
	        hourOptions: hourOptions,
	        minuteOptions: minuteOptions,
	        secondOptions: secondOptions,
	        disabledHours: disabledHours,
	        disabledMinutes: disabledMinutes,
	        disabledSeconds: disabledSeconds,
	        onCurrentSelectPanelChange: this.onCurrentSelectPanelChange
	      })
	    );
	  }
	});

	exports['default'] = Panel;
	module.exports = exports['default'];

/***/ },
/* 483 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	  value: true
	});

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var _react = __webpack_require__(7);

	var _localeEn_US = __webpack_require__(484);

	var _localeEn_US2 = _interopRequireDefault(_localeEn_US);

	exports['default'] = {
	  propTypes: {
	    prefixCls: _react.PropTypes.string,
	    locale: _react.PropTypes.object
	  },

	  getDefaultProps: function getDefaultProps() {
	    return {
	      prefixCls: 'rc-time-picker',
	      locale: _localeEn_US2['default']
	    };
	  }
	};
	module.exports = exports['default'];

/***/ },
/* 484 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	  value: true
	});

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var _gregorianCalendarFormatLibLocaleEn_US = __webpack_require__(410);

	var _gregorianCalendarFormatLibLocaleEn_US2 = _interopRequireDefault(_gregorianCalendarFormatLibLocaleEn_US);

	var _gregorianCalendarLibLocaleEn_US = __webpack_require__(382);

	var _gregorianCalendarLibLocaleEn_US2 = _interopRequireDefault(_gregorianCalendarLibLocaleEn_US);

	exports['default'] = {
	  clear: 'Clear',
	  format: _gregorianCalendarFormatLibLocaleEn_US2['default'],
	  calendar: _gregorianCalendarLibLocaleEn_US2['default']
	};
	module.exports = exports['default'];

/***/ },
/* 485 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	  value: true
	});

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var _react = __webpack_require__(7);

	var _react2 = _interopRequireDefault(_react);

	var _utilSelection = __webpack_require__(486);

	var _utilSelection2 = _interopRequireDefault(_utilSelection);

	var Header = _react2['default'].createClass({
	  displayName: 'Header',

	  propTypes: {
	    formatter: _react.PropTypes.object,
	    prefixCls: _react.PropTypes.string,
	    gregorianCalendarLocale: _react.PropTypes.object,
	    locale: _react.PropTypes.object,
	    disabledDate: _react.PropTypes.func,
	    placeholder: _react.PropTypes.string,
	    value: _react.PropTypes.object,
	    hourOptions: _react.PropTypes.array,
	    minuteOptions: _react.PropTypes.array,
	    secondOptions: _react.PropTypes.array,
	    disabledHours: _react.PropTypes.func,
	    disabledMinutes: _react.PropTypes.func,
	    disabledSeconds: _react.PropTypes.func,
	    onChange: _react.PropTypes.func,
	    onClear: _react.PropTypes.func,
	    onEsc: _react.PropTypes.func,
	    allowEmpty: _react.PropTypes.bool,
	    currentSelectPanel: _react.PropTypes.string
	  },

	  getInitialState: function getInitialState() {
	    var value = this.props.value;
	    return {
	      str: value && this.props.formatter.format(value) || '',
	      invalid: false
	    };
	  },

	  componentDidMount: function componentDidMount() {
	    this.timer = setTimeout(this.selectRange, 0);
	  },

	  componentWillReceiveProps: function componentWillReceiveProps(nextProps) {
	    var value = nextProps.value;
	    this.setState({
	      str: value && nextProps.formatter.format(value) || '',
	      invalid: false
	    });
	  },

	  componentDidUpdate: function componentDidUpdate() {
	    this.timer = setTimeout(this.selectRange, 0);
	  },

	  componentWillUnmount: function componentWillUnmount() {
	    clearTimeout(this.timer);
	  },

	  onInputChange: function onInputChange(event) {
	    var str = event.target.value;
	    this.setState({
	      str: str
	    });
	    var value = null;
	    var _props = this.props;
	    var formatter = _props.formatter;
	    var gregorianCalendarLocale = _props.gregorianCalendarLocale;
	    var hourOptions = _props.hourOptions;
	    var minuteOptions = _props.minuteOptions;
	    var secondOptions = _props.secondOptions;
	    var disabledHours = _props.disabledHours;
	    var disabledMinutes = _props.disabledMinutes;
	    var disabledSeconds = _props.disabledSeconds;
	    var onChange = _props.onChange;
	    var allowEmpty = _props.allowEmpty;

	    if (str) {
	      var originalValue = this.props.value;
	      try {
	        value = formatter.parse(str, {
	          locale: gregorianCalendarLocale,
	          obeyCount: true
	        });
	      } catch (ex) {
	        this.setState({
	          invalid: true
	        });
	        return;
	      }

	      if (value) {
	        // if time value not allowed, response warning.
	        if (hourOptions.indexOf(value.getHourOfDay()) < 0 || minuteOptions.indexOf(value.getMinutes()) < 0 || secondOptions.indexOf(value.getSeconds()) < 0) {
	          this.setState({
	            invalid: true
	          });
	          return;
	        }

	        // if time value is disabled, response warning.
	        var disabledHourOptions = disabledHours();
	        var disabledMinuteOptions = disabledMinutes(value.getHourOfDay());
	        var disabledSecondOptions = disabledSeconds(value.getHourOfDay(), value.getMinutes());
	        if (disabledHourOptions && disabledHourOptions.indexOf(value.getHourOfDay()) >= 0 || disabledMinuteOptions && disabledMinuteOptions.indexOf(value.getMinutes()) >= 0 || disabledSecondOptions && disabledSecondOptions.indexOf(value.getSeconds()) >= 0) {
	          this.setState({
	            invalid: true
	          });
	          return;
	        }

	        if (originalValue && value) {
	          if (originalValue.getHourOfDay() !== value.getHourOfDay() || originalValue.getMinutes() !== value.getMinutes() || originalValue.getSeconds() !== value.getSeconds()) {
	            // keep other fields for rc-calendar
	            var changedValue = originalValue.clone();
	            changedValue.setHourOfDay(value.getHourOfDay());
	            changedValue.setMinutes(value.getMinutes());
	            changedValue.setSeconds(value.getSeconds());
	            onChange(changedValue);
	          }
	        } else if (originalValue !== value) {
	          onChange(value);
	        }
	      } else {
	        this.setState({
	          invalid: true
	        });
	        return;
	      }
	    } else if (allowEmpty) {
	      onChange(null);
	    } else {
	      this.setState({
	        invalid: true
	      });
	      return;
	    }

	    this.setState({
	      invalid: false
	    });
	  },

	  onKeyDown: function onKeyDown(e) {
	    if (e.keyCode === 27) {
	      this.props.onEsc();
	    }
	  },

	  onClear: function onClear() {
	    this.setState({ str: '' });
	    this.props.onClear();
	  },

	  getClearButton: function getClearButton() {
	    var _props2 = this.props;
	    var locale = _props2.locale;
	    var prefixCls = _props2.prefixCls;
	    var allowEmpty = _props2.allowEmpty;

	    if (!allowEmpty) {
	      return null;
	    }
	    return _react2['default'].createElement('a', { className: prefixCls + '-clear-btn', role: 'button', title: locale.clear, onMouseDown: this.onClear });
	  },

	  getInput: function getInput() {
	    var _props3 = this.props;
	    var prefixCls = _props3.prefixCls;
	    var placeholder = _props3.placeholder;
	    var _state = this.state;
	    var invalid = _state.invalid;
	    var str = _state.str;

	    var invalidClass = invalid ? prefixCls + '-input-invalid' : '';
	    return _react2['default'].createElement('input', {
	      className: prefixCls + '-input  ' + invalidClass,
	      ref: 'input',
	      onKeyDown: this.onKeyDown,
	      value: str,
	      placeholder: placeholder, onChange: this.onInputChange
	    });
	  },

	  selectRange: function selectRange() {
	    this.refs.input.focus();
	    if (this.props.currentSelectPanel && this.refs.input.value) {
	      var selectionRangeStart = 0;
	      var selectionRangeEnd = 0;
	      if (this.props.currentSelectPanel === 'hour') {
	        selectionRangeStart = 0;
	        selectionRangeEnd = this.refs.input.value.indexOf(':');
	      } else if (this.props.currentSelectPanel === 'minute') {
	        selectionRangeStart = this.refs.input.value.indexOf(':') + 1;
	        selectionRangeEnd = this.refs.input.value.lastIndexOf(':');
	      } else if (this.props.currentSelectPanel === 'second') {
	        selectionRangeStart = this.refs.input.value.lastIndexOf(':') + 1;
	        selectionRangeEnd = this.refs.input.value.length;
	      }
	      if (selectionRangeEnd - selectionRangeStart === 2) {
	        (0, _utilSelection2['default'])(this.refs.input, selectionRangeStart, selectionRangeEnd);
	      }
	    }
	  },

	  render: function render() {
	    var prefixCls = this.props.prefixCls;

	    return _react2['default'].createElement(
	      'div',
	      { className: prefixCls + '-input-wrap' },
	      this.getInput(),
	      this.getClearButton()
	    );
	  }
	});

	exports['default'] = Header;
	module.exports = exports['default'];

/***/ },
/* 486 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	exports['default'] = createSelection;

	function createSelection(field, start, end) {
	  if (field.createTextRange) {
	    var selRange = field.createTextRange();
	    selRange.collapse(true);
	    selRange.moveStart('character', start);
	    selRange.moveEnd('character', end);
	    selRange.select();
	    field.focus();
	  } else if (field.setSelectionRange) {
	    field.focus();
	    field.setSelectionRange(start, end);
	  } else if (typeof field.selectionStart !== 'undefined') {
	    field.selectionStart = start;
	    field.selectionEnd = end;
	    field.focus();
	  }
	}

	module.exports = exports['default'];

/***/ },
/* 487 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	  value: true
	});

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var _react = __webpack_require__(7);

	var _react2 = _interopRequireDefault(_react);

	var _Select = __webpack_require__(488);

	var _Select2 = _interopRequireDefault(_Select);

	var _gregorianCalendar = __webpack_require__(379);

	var _gregorianCalendar2 = _interopRequireDefault(_gregorianCalendar);

	var formatOption = function formatOption(option, disabledOptions) {
	  var value = '' + option;
	  if (option < 10) {
	    value = '0' + option;
	  }

	  var disabled = false;
	  if (disabledOptions && disabledOptions.indexOf(option) >= 0) {
	    disabled = true;
	  }

	  return {
	    value: value,
	    disabled: disabled
	  };
	};

	var Combobox = _react2['default'].createClass({
	  displayName: 'Combobox',

	  propTypes: {
	    formatter: _react.PropTypes.object,
	    prefixCls: _react.PropTypes.string,
	    value: _react.PropTypes.object,
	    onChange: _react.PropTypes.func,
	    showHour: _react.PropTypes.bool,
	    gregorianCalendarLocale: _react.PropTypes.object,
	    showSecond: _react.PropTypes.bool,
	    hourOptions: _react.PropTypes.array,
	    minuteOptions: _react.PropTypes.array,
	    secondOptions: _react.PropTypes.array,
	    disabledHours: _react.PropTypes.func,
	    disabledMinutes: _react.PropTypes.func,
	    disabledSeconds: _react.PropTypes.func,
	    onCurrentSelectPanelChange: _react.PropTypes.func
	  },

	  onItemChange: function onItemChange(type, itemValue) {
	    var onChange = this.props.onChange;

	    var value = this.props.value;
	    if (value) {
	      value = value.clone();
	    } else {
	      value = this.getNow().clone();
	    }
	    if (type === 'hour') {
	      value.setHourOfDay(itemValue);
	    } else if (type === 'minute') {
	      value.setMinutes(itemValue);
	    } else {
	      value.setSeconds(itemValue);
	    }
	    onChange(value);
	  },

	  onEnterSelectPanel: function onEnterSelectPanel(range) {
	    this.props.onCurrentSelectPanelChange(range);
	  },

	  getHourSelect: function getHourSelect(hour) {
	    var _props = this.props;
	    var prefixCls = _props.prefixCls;
	    var hourOptions = _props.hourOptions;
	    var disabledHours = _props.disabledHours;
	    var showHour = _props.showHour;

	    if (!showHour) {
	      return null;
	    }
	    var disabledOptions = disabledHours();

	    return _react2['default'].createElement(_Select2['default'], {
	      prefixCls: prefixCls,
	      options: hourOptions.map(function (option) {
	        return formatOption(option, disabledOptions);
	      }),
	      selectedIndex: hourOptions.indexOf(hour),
	      type: 'hour',
	      onSelect: this.onItemChange,
	      onMouseEnter: this.onEnterSelectPanel.bind(this, 'hour')
	    });
	  },

	  getMinuteSelect: function getMinuteSelect(minute) {
	    var _props2 = this.props;
	    var prefixCls = _props2.prefixCls;
	    var minuteOptions = _props2.minuteOptions;
	    var disabledMinutes = _props2.disabledMinutes;

	    var value = this.props.value || this.getNow();
	    var disabledOptions = disabledMinutes(value.getHourOfDay());

	    return _react2['default'].createElement(_Select2['default'], {
	      prefixCls: prefixCls,
	      options: minuteOptions.map(function (option) {
	        return formatOption(option, disabledOptions);
	      }),
	      selectedIndex: minuteOptions.indexOf(minute),
	      type: 'minute',
	      onSelect: this.onItemChange,
	      onMouseEnter: this.onEnterSelectPanel.bind(this, 'minute')
	    });
	  },

	  getSecondSelect: function getSecondSelect(second) {
	    var _props3 = this.props;
	    var prefixCls = _props3.prefixCls;
	    var secondOptions = _props3.secondOptions;
	    var disabledSeconds = _props3.disabledSeconds;
	    var showSecond = _props3.showSecond;

	    if (!showSecond) {
	      return null;
	    }
	    var value = this.props.value || this.getNow();
	    var disabledOptions = disabledSeconds(value.getHourOfDay(), value.getMinutes());

	    return _react2['default'].createElement(_Select2['default'], {
	      prefixCls: prefixCls,
	      options: secondOptions.map(function (option) {
	        return formatOption(option, disabledOptions);
	      }),
	      selectedIndex: secondOptions.indexOf(second),
	      type: 'second',
	      onSelect: this.onItemChange,
	      onMouseEnter: this.onEnterSelectPanel.bind(this, 'second')
	    });
	  },

	  getNow: function getNow() {
	    if (this.showNow) {
	      return this.showNow;
	    }
	    var value = new _gregorianCalendar2['default'](this.props.gregorianCalendarLocale);
	    value.setTime(Date.now());
	    this.showNow = value;
	    return value;
	  },

	  render: function render() {
	    var prefixCls = this.props.prefixCls;

	    var value = this.props.value || this.getNow();
	    return _react2['default'].createElement(
	      'div',
	      { className: prefixCls + '-combobox' },
	      this.getHourSelect(value.getHourOfDay()),
	      this.getMinuteSelect(value.getMinutes()),
	      this.getSecondSelect(value.getSeconds())
	    );
	  }
	});

	exports['default'] = Combobox;
	module.exports = exports['default'];

/***/ },
/* 488 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	  value: true
	});

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

	var _react = __webpack_require__(7);

	var _react2 = _interopRequireDefault(_react);

	var _reactDom = __webpack_require__(8);

	var _reactDom2 = _interopRequireDefault(_reactDom);

	var _classnames2 = __webpack_require__(19);

	var _classnames3 = _interopRequireDefault(_classnames2);

	var scrollTo = function scrollTo(element, to, duration) {
	  var requestAnimationFrame = window.requestAnimationFrame || function requestAnimationFrameTimeout() {
	    return setTimeout(arguments[0], 10);
	  };
	  // jump to target if duration zero
	  if (duration <= 0) {
	    element.scrollTop = to;
	    return;
	  }
	  var difference = to - element.scrollTop;
	  var perTick = difference / duration * 10;

	  requestAnimationFrame(function () {
	    element.scrollTop = element.scrollTop + perTick;
	    if (element.scrollTop === to) return;
	    scrollTo(element, to, duration - 10);
	  });
	};

	var Select = _react2['default'].createClass({
	  displayName: 'Select',

	  propTypes: {
	    prefixCls: _react.PropTypes.string,
	    options: _react.PropTypes.array,
	    gregorianCalendarLocale: _react.PropTypes.object,
	    selectedIndex: _react.PropTypes.number,
	    type: _react.PropTypes.string,
	    onSelect: _react.PropTypes.func,
	    onMouseEnter: _react.PropTypes.func
	  },

	  componentDidMount: function componentDidMount() {
	    // jump to selected option
	    this.scrollToSelected(0);
	  },

	  componentDidUpdate: function componentDidUpdate(prevProps) {
	    // smooth scroll to selected option
	    if (prevProps.selectedIndex !== this.props.selectedIndex) {
	      this.scrollToSelected(120);
	    }
	  },

	  onSelect: function onSelect(value) {
	    var _props = this.props;
	    var onSelect = _props.onSelect;
	    var type = _props.type;

	    onSelect(type, value);
	  },

	  getOptions: function getOptions() {
	    var _this = this;

	    var _props2 = this.props;
	    var options = _props2.options;
	    var selectedIndex = _props2.selectedIndex;
	    var prefixCls = _props2.prefixCls;

	    return options.map(function (item, index) {
	      var _classnames;

	      var cls = (0, _classnames3['default'])((_classnames = {}, _defineProperty(_classnames, prefixCls + '-select-option-selected', selectedIndex === index), _defineProperty(_classnames, prefixCls + '-select-option-disabled', item.disabled), _classnames));
	      var onclick = null;
	      if (!item.disabled) {
	        onclick = _this.onSelect.bind(_this, +item.value);
	      }
	      return _react2['default'].createElement(
	        'li',
	        { className: cls, key: index, onClick: onclick, disabled: item.disabled },
	        item.value
	      );
	    });
	  },

	  scrollToSelected: function scrollToSelected(duration) {
	    // move to selected item
	    var select = _reactDom2['default'].findDOMNode(this);
	    var list = _reactDom2['default'].findDOMNode(this.refs.list);
	    var index = this.props.selectedIndex;
	    if (index < 0) {
	      index = 0;
	    }
	    var topOption = list.children[index];
	    var to = topOption.offsetTop;
	    scrollTo(select, to, duration);
	  },

	  render: function render() {
	    if (this.props.options.length === 0) {
	      return null;
	    }

	    var prefixCls = this.props.prefixCls;

	    return _react2['default'].createElement(
	      'div',
	      { className: prefixCls + '-select',
	        onMouseEnter: this.props.onMouseEnter },
	      _react2['default'].createElement(
	        'ul',
	        { ref: 'list' },
	        this.getOptions()
	      )
	    );
	  }
	});

	exports['default'] = Select;
	module.exports = exports['default'];

/***/ },
/* 489 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	var autoAdjustOverflow = {
	  adjustX: 1,
	  adjustY: 1
	};

	var targetOffset = [0, 0];

	var placements = {
	  bottomLeft: {
	    points: ['tl', 'tl'],
	    overflow: autoAdjustOverflow,
	    offset: [0, -3],
	    targetOffset: targetOffset
	  },
	  bottomRight: {
	    points: ['tr', 'tr'],
	    overflow: autoAdjustOverflow,
	    offset: [0, -3],
	    targetOffset: targetOffset
	  },
	  topRight: {
	    points: ['br', 'br'],
	    overflow: autoAdjustOverflow,
	    offset: [0, 3],
	    targetOffset: targetOffset
	  },
	  topLeft: {
	    points: ['bl', 'bl'],
	    overflow: autoAdjustOverflow,
	    offset: [0, 3],
	    targetOffset: targetOffset
	  }
	};

	exports['default'] = placements;
	module.exports = exports['default'];

/***/ },
/* 490 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	exports.getFormatter = getFormatter;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var _gregorianCalendarFormat = __webpack_require__(409);

	var _gregorianCalendarFormat2 = _interopRequireDefault(_gregorianCalendarFormat);

	function getFormatter(format, locale) {
	  if (typeof format === 'string') {
	    return new _gregorianCalendarFormat2['default'](format, locale.format);
	  }
	  return format;
	}

/***/ },
/* 491 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var Formatter = __webpack_require__(372);
	var Tooltip = __webpack_require__(492);
	var classnames = __webpack_require__(19);
	var i18n = __webpack_require__(523);

	/**
	 * code should be an object like this {'xxxx-xx-xx': 'work/leave/schedule'}
	 */
	var generateContentRender = function generateContentRender(code) {
	    var locale = arguments.length <= 1 || arguments[1] === undefined ? 'zh-cn' : arguments[1];

	    return function contentRender(code, locale, current, value) {
	        // see https://github.com/yiminghe/gregorian-calendar to get details about `current` API
	        var time = current.getTime();
	        var date = Formatter.date(time, 'YYYY-MM-DD');
	        var type = code[date];
	        if (typeof type == 'string') {
	            type = [type];
	        } else if (type == undefined) {
	            type = [];
	        }
	        var tipMap = i18n[locale];
	        var content = [];
	        var isWork = type.indexOf('work') !== -1;
	        var isLeave = type.indexOf('leave') !== -1;
	        var isSchedule = type.indexOf('schedule') !== -1;
	        content.push(React.createElement(
	            'span',
	            { key: 'date', className: classnames({
	                    'kuma-calendar-date-content': true,
	                    'work': isWork,
	                    'leave': isLeave,
	                    'schedule': isSchedule
	                }) },
	            current.getDayOfMonth()
	        ));
	        if (isSchedule) {
	            content.push(React.createElement('span', { key: 'bottom-line', className: 'kuma-calendar-date-decoration' }));
	        }

	        if (isWork || isLeave) {
	            return React.createElement(
	                Tooltip,
	                { placement: 'right', trigger: ["hover"], overlay: tipMap[isWork ? 'work' : 'leave'] },
	                React.createElement(
	                    'div',
	                    { className: 'kuma-calendar-date-content-box' },
	                    content
	                )
	            );
	        } else {
	            // only one child can be passed.
	            return React.createElement(
	                'div',
	                { className: 'kuma-calendar-date-content-box' },
	                content
	            );
	        }
	    }.bind(null, code, locale);
	};

	module.exports = {
	    generateContentRender: generateContentRender
	};

/***/ },
/* 492 */
[571, 493],
/* 493 */
[572, 494, 284],
/* 494 */
[573, 495],
/* 495 */
[574, 496, 497],
/* 496 */
111,
/* 497 */
[559, 498],
/* 498 */
[560, 383, 499, 522],
/* 499 */
[561, 500, 511, 520, 521],
/* 500 */
[562, 501],
/* 501 */
[563, 502, 383, 510],
/* 502 */
[564, 503, 504, 505, 506, 507, 508],
/* 503 */
86,
/* 504 */
[565, 503],
/* 505 */
[566, 503, 504],
/* 506 */
[567, 503],
/* 507 */
[568, 503],
/* 508 */
[569, 509],
/* 509 */
92,
/* 510 */
93,
/* 511 */
[554, 512],
/* 512 */
[555, 513, 514, 519],
/* 513 */
45,
/* 514 */
[556, 515, 519],
/* 515 */
[557, 516, 517],
/* 516 */
48,
/* 517 */
[558, 518, 518],
/* 518 */
50,
/* 519 */
51,
/* 520 */
[570, 521],
/* 521 */
104,
/* 522 */
105,
/* 523 */
/***/ function(module, exports) {

	'use strict';

	var locale = {
	    'zh-cn': {
	        'work': '上班',
	        'leave': '休假'
	    },
	    'en-us': {
	        'work': 'work',
	        'leave': 'leave'
	    }
	};

	locale['en'] = locale['en-us'];

	module.exports = locale;

/***/ },
/* 524 */
/***/ function(module, exports) {

	/*
	 * zh-cn locale
	 * @ignore
	 * @author yiminghe@gmail.com
	 */
	"use strict";

	module.exports = {
	  // in minutes
	  timezoneOffset: 8 * 60,
	  firstDayOfWeek: 1,
	  minimalDaysInFirstWeek: 1
	};

/***/ },
/* 525 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _zh_CN = __webpack_require__(526);

	var _zh_CN2 = _interopRequireDefault(_zh_CN);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

	exports["default"] = {
	  today: '今天',
	  now: '此刻',
	  backToToday: '返回今天',
	  ok: '确定',
	  clear: '清除',
	  month: '月',
	  year: '年',
	  previousMonth: '上个月 (翻页上键)',
	  nextMonth: '下个月 (翻页下键)',
	  monthSelect: '选择月份',
	  yearSelect: '选择年份',
	  decadeSelect: '选择年代',
	  yearFormat: 'yyyy\'年\'',
	  monthFormat: 'M\'月\'',
	  dateFormat: 'yyyy\'年\'M\'月\'d\'日\'',
	  previousYear: '上一年 (Control键加左方向键)',
	  nextYear: '下一年 (Control键加右方向键)',
	  previousDecade: '上一年代',
	  nextDecade: '下一年代',
	  previousCentury: '上一世纪',
	  nextCentury: '下一世纪',
	  format: _zh_CN2["default"]
	};
	module.exports = exports['default'];

/***/ },
/* 526 */
/***/ function(module, exports) {

	'use strict';

	module.exports = {
	  eras: ['公元前', '公元'],
	  months: ['一月', '二月', '三月', '四月', '五月', '六月', '七月', '八月', '九月', '十月', '十一月', '十二月'],
	  shortMonths: ['一月', '二月', '三月', '四月', '五月', '六月', '七月', '八月', '九月', '十月', '十一月', '十二月'],
	  weekdays: ['星期天', '星期一', '星期二', '星期三', '星期四', '星期五', '星期六'],
	  shortWeekdays: ['周日', '周一', '周二', '周三', '周四', '周五', '周六'],
	  veryShortWeekdays: ['日', '一', '二', '三', '四', '五', '六'],
	  ampms: ['上午', '下午'],
	  datePatterns: ['yyyy\'年\'M\'月\'d\'日\' EEEE', 'yyyy\'年\'M\'月\'d\'日\'', 'yyyy-M-d', 'yy-M-d'],
	  timePatterns: ['ahh\'时\'mm\'分\'ss\'秒\' \'GMT\'Z', 'ahh\'时\'mm\'分\'ss\'秒\'', 'H:mm:ss', 'ah:mm'],
	  dateTimePattern: '{date} {time}'
	};

/***/ },
/* 527 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	  value: true
	});

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var _gregorianCalendarFormatLibLocaleZh_CN = __webpack_require__(526);

	var _gregorianCalendarFormatLibLocaleZh_CN2 = _interopRequireDefault(_gregorianCalendarFormatLibLocaleZh_CN);

	var _gregorianCalendarLibLocaleZh_CN = __webpack_require__(524);

	var _gregorianCalendarLibLocaleZh_CN2 = _interopRequireDefault(_gregorianCalendarLibLocaleZh_CN);

	exports['default'] = {
	  clear: '清除',
	  format: _gregorianCalendarFormatLibLocaleZh_CN2['default'],
	  calendar: _gregorianCalendarLibLocaleZh_CN2['default']
	};
	module.exports = exports['default'];

/***/ },
/* 528 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var FormField = __webpack_require__(274);
	var Constants = __webpack_require__(272);
	var CheckboxGroup = __webpack_require__(529);
	var Item = CheckboxGroup.Item;

	var CheckboxGroupFormField = function (_FormField) {
	    _inherits(CheckboxGroupFormField, _FormField);

	    function CheckboxGroupFormField(props) {
	        _classCallCheck(this, CheckboxGroupFormField);

	        return _possibleConstructorReturn(this, _FormField.call(this, props));
	    }

	    CheckboxGroupFormField.prototype.handleChange = function handleChange(value) {
	        var me = this;
	        me.handleDataChange(value);
	    };

	    CheckboxGroupFormField.prototype.addSpecificClass = function addSpecificClass() {
	        var me = this;
	        if (me.props.jsxprefixCls == "kuma-uxform-field") {
	            return me.props.jsxprefixCls + " kuma-checkbox-group-uxform-field";
	        } else {
	            return me.props.jsxprefixCls;
	        }
	    };

	    CheckboxGroupFormField.prototype.renderField = function renderField() {
	        var me = this;
	        var mode = me.props.jsxmode || me.props.mode;
	        if (mode == Constants.MODE.EDIT) {
	            return React.createElement(
	                CheckboxGroup,
	                { disabled: !!me.props.jsxdisabled, onChange: me.handleChange.bind(me), value: me.state.value || [] },
	                me.props.children
	            );
	        } else {
	            if (me.state.value instanceof Array) {
	                var textArr = me.props.children.filter(function (child, index) {
	                    return me.state.value.indexOf(child.props.value) != -1;
	                }).map(function (item, index) {
	                    return item.props.text;
	                });
	                return React.createElement(
	                    "span",
	                    null,
	                    textArr.join(" ")
	                );
	            }
	        }
	    };

	    return CheckboxGroupFormField;
	}(FormField);

	CheckboxGroupFormField.Item = Item;
	CheckboxGroupFormField.propTypes = FormField.propTypes;
	CheckboxGroupFormField.defaultProps = FormField.defaultProps;
	CheckboxGroupFormField.displayName = "CheckboxGroupFormField";

	module.exports = CheckboxGroupFormField;

/***/ },
/* 529 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	/**
	 * CheckboxGroup Component for uxcore
	 * @author eternalsky
	 *
	 * Copyright 2014-2015, Uxcore Team, Alinw.
	 * All rights reserved.
	 */

	module.exports = __webpack_require__(530);

/***/ },
/* 530 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	/**
	 * CheckboxGroup Component for uxcore
	 * @author eternalsky
	 *
	 * Copyright 2014-2015, Uxcore Team, Alinw.
	 * All rights reserved.
	 */

	var Item = __webpack_require__(531);
	var assign = __webpack_require__(284);
	var React = __webpack_require__(7);
	var ReactDOM = __webpack_require__(8);

	var CheckboxGroup = function (_React$Component) {
	    _inherits(CheckboxGroup, _React$Component);

	    function CheckboxGroup(props) {
	        _classCallCheck(this, CheckboxGroup);

	        return _possibleConstructorReturn(this, _React$Component.call(this, props));
	    }

	    CheckboxGroup.prototype.componentWillMount = function componentWillMount() {
	        var me = this;
	        me.selected = me._copy(me.props.value) || [];
	    };

	    CheckboxGroup.prototype.componentDidUpdate = function componentDidUpdate() {
	        var me = this;
	        me.selected = me._copy(me.props.value) || [];
	    };

	    CheckboxGroup.prototype._copy = function _copy(a) {
	        return JSON.parse(JSON.stringify(a));
	    };

	    CheckboxGroup.prototype._processChild = function _processChild() {
	        var me = this;
	        var length = React.Children.count(me.props.children);
	        if (!length) return false;
	        var elements = React.Children.map(me.props.children, function (child, index) {
	            if (!!child.type && child.type.displayName == "CheckboxItem") {
	                return React.cloneElement(child, {
	                    jsxdisabled: me.props.disabled,
	                    onChange: me._handleChange.bind(me),
	                    key: index,
	                    checked: me.props.value.indexOf(child.props.value) != -1
	                });
	            }
	        });
	        return elements;
	    };

	    CheckboxGroup.prototype._handleChange = function _handleChange(checked, value) {
	        var me = this;
	        if (checked) {
	            // me.selected = me.selected.concat([value]);
	            me.selected.push(value);
	        } else {
	            me.selected = me.selected.filter(function (item) {
	                return item != value;
	            });
	        }
	        me.props.onChange(JSON.parse(JSON.stringify(me.selected)));
	    };

	    CheckboxGroup.prototype.render = function render() {
	        var me = this;
	        return React.createElement(
	            "div",
	            { className: me.props.className },
	            me._processChild()
	        );
	    };

	    return CheckboxGroup;
	}(React.Component);

	CheckboxGroup.Item = Item;

	CheckboxGroup.defaultProps = {
	    value: [],
	    onChange: function onChange() {},
	    disabled: false,
	    className: 'kuma-checkbox-group'
	};

	// http://facebook.github.io/react/docs/reusable-components.html
	CheckboxGroup.propTypes = {
	    value: React.PropTypes.array,
	    onChange: React.PropTypes.func,
	    disabled: React.PropTypes.bool,
	    className: React.PropTypes.string
	};

	CheckboxGroup.displayName = "CheckboxGroup";

	module.exports = CheckboxGroup;

/***/ },
/* 531 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var React = __webpack_require__(7);
	var ReactDOM = __webpack_require__(8);
	var classnames = __webpack_require__(19);

	var CheckboxItem = function (_React$Component) {
	    _inherits(CheckboxItem, _React$Component);

	    function CheckboxItem(props) {
	        _classCallCheck(this, CheckboxItem);

	        return _possibleConstructorReturn(this, _React$Component.call(this, props));
	    }

	    CheckboxItem.prototype._handleChange = function _handleChange(e) {
	        var me = this;
	        me.props.onChange(e.currentTarget.checked, me.props.value);
	    };

	    CheckboxItem.prototype.render = function render() {
	        var me = this;
	        var prefixCls = me.props.prefixCls;

	        var disabled = false;
	        if ('disabled' in me.props) {
	            disabled = me.props.disabled;
	        } else {
	            disabled = me.props.jsxdisabled;
	        }
	        return React.createElement(
	            'label',
	            { className: '' + prefixCls },
	            React.createElement('input', { type: 'checkbox', disabled: disabled, ref: 'checkbox', checked: me.props.checked, className: 'kuma-checkbox', onChange: me._handleChange.bind(me) }),
	            React.createElement('s', null),
	            React.createElement('span', { className: prefixCls + '-content', dangerouslySetInnerHTML: { __html: me.props.text } })
	        );
	    };

	    return CheckboxItem;
	}(React.Component);

	CheckboxItem.defaultProps = {
	    value: "",
	    prefixCls: "kuma-checkbox-group-item",
	    onChange: function onChange() {}
	};

	CheckboxItem.propTypes = {
	    value: React.PropTypes.string,
	    disabled: React.PropTypes.bool,
	    prefixCls: React.PropTypes.string,
	    onChange: React.PropTypes.func
	};

	CheckboxItem.displayName = "CheckboxItem";

	module.exports = CheckboxItem;

/***/ },
/* 532 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var FormField = __webpack_require__(274);
	var Constants = __webpack_require__(272);
	var Select = __webpack_require__(298);
	var Option = Select.Option;

	var assign = __webpack_require__(284);
	var update = React.addons.update;

	var CascadeSelectFormField = function (_FormField) {
	    _inherits(CascadeSelectFormField, _FormField);

	    function CascadeSelectFormField(props) {
	        _classCallCheck(this, CascadeSelectFormField);

	        return _possibleConstructorReturn(this, _FormField.call(this, props));
	    }

	    CascadeSelectFormField.prototype.getDataLength = function getDataLength() {
	        var me = this;
	        return me.props.jsxdata.length;
	    };

	    CascadeSelectFormField.prototype.handleChange = function handleChange(i, value) {
	        var me = this;
	        var values = update(me.state.value, {}) || [];
	        if (!!values[i]) {
	            values = values.slice(0, i);
	            values.push(value);
	        } else {
	            values[i] = value;
	        }
	        me.handleDataChange(values);
	    };

	    CascadeSelectFormField.prototype.addSpecificClass = function addSpecificClass() {
	        var me = this;
	        if (me.props.jsxprefixCls == "kuma-uxform-field") {
	            return me.props.jsxprefixCls + " kuma-cascade-select-uxform-field";
	        } else {
	            return me.props.jsxprefixCls;
	        }
	    };

	    CascadeSelectFormField.prototype.renderField = function renderField() {
	        var me = this;
	        var length = me.getDataLength();
	        var arr = [];
	        var data = {};
	        var mode = me.props.jsxmode || me.props.mode;
	        if (mode == Constants.MODE.EDIT) {
	            var _ret = function () {
	                try {
	                    data = me.props.jsxdata.contents;
	                } catch (e) {
	                    console.warn(e.message);
	                    return {
	                        v: void 0
	                    };
	                }

	                /*
	                 * 如果 value 存在相应的值，则填充下一级的选择，
	                 * 如果 value 不存在，则填充空数组，
	                 * 如果 data 中不包含 contents，则证明级联选择生成已结束，则跳出循环
	                 */
	                var stateValue = me.state.value || []; // 预防 value 是 undefined 的情况

	                var _loop = function _loop(i) {
	                    var options = data.map(function (item, index) {
	                        return React.createElement(
	                            Option,
	                            { key: index, value: item.value },
	                            item.text
	                        );
	                    });

	                    var selectOptions = {
	                        ref: "el",
	                        key: "select",
	                        optionLabelProp: "children",
	                        style: me.props.jsxstyle,
	                        showSearch: me.props.jsxshowSearch,
	                        placeholder: me.props.jsxplaceholder
	                    };
	                    selectOptions.onChange = me.handleChange.bind(me, i);
	                    selectOptions.value = stateValue[i] || null;
	                    if (i != 0) {
	                        arr.push(React.createElement(
	                            'span',
	                            { key: "split" + i, className: 'kuma-uxform-split' },
	                            '-'
	                        ));
	                    }
	                    arr.push(React.createElement(
	                        Select,
	                        _extends({}, selectOptions, { key: i }),
	                        options
	                    ));
	                    if (!!stateValue[i]) {
	                        data = data.filter(function (item) {
	                            return item.value == stateValue[i];
	                        })[0];
	                        data = data.contents;
	                        if (!data) return 'break';
	                    } else {
	                        data = [];
	                    }
	                };

	                for (var i = 0; i < length; i++) {
	                    var _ret2 = _loop(i);

	                    if (_ret2 === 'break') break;
	                }
	            }();

	            if ((typeof _ret === 'undefined' ? 'undefined' : _typeof(_ret)) === "object") return _ret.v;
	        } else if (mode == Constants.MODE.VIEW) {
	            if (me.state.value instanceof Array) {
	                (function () {
	                    var data = me.props.jsxdata;
	                    var textArr = me.state.value.map(function (item, index) {
	                        data = data.contents.filter(function (ele, i) {
	                            return ele.value == item;
	                        })[0];
	                        return data.text;
	                    });
	                    arr.push(React.createElement(
	                        'span',
	                        { key: 'cascade' },
	                        textArr.join(" ")
	                    ));
	                })();
	            }
	        }

	        return arr;
	    };

	    return CascadeSelectFormField;
	}(FormField);

	CascadeSelectFormField.propTypes = assign({}, FormField.propTypes, {
	    jsxstyle: React.PropTypes.object,
	    jsxshowSearch: React.PropTypes.bool,
	    jsxplaceholder: React.PropTypes.string,
	    jsxdata: React.PropTypes.object
	});
	CascadeSelectFormField.defaultProps = assign({}, FormField.defaultProps, {
	    jsxshowSearch: false,
	    jsxplaceholder: "请下拉选择"
	});
	CascadeSelectFormField.displayName = "CascadeSelectFormField";

	module.exports = CascadeSelectFormField;

/***/ },
/* 533 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	/**
	 * OtherFormField Component for uxcore
	 * @author eternalsky
	 *
	 * Copyright 2014-2015, Uxcore Team, Alinw.
	 * All rights reserved.
	 */

	module.exports = __webpack_require__(534);

/***/ },
/* 534 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	/**
	 * OtherFormField Component for uxcore
	 * @author eternalsky
	 *
	 * Copyright 2014-2015, Uxcore Team, Alinw.
	 * All rights reserved.
	 */

	var React = __webpack_require__(7);
	var ReactDOM = __webpack_require__(8);
	var classnames = __webpack_require__(19);
	var assign = __webpack_require__(284);

	var OtherFormField = function (_React$Component) {
	    _inherits(OtherFormField, _React$Component);

	    function OtherFormField(props) {
	        _classCallCheck(this, OtherFormField);

	        return _possibleConstructorReturn(this, _React$Component.call(this, props));
	    }

	    OtherFormField.prototype.render = function render() {
	        var _classnames;

	        var me = this;
	        var style = {
	            width: me.props.jsxflex / me.props.totalFlex * 100 + '%'
	        };
	        return React.createElement(
	            'div',
	            { className: classnames((_classnames = {}, _classnames[me.props.jsxprefixCls] = true, _classnames[me.props.className] = !!me.props.className, _classnames)), style: assign({}, style, {
	                    display: me.props.jsxshow ? "table" : "none"
	                }) },
	            me.props.children
	        );
	    };

	    return OtherFormField;
	}(React.Component);

	OtherFormField.defaultProps = {
	    jsxprefixCls: "kuma-uxform-field kuma-other-uxform-field", // 默认类名
	    jsxflex: 1, // 占 Form 的比例，类似于 css3 中的 flex-box
	    jsxshow: true
	};

	OtherFormField.propTypes = {
	    /**
	     * @title 类名前缀
	     * @veIgnore
	     */
	    jsxprefixCls: React.PropTypes.string,
	    /**
	     * @title 弹性比例
	     */
	    jsxflex: React.PropTypes.number,
	    /**
	     * @title 是否显示
	     * @veIgnore
	     */
	    jsxshow: React.PropTypes.bool
	};

	OtherFormField.displayName = "OtherFormField";

	module.exports = OtherFormField;

/***/ },
/* 535 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var React = __webpack_require__(7);
	var ReactDOM = __webpack_require__(8);
	var classnames = __webpack_require__(19);
	var assign = __webpack_require__(284);

	var ButtonGroupFormField = function (_React$Component) {
	    _inherits(ButtonGroupFormField, _React$Component);

	    function ButtonGroupFormField(props) {
	        _classCallCheck(this, ButtonGroupFormField);

	        return _possibleConstructorReturn(this, _React$Component.call(this, props));
	    }

	    ButtonGroupFormField.prototype._processChild = function _processChild() {
	        var me = this;
	        var length = React.Children.count(me.props.children);
	        if (!length) {
	            return false;
	        }
	        var elements = React.Children.map(me.props.children, function (child, index) {
	            var props = {};
	            if (child.props.action == "submit") {
	                props.onClick = function () {
	                    var data = me.props.getValues();
	                    child.props.onClick(data);
	                };
	            }
	            if (child.props.action == "reset") {
	                props.onClick = function () {
	                    me.props.resetValues();
	                };
	            }
	            return React.cloneElement(child, props);
	        });

	        return elements;
	    };

	    ButtonGroupFormField.prototype.render = function render() {
	        var _classnames;

	        var me = this;
	        var elements = me._processChild();
	        return React.createElement(
	            'div',
	            { className: classnames((_classnames = {}, _classnames[me.props.jsxprefixCls] = true, _classnames[me.props.className] = !!me.props.className, _classnames)), style: assign({}, me.props.style, {
	                    display: me.props.jsxshow ? "table" : "none"
	                }) },
	            !!elements && elements
	        );
	    };

	    return ButtonGroupFormField;
	}(React.Component);

	ButtonGroupFormField.propTypes = {
	    jsxprefixCls: React.PropTypes.string,
	    jsxflex: React.PropTypes.number,
	    jsxshow: React.PropTypes.bool
	};
	ButtonGroupFormField.defaultProps = {
	    jsxprefixCls: "kuma-uxform-field kuma-button-group-uxform-field", // 默认类名
	    jsxflex: 1, // 占 Form 的比例，类似于 css3 中的 flex-box
	    jsxshow: true
	};
	ButtonGroupFormField.displayName = "ButtonGroupFormField";

	module.exports = ButtonGroupFormField;

/***/ },
/* 536 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var FormField = __webpack_require__(274);
	var Constants = __webpack_require__(272);
	var Tinymce = __webpack_require__(537);
	var assign = __webpack_require__(284);

	var EditorFormField = function (_FormField) {
	    _inherits(EditorFormField, _FormField);

	    function EditorFormField(props) {
	        _classCallCheck(this, EditorFormField);

	        return _possibleConstructorReturn(this, _FormField.call(this, props));
	    }

	    EditorFormField.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
	        var me = this;
	        if (!me._isEqual(nextProps.value, me.props.value)) {
	            me.handleDataChange(nextProps.value, true);
	        }
	    };

	    EditorFormField.prototype.componentDidUpdate = function componentDidUpdate(prevProps) {
	        var me = this;
	        var prevMode = prevProps.jsxmode || prevProps.mode;
	        var mode = me.props.jsxmode || me.props.mode;
	        if (prevMode == Constants.MODE.VIEW && mode == Constants.MODE.EDIT) {
	            me.refs.tinymce.resetValue(me.state.value == undefined || me.state.value == null ? "" : me.state.value);
	        }
	    };

	    EditorFormField.prototype._isEqual = function _isEqual(a, b) {
	        return JSON.stringify(a) == JSON.stringify(b);
	    };

	    EditorFormField.prototype.handleChange = function handleChange(e, editor) {
	        var me = this;
	        me.handleDataChange(editor.getContent());
	    };

	    EditorFormField.prototype.handleKeyup = function handleKeyup(e, editor) {
	        var me = this;
	        me.handleDataChange(editor.getContent());
	    };

	    EditorFormField.prototype.addSpecificClass = function addSpecificClass() {
	        var me = this;
	        if (me.props.jsxprefixCls == "kuma-uxform-field") {
	            return me.props.jsxprefixCls + " kuma-editor-uxform-field";
	        } else {
	            return me.props.jsxprefixCls;
	        }
	    };

	    EditorFormField.prototype.renderField = function renderField() {
	        var me = this;
	        var mode = me.props.jsxmode || me.props.mode;
	        if (me.state.fromReset && mode == Constants.MODE.EDIT) {
	            me.refs.tinymce.resetValue(me.props.jsxcontent);
	        }
	        if (mode == Constants.MODE.EDIT) {
	            return React.createElement(Tinymce, { ref: "tinymce",
	                placeholder: me.props.placeholder,
	                config: me.props.jsxconfig,
	                content: me.state.value || "",
	                onChange: me.handleChange.bind(me),
	                onKeyup: me.handleKeyup.bind(me) });
	        } else {
	            return React.createElement("span", { key: "text", dangerouslySetInnerHTML: { __html: me.state.value } });
	        }
	    };

	    return EditorFormField;
	}(FormField);

	EditorFormField.propTypes = assign({}, FormField.propTypes);
	EditorFormField.defaultProps = assign({}, FormField.defaultProps, {
	    jsxconfig: {},
	    jsxcontent: ""
	});
	EditorFormField.displayName = "EditorFormField";

	module.exports = EditorFormField;

/***/ },
/* 537 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	/**
	 * Tinymce Component for uxcore
	 * @author eternalsky
	 *
	 * Copyright 2014-2015, Uxcore Team, Alinw.
	 * All rights reserved.
	 */

	module.exports = __webpack_require__(538);

/***/ },
/* 538 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

	/**
	 * Tinymce Component for uxcore
	 * Inspired by react-tinymce: https://github.com/mzabriskie/react-tinymce
	 * @author eternalsky
	 *
	 * Copyright 2014-2015, Uxcore Team, Alinw.
	 * All rights reserved.
	 */

	var React = __webpack_require__(7);
	var ReactDOM = __webpack_require__(8);
	var util = __webpack_require__(539);
	var EditorConfig = __webpack_require__(540);
	var assign = __webpack_require__(284);
	// Include all of the Native DOM and custom events from:
	// https://github.com/tinymce/tinymce/blob/master/tools/docs/tinymce.Editor.js#L5-L12
	var EVENTS = ['focusin', 'focusout', 'click', 'dblclick', 'mousedown', 'mouseup', 'mousemove', 'mouseover', 'beforepaste', 'paste', 'cut', 'copy', 'selectionchange', 'mouseout', 'mouseenter', 'mouseleave', 'keydown', 'keypress', 'keyup', 'contextmenu', 'dragend', 'dragover', 'draggesture', 'dragdrop', 'drop', 'drag', 'BeforeRenderUI', 'SetAttrib', 'PreInit', 'PostRender', 'init', 'deactivate', 'activate', 'NodeChange', 'BeforeExecCommand', 'ExecCommand', 'show', 'hide', 'ProgressState', 'LoadContent', 'SaveContent', 'BeforeSetContent', 'SetContent', 'BeforeGetContent', 'GetContent', 'VisualAid', 'remove', 'submit', 'reset', 'BeforeAddUndo', 'AddUndo', 'change', 'undo', 'redo', 'ClearUndos', 'ObjectSelected', 'ObjectResizeStart', 'ObjectResized', 'PreProcess', 'PostProcess', 'focus', 'blur'];

	// Note: because the capitalization of the events is weird, we're going to get
	// some inconsistently-named handlers, for example compare:
	// 'onMouseleave' and 'onNodeChange'
	var HANDLER_NAMES = EVENTS.map(function (event) {
	    return 'on' + util.uc_first(event);
	});

	var Tinymce = function (_React$Component) {
	    _inherits(Tinymce, _React$Component);

	    function Tinymce(props) {
	        _classCallCheck(this, Tinymce);

	        return _possibleConstructorReturn(this, _React$Component.call(this, props));
	    }

	    Tinymce.prototype.componentWillMount = function componentWillMount() {
	        if ((typeof tinymce === 'undefined' ? 'undefined' : _typeof(tinymce)) !== 'object') {
	            console.warn("TinyMCE is not found in global, init failed");
	        }
	        this.id = this.id || util.uuid();
	    };

	    Tinymce.prototype.componentDidMount = function componentDidMount() {
	        this._init(this.props.config);
	    };

	    Tinymce.prototype.componentWillUnmount = function componentWillUnmount() {
	        this._remove();
	    };

	    Tinymce.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
	        if (!util.isEqual(nextProps.config, this.props.config)) {
	            this._init(nextProps.config, nextProps.content);
	        }
	    };

	    Tinymce.prototype.shouldComponentUpdate = function shouldComponentUpdate(nextProps) {
	        return !util.isEqual(this.props.content, nextProps.content) || !util.isEqual(this.props.config, nextProps.config);
	    };

	    Tinymce.prototype.resetValue = function resetValue(value) {
	        tinymce.get(this.id).setContent(value);
	    };

	    Tinymce.prototype._init = function _init(config, content) {
	        var me = this;
	        if (me._isInit) {
	            me._remove();
	        }
	        // hide the textarea until init finished
	        ReactDOM.findDOMNode(me).style.visibility = 'hidden';
	        config.selector = '#' + me.id;
	        config = assign({}, EditorConfig, config);
	        if (!config.language) {
	            config.language = 'zh_CN';
	        }
	        config.setup = function (editor) {
	            EVENTS.forEach(function (event, index) {
	                var handler = me.props[HANDLER_NAMES[index]];
	                if (typeof handler !== 'function') return;
	                editor.on(event, function (e) {
	                    // native DOM events don't have access to the editor so we pass it here
	                    handler(e, editor);
	                });
	            });
	            // need to set content here because the textarea will still have the
	            // old `this.props.content`
	            if (content) {
	                editor.on('init', function () {
	                    editor.setContent(content);
	                });
	            }
	        };
	        tinymce.baseURL = '//g.alicdn.com/uxcore/uxcore-lib/tinymce/4.2.5/';
	        tinymce.init(config);
	        ReactDOM.findDOMNode(me).style.visibility = "";
	        me._isInit = true;
	    };

	    Tinymce.prototype._remove = function _remove() {
	        tinymce.EditorManager.execCommand("mceRemoveEditor", true, this.id);
	        this._isInit = false;
	    };

	    Tinymce.prototype.render = function render() {
	        return React.createElement('textarea', { id: this.id, defaultValue: this.props.content, placeholder: this.props.placeholder });
	    };

	    return Tinymce;
	}(React.Component);

	Tinymce.defaultProps = {
	    config: {}
	};

	// http://facebook.github.io/react/docs/reusable-components.html
	Tinymce.propTypes = {
	    config: React.PropTypes.object,
	    content: React.PropTypes.string
	};

	//add handler propTypes
	HANDLER_NAMES.forEach(function (name) {
	    Tinymce.propTypes[name] = React.PropTypes.func;
	});

	Tinymce.displayName = "Tinymce";

	module.exports = Tinymce;

/***/ },
/* 539 */
/***/ function(module, exports) {

	'use strict';

	var count = 0;

	module.exports = {
	    uc_first: function uc_first(str) {
	        return str.substring(0, 1).toUpperCase() + str.substring(1);
	    },
	    uuid: function uuid() {
	        return 'uxcore-tinymce-' + count++;
	    },
	    isEqual: function isEqual(a, b) {
	        return JSON.stringify(a) == JSON.stringify(b);
	    }
	};

/***/ },
/* 540 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var plugins = ['lists', 'hr', 'emoticons', 'textcolor', 'insertdatetime', 'link', 'table', 'paste', 'preview', 'wordcount', 'image', 'upload', 'placeholder', 'variable', 'noneditable'];

	exports["default"] = {
	  theme: 'modern',
	  height: 400,
	  external_plugins: {
	    'emoticons': '//g.alicdn.com/uxcore/uxcore-lib/tinymce/4.2.5/plugins/emoticons/plugin.min.js',
	    'upload': '//g.alicdn.com/uxcore/uxcore-lib/tinymce/4.2.5/plugins/upload/plugin.min.js',
	    'textcolor': '//g.alicdn.com/uxcore/uxcore-lib/tinymce/4.2.5/plugins/textcolor/plugin.min.js',
	    'hr': '//g.alicdn.com/uxcore/uxcore-lib/tinymce/4.2.5/plugins/hr/plugin.min.js',
	    'placeholder': '//g.alicdn.com/uxcore/uxcore-lib/tinymce/4.2.5/plugins/placeholder/plugin.min.js',
	    'variable': '//g.alicdn.com/uxcore/uxcore-lib/tinymce/4.2.5/plugins/variable/plugin.min.js'
	  },
	  resize: true, // 是否可以鼠标拖动编辑器改变大小
	  border_width: 1, // 编辑器的边框宽度
	  convert_urls: false, // 当你insertContent的时候，取消一些节点src的转换
	  visual: true, // table的虚框是否显示，由于大文本设置虚框很耗性能，所以取消掉
	  keep_values: false, // 必须设置false用来提高性能
	  forced_root_block: 'div', // 当空文本的时候，tinymce会设置一个根节点，默认是P，我们要改成div比较合理
	  show_system_default_font: true, // 是否开启系统字体的探测。
	  link_title: true, // link plugins enable title edit
	  plugins: plugins,
	  cssFiles: ['styles/skin.css', 'styles/skin-ext.css'],
	  toolbar1: 'preview undo redo | fontselect fontsizeselect | bold italic underline strikethrough removeformat | forecolor backcolor | link | emoticons upload',
	  toolbar2: 'alignleft aligncenter alignright alignjustify | bullist numlist outdent indent | table hr inserttime',
	  uploadConfig: {
	    "inputName": "imageUploadInput",
	    "actionUrl": "http://test.alibaba-inc.com/work/xservice/http/uploadimage.json",
	    "errorCallback": function errorCallback() {
	      console.log('errorCallback', arguments);
	    },
	    "progressCallback": function progressCallback() {
	      console.log('progressCallback', arguments);
	    }
	  },
	  wordcount_countregex: /[^\x00-\xff]+/g
	};
	module.exports = exports['default'];

/***/ },
/* 541 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	/**
	 * Created by xy on 15/4/13.
	 */
	var SelectFormField = __webpack_require__(296);
	var Constants = __webpack_require__(272);
	var Select = __webpack_require__(298);
	var assign = __webpack_require__(284);
	var deepcopy = __webpack_require__(285);
	var classnames = __webpack_require__(19);
	var Option = Select.Option;

	var selectOptions = ['onSelect', 'onDeselect', 'getPopupContainer', 'filterOption', 'allowClear', 'searchPlaceholder', 'tags', 'disabled', 'showSearch', 'placeholder', 'optionLabelProp', 'maxTagTextLength', 'dropdownMatchSelectWidth', 'dropdownClassName', 'notFoundContent'];

	var SearchFormField = function (_SelectFormField) {
	    _inherits(SearchFormField, _SelectFormField);

	    function SearchFormField(props) {
	        _classCallCheck(this, SearchFormField);

	        return _possibleConstructorReturn(this, _SelectFormField.call(this, props));
	    }

	    SearchFormField.prototype.addSpecificClass = function addSpecificClass() {
	        var me = this;
	        if (me.props.jsxprefixCls == "kuma-uxform-field") {
	            return me.props.jsxprefixCls + " kuma-search-uxform-field";
	        } else {
	            return me.props.jsxprefixCls;
	        }
	    };

	    SearchFormField.prototype._processAdvanced = function _processAdvanced() {
	        var me = this;
	        var advancedOptions = me.props.advancedOptions;

	        return advancedOptions.map(function (item) {
	            return React.createElement(
	                Option,
	                { key: item.value, title: item.text },
	                item.text
	            );
	        });
	    };

	    SearchFormField.prototype._processClassOptions = function _processClassOptions() {
	        var me = this;
	        var classOptions = me.props.classOptions;

	        return classOptions.map(function (item) {
	            return React.createElement(
	                Option,
	                { key: item.value, title: item.text },
	                item.text
	            );
	        });
	    };

	    SearchFormField.prototype.handleChange = function handleChange(value, label) {
	        var me = this;
	        var stateValue = deepcopy(me.state.value) || {};
	        stateValue.main = value;
	        me.handleDataChange(stateValue, false, label);
	    };

	    SearchFormField.prototype.handleClassChange = function handleClassChange(value) {
	        var me = this;
	        var stateValue = deepcopy(me.state.value) || {};
	        var label = me.state.label;
	        stateValue["class"] = value;
	        me.handleDataChange(stateValue, false, label);
	    };

	    SearchFormField.prototype.handleAdvancedChange = function handleAdvancedChange(value) {
	        var me = this;
	        var stateValue = deepcopy(me.state.value) || {};
	        var label = me.state.label;
	        stateValue.advanced = value;
	        me.handleDataChange(stateValue, false, label);
	    };

	    SearchFormField.prototype.handleIconClick = function handleIconClick(e) {
	        var me = this;
	        me.props.onIconClick(e);
	    };

	    SearchFormField.prototype.renderField = function renderField() {
	        var _options;

	        var me = this;
	        var arr = [];
	        var mode = me.props.jsxmode || me.props.mode;
	        var hasClass = me.props.classOptions instanceof Array && me.props.classOptions.length > 0;
	        var hasAdvance = me.props.advancedOptions instanceof Array && me.props.advancedOptions.length > 0;

	        var options = (_options = {
	            ref: "el",
	            key: "select",
	            className: classnames({
	                'has-class': hasClass,
	                'has-advance': hasAdvance,
	                'kuma-uxform-main-search': true
	            }),
	            optionFilterProp: me.props.optionFilterProp,
	            combobox: me.props.combobox,
	            onChange: me.handleChange.bind(me),
	            onSearch: me.handleSearch.bind(me)
	        }, _options['key'] = 'search', _options);

	        selectOptions.forEach(function (item, index) {
	            if (item in me.props) {
	                options[item] = me.props[item];
	            }
	        });

	        if (Object.keys(me.props.jsxdata).length > 0) {
	            options.optionFilterProp = 'title';
	        }

	        // only jsxfetchUrl mode need pass label, for the options always change.
	        // when mounted, state.label is undefined, which cause defalutValue cannot be used.
	        if (!!me.props.jsxfetchUrl && !!me.state.label && me.state.label.length !== 0) {
	            options.label = me.state.label || [];
	        }

	        if (!me.props.combobox || me.state.fromReset) {
	            options.value = me.state.value.main || [];
	        }

	        if (!!me.props.jsxfetchUrl) {
	            options.filterOption = false;
	        }
	        if (!me.props.tidy && hasClass) {
	            arr.push(me.renderClassOptions());
	        }
	        arr.push(React.createElement(
	            Select,
	            options,
	            me._generateOptionsFromData()
	        ));

	        if (!me.props.tidy && hasAdvance) {
	            arr.push(me.renderAdvancedOptions());
	        }
	        arr.push(React.createElement(
	            'span',
	            { className: classnames({
	                    "kuma-search-uxform-field-icon": true,
	                    "tidy-pattern": me.props.tidy
	                }), key: 'icon', onClick: me.handleIconClick.bind(me) },
	            React.createElement('i', { className: 'kuma-icon kuma-icon-search' })
	        ));
	        return arr;
	    };

	    SearchFormField.prototype.renderClassOptions = function renderClassOptions() {
	        var _classnames, _classnames2;

	        var me = this;
	        var _me$props$classConfig = me.props.classConfig;
	        var className = _me$props$classConfig.className;
	        var dropdownClassName = _me$props$classConfig.dropdownClassName;
	        var onChange = _me$props$classConfig.onChange;

	        var otherOptions = _objectWithoutProperties(_me$props$classConfig, ['className', 'dropdownClassName', 'onChange']);

	        var options = assign({}, {
	            showSearch: false,
	            key: 'class',
	            dropdownAlign: {
	                offset: [0, 0]
	            },
	            dropdownClassName: classnames((_classnames = {
	                "kuma-uxform-class-dropdown": true
	            }, _classnames[dropdownClassName] = !!dropdownClassName, _classnames)),
	            className: classnames((_classnames2 = {
	                "kuma-uxform-class-search": true
	            }, _classnames2[className] = !!className, _classnames2)),
	            onChange: me.handleClassChange.bind(me)
	        }, otherOptions);
	        return React.createElement(
	            Select,
	            options,
	            me._processClassOptions()
	        );
	    };

	    SearchFormField.prototype.renderAdvancedOptions = function renderAdvancedOptions() {
	        var _classnames3, _classnames4;

	        var me = this;
	        var _me$props$advancedCon = me.props.advancedConfig;
	        var className = _me$props$advancedCon.className;
	        var dropdownClassName = _me$props$advancedCon.dropdownClassName;
	        var onChange = _me$props$advancedCon.onChange;

	        var otherOptions = _objectWithoutProperties(_me$props$advancedCon, ['className', 'dropdownClassName', 'onChange']);

	        var options = assign({}, {
	            showSearch: false,
	            key: 'advanced',
	            className: classnames((_classnames3 = {
	                'kuma-uxform-advanced-search': true
	            }, _classnames3[className] = !!className, _classnames3)),
	            dropdownClassName: classnames((_classnames4 = {
	                "kuma-uxform-advanced-dropdown": true
	            }, _classnames4[dropdownClassName] = !!dropdownClassName, _classnames4)),
	            dropdownAlign: {
	                offset: [0, 0]
	            },
	            onChange: me.handleAdvancedChange.bind(me)
	        }, otherOptions);
	        return React.createElement(
	            Select,
	            options,
	            me._processAdvanced()
	        );
	    };

	    return SearchFormField;
	}(SelectFormField);

	SearchFormField.Option = Option;
	SearchFormField.displayName = "SearchFormField";
	SearchFormField.propTypes = assign({}, SelectFormField.propTypes, {
	    advancedOptions: React.PropTypes.array,
	    advancedConfig: React.PropTypes.object,
	    classOptions: React.PropTypes.array,
	    classConfig: React.PropTypes.object,
	    tidy: React.PropTypes.bool,
	    onIconClick: React.PropTypes.func
	});
	SearchFormField.defaultProps = assign({}, SelectFormField.defaultProps, {
	    jsxshowLabel: false,
	    combobox: true,
	    advancedConfig: {},
	    classConfig: {},
	    tidy: false,
	    onIconClick: function onIconClick() {}
	});

	module.exports = SearchFormField;

/***/ },
/* 542 */
/***/ function(module, exports, __webpack_require__, __webpack_module_template_argument_0__) {

	'use strict';

	/**
	 * Const Component for uxcore
	 * @author zhouquan.yezq
	 *
	 * Copyright 2014-2015, Uxcore Team, Alinw.
	 * All rights reserved.
	 */

	module.exports = __webpack_require__(__webpack_module_template_argument_0__);

/***/ },
/* 543 */
/***/ function(module, exports, __webpack_require__, __webpack_module_template_argument_0__, __webpack_module_template_argument_1__, __webpack_module_template_argument_2__, __webpack_module_template_argument_3__, __webpack_module_template_argument_4__, __webpack_module_template_argument_5__, __webpack_module_template_argument_6__, __webpack_module_template_argument_7__, __webpack_module_template_argument_8__, __webpack_module_template_argument_9__, __webpack_module_template_argument_10__) {

	'use strict';

	module.exports = {
	  guid: __webpack_require__(__webpack_module_template_argument_0__),
	  classSet: __webpack_require__(__webpack_module_template_argument_1__),
	  joinClasses: __webpack_require__(__webpack_module_template_argument_2__),
	  KeyCode: __webpack_require__(__webpack_module_template_argument_3__),
	  PureRenderMixin: __webpack_require__(__webpack_module_template_argument_4__),
	  shallowEqual: __webpack_require__(__webpack_module_template_argument_5__),
	  createChainedFunction: __webpack_require__(__webpack_module_template_argument_6__),
	  Dom: {
	    addEventListener: __webpack_require__(__webpack_module_template_argument_7__),
	    contains: __webpack_require__(__webpack_module_template_argument_8__)
	  },
	  Children: {
	    toArray: __webpack_require__(__webpack_module_template_argument_9__),
	    mapSelf: __webpack_require__(__webpack_module_template_argument_10__)
	  }
	};

/***/ },
/* 544 */
/***/ function(module, exports, __webpack_require__, __webpack_module_template_argument_0__) {

	'use strict';

	var deprecate = __webpack_require__(__webpack_module_template_argument_0__);
	var classNames = __webpack_require__(19);

	module.exports = deprecate(classNames, '`rcUtil.classSet()` is deprecated, use `classNames()` by `require(\'classnames\')` instead');

/***/ },
/* 545 */
/***/ function(module, exports, __webpack_require__, __webpack_module_template_argument_0__) {

	'use strict';

	var deprecate = __webpack_require__(__webpack_module_template_argument_0__);
	var classNames = __webpack_require__(19);

	module.exports = deprecate(classNames, '`rcUtil.joinClasses()` is deprecated, use `classNames()` by `require(\'classnames\')` instead');

/***/ },
/* 546 */
/***/ function(module, exports, __webpack_require__, __webpack_module_template_argument_0__) {

	'use strict';

	var shallowEqual = __webpack_require__(__webpack_module_template_argument_0__);

	/**
	 * If your React component's render function is "pure", e.g. it will render the
	 * same result given the same props and state, provide this Mixin for a
	 * considerable performance boost.
	 *
	 * Most React components have pure render functions.
	 *
	 * Example:
	 *
	 *   const ReactComponentWithPureRenderMixin =
	 *     require('ReactComponentWithPureRenderMixin');
	 *   React.createClass({
	 *     mixins: [ReactComponentWithPureRenderMixin],
	 *
	 *     render: function() {
	 *       return <div className={this.props.className}>foo</div>;
	 *     }
	 *   });
	 *
	 * Note: This only checks shallow equality for props and state. If these contain
	 * complex data structures this mixin may have false-negatives for deeper
	 * differences. Only mixin to components which have simple props and state, or
	 * use `forceUpdate()` when you know deep data structures have changed.
	 */
	var ReactComponentWithPureRenderMixin = {
	  shouldComponentUpdate: function shouldComponentUpdate(nextProps, nextState) {
	    return !shallowEqual(this.props, nextProps) || !shallowEqual(this.state, nextState);
	  }
	};

	module.exports = ReactComponentWithPureRenderMixin;

/***/ },
/* 547 */
/***/ function(module, exports, __webpack_require__, __webpack_module_template_argument_0__) {

	'use strict';

	var fetchKeys = __webpack_require__(__webpack_module_template_argument_0__);

	module.exports = function shallowEqual(objA, objB, compare, compareContext) {

	    var ret = compare ? compare.call(compareContext, objA, objB) : void 0;

	    if (ret !== void 0) {
	        return !!ret;
	    }

	    if (objA === objB) {
	        return true;
	    }

	    if (typeof objA !== 'object' || objA === null || typeof objB !== 'object' || objB === null) {
	        return false;
	    }

	    var keysA = fetchKeys(objA);
	    var keysB = fetchKeys(objB);

	    var len = keysA.length;
	    if (len !== keysB.length) {
	        return false;
	    }

	    compareContext = compareContext || null;

	    // Test for A's keys different from B.
	    var bHasOwnProperty = Object.prototype.hasOwnProperty.bind(objB);
	    for (var i = 0; i < len; i++) {
	        var key = keysA[i];
	        if (!bHasOwnProperty(key)) {
	            return false;
	        }
	        var valueA = objA[key];
	        var valueB = objB[key];

	        var _ret = compare ? compare.call(compareContext, valueA, valueB, key) : void 0;
	        if (_ret === false || _ret === void 0 && valueA !== valueB) {
	            return false;
	        }
	    }

	    return true;
	};

/***/ },
/* 548 */
/***/ function(module, exports, __webpack_require__, __webpack_module_template_argument_0__, __webpack_module_template_argument_1__, __webpack_module_template_argument_2__) {

	/**
	 * lodash 3.1.2 (Custom Build) <https://lodash.com/>
	 * Build: `lodash modern modularize exports="npm" -o ./`
	 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
	 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
	 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
	 * Available under MIT license <https://lodash.com/license>
	 */
	var getNative = __webpack_require__(__webpack_module_template_argument_0__),
	    isArguments = __webpack_require__(__webpack_module_template_argument_1__),
	    isArray = __webpack_require__(__webpack_module_template_argument_2__);

	/** Used to detect unsigned integer values. */
	var reIsUint = /^\d+$/;

	/** Used for native method references. */
	var objectProto = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/* Native method references for those with the same name as other `lodash` methods. */
	var nativeKeys = getNative(Object, 'keys');

	/**
	 * Used as the [maximum length](http://ecma-international.org/ecma-262/6.0/#sec-number.max_safe_integer)
	 * of an array-like value.
	 */
	var MAX_SAFE_INTEGER = 9007199254740991;

	/**
	 * The base implementation of `_.property` without support for deep paths.
	 *
	 * @private
	 * @param {string} key The key of the property to get.
	 * @returns {Function} Returns the new function.
	 */
	function baseProperty(key) {
	  return function(object) {
	    return object == null ? undefined : object[key];
	  };
	}

	/**
	 * Gets the "length" property value of `object`.
	 *
	 * **Note:** This function is used to avoid a [JIT bug](https://bugs.webkit.org/show_bug.cgi?id=142792)
	 * that affects Safari on at least iOS 8.1-8.3 ARM64.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {*} Returns the "length" value.
	 */
	var getLength = baseProperty('length');

	/**
	 * Checks if `value` is array-like.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
	 */
	function isArrayLike(value) {
	  return value != null && isLength(getLength(value));
	}

	/**
	 * Checks if `value` is a valid array-like index.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
	 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
	 */
	function isIndex(value, length) {
	  value = (typeof value == 'number' || reIsUint.test(value)) ? +value : -1;
	  length = length == null ? MAX_SAFE_INTEGER : length;
	  return value > -1 && value % 1 == 0 && value < length;
	}

	/**
	 * Checks if `value` is a valid array-like length.
	 *
	 * **Note:** This function is based on [`ToLength`](http://ecma-international.org/ecma-262/6.0/#sec-tolength).
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
	 */
	function isLength(value) {
	  return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
	}

	/**
	 * A fallback implementation of `Object.keys` which creates an array of the
	 * own enumerable property names of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names.
	 */
	function shimKeys(object) {
	  var props = keysIn(object),
	      propsLength = props.length,
	      length = propsLength && object.length;

	  var allowIndexes = !!length && isLength(length) &&
	    (isArray(object) || isArguments(object));

	  var index = -1,
	      result = [];

	  while (++index < propsLength) {
	    var key = props[index];
	    if ((allowIndexes && isIndex(key, length)) || hasOwnProperty.call(object, key)) {
	      result.push(key);
	    }
	  }
	  return result;
	}

	/**
	 * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.
	 * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
	 *
	 * @static
	 * @memberOf _
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
	 * @example
	 *
	 * _.isObject({});
	 * // => true
	 *
	 * _.isObject([1, 2, 3]);
	 * // => true
	 *
	 * _.isObject(1);
	 * // => false
	 */
	function isObject(value) {
	  // Avoid a V8 JIT bug in Chrome 19-20.
	  // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.
	  var type = typeof value;
	  return !!value && (type == 'object' || type == 'function');
	}

	/**
	 * Creates an array of the own enumerable property names of `object`.
	 *
	 * **Note:** Non-object values are coerced to objects. See the
	 * [ES spec](http://ecma-international.org/ecma-262/6.0/#sec-object.keys)
	 * for more details.
	 *
	 * @static
	 * @memberOf _
	 * @category Object
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names.
	 * @example
	 *
	 * function Foo() {
	 *   this.a = 1;
	 *   this.b = 2;
	 * }
	 *
	 * Foo.prototype.c = 3;
	 *
	 * _.keys(new Foo);
	 * // => ['a', 'b'] (iteration order is not guaranteed)
	 *
	 * _.keys('hi');
	 * // => ['0', '1']
	 */
	var keys = !nativeKeys ? shimKeys : function(object) {
	  var Ctor = object == null ? undefined : object.constructor;
	  if ((typeof Ctor == 'function' && Ctor.prototype === object) ||
	      (typeof object != 'function' && isArrayLike(object))) {
	    return shimKeys(object);
	  }
	  return isObject(object) ? nativeKeys(object) : [];
	};

	/**
	 * Creates an array of the own and inherited enumerable property names of `object`.
	 *
	 * **Note:** Non-object values are coerced to objects.
	 *
	 * @static
	 * @memberOf _
	 * @category Object
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names.
	 * @example
	 *
	 * function Foo() {
	 *   this.a = 1;
	 *   this.b = 2;
	 * }
	 *
	 * Foo.prototype.c = 3;
	 *
	 * _.keysIn(new Foo);
	 * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
	 */
	function keysIn(object) {
	  if (object == null) {
	    return [];
	  }
	  if (!isObject(object)) {
	    object = Object(object);
	  }
	  var length = object.length;
	  length = (length && isLength(length) &&
	    (isArray(object) || isArguments(object)) && length) || 0;

	  var Ctor = object.constructor,
	      index = -1,
	      isProto = typeof Ctor == 'function' && Ctor.prototype === object,
	      result = Array(length),
	      skipIndexes = length > 0;

	  while (++index < length) {
	    result[index] = (index + '');
	  }
	  for (var key in object) {
	    if (!(skipIndexes && isIndex(key, length)) &&
	        !(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
	      result.push(key);
	    }
	  }
	  return result;
	}

	module.exports = keys;


/***/ },
/* 549 */
/***/ function(module, exports, __webpack_require__, __webpack_module_template_argument_0__) {

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	exports['default'] = addEventListenerWrap;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var _addDomEventListener = __webpack_require__(__webpack_module_template_argument_0__);

	var _addDomEventListener2 = _interopRequireDefault(_addDomEventListener);

	var _reactDom = __webpack_require__(8);

	var _reactDom2 = _interopRequireDefault(_reactDom);

	function addEventListenerWrap(target, eventType, cb) {
	  /* eslint camelcase: 2 */
	  var callback = _reactDom2['default'].unstable_batchedUpdates ? function run(e) {
	    _reactDom2['default'].unstable_batchedUpdates(cb, e);
	  } : cb;
	  return (0, _addDomEventListener2['default'])(target, eventType, callback);
	}

	module.exports = exports['default'];

/***/ },
/* 550 */
/***/ function(module, exports, __webpack_require__, __webpack_module_template_argument_0__) {

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	exports['default'] = addEventListener;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var _EventObject = __webpack_require__(__webpack_module_template_argument_0__);

	var _EventObject2 = _interopRequireDefault(_EventObject);

	function addEventListener(target, eventType, callback) {
	  function wrapCallback(e) {
	    var ne = new _EventObject2['default'](e);
	    callback.call(target, ne);
	  }

	  if (target.addEventListener) {
	    target.addEventListener(eventType, wrapCallback, false);
	    return {
	      remove: function remove() {
	        target.removeEventListener(eventType, wrapCallback, false);
	      }
	    };
	  } else if (target.attachEvent) {
	    target.attachEvent('on' + eventType, wrapCallback);
	    return {
	      remove: function remove() {
	        target.detachEvent('on' + eventType, wrapCallback);
	      }
	    };
	  }
	}

	module.exports = exports['default'];

/***/ },
/* 551 */
/***/ function(module, exports, __webpack_require__, __webpack_module_template_argument_0__, __webpack_module_template_argument_1__) {

	/**
	 * @ignore
	 * event object for dom
	 * @author yiminghe@gmail.com
	 */

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	  value: true
	});

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var _EventBaseObject = __webpack_require__(__webpack_module_template_argument_0__);

	var _EventBaseObject2 = _interopRequireDefault(_EventBaseObject);

	var _objectAssign = __webpack_require__(__webpack_module_template_argument_1__);

	var _objectAssign2 = _interopRequireDefault(_objectAssign);

	var TRUE = true;
	var FALSE = false;
	var commonProps = ['altKey', 'bubbles', 'cancelable', 'ctrlKey', 'currentTarget', 'eventPhase', 'metaKey', 'shiftKey', 'target', 'timeStamp', 'view', 'type'];

	function isNullOrUndefined(w) {
	  return w === null || w === undefined;
	}

	var eventNormalizers = [{
	  reg: /^key/,
	  props: ['char', 'charCode', 'key', 'keyCode', 'which'],
	  fix: function fix(event, nativeEvent) {
	    if (isNullOrUndefined(event.which)) {
	      event.which = !isNullOrUndefined(nativeEvent.charCode) ? nativeEvent.charCode : nativeEvent.keyCode;
	    }

	    // add metaKey to non-Mac browsers (use ctrl for PC 's and Meta for Macs)
	    if (event.metaKey === undefined) {
	      event.metaKey = event.ctrlKey;
	    }
	  }
	}, {
	  reg: /^touch/,
	  props: ['touches', 'changedTouches', 'targetTouches']
	}, {
	  reg: /^hashchange$/,
	  props: ['newURL', 'oldURL']
	}, {
	  reg: /^gesturechange$/i,
	  props: ['rotation', 'scale']
	}, {
	  reg: /^(mousewheel|DOMMouseScroll)$/,
	  props: [],
	  fix: function fix(event, nativeEvent) {
	    var deltaX = undefined;
	    var deltaY = undefined;
	    var delta = undefined;
	    var wheelDelta = nativeEvent.wheelDelta;
	    var axis = nativeEvent.axis;
	    var wheelDeltaY = nativeEvent.wheelDeltaY;
	    var wheelDeltaX = nativeEvent.wheelDeltaX;
	    var detail = nativeEvent.detail;

	    // ie/webkit
	    if (wheelDelta) {
	      delta = wheelDelta / 120;
	    }

	    // gecko
	    if (detail) {
	      // press control e.detail == 1 else e.detail == 3
	      delta = 0 - (detail % 3 === 0 ? detail / 3 : detail);
	    }

	    // Gecko
	    if (axis !== undefined) {
	      if (axis === event.HORIZONTAL_AXIS) {
	        deltaY = 0;
	        deltaX = 0 - delta;
	      } else if (axis === event.VERTICAL_AXIS) {
	        deltaX = 0;
	        deltaY = delta;
	      }
	    }

	    // Webkit
	    if (wheelDeltaY !== undefined) {
	      deltaY = wheelDeltaY / 120;
	    }
	    if (wheelDeltaX !== undefined) {
	      deltaX = -1 * wheelDeltaX / 120;
	    }

	    // 默认 deltaY (ie)
	    if (!deltaX && !deltaY) {
	      deltaY = delta;
	    }

	    if (deltaX !== undefined) {
	      /**
	       * deltaX of mousewheel event
	       * @property deltaX
	       * @member Event.DomEvent.Object
	       */
	      event.deltaX = deltaX;
	    }

	    if (deltaY !== undefined) {
	      /**
	       * deltaY of mousewheel event
	       * @property deltaY
	       * @member Event.DomEvent.Object
	       */
	      event.deltaY = deltaY;
	    }

	    if (delta !== undefined) {
	      /**
	       * delta of mousewheel event
	       * @property delta
	       * @member Event.DomEvent.Object
	       */
	      event.delta = delta;
	    }
	  }
	}, {
	  reg: /^mouse|contextmenu|click|mspointer|(^DOMMouseScroll$)/i,
	  props: ['buttons', 'clientX', 'clientY', 'button', 'offsetX', 'relatedTarget', 'which', 'fromElement', 'toElement', 'offsetY', 'pageX', 'pageY', 'screenX', 'screenY'],
	  fix: function fix(event, nativeEvent) {
	    var eventDoc = undefined;
	    var doc = undefined;
	    var body = undefined;
	    var target = event.target;
	    var button = nativeEvent.button;

	    // Calculate pageX/Y if missing and clientX/Y available
	    if (target && isNullOrUndefined(event.pageX) && !isNullOrUndefined(nativeEvent.clientX)) {
	      eventDoc = target.ownerDocument || document;
	      doc = eventDoc.documentElement;
	      body = eventDoc.body;
	      event.pageX = nativeEvent.clientX + (doc && doc.scrollLeft || body && body.scrollLeft || 0) - (doc && doc.clientLeft || body && body.clientLeft || 0);
	      event.pageY = nativeEvent.clientY + (doc && doc.scrollTop || body && body.scrollTop || 0) - (doc && doc.clientTop || body && body.clientTop || 0);
	    }

	    // which for click: 1 === left; 2 === middle; 3 === right
	    // do not use button
	    if (!event.which && button !== undefined) {
	      if (button & 1) {
	        event.which = 1;
	      } else if (button & 2) {
	        event.which = 3;
	      } else if (button & 4) {
	        event.which = 2;
	      } else {
	        event.which = 0;
	      }
	    }

	    // add relatedTarget, if necessary
	    if (!event.relatedTarget && event.fromElement) {
	      event.relatedTarget = event.fromElement === target ? event.toElement : event.fromElement;
	    }

	    return event;
	  }
	}];

	function retTrue() {
	  return TRUE;
	}

	function retFalse() {
	  return FALSE;
	}

	function DomEventObject(nativeEvent) {
	  var type = nativeEvent.type;

	  var isNative = typeof nativeEvent.stopPropagation === 'function' || typeof nativeEvent.cancelBubble === 'boolean';

	  _EventBaseObject2['default'].call(this);

	  this.nativeEvent = nativeEvent;

	  // in case dom event has been mark as default prevented by lower dom node
	  var isDefaultPrevented = retFalse;
	  if ('defaultPrevented' in nativeEvent) {
	    isDefaultPrevented = nativeEvent.defaultPrevented ? retTrue : retFalse;
	  } else if ('getPreventDefault' in nativeEvent) {
	    // https://bugzilla.mozilla.org/show_bug.cgi?id=691151
	    isDefaultPrevented = nativeEvent.getPreventDefault() ? retTrue : retFalse;
	  } else if ('returnValue' in nativeEvent) {
	    isDefaultPrevented = nativeEvent.returnValue === FALSE ? retTrue : retFalse;
	  }

	  this.isDefaultPrevented = isDefaultPrevented;

	  var fixFns = [];
	  var fixFn = undefined;
	  var l = undefined;
	  var prop = undefined;
	  var props = commonProps.concat();

	  eventNormalizers.forEach(function (normalizer) {
	    if (type.match(normalizer.reg)) {
	      props = props.concat(normalizer.props);
	      if (normalizer.fix) {
	        fixFns.push(normalizer.fix);
	      }
	    }
	  });

	  l = props.length;

	  // clone properties of the original event object
	  while (l) {
	    prop = props[--l];
	    this[prop] = nativeEvent[prop];
	  }

	  // fix target property, if necessary
	  if (!this.target && isNative) {
	    this.target = nativeEvent.srcElement || document; // srcElement might not be defined either
	  }

	  // check if target is a text node (safari)
	  if (this.target && this.target.nodeType === 3) {
	    this.target = this.target.parentNode;
	  }

	  l = fixFns.length;

	  while (l) {
	    fixFn = fixFns[--l];
	    fixFn(this, nativeEvent);
	  }

	  this.timeStamp = nativeEvent.timeStamp || Date.now();
	}

	var EventBaseObjectProto = _EventBaseObject2['default'].prototype;

	(0, _objectAssign2['default'])(DomEventObject.prototype, EventBaseObjectProto, {
	  constructor: DomEventObject,

	  preventDefault: function preventDefault() {
	    var e = this.nativeEvent;

	    // if preventDefault exists run it on the original event
	    if (e.preventDefault) {
	      e.preventDefault();
	    } else {
	      // otherwise set the returnValue property of the original event to FALSE (IE)
	      e.returnValue = FALSE;
	    }

	    EventBaseObjectProto.preventDefault.call(this);
	  },

	  stopPropagation: function stopPropagation() {
	    var e = this.nativeEvent;

	    // if stopPropagation exists run it on the original event
	    if (e.stopPropagation) {
	      e.stopPropagation();
	    } else {
	      // otherwise set the cancelBubble property of the original event to TRUE (IE)
	      e.cancelBubble = TRUE;
	    }

	    EventBaseObjectProto.stopPropagation.call(this);
	  }
	});

	exports['default'] = DomEventObject;
	module.exports = exports['default'];

/***/ },
/* 552 */
/***/ function(module, exports, __webpack_require__, __webpack_module_template_argument_0__) {

	'use strict';

	module.exports = __webpack_require__(__webpack_module_template_argument_0__);

/***/ },
/* 553 */
/***/ function(module, exports, __webpack_require__, __webpack_module_template_argument_0__) {

	'use strict';

	var util = __webpack_require__(__webpack_module_template_argument_0__);

	function scrollIntoView(elem, container, config) {
	  config = config || {};
	  // document 归一化到 window
	  if (container.nodeType === 9) {
	    container = util.getWindow(container);
	  }

	  var allowHorizontalScroll = config.allowHorizontalScroll;
	  var onlyScrollIfNeeded = config.onlyScrollIfNeeded;
	  var alignWithTop = config.alignWithTop;
	  var alignWithLeft = config.alignWithLeft;
	  var offsetTop = config.offsetTop || 0;
	  var offsetLeft = config.offsetLeft || 0;
	  var offsetBottom = config.offsetBottom || 0;
	  var offsetRight = config.offsetRight || 0;

	  allowHorizontalScroll = allowHorizontalScroll === undefined ? true : allowHorizontalScroll;

	  var isWin = util.isWindow(container);
	  var elemOffset = util.offset(elem);
	  var eh = util.outerHeight(elem);
	  var ew = util.outerWidth(elem);
	  var containerOffset = undefined;
	  var ch = undefined;
	  var cw = undefined;
	  var containerScroll = undefined;
	  var diffTop = undefined;
	  var diffBottom = undefined;
	  var win = undefined;
	  var winScroll = undefined;
	  var ww = undefined;
	  var wh = undefined;

	  if (isWin) {
	    win = container;
	    wh = util.height(win);
	    ww = util.width(win);
	    winScroll = {
	      left: util.scrollLeft(win),
	      top: util.scrollTop(win)
	    };
	    // elem 相对 container 可视视窗的距离
	    diffTop = {
	      left: elemOffset.left - winScroll.left - offsetLeft,
	      top: elemOffset.top - winScroll.top - offsetTop
	    };
	    diffBottom = {
	      left: elemOffset.left + ew - (winScroll.left + ww) + offsetRight,
	      top: elemOffset.top + eh - (winScroll.top + wh) + offsetBottom
	    };
	    containerScroll = winScroll;
	  } else {
	    containerOffset = util.offset(container);
	    ch = container.clientHeight;
	    cw = container.clientWidth;
	    containerScroll = {
	      left: container.scrollLeft,
	      top: container.scrollTop
	    };
	    // elem 相对 container 可视视窗的距离
	    // 注意边框, offset 是边框到根节点
	    diffTop = {
	      left: elemOffset.left - (containerOffset.left + (parseFloat(util.css(container, 'borderLeftWidth')) || 0)) - offsetLeft,
	      top: elemOffset.top - (containerOffset.top + (parseFloat(util.css(container, 'borderTopWidth')) || 0)) - offsetTop
	    };
	    diffBottom = {
	      left: elemOffset.left + ew - (containerOffset.left + cw + (parseFloat(util.css(container, 'borderRightWidth')) || 0)) + offsetRight,
	      top: elemOffset.top + eh - (containerOffset.top + ch + (parseFloat(util.css(container, 'borderBottomWidth')) || 0)) + offsetBottom
	    };
	  }

	  if (diffTop.top < 0 || diffBottom.top > 0) {
	    // 强制向上
	    if (alignWithTop === true) {
	      util.scrollTop(container, containerScroll.top + diffTop.top);
	    } else if (alignWithTop === false) {
	      util.scrollTop(container, containerScroll.top + diffBottom.top);
	    } else {
	      // 自动调整
	      if (diffTop.top < 0) {
	        util.scrollTop(container, containerScroll.top + diffTop.top);
	      } else {
	        util.scrollTop(container, containerScroll.top + diffBottom.top);
	      }
	    }
	  } else {
	    if (!onlyScrollIfNeeded) {
	      alignWithTop = alignWithTop === undefined ? true : !!alignWithTop;
	      if (alignWithTop) {
	        util.scrollTop(container, containerScroll.top + diffTop.top);
	      } else {
	        util.scrollTop(container, containerScroll.top + diffBottom.top);
	      }
	    }
	  }

	  if (allowHorizontalScroll) {
	    if (diffTop.left < 0 || diffBottom.left > 0) {
	      // 强制向上
	      if (alignWithLeft === true) {
	        util.scrollLeft(container, containerScroll.left + diffTop.left);
	      } else if (alignWithLeft === false) {
	        util.scrollLeft(container, containerScroll.left + diffBottom.left);
	      } else {
	        // 自动调整
	        if (diffTop.left < 0) {
	          util.scrollLeft(container, containerScroll.left + diffTop.left);
	        } else {
	          util.scrollLeft(container, containerScroll.left + diffBottom.left);
	        }
	      }
	    } else {
	      if (!onlyScrollIfNeeded) {
	        alignWithLeft = alignWithLeft === undefined ? true : !!alignWithLeft;
	        if (alignWithLeft) {
	          util.scrollLeft(container, containerScroll.left + diffTop.left);
	        } else {
	          util.scrollLeft(container, containerScroll.left + diffBottom.left);
	        }
	      }
	    }
	  }
	}

	module.exports = scrollIntoView;

/***/ },
/* 554 */
/***/ function(module, exports, __webpack_require__, __webpack_module_template_argument_0__) {

	// export this package's api
	'use strict';

	module.exports = __webpack_require__(__webpack_module_template_argument_0__);

/***/ },
/* 555 */
/***/ function(module, exports, __webpack_require__, __webpack_module_template_argument_0__, __webpack_module_template_argument_1__, __webpack_module_template_argument_2__) {

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	  value: true
	});

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

	var _react = __webpack_require__(7);

	var _react2 = _interopRequireDefault(_react);

	var _ChildrenUtils = __webpack_require__(__webpack_module_template_argument_0__);

	var _AnimateChild = __webpack_require__(__webpack_module_template_argument_1__);

	var _AnimateChild2 = _interopRequireDefault(_AnimateChild);

	var _util = __webpack_require__(__webpack_module_template_argument_2__);

	var _util2 = _interopRequireDefault(_util);

	var defaultKey = 'rc_animate_' + Date.now();

	function getChildrenFromProps(props) {
	  var children = props.children;
	  if (_react2['default'].isValidElement(children)) {
	    if (!children.key) {
	      return _react2['default'].cloneElement(children, {
	        key: defaultKey
	      });
	    }
	  }
	  return children;
	}

	function noop() {}

	var Animate = _react2['default'].createClass({
	  displayName: 'Animate',

	  propTypes: {
	    component: _react2['default'].PropTypes.any,
	    animation: _react2['default'].PropTypes.object,
	    transitionName: _react2['default'].PropTypes.string,
	    transitionEnter: _react2['default'].PropTypes.bool,
	    transitionAppear: _react2['default'].PropTypes.bool,
	    exclusive: _react2['default'].PropTypes.bool,
	    transitionLeave: _react2['default'].PropTypes.bool,
	    onEnd: _react2['default'].PropTypes.func,
	    onEnter: _react2['default'].PropTypes.func,
	    onLeave: _react2['default'].PropTypes.func,
	    onAppear: _react2['default'].PropTypes.func,
	    showProp: _react2['default'].PropTypes.string
	  },

	  getDefaultProps: function getDefaultProps() {
	    return {
	      animation: {},
	      component: 'span',
	      transitionEnter: true,
	      transitionLeave: true,
	      transitionAppear: false,
	      onEnd: noop,
	      onEnter: noop,
	      onLeave: noop,
	      onAppear: noop
	    };
	  },

	  getInitialState: function getInitialState() {
	    this.currentlyAnimatingKeys = {};
	    this.keysToEnter = [];
	    this.keysToLeave = [];
	    return {
	      children: (0, _ChildrenUtils.toArrayChildren)(getChildrenFromProps(this.props))
	    };
	  },

	  componentDidMount: function componentDidMount() {
	    var _this = this;

	    var showProp = this.props.showProp;
	    var children = this.state.children;
	    if (showProp) {
	      children = children.filter(function (child) {
	        return !!child.props[showProp];
	      });
	    }
	    children.forEach(function (child) {
	      _this.performAppear(child.key);
	    });
	  },

	  componentWillReceiveProps: function componentWillReceiveProps(nextProps) {
	    var _this2 = this;

	    this.nextProps = nextProps;
	    var nextChildren = (0, _ChildrenUtils.toArrayChildren)(getChildrenFromProps(nextProps));
	    var props = this.props;
	    // exclusive needs immediate response
	    if (props.exclusive) {
	      Object.keys(this.currentlyAnimatingKeys).forEach(function (key) {
	        _this2.stop(key);
	      });
	    }
	    var showProp = props.showProp;
	    var currentlyAnimatingKeys = this.currentlyAnimatingKeys;
	    // last props children if exclusive
	    var currentChildren = props.exclusive ? (0, _ChildrenUtils.toArrayChildren)(getChildrenFromProps(props)) : this.state.children;
	    // in case destroy in showProp mode
	    var newChildren = [];
	    if (showProp) {
	      currentChildren.forEach(function (currentChild) {
	        var nextChild = (0, _ChildrenUtils.findChildInChildrenByKey)(nextChildren, currentChild.key);
	        var newChild = undefined;
	        if ((!nextChild || !nextChild.props[showProp]) && currentChild.props[showProp]) {
	          newChild = _react2['default'].cloneElement(nextChild || currentChild, _defineProperty({}, showProp, true));
	        } else {
	          newChild = nextChild;
	        }
	        if (newChild) {
	          newChildren.push(newChild);
	        }
	      });
	      nextChildren.forEach(function (nextChild) {
	        if (!(0, _ChildrenUtils.findChildInChildrenByKey)(currentChildren, nextChild.key)) {
	          newChildren.push(nextChild);
	        }
	      });
	    } else {
	      newChildren = (0, _ChildrenUtils.mergeChildren)(currentChildren, nextChildren);
	    }

	    // need render to avoid update
	    this.setState({
	      children: newChildren
	    });

	    nextChildren.forEach(function (child) {
	      var key = child.key;
	      if (currentlyAnimatingKeys[key]) {
	        return;
	      }
	      var hasPrev = (0, _ChildrenUtils.findChildInChildrenByKey)(currentChildren, key);
	      if (showProp) {
	        var showInNext = child.props[showProp];
	        if (hasPrev) {
	          var showInNow = (0, _ChildrenUtils.findShownChildInChildrenByKey)(currentChildren, key, showProp);
	          if (!showInNow && showInNext) {
	            _this2.keysToEnter.push(key);
	          }
	        } else if (showInNext) {
	          _this2.keysToEnter.push(key);
	        }
	      } else if (!hasPrev) {
	        _this2.keysToEnter.push(key);
	      }
	    });

	    currentChildren.forEach(function (child) {
	      var key = child.key;
	      if (currentlyAnimatingKeys[key]) {
	        return;
	      }
	      var hasNext = (0, _ChildrenUtils.findChildInChildrenByKey)(nextChildren, key);
	      if (showProp) {
	        var showInNow = child.props[showProp];
	        if (hasNext) {
	          var showInNext = (0, _ChildrenUtils.findShownChildInChildrenByKey)(nextChildren, key, showProp);
	          if (!showInNext && showInNow) {
	            _this2.keysToLeave.push(key);
	          }
	        } else if (showInNow) {
	          _this2.keysToLeave.push(key);
	        }
	      } else if (!hasNext) {
	        _this2.keysToLeave.push(key);
	      }
	    });
	  },

	  componentDidUpdate: function componentDidUpdate() {
	    if (this.isMounted()) {
	      var keysToEnter = this.keysToEnter;
	      this.keysToEnter = [];
	      keysToEnter.forEach(this.performEnter);
	      var keysToLeave = this.keysToLeave;
	      this.keysToLeave = [];
	      keysToLeave.forEach(this.performLeave);
	    }
	  },

	  performEnter: function performEnter(key) {
	    // may already remove by exclusive
	    if (this.refs[key]) {
	      this.currentlyAnimatingKeys[key] = true;
	      this.refs[key].componentWillEnter(this.handleDoneAdding.bind(this, key, 'enter'));
	    }
	  },

	  performAppear: function performAppear(key) {
	    if (this.refs[key]) {
	      this.currentlyAnimatingKeys[key] = true;
	      this.refs[key].componentWillAppear(this.handleDoneAdding.bind(this, key, 'appear'));
	    }
	  },

	  handleDoneAdding: function handleDoneAdding(key, type) {
	    var props = this.props;
	    delete this.currentlyAnimatingKeys[key];
	    // if update on exclusive mode, skip check
	    if (props.exclusive && props !== this.nextProps) {
	      return;
	    }
	    var currentChildren = (0, _ChildrenUtils.toArrayChildren)(getChildrenFromProps(props));
	    if (!this.isValidChildByKey(currentChildren, key)) {
	      // exclusive will not need this
	      this.performLeave(key);
	    } else {
	      if (type === 'appear') {
	        if (_util2['default'].allowAppearCallback(props)) {
	          props.onAppear(key);
	          props.onEnd(key, true);
	        }
	      } else {
	        if (_util2['default'].allowEnterCallback(props)) {
	          props.onEnter(key);
	          props.onEnd(key, true);
	        }
	      }
	    }
	  },

	  performLeave: function performLeave(key) {
	    // may already remove by exclusive
	    if (this.refs[key]) {
	      this.currentlyAnimatingKeys[key] = true;
	      this.refs[key].componentWillLeave(this.handleDoneLeaving.bind(this, key));
	    }
	  },

	  handleDoneLeaving: function handleDoneLeaving(key) {
	    var props = this.props;
	    delete this.currentlyAnimatingKeys[key];
	    // if update on exclusive mode, skip check
	    if (props.exclusive && props !== this.nextProps) {
	      return;
	    }
	    var currentChildren = (0, _ChildrenUtils.toArrayChildren)(getChildrenFromProps(props));
	    // in case state change is too fast
	    if (this.isValidChildByKey(currentChildren, key)) {
	      this.performEnter(key);
	    } else {
	      if (this.isMounted() && !(0, _ChildrenUtils.isSameChildren)(this.state.children, currentChildren, props.showProp)) {
	        this.setState({
	          children: currentChildren
	        });
	      }
	      if (_util2['default'].allowLeaveCallback(props)) {
	        props.onLeave(key);
	        props.onEnd(key, false);
	      }
	    }
	  },

	  isValidChildByKey: function isValidChildByKey(currentChildren, key) {
	    var showProp = this.props.showProp;
	    if (showProp) {
	      return (0, _ChildrenUtils.findShownChildInChildrenByKey)(currentChildren, key, showProp);
	    }
	    return (0, _ChildrenUtils.findChildInChildrenByKey)(currentChildren, key);
	  },

	  stop: function stop(key) {
	    delete this.currentlyAnimatingKeys[key];
	    var component = this.refs[key];
	    if (component) {
	      component.stop();
	    }
	  },

	  render: function render() {
	    var props = this.props;
	    this.nextProps = props;
	    var stateChildren = this.state.children;
	    var children = null;
	    if (stateChildren) {
	      children = stateChildren.map(function (child) {
	        if (child === null) {
	          return child;
	        }
	        if (!child.key) {
	          throw new Error('must set key for <rc-animate> children');
	        }
	        return _react2['default'].createElement(
	          _AnimateChild2['default'],
	          {
	            key: child.key,
	            ref: child.key,
	            animation: props.animation,
	            transitionName: props.transitionName,
	            transitionEnter: props.transitionEnter,
	            transitionAppear: props.transitionAppear,
	            transitionLeave: props.transitionLeave },
	          child
	        );
	      });
	    }
	    var Component = props.component;
	    if (Component) {
	      return _react2['default'].createElement(
	        Component,
	        this.props,
	        children
	      );
	    }
	    return children[0] || null;
	  }
	});

	exports['default'] = Animate;
	module.exports = exports['default'];

/***/ },
/* 556 */
/***/ function(module, exports, __webpack_require__, __webpack_module_template_argument_0__, __webpack_module_template_argument_1__) {

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	  value: true
	});

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var _react = __webpack_require__(7);

	var _react2 = _interopRequireDefault(_react);

	var _reactDom = __webpack_require__(8);

	var _reactDom2 = _interopRequireDefault(_reactDom);

	var _cssAnimation = __webpack_require__(__webpack_module_template_argument_0__);

	var _cssAnimation2 = _interopRequireDefault(_cssAnimation);

	var _util = __webpack_require__(__webpack_module_template_argument_1__);

	var _util2 = _interopRequireDefault(_util);

	var transitionMap = {
	  enter: 'transitionEnter',
	  appear: 'transitionAppear',
	  leave: 'transitionLeave'
	};

	var AnimateChild = _react2['default'].createClass({
	  displayName: 'AnimateChild',

	  propTypes: {
	    children: _react2['default'].PropTypes.any
	  },

	  componentWillUnmount: function componentWillUnmount() {
	    this.stop();
	  },

	  componentWillEnter: function componentWillEnter(done) {
	    if (_util2['default'].isEnterSupported(this.props)) {
	      this.transition('enter', done);
	    } else {
	      done();
	    }
	  },

	  componentWillAppear: function componentWillAppear(done) {
	    if (_util2['default'].isAppearSupported(this.props)) {
	      this.transition('appear', done);
	    } else {
	      done();
	    }
	  },

	  componentWillLeave: function componentWillLeave(done) {
	    if (_util2['default'].isLeaveSupported(this.props)) {
	      this.transition('leave', done);
	    } else {
	      done();
	    }
	  },

	  transition: function transition(animationType, finishCallback) {
	    var _this = this;

	    var node = _reactDom2['default'].findDOMNode(this);
	    var props = this.props;
	    var transitionName = props.transitionName;
	    this.stop();
	    var end = function end() {
	      _this.stopper = null;
	      finishCallback();
	    };
	    if ((_cssAnimation.isCssAnimationSupported || !props.animation[animationType]) && transitionName && props[transitionMap[animationType]]) {
	      this.stopper = (0, _cssAnimation2['default'])(node, transitionName + '-' + animationType, end);
	    } else {
	      this.stopper = props.animation[animationType](node, end);
	    }
	  },

	  stop: function stop() {
	    var stopper = this.stopper;
	    if (stopper) {
	      this.stopper = null;
	      stopper.stop();
	    }
	  },

	  render: function render() {
	    return this.props.children;
	  }
	});

	exports['default'] = AnimateChild;
	module.exports = exports['default'];

/***/ },
/* 557 */
/***/ function(module, exports, __webpack_require__, __webpack_module_template_argument_0__, __webpack_module_template_argument_1__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _Event = __webpack_require__(__webpack_module_template_argument_0__);

	var _Event2 = _interopRequireDefault(_Event);

	var _componentClasses = __webpack_require__(__webpack_module_template_argument_1__);

	var _componentClasses2 = _interopRequireDefault(_componentClasses);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

	var isCssAnimationSupported = _Event2["default"].endEvents.length !== 0;


	var capitalPrefixes = ['Webkit', 'Moz', 'O',
	// ms is special .... !
	'ms'];
	var prefixes = ['-webkit-', '-moz-', '-o-', 'ms-', ''];

	function getDuration(node, name) {
	  var style = window.getComputedStyle(node);

	  var ret = '';
	  for (var i = 0; i < prefixes.length; i++) {
	    ret = style.getPropertyValue(prefixes[i] + name);
	    if (ret) {
	      break;
	    }
	  }
	  return ret;
	}

	function fixBrowserByTimeout(node) {
	  if (isCssAnimationSupported) {
	    var transitionDuration = parseFloat(getDuration(node, 'transition-duration')) || 0;
	    var animationDuration = parseFloat(getDuration(node, 'animation-duration')) || 0;
	    var time = Math.max(transitionDuration, animationDuration);
	    // sometimes, browser bug
	    node.rcEndAnimTimeout = setTimeout(function () {
	      node.rcEndAnimTimeout = null;
	      if (node.rcEndListener) {
	        node.rcEndListener();
	      }
	    }, time * 1000 + 200);
	  }
	}

	function clearBrowserBugTimeout(node) {
	  if (node.rcEndAnimTimeout) {
	    clearTimeout(node.rcEndAnimTimeout);
	    node.rcEndAnimTimeout = null;
	  }
	}

	var cssAnimation = function cssAnimation(node, transitionName, endCallback) {
	  var className = transitionName;
	  var activeClassName = className + '-active';
	  var end = endCallback;
	  var start = void 0;
	  var active = void 0;
	  var nodeClasses = (0, _componentClasses2["default"])(node);

	  if (endCallback && Object.prototype.toString.call(endCallback) === '[object Object]') {
	    end = endCallback.end;
	    start = endCallback.start;
	    active = endCallback.active;
	  }

	  if (node.rcEndListener) {
	    node.rcEndListener();
	  }

	  node.rcEndListener = function (e) {
	    if (e && e.target !== node) {
	      return;
	    }

	    if (node.rcAnimTimeout) {
	      clearTimeout(node.rcAnimTimeout);
	      node.rcAnimTimeout = null;
	    }

	    clearBrowserBugTimeout(node);

	    nodeClasses.remove(className);
	    nodeClasses.remove(activeClassName);

	    _Event2["default"].removeEndEventListener(node, node.rcEndListener);
	    node.rcEndListener = null;

	    // Usually this optional end is used for informing an owner of
	    // a leave animation and telling it to remove the child.
	    if (end) {
	      end();
	    }
	  };

	  _Event2["default"].addEndEventListener(node, node.rcEndListener);

	  if (start) {
	    start();
	  }
	  nodeClasses.add(className);

	  node.rcAnimTimeout = setTimeout(function () {
	    node.rcAnimTimeout = null;
	    nodeClasses.add(activeClassName);
	    if (active) {
	      setTimeout(active, 0);
	    }
	    fixBrowserByTimeout(node);
	    // 30ms for firefox
	  }, 30);

	  return {
	    stop: function stop() {
	      if (node.rcEndListener) {
	        node.rcEndListener();
	      }
	    }
	  };
	};

	cssAnimation.style = function (node, style, callback) {
	  if (node.rcEndListener) {
	    node.rcEndListener();
	  }

	  node.rcEndListener = function (e) {
	    if (e && e.target !== node) {
	      return;
	    }

	    if (node.rcAnimTimeout) {
	      clearTimeout(node.rcAnimTimeout);
	      node.rcAnimTimeout = null;
	    }

	    clearBrowserBugTimeout(node);

	    _Event2["default"].removeEndEventListener(node, node.rcEndListener);
	    node.rcEndListener = null;

	    // Usually this optional callback is used for informing an owner of
	    // a leave animation and telling it to remove the child.
	    if (callback) {
	      callback();
	    }
	  };

	  _Event2["default"].addEndEventListener(node, node.rcEndListener);

	  node.rcAnimTimeout = setTimeout(function () {
	    for (var s in style) {
	      if (style.hasOwnProperty(s)) {
	        node.style[s] = style[s];
	      }
	    }
	    node.rcAnimTimeout = null;
	    fixBrowserByTimeout(node);
	  }, 0);
	};

	cssAnimation.setTransition = function (node, p, value) {
	  var property = p;
	  var v = value;
	  if (value === undefined) {
	    v = property;
	    property = '';
	  }
	  property = property || '';
	  capitalPrefixes.forEach(function (prefix) {
	    node.style[prefix + 'Transition' + property] = v;
	  });
	};

	cssAnimation.isCssAnimationSupported = isCssAnimationSupported;

	exports["default"] = cssAnimation;
	module.exports = exports['default'];

/***/ },
/* 558 */
/***/ function(module, exports, __webpack_require__, __webpack_module_template_argument_0__, __webpack_module_template_argument_1__) {

	/**
	 * Module dependencies.
	 */

	try {
	  var index = __webpack_require__(__webpack_module_template_argument_0__);
	} catch (err) {
	  var index = __webpack_require__(__webpack_module_template_argument_1__);
	}

	/**
	 * Whitespace regexp.
	 */

	var re = /\s+/;

	/**
	 * toString reference.
	 */

	var toString = Object.prototype.toString;

	/**
	 * Wrap `el` in a `ClassList`.
	 *
	 * @param {Element} el
	 * @return {ClassList}
	 * @api public
	 */

	module.exports = function(el){
	  return new ClassList(el);
	};

	/**
	 * Initialize a new ClassList for `el`.
	 *
	 * @param {Element} el
	 * @api private
	 */

	function ClassList(el) {
	  if (!el || !el.nodeType) {
	    throw new Error('A DOM element reference is required');
	  }
	  this.el = el;
	  this.list = el.classList;
	}

	/**
	 * Add class `name` if not already present.
	 *
	 * @param {String} name
	 * @return {ClassList}
	 * @api public
	 */

	ClassList.prototype.add = function(name){
	  // classList
	  if (this.list) {
	    this.list.add(name);
	    return this;
	  }

	  // fallback
	  var arr = this.array();
	  var i = index(arr, name);
	  if (!~i) arr.push(name);
	  this.el.className = arr.join(' ');
	  return this;
	};

	/**
	 * Remove class `name` when present, or
	 * pass a regular expression to remove
	 * any which match.
	 *
	 * @param {String|RegExp} name
	 * @return {ClassList}
	 * @api public
	 */

	ClassList.prototype.remove = function(name){
	  if ('[object RegExp]' == toString.call(name)) {
	    return this.removeMatching(name);
	  }

	  // classList
	  if (this.list) {
	    this.list.remove(name);
	    return this;
	  }

	  // fallback
	  var arr = this.array();
	  var i = index(arr, name);
	  if (~i) arr.splice(i, 1);
	  this.el.className = arr.join(' ');
	  return this;
	};

	/**
	 * Remove all classes matching `re`.
	 *
	 * @param {RegExp} re
	 * @return {ClassList}
	 * @api private
	 */

	ClassList.prototype.removeMatching = function(re){
	  var arr = this.array();
	  for (var i = 0; i < arr.length; i++) {
	    if (re.test(arr[i])) {
	      this.remove(arr[i]);
	    }
	  }
	  return this;
	};

	/**
	 * Toggle class `name`, can force state via `force`.
	 *
	 * For browsers that support classList, but do not support `force` yet,
	 * the mistake will be detected and corrected.
	 *
	 * @param {String} name
	 * @param {Boolean} force
	 * @return {ClassList}
	 * @api public
	 */

	ClassList.prototype.toggle = function(name, force){
	  // classList
	  if (this.list) {
	    if ("undefined" !== typeof force) {
	      if (force !== this.list.toggle(name, force)) {
	        this.list.toggle(name); // toggle again to correct
	      }
	    } else {
	      this.list.toggle(name);
	    }
	    return this;
	  }

	  // fallback
	  if ("undefined" !== typeof force) {
	    if (!force) {
	      this.remove(name);
	    } else {
	      this.add(name);
	    }
	  } else {
	    if (this.has(name)) {
	      this.remove(name);
	    } else {
	      this.add(name);
	    }
	  }

	  return this;
	};

	/**
	 * Return an array of classes.
	 *
	 * @return {Array}
	 * @api public
	 */

	ClassList.prototype.array = function(){
	  var className = this.el.getAttribute('class') || '';
	  var str = className.replace(/^\s+|\s+$/g, '');
	  var arr = str.split(re);
	  if ('' === arr[0]) arr.shift();
	  return arr;
	};

	/**
	 * Check if class `name` is present.
	 *
	 * @param {String} name
	 * @return {ClassList}
	 * @api public
	 */

	ClassList.prototype.has =
	ClassList.prototype.contains = function(name){
	  return this.list
	    ? this.list.contains(name)
	    : !! ~index(this.array(), name);
	};


/***/ },
/* 559 */
/***/ function(module, exports, __webpack_require__, __webpack_module_template_argument_0__) {

	'use strict';

	module.exports = __webpack_require__(__webpack_module_template_argument_0__);

/***/ },
/* 560 */
/***/ function(module, exports, __webpack_require__, __webpack_module_template_argument_0__, __webpack_module_template_argument_1__, __webpack_module_template_argument_2__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	var _react = __webpack_require__(7);

	var _react2 = _interopRequireDefault(_react);

	var _reactDom = __webpack_require__(8);

	var _reactDom2 = _interopRequireDefault(_reactDom);

	var _rcUtil = __webpack_require__(__webpack_module_template_argument_0__);

	var _Popup = __webpack_require__(__webpack_module_template_argument_1__);

	var _Popup2 = _interopRequireDefault(_Popup);

	var _utils = __webpack_require__(__webpack_module_template_argument_2__);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

	function noop() {}

	function returnEmptyString() {
	  return '';
	}

	var ALL_HANDLERS = ['onClick', 'onMouseDown', 'onTouchStart', 'onMouseEnter', 'onMouseLeave', 'onFocus', 'onBlur'];

	var Trigger = _react2["default"].createClass({
	  displayName: 'Trigger',

	  propTypes: {
	    action: _react.PropTypes.any,
	    showAction: _react.PropTypes.any,
	    hideAction: _react.PropTypes.any,
	    getPopupClassNameFromAlign: _react.PropTypes.any,
	    onPopupVisibleChange: _react.PropTypes.func,
	    afterPopupVisibleChange: _react.PropTypes.func,
	    popup: _react.PropTypes.node.isRequired,
	    popupStyle: _react.PropTypes.object,
	    prefixCls: _react.PropTypes.string,
	    popupClassName: _react.PropTypes.string,
	    popupPlacement: _react.PropTypes.string,
	    builtinPlacements: _react.PropTypes.object,
	    popupTransitionName: _react.PropTypes.string,
	    popupAnimation: _react.PropTypes.any,
	    mouseEnterDelay: _react.PropTypes.number,
	    mouseLeaveDelay: _react.PropTypes.number,
	    zIndex: _react.PropTypes.number,
	    focusDelay: _react.PropTypes.number,
	    blurDelay: _react.PropTypes.number,
	    getPopupContainer: _react.PropTypes.func,
	    destroyPopupOnHide: _react.PropTypes.bool,
	    mask: _react.PropTypes.bool,
	    onPopupAlign: _react.PropTypes.func,
	    popupAlign: _react.PropTypes.object,
	    popupVisible: _react.PropTypes.bool,
	    maskTransitionName: _react.PropTypes.string,
	    maskAnimation: _react.PropTypes.string
	  },

	  getDefaultProps: function getDefaultProps() {
	    return {
	      prefixCls: 'rc-trigger-popup',
	      getPopupClassNameFromAlign: returnEmptyString,
	      onPopupVisibleChange: noop,
	      afterPopupVisibleChange: noop,
	      onPopupAlign: noop,
	      popupClassName: '',
	      mouseEnterDelay: 0,
	      mouseLeaveDelay: 0.1,
	      focusDelay: 0,
	      blurDelay: 0.15,
	      popupStyle: {},
	      destroyPopupOnHide: false,
	      popupAlign: {},
	      defaultPopupVisible: false,
	      mask: false,
	      action: [],
	      showAction: [],
	      hideAction: []
	    };
	  },
	  getInitialState: function getInitialState() {
	    var props = this.props;
	    var popupVisible = void 0;
	    if ('popupVisible' in props) {
	      popupVisible = !!props.popupVisible;
	    } else {
	      popupVisible = !!props.defaultPopupVisible;
	    }
	    return {
	      popupVisible: popupVisible
	    };
	  },
	  componentDidMount: function componentDidMount() {
	    this.componentDidUpdate({}, {
	      popupVisible: this.state.popupVisible
	    });
	  },
	  componentWillReceiveProps: function componentWillReceiveProps(nextProps) {
	    if ('popupVisible' in nextProps) {
	      this.setState({
	        popupVisible: !!nextProps.popupVisible
	      });
	    }
	  },
	  componentDidUpdate: function componentDidUpdate(prevProps, prevState) {
	    var _this = this;

	    var props = this.props;
	    var state = this.state;
	    if (this.popupRendered) {
	      var _ret = function () {
	        var self = _this;
	        self.popupInstance = _reactDom2["default"].unstable_renderSubtreeIntoContainer(_this, _this.getPopupElement(), _this.getPopupContainer(), function renderPopup() {
	          /* eslint react/no-is-mounted:0 */
	          if (this.isMounted()) {
	            self.popupDomNode = this.getPopupDomNode();
	          } else {
	            self.popupDomNode = null;
	          }
	          if (prevState.popupVisible !== state.popupVisible) {
	            props.afterPopupVisibleChange(state.popupVisible);
	          }
	        });
	        if (_this.isClickToHide()) {
	          if (state.popupVisible) {
	            if (!_this.clickOutsideHandler) {
	              _this.clickOutsideHandler = _rcUtil.Dom.addEventListener(document, 'mousedown', _this.onDocumentClick);
	              _this.touchOutsideHandler = _rcUtil.Dom.addEventListener(document, 'touchstart', _this.onDocumentClick);
	            }
	            return {
	              v: void 0
	            };
	          }
	        }
	        if (_this.clickOutsideHandler) {
	          _this.clickOutsideHandler.remove();
	          _this.touchOutsideHandler.remove();
	          _this.clickOutsideHandler = null;
	          _this.touchOutsideHandler = null;
	        }
	      }();

	      if ((typeof _ret === 'undefined' ? 'undefined' : _typeof(_ret)) === "object") return _ret.v;
	    }
	  },
	  componentWillUnmount: function componentWillUnmount() {
	    var popupContainer = this.popupContainer;
	    if (popupContainer) {
	      _reactDom2["default"].unmountComponentAtNode(popupContainer);
	      popupContainer.parentNode.removeChild(popupContainer);
	      this.popupContainer = null;
	    }
	    this.clearDelayTimer();
	    if (this.clickOutsideHandler) {
	      this.clickOutsideHandler.remove();
	      this.touchOutsideHandler.remove();
	      this.clickOutsideHandler = null;
	      this.touchOutsideHandler = null;
	    }
	  },
	  onMouseEnter: function onMouseEnter() {
	    this.delaySetPopupVisible(true, this.props.mouseEnterDelay);
	  },
	  onMouseLeave: function onMouseLeave(e) {
	    // https://github.com/react-component/trigger/pull/13
	    // react bug?
	    if (e.relatedTarget && !e.relatedTarget.setTimeout && _rcUtil.Dom.contains(this.popupContainer, e.relatedTarget)) {
	      return;
	    }
	    this.delaySetPopupVisible(false, this.props.mouseLeaveDelay);
	  },
	  onFocus: function onFocus() {
	    // incase focusin and focusout
	    this.clearDelayTimer();
	    if (this.isFocusToShow()) {
	      this.focusTime = Date.now();
	      this.delaySetPopupVisible(true, this.props.focusDelay);
	    }
	  },
	  onMouseDown: function onMouseDown() {
	    this.preClickTime = Date.now();
	  },
	  onTouchStart: function onTouchStart() {
	    this.preTouchTime = Date.now();
	  },
	  onBlur: function onBlur() {
	    this.clearDelayTimer();
	    if (this.isBlurToHide()) {
	      this.delaySetPopupVisible(false, this.props.blurDelay);
	    }
	  },
	  onClick: function onClick(event) {
	    // focus will trigger click
	    if (this.focusTime) {
	      var preTime = void 0;
	      if (this.preClickTime && this.preTouchTime) {
	        preTime = Math.min(this.preClickTime, this.preTouchTime);
	      } else if (this.preClickTime) {
	        preTime = this.preClickTime;
	      } else if (this.preTouchTime) {
	        preTime = this.preTouchTime;
	      }
	      if (Math.abs(preTime - this.focusTime) < 20) {
	        return;
	      }
	      this.focusTime = 0;
	    }
	    this.preClickTime = 0;
	    this.preTouchTime = 0;
	    event.preventDefault();
	    var nextVisible = !this.state.popupVisible;
	    if (this.isClickToHide() && !nextVisible || nextVisible && this.isClickToShow()) {
	      this.setPopupVisible(!this.state.popupVisible);
	    }
	  },
	  onDocumentClick: function onDocumentClick(event) {
	    var target = event.target;
	    var root = (0, _reactDom.findDOMNode)(this);
	    var popupNode = this.getPopupDomNode();
	    if (!_rcUtil.Dom.contains(root, target) && !_rcUtil.Dom.contains(popupNode, target)) {
	      this.setPopupVisible(false);
	    }
	  },
	  getPopupDomNode: function getPopupDomNode() {
	    // for test
	    return this.popupDomNode;
	  },
	  getRootDomNode: function getRootDomNode() {
	    return _reactDom2["default"].findDOMNode(this);
	  },
	  getPopupContainer: function getPopupContainer() {
	    if (!this.popupContainer) {
	      this.popupContainer = document.createElement('div');
	      var mountNode = this.props.getPopupContainer ? this.props.getPopupContainer((0, _reactDom.findDOMNode)(this)) : document.body;
	      mountNode.appendChild(this.popupContainer);
	    }
	    return this.popupContainer;
	  },
	  getPopupClassNameFromAlign: function getPopupClassNameFromAlign(align) {
	    var className = [];
	    var props = this.props;
	    var popupPlacement = props.popupPlacement;
	    var builtinPlacements = props.builtinPlacements;
	    var prefixCls = props.prefixCls;

	    if (popupPlacement && builtinPlacements) {
	      className.push((0, _utils.getPopupClassNameFromAlign)(builtinPlacements, prefixCls, align));
	    }
	    if (props.getPopupClassNameFromAlign) {
	      className.push(props.getPopupClassNameFromAlign(align));
	    }
	    return className.join(' ');
	  },
	  getPopupAlign: function getPopupAlign() {
	    var props = this.props;
	    var popupPlacement = props.popupPlacement;
	    var popupAlign = props.popupAlign;
	    var builtinPlacements = props.builtinPlacements;

	    if (popupPlacement && builtinPlacements) {
	      return (0, _utils.getAlignFromPlacement)(builtinPlacements, popupPlacement, popupAlign);
	    }
	    return popupAlign;
	  },
	  getPopupElement: function getPopupElement() {
	    var props = this.props;
	    var state = this.state;

	    var mouseProps = {};
	    if (this.isMouseEnterToShow()) {
	      mouseProps.onMouseEnter = this.onMouseEnter;
	    }
	    if (this.isMouseLeaveToHide()) {
	      mouseProps.onMouseLeave = this.onMouseLeave;
	    }
	    return _react2["default"].createElement(
	      _Popup2["default"],
	      _extends({
	        prefixCls: props.prefixCls,
	        destroyPopupOnHide: props.destroyPopupOnHide,
	        visible: state.popupVisible,
	        className: props.popupClassName,
	        action: props.action,
	        align: this.getPopupAlign(),
	        onAlign: props.onPopupAlign,
	        animation: props.popupAnimation,
	        getClassNameFromAlign: this.getPopupClassNameFromAlign
	      }, mouseProps, {
	        getRootDomNode: this.getRootDomNode,
	        style: props.popupStyle,
	        mask: props.mask,
	        zIndex: props.zIndex,
	        transitionName: props.popupTransitionName,
	        maskAnimation: props.maskAnimation,
	        maskTransitionName: props.maskTransitionName
	      }),
	      props.popup
	    );
	  },
	  setPopupVisible: function setPopupVisible(popupVisible) {
	    this.clearDelayTimer();
	    if (this.state.popupVisible !== popupVisible) {
	      if (!('popupVisible' in this.props)) {
	        this.setState({
	          popupVisible: popupVisible
	        });
	      }
	      this.props.onPopupVisibleChange(popupVisible);
	    }
	  },
	  delaySetPopupVisible: function delaySetPopupVisible(visible, delayS) {
	    var _this2 = this;

	    var delay = delayS * 1000;
	    this.clearDelayTimer();
	    if (delay) {
	      this.delayTimer = setTimeout(function () {
	        _this2.setPopupVisible(visible);
	        _this2.clearDelayTimer();
	      }, delay);
	    } else {
	      this.setPopupVisible(visible);
	    }
	  },
	  clearDelayTimer: function clearDelayTimer() {
	    if (this.delayTimer) {
	      clearTimeout(this.delayTimer);
	      this.delayTimer = null;
	    }
	  },
	  isClickToShow: function isClickToShow() {
	    var _props = this.props;
	    var action = _props.action;
	    var showAction = _props.showAction;

	    return action.indexOf('click') !== -1 || showAction.indexOf('click') !== -1;
	  },
	  isClickToHide: function isClickToHide() {
	    var _props2 = this.props;
	    var action = _props2.action;
	    var hideAction = _props2.hideAction;

	    return action.indexOf('click') !== -1 || hideAction.indexOf('click') !== -1;
	  },
	  isMouseEnterToShow: function isMouseEnterToShow() {
	    var _props3 = this.props;
	    var action = _props3.action;
	    var showAction = _props3.showAction;

	    return action.indexOf('hover') !== -1 || showAction.indexOf('mouseEnter') !== -1;
	  },
	  isMouseLeaveToHide: function isMouseLeaveToHide() {
	    var _props4 = this.props;
	    var action = _props4.action;
	    var hideAction = _props4.hideAction;

	    return action.indexOf('hover') !== -1 || hideAction.indexOf('mouseLeave') !== -1;
	  },
	  isFocusToShow: function isFocusToShow() {
	    var _props5 = this.props;
	    var action = _props5.action;
	    var showAction = _props5.showAction;

	    return action.indexOf('focus') !== -1 || showAction.indexOf('focus') !== -1;
	  },
	  isBlurToHide: function isBlurToHide() {
	    var _props6 = this.props;
	    var action = _props6.action;
	    var hideAction = _props6.hideAction;

	    return action.indexOf('focus') !== -1 || hideAction.indexOf('blur') !== -1;
	  },
	  forcePopupAlign: function forcePopupAlign() {
	    if (this.state.popupVisible && this.popupInstance && this.popupInstance.alignInstance) {
	      this.popupInstance.alignInstance.forceAlign();
	    }
	  },
	  render: function render() {
	    this.popupRendered = this.popupRendered || this.state.popupVisible;
	    var props = this.props;
	    var children = props.children;
	    var child = _react2["default"].Children.only(children);
	    var childProps = child.props || {};
	    var newChildProps = {};

	    if (this.isClickToHide() || this.isClickToShow()) {
	      newChildProps.onClick = (0, _rcUtil.createChainedFunction)(this.onClick, childProps.onClick);
	      newChildProps.onMouseDown = (0, _rcUtil.createChainedFunction)(this.onMouseDown, childProps.onMouseDown);
	      newChildProps.onTouchStart = (0, _rcUtil.createChainedFunction)(this.onTouchStart, childProps.onTouchStart);
	    }
	    if (this.isMouseEnterToShow()) {
	      newChildProps.onMouseEnter = (0, _rcUtil.createChainedFunction)(this.onMouseEnter, childProps.onMouseEnter);
	    }
	    if (this.isMouseLeaveToHide()) {
	      newChildProps.onMouseLeave = (0, _rcUtil.createChainedFunction)(this.onMouseLeave, childProps.onMouseLeave);
	    }
	    if (this.isFocusToShow() || this.isBlurToHide()) {
	      newChildProps.onFocus = (0, _rcUtil.createChainedFunction)(this.onFocus, childProps.onFocus);
	      newChildProps.onBlur = (0, _rcUtil.createChainedFunction)(this.onBlur, childProps.onBlur);
	    }

	    ALL_HANDLERS.forEach(function (handler) {
	      var newFn = void 0;
	      if (props[handler] && newChildProps[handler]) {
	        newFn = (0, _rcUtil.createChainedFunction)(props[handler], newChildProps[handler]);
	      } else {
	        newFn = props[handler] || newChildProps[handler];
	      }
	      if (newFn) {
	        newChildProps[handler] = newFn;
	      }
	    });

	    return _react2["default"].cloneElement(child, newChildProps);
	  }
	});

	exports["default"] = Trigger;
	module.exports = exports['default'];

/***/ },
/* 561 */
/***/ function(module, exports, __webpack_require__, __webpack_module_template_argument_0__, __webpack_module_template_argument_1__, __webpack_module_template_argument_2__, __webpack_module_template_argument_3__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

	var _react = __webpack_require__(7);

	var _react2 = _interopRequireDefault(_react);

	var _reactDom = __webpack_require__(8);

	var _reactDom2 = _interopRequireDefault(_reactDom);

	var _rcAlign = __webpack_require__(__webpack_module_template_argument_0__);

	var _rcAlign2 = _interopRequireDefault(_rcAlign);

	var _rcAnimate = __webpack_require__(__webpack_module_template_argument_1__);

	var _rcAnimate2 = _interopRequireDefault(_rcAnimate);

	var _PopupInner = __webpack_require__(__webpack_module_template_argument_2__);

	var _PopupInner2 = _interopRequireDefault(_PopupInner);

	var _LazyRenderBox = __webpack_require__(__webpack_module_template_argument_3__);

	var _LazyRenderBox2 = _interopRequireDefault(_LazyRenderBox);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

	var Popup = _react2["default"].createClass({
	  displayName: 'Popup',

	  propTypes: {
	    visible: _react.PropTypes.bool,
	    style: _react.PropTypes.object,
	    getClassNameFromAlign: _react.PropTypes.func,
	    onAlign: _react.PropTypes.func,
	    getRootDomNode: _react.PropTypes.func,
	    onMouseEnter: _react.PropTypes.func,
	    align: _react.PropTypes.any,
	    destroyPopupOnHide: _react.PropTypes.bool,
	    className: _react.PropTypes.string,
	    prefixCls: _react.PropTypes.string,
	    onMouseLeave: _react.PropTypes.func
	  },

	  componentDidMount: function componentDidMount() {
	    this.rootNode = this.getPopupDomNode();
	  },
	  onAlign: function onAlign(popupDomNode, align) {
	    var props = this.props;
	    var alignClassName = props.getClassNameFromAlign(props.align);
	    var currentAlignClassName = props.getClassNameFromAlign(align);
	    if (alignClassName !== currentAlignClassName) {
	      this.currentAlignClassName = currentAlignClassName;
	      popupDomNode.className = this.getClassName(currentAlignClassName);
	    }
	    props.onAlign(popupDomNode, align);
	  },
	  getPopupDomNode: function getPopupDomNode() {
	    return _reactDom2["default"].findDOMNode(this.refs.popup);
	  },
	  getTarget: function getTarget() {
	    return this.props.getRootDomNode();
	  },
	  getMaskTransitionName: function getMaskTransitionName() {
	    var props = this.props;
	    var transitionName = props.maskTransitionName;
	    var animation = props.maskAnimation;
	    if (!transitionName && animation) {
	      transitionName = props.prefixCls + '-' + animation;
	    }
	    return transitionName;
	  },
	  getTransitionName: function getTransitionName() {
	    var props = this.props;
	    var transitionName = props.transitionName;
	    if (!transitionName && props.animation) {
	      transitionName = props.prefixCls + '-' + props.animation;
	    }
	    return transitionName;
	  },
	  getClassName: function getClassName(currentAlignClassName) {
	    return this.props.prefixCls + ' ' + this.props.className + ' ' + currentAlignClassName;
	  },
	  getPopupElement: function getPopupElement() {
	    var props = this.props;
	    var align = props.align;
	    var style = props.style;
	    var visible = props.visible;
	    var prefixCls = props.prefixCls;
	    var destroyPopupOnHide = props.destroyPopupOnHide;

	    var className = this.getClassName(this.currentAlignClassName || props.getClassNameFromAlign(align));
	    var hiddenClassName = prefixCls + '-hidden';
	    if (!visible) {
	      this.currentAlignClassName = null;
	    }
	    var newStyle = _extends({}, style, this.getZIndexStyle());
	    var popupInnerProps = {
	      className: className,
	      prefixCls: prefixCls,
	      ref: 'popup',
	      onMouseEnter: props.onMouseEnter,
	      onMouseLeave: props.onMouseLeave,
	      style: newStyle
	    };
	    if (destroyPopupOnHide) {
	      return _react2["default"].createElement(
	        _rcAnimate2["default"],
	        {
	          component: '',
	          exclusive: true,
	          transitionAppear: true,
	          transitionName: this.getTransitionName()
	        },
	        visible ? _react2["default"].createElement(
	          _rcAlign2["default"],
	          {
	            target: this.getTarget,
	            key: 'popup',
	            ref: this.saveAlign,
	            monitorWindowResize: true,
	            align: align,
	            onAlign: this.onAlign
	          },
	          _react2["default"].createElement(
	            _PopupInner2["default"],
	            _extends({
	              visible: true
	            }, popupInnerProps),
	            props.children
	          )
	        ) : null
	      );
	    }
	    return _react2["default"].createElement(
	      _rcAnimate2["default"],
	      {
	        component: '',
	        exclusive: true,
	        transitionAppear: true,
	        transitionName: this.getTransitionName(),
	        showProp: 'xVisible'
	      },
	      _react2["default"].createElement(
	        _rcAlign2["default"],
	        {
	          target: this.getTarget,
	          key: 'popup',
	          ref: this.saveAlign,
	          monitorWindowResize: true,
	          xVisible: visible,
	          childrenProps: { visible: 'xVisible' },
	          disabled: !visible,
	          align: align,
	          onAlign: this.onAlign
	        },
	        _react2["default"].createElement(
	          _PopupInner2["default"],
	          _extends({
	            hiddenClassName: hiddenClassName
	          }, popupInnerProps),
	          props.children
	        )
	      )
	    );
	  },
	  getZIndexStyle: function getZIndexStyle() {
	    var style = {};
	    var props = this.props;
	    if (props.zIndex !== undefined) {
	      style.zIndex = props.zIndex;
	    }
	    return style;
	  },
	  getMaskElement: function getMaskElement() {
	    var props = this.props;
	    var maskElement = void 0;
	    if (props.mask) {
	      var maskTransition = this.getMaskTransitionName();
	      maskElement = _react2["default"].createElement(_LazyRenderBox2["default"], {
	        style: this.getZIndexStyle(),
	        key: 'mask',
	        className: props.prefixCls + '-mask',
	        hiddenClassName: props.prefixCls + '-mask-hidden',
	        visible: props.visible
	      });
	      if (maskTransition) {
	        maskElement = _react2["default"].createElement(
	          _rcAnimate2["default"],
	          {
	            key: 'mask',
	            showProp: 'visible',
	            transitionAppear: true,
	            component: '',
	            transitionName: maskTransition
	          },
	          maskElement
	        );
	      }
	    }
	    return maskElement;
	  },
	  saveAlign: function saveAlign(align) {
	    this.alignInstance = align;
	  },
	  render: function render() {
	    return _react2["default"].createElement(
	      'div',
	      null,
	      this.getMaskElement(),
	      this.getPopupElement()
	    );
	  }
	});

	exports["default"] = Popup;
	module.exports = exports['default'];

/***/ },
/* 562 */
/***/ function(module, exports, __webpack_require__, __webpack_module_template_argument_0__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _Align = __webpack_require__(__webpack_module_template_argument_0__);

	var _Align2 = _interopRequireDefault(_Align);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

	exports["default"] = _Align2["default"]; // export this package's api

	module.exports = exports['default'];

/***/ },
/* 563 */
/***/ function(module, exports, __webpack_require__, __webpack_module_template_argument_0__, __webpack_module_template_argument_1__, __webpack_module_template_argument_2__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _react = __webpack_require__(7);

	var _react2 = _interopRequireDefault(_react);

	var _reactDom = __webpack_require__(8);

	var _reactDom2 = _interopRequireDefault(_reactDom);

	var _domAlign = __webpack_require__(__webpack_module_template_argument_0__);

	var _domAlign2 = _interopRequireDefault(_domAlign);

	var _rcUtil = __webpack_require__(__webpack_module_template_argument_1__);

	var _isWindow = __webpack_require__(__webpack_module_template_argument_2__);

	var _isWindow2 = _interopRequireDefault(_isWindow);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

	function buffer(fn, ms) {
	  var timer = void 0;
	  return function bufferFn() {
	    if (timer) {
	      clearTimeout(timer);
	    }
	    timer = setTimeout(fn, ms);
	  };
	}

	var Align = _react2["default"].createClass({
	  displayName: 'Align',

	  propTypes: {
	    childrenProps: _react.PropTypes.object,
	    align: _react.PropTypes.object.isRequired,
	    target: _react.PropTypes.func,
	    onAlign: _react.PropTypes.func,
	    monitorBufferTime: _react.PropTypes.number,
	    monitorWindowResize: _react.PropTypes.bool,
	    disabled: _react.PropTypes.bool,
	    children: _react.PropTypes.any
	  },

	  getDefaultProps: function getDefaultProps() {
	    return {
	      target: function target() {
	        return window;
	      },
	      onAlign: function onAlign() {},

	      monitorBufferTime: 50,
	      monitorWindowResize: false,
	      disabled: false
	    };
	  },
	  componentDidMount: function componentDidMount() {
	    var props = this.props;
	    // if parent ref not attached .... use document.getElementById
	    this.forceAlign();
	    if (!props.disabled && props.monitorWindowResize) {
	      this.startMonitorWindowResize();
	    }
	  },
	  componentDidUpdate: function componentDidUpdate(prevProps) {
	    var reAlign = false;
	    var props = this.props;

	    if (!props.disabled) {
	      if (prevProps.disabled || prevProps.align !== props.align) {
	        reAlign = true;
	      } else {
	        var lastTarget = prevProps.target();
	        var currentTarget = props.target();
	        if ((0, _isWindow2["default"])(lastTarget) && (0, _isWindow2["default"])(currentTarget)) {
	          reAlign = false;
	        } else if (lastTarget !== currentTarget) {
	          reAlign = true;
	        }
	      }
	    }

	    if (reAlign) {
	      this.forceAlign();
	    }

	    if (props.monitorWindowResize && !props.disabled) {
	      this.startMonitorWindowResize();
	    } else {
	      this.stopMonitorWindowResize();
	    }
	  },
	  componentWillUnmount: function componentWillUnmount() {
	    this.stopMonitorWindowResize();
	  },
	  startMonitorWindowResize: function startMonitorWindowResize() {
	    if (!this.resizeHandler) {
	      this.resizeHandler = _rcUtil.Dom.addEventListener(window, 'resize', buffer(this.forceAlign, this.props.monitorBufferTime));
	    }
	  },
	  stopMonitorWindowResize: function stopMonitorWindowResize() {
	    if (this.resizeHandler) {
	      this.resizeHandler.remove();
	      this.resizeHandler = null;
	    }
	  },
	  forceAlign: function forceAlign() {
	    var props = this.props;
	    if (!props.disabled) {
	      var source = _reactDom2["default"].findDOMNode(this);
	      props.onAlign(source, (0, _domAlign2["default"])(source, props.target(), props.align));
	    }
	  },
	  render: function render() {
	    var _props = this.props;
	    var childrenProps = _props.childrenProps;
	    var children = _props.children;

	    var child = _react2["default"].Children.only(children);
	    if (childrenProps) {
	      var newProps = {};
	      for (var prop in childrenProps) {
	        if (childrenProps.hasOwnProperty(prop)) {
	          newProps[prop] = this.props[childrenProps[prop]];
	        }
	      }
	      return _react2["default"].cloneElement(child, newProps);
	    }
	    return child;
	  }
	});

	exports["default"] = Align;
	module.exports = exports['default'];

/***/ },
/* 564 */
/***/ function(module, exports, __webpack_require__, __webpack_module_template_argument_0__, __webpack_module_template_argument_1__, __webpack_module_template_argument_2__, __webpack_module_template_argument_3__, __webpack_module_template_argument_4__, __webpack_module_template_argument_5__) {

	/**
	 * align dom node flexibly
	 * @author yiminghe@gmail.com
	 */

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	  value: true
	});

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var _utils = __webpack_require__(__webpack_module_template_argument_0__);

	var _utils2 = _interopRequireDefault(_utils);

	var _getOffsetParent = __webpack_require__(__webpack_module_template_argument_1__);

	var _getOffsetParent2 = _interopRequireDefault(_getOffsetParent);

	var _getVisibleRectForElement = __webpack_require__(__webpack_module_template_argument_2__);

	var _getVisibleRectForElement2 = _interopRequireDefault(_getVisibleRectForElement);

	var _adjustForViewport = __webpack_require__(__webpack_module_template_argument_3__);

	var _adjustForViewport2 = _interopRequireDefault(_adjustForViewport);

	var _getRegion = __webpack_require__(__webpack_module_template_argument_4__);

	var _getRegion2 = _interopRequireDefault(_getRegion);

	var _getElFuturePos = __webpack_require__(__webpack_module_template_argument_5__);

	var _getElFuturePos2 = _interopRequireDefault(_getElFuturePos);

	// http://yiminghe.iteye.com/blog/1124720

	function isFailX(elFuturePos, elRegion, visibleRect) {
	  return elFuturePos.left < visibleRect.left || elFuturePos.left + elRegion.width > visibleRect.right;
	}

	function isFailY(elFuturePos, elRegion, visibleRect) {
	  return elFuturePos.top < visibleRect.top || elFuturePos.top + elRegion.height > visibleRect.bottom;
	}

	function isCompleteFailX(elFuturePos, elRegion, visibleRect) {
	  return elFuturePos.left > visibleRect.right || elFuturePos.left + elRegion.width < visibleRect.left;
	}

	function isCompleteFailY(elFuturePos, elRegion, visibleRect) {
	  return elFuturePos.top > visibleRect.bottom || elFuturePos.top + elRegion.height < visibleRect.top;
	}

	function flip(points, reg, map) {
	  var ret = [];
	  _utils2['default'].each(points, function (p) {
	    ret.push(p.replace(reg, function (m) {
	      return map[m];
	    }));
	  });
	  return ret;
	}

	function flipOffset(offset, index) {
	  offset[index] = -offset[index];
	  return offset;
	}

	function convertOffset(str, offsetLen) {
	  var n = undefined;
	  if (/%$/.test(str)) {
	    n = parseInt(str.substring(0, str.length - 1), 10) / 100 * offsetLen;
	  } else {
	    n = parseInt(str, 10);
	  }
	  return n || 0;
	}

	function normalizeOffset(offset, el) {
	  offset[0] = convertOffset(offset[0], el.width);
	  offset[1] = convertOffset(offset[1], el.height);
	}

	function domAlign(el, refNode, align) {
	  var points = align.points;
	  var offset = align.offset || [0, 0];
	  var targetOffset = align.targetOffset || [0, 0];
	  var overflow = align.overflow;
	  var target = align.target || refNode;
	  var source = align.source || el;
	  offset = [].concat(offset);
	  targetOffset = [].concat(targetOffset);
	  overflow = overflow || {};
	  var newOverflowCfg = {};

	  var fail = 0;
	  // 当前节点可以被放置的显示区域
	  var visibleRect = (0, _getVisibleRectForElement2['default'])(source);
	  // 当前节点所占的区域, left/top/width/height
	  var elRegion = (0, _getRegion2['default'])(source);
	  // 参照节点所占的区域, left/top/width/height
	  var refNodeRegion = (0, _getRegion2['default'])(target);
	  // 将 offset 转换成数值，支持百分比
	  normalizeOffset(offset, elRegion);
	  normalizeOffset(targetOffset, refNodeRegion);
	  // 当前节点将要被放置的位置
	  var elFuturePos = (0, _getElFuturePos2['default'])(elRegion, refNodeRegion, points, offset, targetOffset);
	  // 当前节点将要所处的区域
	  var newElRegion = _utils2['default'].merge(elRegion, elFuturePos);

	  // 如果可视区域不能完全放置当前节点时允许调整
	  if (visibleRect && (overflow.adjustX || overflow.adjustY)) {
	    if (overflow.adjustX) {
	      // 如果横向不能放下
	      if (isFailX(elFuturePos, elRegion, visibleRect)) {
	        // 对齐位置反下
	        var newPoints = flip(points, /[lr]/ig, {
	          l: 'r',
	          r: 'l'
	        });
	        // 偏移量也反下
	        var newOffset = flipOffset(offset, 0);
	        var newTargetOffset = flipOffset(targetOffset, 0);
	        var newElFuturePos = (0, _getElFuturePos2['default'])(elRegion, refNodeRegion, newPoints, newOffset, newTargetOffset);
	        if (!isCompleteFailX(newElFuturePos, elRegion, visibleRect)) {
	          fail = 1;
	          points = newPoints;
	          offset = newOffset;
	          targetOffset = newTargetOffset;
	        }
	      }
	    }

	    if (overflow.adjustY) {
	      // 如果纵向不能放下
	      if (isFailY(elFuturePos, elRegion, visibleRect)) {
	        // 对齐位置反下
	        var newPoints = flip(points, /[tb]/ig, {
	          t: 'b',
	          b: 't'
	        });
	        // 偏移量也反下
	        var newOffset = flipOffset(offset, 1);
	        var newTargetOffset = flipOffset(targetOffset, 1);
	        var newElFuturePos = (0, _getElFuturePos2['default'])(elRegion, refNodeRegion, newPoints, newOffset, newTargetOffset);
	        if (!isCompleteFailY(newElFuturePos, elRegion, visibleRect)) {
	          fail = 1;
	          points = newPoints;
	          offset = newOffset;
	          targetOffset = newTargetOffset;
	        }
	      }
	    }

	    // 如果失败，重新计算当前节点将要被放置的位置
	    if (fail) {
	      elFuturePos = (0, _getElFuturePos2['default'])(elRegion, refNodeRegion, points, offset, targetOffset);
	      _utils2['default'].mix(newElRegion, elFuturePos);
	    }

	    // 检查反下后的位置是否可以放下了
	    // 如果仍然放不下只有指定了可以调整当前方向才调整
	    newOverflowCfg.adjustX = overflow.adjustX && isFailX(elFuturePos, elRegion, visibleRect);

	    newOverflowCfg.adjustY = overflow.adjustY && isFailY(elFuturePos, elRegion, visibleRect);

	    // 确实要调整，甚至可能会调整高度宽度
	    if (newOverflowCfg.adjustX || newOverflowCfg.adjustY) {
	      newElRegion = (0, _adjustForViewport2['default'])(elFuturePos, elRegion, visibleRect, newOverflowCfg);
	    }
	  }

	  // need judge to in case set fixed with in css on height auto element
	  if (newElRegion.width !== elRegion.width) {
	    _utils2['default'].css(source, 'width', source.width() + newElRegion.width - elRegion.width);
	  }

	  if (newElRegion.height !== elRegion.height) {
	    _utils2['default'].css(source, 'height', source.height() + newElRegion.height - elRegion.height);
	  }

	  // https://github.com/kissyteam/kissy/issues/190
	  // http://localhost:8888/kissy/src/overlay/demo/other/relative_align/align.html
	  // 相对于屏幕位置没变，而 left/top 变了
	  // 例如 <div 'relative'><el absolute></div>
	  _utils2['default'].offset(source, {
	    left: newElRegion.left,
	    top: newElRegion.top
	  }, {
	    useCssRight: align.useCssRight,
	    useCssBottom: align.useCssBottom
	  });

	  return {
	    points: points,
	    offset: offset,
	    targetOffset: targetOffset,
	    overflow: newOverflowCfg
	  };
	}

	domAlign.__getOffsetParent = _getOffsetParent2['default'];

	domAlign.__getVisibleRectForElement = _getVisibleRectForElement2['default'];

	exports['default'] = domAlign;

	/**
	 *  2012-04-26 yiminghe@gmail.com
	 *   - 优化智能对齐算法
	 *   - 慎用 resizeXX
	 *
	 *  2011-07-13 yiminghe@gmail.com note:
	 *   - 增加智能对齐，以及大小调整选项
	 **/
	module.exports = exports['default'];

/***/ },
/* 565 */
/***/ function(module, exports, __webpack_require__, __webpack_module_template_argument_0__) {

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	  value: true
	});

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var _utils = __webpack_require__(__webpack_module_template_argument_0__);

	var _utils2 = _interopRequireDefault(_utils);

	/**
	 * 得到会导致元素显示不全的祖先元素
	 */

	function getOffsetParent(element) {
	  // ie 这个也不是完全可行
	  /*
	   <div style="width: 50px;height: 100px;overflow: hidden">
	   <div style="width: 50px;height: 100px;position: relative;" id="d6">
	   元素 6 高 100px 宽 50px<br/>
	   </div>
	   </div>
	   */
	  // element.offsetParent does the right thing in ie7 and below. Return parent with layout!
	  //  In other browsers it only includes elements with position absolute, relative or
	  // fixed, not elements with overflow set to auto or scroll.
	  //        if (UA.ie && ieMode < 8) {
	  //            return element.offsetParent;
	  //        }
	  // 统一的 offsetParent 方法
	  var doc = element.ownerDocument;
	  var body = doc.body;
	  var parent = undefined;
	  var positionStyle = _utils2['default'].css(element, 'position');
	  var skipStatic = positionStyle === 'fixed' || positionStyle === 'absolute';

	  if (!skipStatic) {
	    return element.nodeName.toLowerCase() === 'html' ? null : element.parentNode;
	  }

	  for (parent = element.parentNode; parent && parent !== body; parent = parent.parentNode) {
	    positionStyle = _utils2['default'].css(parent, 'position');
	    if (positionStyle !== 'static') {
	      return parent;
	    }
	  }
	  return null;
	}

	exports['default'] = getOffsetParent;
	module.exports = exports['default'];

/***/ },
/* 566 */
/***/ function(module, exports, __webpack_require__, __webpack_module_template_argument_0__, __webpack_module_template_argument_1__) {

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	  value: true
	});

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var _utils = __webpack_require__(__webpack_module_template_argument_0__);

	var _utils2 = _interopRequireDefault(_utils);

	var _getOffsetParent = __webpack_require__(__webpack_module_template_argument_1__);

	var _getOffsetParent2 = _interopRequireDefault(_getOffsetParent);

	/**
	 * 获得元素的显示部分的区域
	 */
	function getVisibleRectForElement(element) {
	  var visibleRect = {
	    left: 0,
	    right: Infinity,
	    top: 0,
	    bottom: Infinity
	  };
	  var el = (0, _getOffsetParent2['default'])(element);
	  var scrollX = undefined;
	  var scrollY = undefined;
	  var winSize = undefined;
	  var doc = element.ownerDocument;
	  var win = doc.defaultView || doc.parentWindow;
	  var body = doc.body;
	  var documentElement = doc.documentElement;

	  // Determine the size of the visible rect by climbing the dom accounting for
	  // all scrollable containers.
	  while (el) {
	    // clientWidth is zero for inline block elements in ie.
	    if ((navigator.userAgent.indexOf('MSIE') === -1 || el.clientWidth !== 0) &&
	    // body may have overflow set on it, yet we still get the entire
	    // viewport. In some browsers, el.offsetParent may be
	    // document.documentElement, so check for that too.
	    el !== body && el !== documentElement && _utils2['default'].css(el, 'overflow') !== 'visible') {
	      var pos = _utils2['default'].offset(el);
	      // add border
	      pos.left += el.clientLeft;
	      pos.top += el.clientTop;
	      visibleRect.top = Math.max(visibleRect.top, pos.top);
	      visibleRect.right = Math.min(visibleRect.right,
	      // consider area without scrollBar
	      pos.left + el.clientWidth);
	      visibleRect.bottom = Math.min(visibleRect.bottom, pos.top + el.clientHeight);
	      visibleRect.left = Math.max(visibleRect.left, pos.left);
	    } else if (el === body || el === documentElement) {
	      break;
	    }
	    el = (0, _getOffsetParent2['default'])(el);
	  }

	  // Clip by window's viewport.
	  scrollX = _utils2['default'].getWindowScrollLeft(win);
	  scrollY = _utils2['default'].getWindowScrollTop(win);
	  visibleRect.left = Math.max(visibleRect.left, scrollX);
	  visibleRect.top = Math.max(visibleRect.top, scrollY);
	  winSize = {
	    width: _utils2['default'].viewportWidth(win),
	    height: _utils2['default'].viewportHeight(win)
	  };
	  visibleRect.right = Math.min(visibleRect.right, scrollX + winSize.width);
	  visibleRect.bottom = Math.min(visibleRect.bottom, scrollY + winSize.height);
	  return visibleRect.top >= 0 && visibleRect.left >= 0 && visibleRect.bottom > visibleRect.top && visibleRect.right > visibleRect.left ? visibleRect : null;
	}

	exports['default'] = getVisibleRectForElement;
	module.exports = exports['default'];

/***/ },
/* 567 */
/***/ function(module, exports, __webpack_require__, __webpack_module_template_argument_0__) {

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	  value: true
	});

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var _utils = __webpack_require__(__webpack_module_template_argument_0__);

	var _utils2 = _interopRequireDefault(_utils);

	function adjustForViewport(elFuturePos, elRegion, visibleRect, overflow) {
	  var pos = _utils2['default'].clone(elFuturePos);
	  var size = {
	    width: elRegion.width,
	    height: elRegion.height
	  };

	  if (overflow.adjustX && pos.left < visibleRect.left) {
	    pos.left = visibleRect.left;
	  }

	  // Left edge inside and right edge outside viewport, try to resize it.
	  if (overflow.resizeWidth && pos.left >= visibleRect.left && pos.left + size.width > visibleRect.right) {
	    size.width -= pos.left + size.width - visibleRect.right;
	  }

	  // Right edge outside viewport, try to move it.
	  if (overflow.adjustX && pos.left + size.width > visibleRect.right) {
	    // 保证左边界和可视区域左边界对齐
	    pos.left = Math.max(visibleRect.right - size.width, visibleRect.left);
	  }

	  // Top edge outside viewport, try to move it.
	  if (overflow.adjustY && pos.top < visibleRect.top) {
	    pos.top = visibleRect.top;
	  }

	  // Top edge inside and bottom edge outside viewport, try to resize it.
	  if (overflow.resizeHeight && pos.top >= visibleRect.top && pos.top + size.height > visibleRect.bottom) {
	    size.height -= pos.top + size.height - visibleRect.bottom;
	  }

	  // Bottom edge outside viewport, try to move it.
	  if (overflow.adjustY && pos.top + size.height > visibleRect.bottom) {
	    // 保证上边界和可视区域上边界对齐
	    pos.top = Math.max(visibleRect.bottom - size.height, visibleRect.top);
	  }

	  return _utils2['default'].mix(pos, size);
	}

	exports['default'] = adjustForViewport;
	module.exports = exports['default'];

/***/ },
/* 568 */
/***/ function(module, exports, __webpack_require__, __webpack_module_template_argument_0__) {

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	  value: true
	});

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var _utils = __webpack_require__(__webpack_module_template_argument_0__);

	var _utils2 = _interopRequireDefault(_utils);

	function getRegion(node) {
	  var offset = undefined;
	  var w = undefined;
	  var h = undefined;
	  if (!_utils2['default'].isWindow(node) && node.nodeType !== 9) {
	    offset = _utils2['default'].offset(node);
	    w = _utils2['default'].outerWidth(node);
	    h = _utils2['default'].outerHeight(node);
	  } else {
	    var win = _utils2['default'].getWindow(node);
	    offset = {
	      left: _utils2['default'].getWindowScrollLeft(win),
	      top: _utils2['default'].getWindowScrollTop(win)
	    };
	    w = _utils2['default'].viewportWidth(win);
	    h = _utils2['default'].viewportHeight(win);
	  }
	  offset.width = w;
	  offset.height = h;
	  return offset;
	}

	exports['default'] = getRegion;
	module.exports = exports['default'];

/***/ },
/* 569 */
/***/ function(module, exports, __webpack_require__, __webpack_module_template_argument_0__) {

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	  value: true
	});

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var _getAlignOffset = __webpack_require__(__webpack_module_template_argument_0__);

	var _getAlignOffset2 = _interopRequireDefault(_getAlignOffset);

	function getElFuturePos(elRegion, refNodeRegion, points, offset, targetOffset) {
	  var xy = undefined;
	  var diff = undefined;
	  var p1 = undefined;
	  var p2 = undefined;

	  xy = {
	    left: elRegion.left,
	    top: elRegion.top
	  };

	  p1 = (0, _getAlignOffset2['default'])(refNodeRegion, points[1]);
	  p2 = (0, _getAlignOffset2['default'])(elRegion, points[0]);

	  diff = [p2.left - p1.left, p2.top - p1.top];

	  return {
	    left: xy.left - diff[0] + offset[0] - targetOffset[0],
	    top: xy.top - diff[1] + offset[1] - targetOffset[1]
	  };
	}

	exports['default'] = getElFuturePos;
	module.exports = exports['default'];

/***/ },
/* 570 */
/***/ function(module, exports, __webpack_require__, __webpack_module_template_argument_0__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _react = __webpack_require__(7);

	var _react2 = _interopRequireDefault(_react);

	var _LazyRenderBox = __webpack_require__(__webpack_module_template_argument_0__);

	var _LazyRenderBox2 = _interopRequireDefault(_LazyRenderBox);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

	var PopupInner = _react2["default"].createClass({
	  displayName: 'PopupInner',

	  propTypes: {
	    hiddenClassName: _react.PropTypes.string,
	    className: _react.PropTypes.string,
	    prefixCls: _react.PropTypes.string,
	    onMouseEnter: _react.PropTypes.func,
	    onMouseLeave: _react.PropTypes.func,
	    children: _react.PropTypes.any
	  },
	  render: function render() {
	    var props = this.props;
	    var className = props.className;
	    if (!props.visible) {
	      className += ' ' + props.hiddenClassName;
	    }
	    return _react2["default"].createElement(
	      'div',
	      {
	        className: className,
	        onMouseEnter: props.onMouseEnter,
	        onMouseLeave: props.onMouseLeave,
	        style: props.style
	      },
	      _react2["default"].createElement(
	        _LazyRenderBox2["default"],
	        { className: props.prefixCls + '-content', visible: props.visible },
	        props.children
	      )
	    );
	  }
	});

	exports["default"] = PopupInner;
	module.exports = exports['default'];

/***/ },
/* 571 */
/***/ function(module, exports, __webpack_require__, __webpack_module_template_argument_0__) {

	'use strict';

	/**
	 * Tooltip Component for uxcore
	 * @author 
	 *
	 * Copyright 2014-2015, Uxcore Team, Alinw.
	 * All rights reserved.
	 */

	module.exports = __webpack_require__(__webpack_module_template_argument_0__);

/***/ },
/* 572 */
/***/ function(module, exports, __webpack_require__, __webpack_module_template_argument_0__, __webpack_module_template_argument_1__) {

	'use strict';

	exports.__esModule = true;

	var _rcTooltip = __webpack_require__(__webpack_module_template_argument_0__);

	var _rcTooltip2 = _interopRequireDefault(_rcTooltip);

	var _objectAssign = __webpack_require__(__webpack_module_template_argument_1__);

	var _objectAssign2 = _interopRequireDefault(_objectAssign);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var Tooltip = function (_RcTooltip) {
		_inherits(Tooltip, _RcTooltip);

		function Tooltip(props) {
			_classCallCheck(this, Tooltip);

			return _possibleConstructorReturn(this, _RcTooltip.call(this, props));
		}

		return Tooltip;
	}(_rcTooltip2["default"]);

	exports["default"] = Tooltip;

	Tooltip.displayName = 'uxcore-tooltip';
	Tooltip.propTypes = _rcTooltip2["default"].propTypes;

	Tooltip.defaultProps = (0, _objectAssign2["default"])(_rcTooltip2["default"].defaultProps, {
		prefixCls: 'kuma-tooltip',
		transitionName: 'flip'
	});
	module.exports = exports['default'];

/***/ },
/* 573 */
/***/ function(module, exports, __webpack_require__, __webpack_module_template_argument_0__) {

	'use strict';

	module.exports = __webpack_require__(__webpack_module_template_argument_0__);

/***/ },
/* 574 */
/***/ function(module, exports, __webpack_require__, __webpack_module_template_argument_0__, __webpack_module_template_argument_1__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

	var _react = __webpack_require__(7);

	var _react2 = _interopRequireDefault(_react);

	var _placements = __webpack_require__(__webpack_module_template_argument_0__);

	var _rcTrigger = __webpack_require__(__webpack_module_template_argument_1__);

	var _rcTrigger2 = _interopRequireDefault(_rcTrigger);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

	function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

	var Tooltip = _react2["default"].createClass({
	  displayName: 'Tooltip',

	  propTypes: {
	    trigger: _react.PropTypes.any,
	    children: _react.PropTypes.any,
	    defaultVisible: _react.PropTypes.bool,
	    visible: _react.PropTypes.bool,
	    placement: _react.PropTypes.string,
	    transitionName: _react.PropTypes.string,
	    animation: _react.PropTypes.any,
	    onVisibleChange: _react.PropTypes.func,
	    afterVisibleChange: _react.PropTypes.func,
	    overlay: _react.PropTypes.node.isRequired,
	    overlayStyle: _react.PropTypes.object,
	    overlayClassName: _react.PropTypes.string,
	    prefixCls: _react.PropTypes.string,
	    mouseEnterDelay: _react.PropTypes.number,
	    mouseLeaveDelay: _react.PropTypes.number,
	    getTooltipContainer: _react.PropTypes.func,
	    destroyTooltipOnHide: _react.PropTypes.bool,
	    align: _react.PropTypes.object,
	    arrowContent: _react.PropTypes.any
	  },

	  getDefaultProps: function getDefaultProps() {
	    return {
	      prefixCls: 'rc-tooltip',
	      mouseEnterDelay: 0,
	      destroyTooltipOnHide: false,
	      mouseLeaveDelay: 0.1,
	      align: {},
	      placement: 'right',
	      trigger: ['hover'],
	      arrowContent: null
	    };
	  },
	  getPopupElement: function getPopupElement() {
	    var _props = this.props;
	    var arrowContent = _props.arrowContent;
	    var overlay = _props.overlay;
	    var prefixCls = _props.prefixCls;

	    return [_react2["default"].createElement(
	      'div',
	      { className: prefixCls + '-arrow', key: 'arrow' },
	      arrowContent
	    ), _react2["default"].createElement(
	      'div',
	      { className: prefixCls + '-inner', key: 'content' },
	      overlay
	    )];
	  },
	  getPopupDomNode: function getPopupDomNode() {
	    return this.refs.trigger.popupDomNode;
	  },
	  render: function render() {
	    var _props2 = this.props;
	    var overlayClassName = _props2.overlayClassName;
	    var trigger = _props2.trigger;
	    var mouseEnterDelay = _props2.mouseEnterDelay;
	    var mouseLeaveDelay = _props2.mouseLeaveDelay;
	    var overlayStyle = _props2.overlayStyle;
	    var prefixCls = _props2.prefixCls;
	    var children = _props2.children;
	    var onVisibleChange = _props2.onVisibleChange;
	    var transitionName = _props2.transitionName;
	    var animation = _props2.animation;
	    var placement = _props2.placement;
	    var align = _props2.align;
	    var destroyTooltipOnHide = _props2.destroyTooltipOnHide;
	    var defaultVisible = _props2.defaultVisible;
	    var getTooltipContainer = _props2.getTooltipContainer;

	    var restProps = _objectWithoutProperties(_props2, ['overlayClassName', 'trigger', 'mouseEnterDelay', 'mouseLeaveDelay', 'overlayStyle', 'prefixCls', 'children', 'onVisibleChange', 'transitionName', 'animation', 'placement', 'align', 'destroyTooltipOnHide', 'defaultVisible', 'getTooltipContainer']);

	    var extraProps = _extends({}, restProps);
	    if ('visible' in this.props) {
	      extraProps.popupVisible = this.props.visible;
	    }
	    return _react2["default"].createElement(
	      _rcTrigger2["default"],
	      _extends({
	        popupClassName: overlayClassName,
	        ref: 'trigger',
	        prefixCls: prefixCls,
	        popup: this.getPopupElement(),
	        action: trigger,
	        builtinPlacements: _placements.placements,
	        popupPlacement: placement,
	        popupAlign: align,
	        getPopupContainer: getTooltipContainer,
	        onPopupVisibleChange: onVisibleChange,
	        popupTransitionName: transitionName,
	        popupAnimation: animation,
	        defaultPopupVisible: defaultVisible,
	        destroyPopupOnHide: destroyTooltipOnHide,
	        mouseLeaveDelay: mouseLeaveDelay,
	        popupStyle: overlayStyle,
	        mouseEnterDelay: mouseEnterDelay
	      }, extraProps),
	      children
	    );
	  }
	});

	exports["default"] = Tooltip;
	module.exports = exports['default'];

/***/ },
/* 575 */
/***/ function(module, exports, __webpack_require__, __webpack_module_template_argument_0__) {

	'use strict';

	/**
	 * Select2 Component for uxcore
	 * @author 
	 *
	 * Copyright 2014-2015, Uxcore Team, Alinw.
	 * All rights reserved.
	 */

	module.exports = __webpack_require__(__webpack_module_template_argument_0__);

/***/ },
/* 576 */
/***/ function(module, exports, __webpack_require__, __webpack_module_template_argument_0__, __webpack_module_template_argument_1__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var _rcSelect = __webpack_require__(__webpack_module_template_argument_0__);

	var _rcSelect2 = _interopRequireDefault(_rcSelect);

	var _objectAssign = __webpack_require__(__webpack_module_template_argument_1__);

	var _objectAssign2 = _interopRequireDefault(_objectAssign);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

	function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

	var Select2 = function (_RcSelect) {
	    _inherits(Select2, _RcSelect);

	    function Select2(props) {
	        _classCallCheck(this, Select2);

	        return _possibleConstructorReturn(this, _RcSelect.call(this, props));
	    }

	    return Select2;
	}(_rcSelect2["default"]);

	Select2.displayName = 'Select2';
	Select2.defaultProps = (0, _objectAssign2["default"])({}, _rcSelect2["default"].defaultProps, {
	    prefixCls: 'kuma-select2',
	    optionLabelProp: 'children',
	    transitionName: 'slideUp'
	});

	exports["default"] = Select2;
	module.exports = exports['default'];

/***/ },
/* 577 */
/***/ function(module, exports, __webpack_require__, __webpack_module_template_argument_0__, __webpack_module_template_argument_1__, __webpack_module_template_argument_2__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.OptGroup = exports.Option = undefined;

	var _Select = __webpack_require__(__webpack_module_template_argument_0__);

	var _Select2 = _interopRequireDefault(_Select);

	var _Option = __webpack_require__(__webpack_module_template_argument_1__);

	var _Option2 = _interopRequireDefault(_Option);

	var _OptGroup = __webpack_require__(__webpack_module_template_argument_2__);

	var _OptGroup2 = _interopRequireDefault(_OptGroup);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

	_Select2["default"].Option = _Option2["default"];
	_Select2["default"].OptGroup = _OptGroup2["default"];
	exports.Option = _Option2["default"];
	exports.OptGroup = _OptGroup2["default"];
	exports["default"] = _Select2["default"];

/***/ },
/* 578 */
/***/ function(module, exports, __webpack_require__, __webpack_module_template_argument_0__, __webpack_module_template_argument_1__, __webpack_module_template_argument_2__, __webpack_module_template_argument_3__, __webpack_module_template_argument_4__, __webpack_module_template_argument_5__, __webpack_module_template_argument_6__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

	var _react = __webpack_require__(7);

	var _react2 = _interopRequireDefault(_react);

	var _reactDom = __webpack_require__(8);

	var _reactDom2 = _interopRequireDefault(_reactDom);

	var _rcUtil = __webpack_require__(__webpack_module_template_argument_0__);

	var _classnames = __webpack_require__(19);

	var _classnames2 = _interopRequireDefault(_classnames);

	var _OptGroup = __webpack_require__(__webpack_module_template_argument_1__);

	var _OptGroup2 = _interopRequireDefault(_OptGroup);

	var _rcAnimate = __webpack_require__(__webpack_module_template_argument_2__);

	var _rcAnimate2 = _interopRequireDefault(_rcAnimate);

	var _componentClasses = __webpack_require__(__webpack_module_template_argument_3__);

	var _componentClasses2 = _interopRequireDefault(_componentClasses);

	var _util = __webpack_require__(__webpack_module_template_argument_4__);

	var _SelectTrigger = __webpack_require__(__webpack_module_template_argument_5__);

	var _SelectTrigger2 = _interopRequireDefault(_SelectTrigger);

	var _FilterMixin = __webpack_require__(__webpack_module_template_argument_6__);

	var _FilterMixin2 = _interopRequireDefault(_FilterMixin);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

	function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

	function noop() {}

	function filterFn(input, child) {
	  return String((0, _util.getPropValue)(child, this.props.optionFilterProp)).indexOf(input) > -1;
	}

	function saveRef(name, component) {
	  this[name] = component;
	}

	var Select = _react2["default"].createClass({
	  displayName: 'Select',

	  propTypes: {
	    defaultActiveFirstOption: _react.PropTypes.bool,
	    multiple: _react.PropTypes.bool,
	    filterOption: _react.PropTypes.any,
	    showSearch: _react.PropTypes.bool,
	    disabled: _react.PropTypes.bool,
	    allowClear: _react.PropTypes.bool,
	    showArrow: _react.PropTypes.bool,
	    tags: _react.PropTypes.bool,
	    prefixCls: _react.PropTypes.string,
	    className: _react.PropTypes.string,
	    transitionName: _react.PropTypes.string,
	    optionLabelProp: _react.PropTypes.string,
	    optionFilterProp: _react.PropTypes.string,
	    animation: _react.PropTypes.string,
	    choiceTransitionName: _react.PropTypes.string,
	    onChange: _react.PropTypes.func,
	    onSelect: _react.PropTypes.func,
	    onSearch: _react.PropTypes.func,
	    searchPlaceholder: _react.PropTypes.string,
	    placeholder: _react.PropTypes.any,
	    onDeselect: _react.PropTypes.func,
	    labelInValue: _react.PropTypes.bool,
	    value: _react.PropTypes.any,
	    defaultValue: _react.PropTypes.any,
	    dropdownStyle: _react.PropTypes.object,
	    maxTagTextLength: _react.PropTypes.number
	  },

	  mixins: [_FilterMixin2["default"]],

	  getDefaultProps: function getDefaultProps() {
	    return {
	      prefixCls: 'rc-select',
	      filterOption: filterFn,
	      defaultOpen: false,
	      labelInValue: false,
	      defaultActiveFirstOption: true,
	      showSearch: true,
	      allowClear: false,
	      placeholder: '',
	      searchPlaceholder: '',
	      defaultValue: [],
	      onChange: noop,
	      onSelect: noop,
	      onSearch: noop,
	      onDeselect: noop,
	      showArrow: true,
	      dropdownMatchSelectWidth: true,
	      dropdownStyle: {},
	      dropdownMenuStyle: {},
	      optionFilterProp: 'value',
	      optionLabelProp: 'value',
	      notFoundContent: 'Not Found'
	    };
	  },
	  getInitialState: function getInitialState() {
	    var props = this.props;
	    var value = [];
	    if ('value' in props) {
	      value = (0, _util.toArray)(props.value);
	    } else {
	      value = (0, _util.toArray)(props.defaultValue);
	    }
	    value = this.addLabelToValue(props, value);
	    var inputValue = '';
	    if (props.combobox) {
	      inputValue = value.length ? String(value[0].key) : '';
	    }
	    this.saveInputRef = saveRef.bind(this, 'inputInstance');
	    var open = props.open;
	    if (open === undefined) {
	      open = props.defaultOpen;
	    }
	    return {
	      value: value,
	      inputValue: inputValue,
	      open: open
	    };
	  },
	  componentWillReceiveProps: function componentWillReceiveProps(nextProps) {
	    if ('value' in nextProps) {
	      var value = (0, _util.toArray)(nextProps.value);
	      value = this.addLabelToValue(nextProps, value);
	      this.setState({
	        value: value
	      });
	      if (nextProps.combobox) {
	        this.setState({
	          inputValue: value.length ? String(value[0].key) : ''
	        });
	      }
	    }
	  },
	  componentDidUpdate: function componentDidUpdate() {
	    var state = this.state;
	    var props = this.props;

	    if (state.open && ((0, _util.isMultipleOrTags)(props) || props.showSearch)) {
	      var inputNode = this.getInputDOMNode();
	      if (inputNode.value) {
	        inputNode.style.width = '';
	        inputNode.style.width = inputNode.scrollWidth + 'px';
	      } else {
	        inputNode.style.width = '';
	      }
	    }
	  },
	  componentWillUnmount: function componentWillUnmount() {
	    if (this.dropdownContainer) {
	      _reactDom2["default"].unmountComponentAtNode(this.dropdownContainer);
	      document.body.removeChild(this.dropdownContainer);
	      this.dropdownContainer = null;
	    }
	  },
	  onInputChange: function onInputChange(event) {
	    var val = event.target.value;
	    var props = this.props;

	    this.setState({
	      inputValue: val,
	      open: true
	    });
	    if ((0, _util.isCombobox)(props)) {
	      this.fireChange([{
	        key: val
	      }]);
	    }
	    props.onSearch(val);
	  },
	  onDropdownVisibleChange: function onDropdownVisibleChange(open) {
	    this.setOpenState(open);
	  },


	  // combobox ignore
	  onKeyDown: function onKeyDown(event) {
	    var props = this.props;
	    if (props.disabled) {
	      return;
	    }
	    var keyCode = event.keyCode;
	    if (this.state.open && !this.getInputDOMNode()) {
	      this.onInputKeyDown(event);
	    } else if (keyCode === _rcUtil.KeyCode.ENTER || keyCode === _rcUtil.KeyCode.DOWN) {
	      this.setOpenState(true);
	      event.preventDefault();
	    }
	  },
	  onInputKeyDown: function onInputKeyDown(event) {
	    var props = this.props;
	    if (props.disabled) {
	      return;
	    }
	    var state = this.state;
	    var keyCode = event.keyCode;
	    if ((0, _util.isMultipleOrTags)(props) && !event.target.value && keyCode === _rcUtil.KeyCode.BACKSPACE) {
	      var value = state.value.concat();
	      if (value.length) {
	        var popValue = value.pop();
	        props.onDeselect(props.labelInValue ? popValue : popValue.key);
	        this.fireChange(value);
	      }
	      return;
	    }
	    if (keyCode === _rcUtil.KeyCode.DOWN) {
	      if (!state.open) {
	        this.openIfHasChildren();
	        event.preventDefault();
	        event.stopPropagation();
	        return;
	      }
	    } else if (keyCode === _rcUtil.KeyCode.ESC) {
	      if (state.open) {
	        this.setOpenState(false);
	        event.preventDefault();
	        event.stopPropagation();
	      }
	      return;
	    }

	    if (state.open) {
	      var menu = this.refs.trigger.getInnerMenu();
	      if (menu && menu.onKeyDown(event)) {
	        event.preventDefault();
	        event.stopPropagation();
	      }
	    }
	  },
	  onMenuSelect: function onMenuSelect(_ref) {
	    var item = _ref.item;

	    var value = this.state.value;
	    var props = this.props;
	    var selectedValue = (0, _util.getValuePropValue)(item);
	    var selectedLabel = this.getLabelFromOption(item);
	    var event = selectedValue;
	    if (props.labelInValue) {
	      event = {
	        key: event,
	        label: selectedLabel
	      };
	    }
	    props.onSelect(event, item);
	    if ((0, _util.isMultipleOrTags)(props)) {
	      if ((0, _util.findIndexInValueByKey)(value, selectedValue) !== -1) {
	        return;
	      }
	      value = value.concat([{
	        key: selectedValue,
	        label: selectedLabel
	      }]);
	    } else {
	      if (value.length && value[0].key === selectedValue) {
	        this.setOpenState(false, true);
	        return;
	      }
	      value = [{
	        key: selectedValue,
	        label: selectedLabel
	      }];
	      this.setOpenState(false, true);
	    }
	    this.fireChange(value);
	    this.setState({
	      inputValue: ''
	    });
	    if ((0, _util.isCombobox)(props)) {
	      this.setState({
	        inputValue: (0, _util.getPropValue)(item, props.optionLabelProp)
	      });
	    }
	  },
	  onMenuDeselect: function onMenuDeselect(_ref2) {
	    var item = _ref2.item;
	    var domEvent = _ref2.domEvent;

	    if (domEvent.type === 'click') {
	      this.removeSelected((0, _util.getValuePropValue)(item));
	    }
	    this.setState({
	      inputValue: ''
	    });
	  },
	  onArrowClick: function onArrowClick(e) {
	    e.stopPropagation();
	    this.setOpenState(!this.state.open, true);
	  },
	  onPlaceholderClick: function onPlaceholderClick() {
	    this.getInputDOMNode().focus();
	  },
	  onOuterFocus: function onOuterFocus() {
	    this._focused = true;
	    this.updateFocusClassName();
	  },
	  onPopupFocus: function onPopupFocus() {
	    // fix ie scrollbar, focus element again
	    this.maybeFocus(true, true);
	  },
	  onOuterBlur: function onOuterBlur() {
	    this._focused = false;
	    this.updateFocusClassName();
	  },
	  onClearSelection: function onClearSelection(event) {
	    var props = this.props;
	    var state = this.state;
	    if (props.disabled) {
	      return;
	    }
	    event.stopPropagation();
	    if (state.inputValue || state.value.length) {
	      this.fireChange([]);
	      this.setOpenState(false);
	      this.setState({
	        inputValue: ''
	      });
	    }
	  },
	  getLabelBySingleValue: function getLabelBySingleValue(children, value) {
	    var _this = this;

	    if (value === undefined) {
	      return null;
	    }
	    var label = null;
	    _react2["default"].Children.forEach(children, function (child) {
	      if (child.type === _OptGroup2["default"]) {
	        var maybe = _this.getLabelBySingleValue(child.props.children, value);
	        if (maybe !== null) {
	          label = maybe;
	        }
	      } else if ((0, _util.getValuePropValue)(child) === value) {
	        label = _this.getLabelFromOption(child);
	      }
	    });
	    return label;
	  },
	  getLabelFromOption: function getLabelFromOption(child) {
	    return (0, _util.getPropValue)(child, this.props.optionLabelProp);
	  },
	  getLabelFromProps: function getLabelFromProps(props, value) {
	    return this.getLabelByValue(props.children, value);
	  },
	  getVLForOnChange: function getVLForOnChange(vls_) {
	    var vls = vls_;
	    if (vls !== undefined) {
	      if (!this.props.labelInValue) {
	        vls = vls.map(function (v) {
	          return v.key;
	        });
	      }
	      return (0, _util.isMultipleOrTags)(this.props) ? vls : vls[0];
	    }
	    return vls;
	  },
	  getLabelByValue: function getLabelByValue(children, value) {
	    var label = this.getLabelBySingleValue(children, value);
	    if (label === null) {
	      return value;
	    }
	    return label;
	  },
	  getDropdownContainer: function getDropdownContainer() {
	    if (!this.dropdownContainer) {
	      this.dropdownContainer = document.createElement('div');
	      document.body.appendChild(this.dropdownContainer);
	    }
	    return this.dropdownContainer;
	  },
	  getSearchPlaceholderElement: function getSearchPlaceholderElement(hidden) {
	    var props = this.props;
	    var placeholder = void 0;
	    if ((0, _util.isMultipleOrTagsOrCombobox)(props)) {
	      placeholder = props.placeholder || props.searchPlaceholder;
	    } else {
	      placeholder = props.searchPlaceholder;
	    }
	    if (placeholder) {
	      return _react2["default"].createElement(
	        'div',
	        _extends({
	          onMouseDown: _util.preventDefaultEvent,
	          style: _extends({
	            display: hidden ? 'none' : 'block'
	          }, _util.UNSELECTABLE_STYLE)
	        }, _util.UNSELECTABLE_ATTRIBUTE, {
	          onClick: this.onPlaceholderClick,
	          className: props.prefixCls + '-search__field__placeholder'
	        }),
	        placeholder
	      );
	    }
	    return null;
	  },
	  getInputElement: function getInputElement() {
	    var props = this.props;
	    var shouldShowPlaceholder = (0, _util.isMultipleOrTags)(props) || props.showSearch;
	    return _react2["default"].createElement(
	      'div',
	      { className: props.prefixCls + '-search__field__wrap' },
	      _react2["default"].createElement('input', {
	        ref: this.saveInputRef,
	        onChange: this.onInputChange,
	        onKeyDown: this.onInputKeyDown,
	        value: this.state.inputValue,
	        disabled: props.disabled,
	        className: props.prefixCls + '-search__field'
	      }),
	      shouldShowPlaceholder ? null : this.getSearchPlaceholderElement(!!this.state.inputValue)
	    );
	  },
	  getInputDOMNode: function getInputDOMNode() {
	    return this.inputInstance;
	  },
	  getPopupDOMNode: function getPopupDOMNode() {
	    return this.refs.trigger.getPopupDOMNode();
	  },
	  getPopupMenuComponent: function getPopupMenuComponent() {
	    return this.refs.trigger.getInnerMenu();
	  },
	  setOpenState: function setOpenState(open, needFocus) {
	    var _this2 = this;

	    var props = this.props;
	    var state = this.state;

	    if (state.open === open) {
	      this.maybeFocus(open, needFocus);
	      return;
	    }
	    var nextState = {
	      open: open
	    };
	    // clear search input value when open is false in singleMode.
	    if (!open && (0, _util.isSingleMode)(props) && props.showSearch) {
	      nextState.inputValue = '';
	    }
	    if (!open) {
	      this.maybeFocus(open, needFocus);
	    }
	    this.setState(nextState, function () {
	      if (open) {
	        _this2.maybeFocus(open, needFocus);
	      }
	    });
	  },
	  updateFocusClassName: function updateFocusClassName() {
	    var refs = this.refs;
	    var props = this.props;
	    // avoid setState and its side effect

	    if (this._focused || this.state.open) {
	      (0, _componentClasses2["default"])(refs.root).add(props.prefixCls + '-focused');
	    } else {
	      (0, _componentClasses2["default"])(refs.root).remove(props.prefixCls + '-focused');
	    }
	  },
	  maybeFocus: function maybeFocus(open, needFocus) {
	    if (needFocus || open) {
	      var input = this.getInputDOMNode();
	      var _document = document;
	      var activeElement = _document.activeElement;

	      if (input && (open || (0, _util.isMultipleOrTagsOrCombobox)(this.props))) {
	        if (activeElement !== input) {
	          input.focus();
	        }
	      } else {
	        var selection = this.refs.selection;
	        if (activeElement !== selection) {
	          selection.focus();
	        }
	      }
	    }
	  },
	  addLabelToValue: function addLabelToValue(props, value_) {
	    var _this3 = this;

	    var value = value_;
	    if (props.labelInValue) {
	      value.forEach(function (v) {
	        v.label = v.label || _this3.getLabelFromProps(props, v.key);
	      });
	    } else {
	      value = value.map(function (v) {
	        return {
	          key: v,
	          label: _this3.getLabelFromProps(props, v)
	        };
	      });
	    }
	    return value;
	  },
	  removeSelected: function removeSelected(selectedKey) {
	    var props = this.props;
	    if (props.disabled) {
	      return;
	    }
	    var label = void 0;
	    var value = this.state.value.filter(function (singleValue) {
	      if (singleValue.key === selectedKey) {
	        label = singleValue.label;
	      }
	      return singleValue.key !== selectedKey;
	    });
	    var canMultiple = (0, _util.isMultipleOrTags)(props);

	    if (canMultiple) {
	      var event = selectedKey;
	      if (props.labelInValue) {
	        event = {
	          key: selectedKey,
	          label: label
	        };
	      }
	      props.onDeselect(event);
	    }
	    this.fireChange(value);
	  },
	  openIfHasChildren: function openIfHasChildren() {
	    var props = this.props;
	    if (_react2["default"].Children.count(props.children) || (0, _util.isSingleMode)(props)) {
	      this.setOpenState(true);
	    }
	  },
	  fireChange: function fireChange(value) {
	    var props = this.props;
	    if (!('value' in props)) {
	      this.setState({
	        value: value
	      });
	    }
	    props.onChange(this.getVLForOnChange(value));
	  },
	  renderTopControlNode: function renderTopControlNode() {
	    var _this4 = this;

	    var _state = this.state;
	    var value = _state.value;
	    var open = _state.open;
	    var inputValue = _state.inputValue;

	    var props = this.props;
	    var choiceTransitionName = props.choiceTransitionName;
	    var prefixCls = props.prefixCls;
	    var maxTagTextLength = props.maxTagTextLength;
	    var showSearch = props.showSearch;
	    // search input is inside topControlNode in single, multiple & combobox. 2016/04/13

	    if ((0, _util.isSingleMode)(props)) {
	      var innerNode = null;
	      var selectedValue = null;
	      if (!value.length) {
	        selectedValue = _react2["default"].createElement(
	          'div',
	          {
	            key: 'placeholder',
	            className: prefixCls + '-selection__placeholder'
	          },
	          props.placeholder
	        );
	      } else {
	        selectedValue = _react2["default"].createElement(
	          'div',
	          { key: 'value', className: prefixCls + '-selection-selected-value' },
	          value[0].label
	        );
	      }
	      if (!showSearch || !open) {
	        innerNode = selectedValue;
	      } else {
	        innerNode = _react2["default"].createElement(
	          'div',
	          {
	            className: prefixCls + '-search ' + prefixCls + '-search--inline',
	            key: 'input'
	          },
	          !!inputValue ? null : selectedValue,
	          this.getInputElement()
	        );
	      }
	      return _react2["default"].createElement(
	        'div',
	        { className: prefixCls + '-selection__rendered' },
	        innerNode
	      );
	    }

	    var selectedValueNodes = [];
	    if ((0, _util.isMultipleOrTags)(props)) {
	      selectedValueNodes = value.map(function (singleValue) {
	        var content = singleValue.label;
	        var title = content;
	        if (maxTagTextLength && typeof content === 'string' && content.length > maxTagTextLength) {
	          content = content.slice(0, maxTagTextLength) + '...';
	        }
	        return _react2["default"].createElement(
	          'li',
	          _extends({
	            style: _util.UNSELECTABLE_STYLE
	          }, _util.UNSELECTABLE_ATTRIBUTE, {
	            onMouseDown: _util.preventDefaultEvent,
	            className: prefixCls + '-selection__choice',
	            key: singleValue.key,
	            title: title
	          }),
	          _react2["default"].createElement(
	            'div',
	            { className: prefixCls + '-selection__choice__content' },
	            content
	          ),
	          _react2["default"].createElement('span', {
	            className: prefixCls + '-selection__choice__remove',
	            onClick: _this4.removeSelected.bind(_this4, singleValue.key)
	          })
	        );
	      });
	    }
	    selectedValueNodes.push(_react2["default"].createElement(
	      'li',
	      {
	        className: prefixCls + '-search ' + prefixCls + '-search--inline',
	        key: '__input'
	      },
	      this.getInputElement()
	    ));
	    var className = prefixCls + '-selection__rendered';
	    if ((0, _util.isMultipleOrTags)(props) && choiceTransitionName) {
	      return _react2["default"].createElement(
	        _rcAnimate2["default"],
	        {
	          className: className,
	          component: 'ul',
	          transitionName: choiceTransitionName
	        },
	        selectedValueNodes
	      );
	    }
	    return _react2["default"].createElement(
	      'ul',
	      { className: className },
	      selectedValueNodes
	    );
	  },
	  render: function render() {
	    var _rootCls;

	    var props = this.props;
	    var multiple = (0, _util.isMultipleOrTags)(props);
	    var state = this.state;
	    var className = props.className;
	    var disabled = props.disabled;
	    var allowClear = props.allowClear;
	    var prefixCls = props.prefixCls;

	    var ctrlNode = this.renderTopControlNode();
	    var extraSelectionProps = {};
	    var open = this.state.open;

	    var options = [];
	    if (open) {
	      options = this.renderFilterOptions();
	    }
	    if (open && ((0, _util.isMultipleOrTagsOrCombobox)(props) || !props.showSearch) && !options.length) {
	      open = false;
	    }
	    if (!(0, _util.isMultipleOrTagsOrCombobox)(props)) {
	      extraSelectionProps = {
	        onKeyDown: this.onKeyDown,
	        tabIndex: 0
	      };
	    }
	    var rootCls = (_rootCls = {}, _defineProperty(_rootCls, className, !!className), _defineProperty(_rootCls, prefixCls, 1), _defineProperty(_rootCls, prefixCls + '-open', open), _defineProperty(_rootCls, prefixCls + '-focused', open || !!this._focused), _defineProperty(_rootCls, prefixCls + '-combobox', (0, _util.isCombobox)(props)), _defineProperty(_rootCls, prefixCls + '-disabled', disabled), _defineProperty(_rootCls, prefixCls + '-enabled', !disabled), _rootCls);

	    var clear = _react2["default"].createElement('span', _extends({
	      key: 'clear',
	      onMouseDown: _util.preventDefaultEvent,
	      style: _util.UNSELECTABLE_STYLE
	    }, _util.UNSELECTABLE_ATTRIBUTE, {
	      className: prefixCls + '-selection__clear',
	      onClick: this.onClearSelection
	    }));
	    return _react2["default"].createElement(
	      _SelectTrigger2["default"],
	      {
	        onPopupFocus: this.onPopupFocus,
	        dropdownAlign: props.dropdownAlign,
	        dropdownClassName: props.dropdownClassName,
	        dropdownMatchSelectWidth: props.dropdownMatchSelectWidth,
	        defaultActiveFirstOption: props.defaultActiveFirstOption,
	        dropdownMenuStyle: props.dropdownMenuStyle,
	        transitionName: props.transitionName,
	        animation: props.animation,
	        prefixCls: props.prefixCls,
	        dropdownStyle: props.dropdownStyle,
	        combobox: props.combobox,
	        showSearch: props.showSearch,
	        options: options,
	        multiple: multiple,
	        disabled: disabled,
	        visible: open,
	        inputValue: state.inputValue,
	        value: state.value,
	        onDropdownVisibleChange: this.onDropdownVisibleChange,
	        getPopupContainer: props.getPopupContainer,
	        onMenuSelect: this.onMenuSelect,
	        onMenuDeselect: this.onMenuDeselect,
	        ref: 'trigger'
	      },
	      _react2["default"].createElement(
	        'div',
	        {
	          style: props.style,
	          ref: 'root',
	          onBlur: this.onOuterBlur,
	          onFocus: this.onOuterFocus,
	          className: (0, _classnames2["default"])(rootCls)
	        },
	        _react2["default"].createElement(
	          'div',
	          _extends({
	            ref: 'selection',
	            key: 'selection',
	            className: prefixCls + '-selection\n            ' + prefixCls + '-selection--' + (multiple ? 'multiple' : 'single'),
	            role: 'combobox',
	            'aria-autocomplete': 'list',
	            'aria-haspopup': 'true',
	            'aria-expanded': open
	          }, extraSelectionProps),
	          ctrlNode,
	          allowClear && !multiple ? clear : null,
	          multiple || !props.showArrow ? null : _react2["default"].createElement(
	            'span',
	            _extends({
	              key: 'arrow',
	              className: prefixCls + '-arrow',
	              style: _util.UNSELECTABLE_STYLE
	            }, _util.UNSELECTABLE_ATTRIBUTE, {
	              onMouseDown: _util.preventDefaultEvent,
	              onClick: this.onArrowClick
	            }),
	            _react2["default"].createElement('b', null)
	          ),
	          multiple ? this.getSearchPlaceholderElement(!!this.state.inputValue || this.state.value.length) : null
	        )
	      )
	    );
	  }
	});

	exports["default"] = Select;
	module.exports = exports['default'];

/***/ },
/* 579 */
/***/ function(module, exports, __webpack_require__, __webpack_module_template_argument_0__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.UNSELECTABLE_ATTRIBUTE = exports.UNSELECTABLE_STYLE = undefined;
	exports.getValuePropValue = getValuePropValue;
	exports.getPropValue = getPropValue;
	exports.isCombobox = isCombobox;
	exports.isMultipleOrTags = isMultipleOrTags;
	exports.isMultipleOrTagsOrCombobox = isMultipleOrTagsOrCombobox;
	exports.isSingleMode = isSingleMode;
	exports.toArray = toArray;
	exports.preventDefaultEvent = preventDefaultEvent;
	exports.findIndexInValueByKey = findIndexInValueByKey;
	exports.getSelectKeys = getSelectKeys;

	var _rcMenu = __webpack_require__(__webpack_module_template_argument_0__);

	var _react = __webpack_require__(7);

	var _react2 = _interopRequireDefault(_react);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

	function getValuePropValue(child) {
	  var props = child.props;
	  if ('value' in props) {
	    return props.value;
	  }
	  if (child.key) {
	    return child.key;
	  }
	  throw new Error('no key or value for ' + child);
	}

	function getPropValue(child, prop) {
	  if (prop === 'value') {
	    return getValuePropValue(child);
	  }
	  return child.props[prop];
	}

	function isCombobox(props) {
	  return props.combobox;
	}

	function isMultipleOrTags(props) {
	  return props.multiple || props.tags;
	}

	function isMultipleOrTagsOrCombobox(props) {
	  return isMultipleOrTags(props) || isCombobox(props);
	}

	function isSingleMode(props) {
	  return !isMultipleOrTagsOrCombobox(props);
	}

	function toArray(value) {
	  var ret = value;
	  if (value === undefined) {
	    ret = [];
	  } else if (!Array.isArray(value)) {
	    ret = [value];
	  }
	  return ret;
	}

	function preventDefaultEvent(e) {
	  e.preventDefault();
	}

	function findIndexInValueByKey(value, key) {
	  var index = -1;
	  for (var i = 0; i < value.length; i++) {
	    if (value[i].key === key) {
	      index = i;
	      break;
	    }
	  }
	  return index;
	}

	function getSelectKeys(menuItems, value) {
	  if (value === null || value === undefined) {
	    return [];
	  }
	  var selectedKeys = [];
	  _react2["default"].Children.forEach(menuItems, function (item) {
	    if (item.type === _rcMenu.ItemGroup) {
	      selectedKeys = selectedKeys.concat(getSelectKeys(item.props.children, value));
	    } else {
	      var itemValue = getValuePropValue(item);
	      var itemKey = item.key;
	      if (findIndexInValueByKey(value, itemValue) !== -1 && itemKey) {
	        selectedKeys.push(itemKey);
	      }
	    }
	  });
	  return selectedKeys;
	}

	var UNSELECTABLE_STYLE = exports.UNSELECTABLE_STYLE = {
	  userSelect: 'none',
	  WebkitUserSelect: 'none'
	};

	var UNSELECTABLE_ATTRIBUTE = exports.UNSELECTABLE_ATTRIBUTE = {
	  unselectable: 'unselectable'
	};

/***/ },
/* 580 */
/***/ function(module, exports, __webpack_require__, __webpack_module_template_argument_0__, __webpack_module_template_argument_1__, __webpack_module_template_argument_2__, __webpack_module_template_argument_3__, __webpack_module_template_argument_4__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.Divider = exports.ItemGroup = exports.MenuItemGroup = exports.MenuItem = exports.Item = exports.SubMenu = undefined;

	var _Menu = __webpack_require__(__webpack_module_template_argument_0__);

	var _Menu2 = _interopRequireDefault(_Menu);

	var _SubMenu = __webpack_require__(__webpack_module_template_argument_1__);

	var _SubMenu2 = _interopRequireDefault(_SubMenu);

	var _MenuItem = __webpack_require__(__webpack_module_template_argument_2__);

	var _MenuItem2 = _interopRequireDefault(_MenuItem);

	var _MenuItemGroup = __webpack_require__(__webpack_module_template_argument_3__);

	var _MenuItemGroup2 = _interopRequireDefault(_MenuItemGroup);

	var _Divider = __webpack_require__(__webpack_module_template_argument_4__);

	var _Divider2 = _interopRequireDefault(_Divider);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

	exports.SubMenu = _SubMenu2["default"];
	exports.Item = _MenuItem2["default"];
	exports.MenuItem = _MenuItem2["default"];
	exports.MenuItemGroup = _MenuItemGroup2["default"];
	exports.ItemGroup = _MenuItemGroup2["default"];
	exports.Divider = _Divider2["default"];
	exports["default"] = _Menu2["default"];

/***/ },
/* 581 */
/***/ function(module, exports, __webpack_require__, __webpack_module_template_argument_0__, __webpack_module_template_argument_1__, __webpack_module_template_argument_2__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _react = __webpack_require__(7);

	var _react2 = _interopRequireDefault(_react);

	var _MenuMixin = __webpack_require__(__webpack_module_template_argument_0__);

	var _MenuMixin2 = _interopRequireDefault(_MenuMixin);

	var _objectAssign = __webpack_require__(__webpack_module_template_argument_1__);

	var _objectAssign2 = _interopRequireDefault(_objectAssign);

	var _util = __webpack_require__(__webpack_module_template_argument_2__);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

	var Menu = _react2["default"].createClass({
	  displayName: 'Menu',

	  propTypes: {
	    openSubMenuOnMouseEnter: _react.PropTypes.bool,
	    closeSubMenuOnMouseLeave: _react.PropTypes.bool,
	    selectedKeys: _react.PropTypes.arrayOf(_react.PropTypes.string),
	    defaultSelectedKeys: _react.PropTypes.arrayOf(_react.PropTypes.string),
	    defaultOpenKeys: _react.PropTypes.arrayOf(_react.PropTypes.string),
	    openKeys: _react.PropTypes.arrayOf(_react.PropTypes.string),
	    mode: _react.PropTypes.string,
	    onClick: _react.PropTypes.func,
	    onSelect: _react.PropTypes.func,
	    onDeselect: _react.PropTypes.func,
	    onDestroy: _react.PropTypes.func,
	    openTransitionName: _react.PropTypes.string,
	    openAnimation: _react.PropTypes.oneOfType([_react.PropTypes.string, _react.PropTypes.object]),
	    level: _react.PropTypes.number,
	    eventKey: _react.PropTypes.string,
	    selectable: _react.PropTypes.bool,
	    children: _react.PropTypes.any
	  },

	  mixins: [_MenuMixin2["default"]],

	  getDefaultProps: function getDefaultProps() {
	    return {
	      openSubMenuOnMouseEnter: true,
	      closeSubMenuOnMouseLeave: true,
	      selectable: true,
	      onClick: _util.noop,
	      onSelect: _util.noop,
	      onOpen: _util.noop,
	      onClose: _util.noop,
	      onDeselect: _util.noop,
	      defaultSelectedKeys: [],
	      defaultOpenKeys: []
	    };
	  },
	  getInitialState: function getInitialState() {
	    var props = this.props;
	    var selectedKeys = props.defaultSelectedKeys;
	    var openKeys = props.defaultOpenKeys;
	    if ('selectedKeys' in props) {
	      selectedKeys = props.selectedKeys || [];
	    }
	    if ('openKeys' in props) {
	      openKeys = props.openKeys || [];
	    }
	    return {
	      selectedKeys: selectedKeys, openKeys: openKeys
	    };
	  },
	  componentWillReceiveProps: function componentWillReceiveProps(nextProps) {
	    var props = {};
	    if ('selectedKeys' in nextProps) {
	      props.selectedKeys = nextProps.selectedKeys;
	    }
	    if ('openKeys' in nextProps) {
	      props.openKeys = nextProps.openKeys;
	    }
	    this.setState(props);
	  },
	  onDestroy: function onDestroy(key) {
	    var state = this.state;
	    var props = this.props;
	    var selectedKeys = state.selectedKeys;
	    var openKeys = state.openKeys;
	    var index = selectedKeys.indexOf(key);
	    if (!('selectedKeys' in props) && index !== -1) {
	      selectedKeys.splice(index, 1);
	    }
	    index = openKeys.indexOf(key);
	    if (!('openKeys' in props) && index !== -1) {
	      openKeys.splice(index, 1);
	    }
	  },
	  onItemHover: function onItemHover(e) {
	    var _this = this;

	    var item = e.item;
	    // special for top sub menu

	    if (this.props.mode !== 'inline' && !this.props.closeSubMenuOnMouseLeave && item.isSubMenu) {
	      (function () {
	        var activeKey = _this.state.activeKey;
	        var activeItem = _this.getFlatInstanceArray().filter(function (c) {
	          return c && c.props.eventKey === activeKey;
	        })[0];
	        if (activeItem && activeItem.props.open) {
	          _this.onOpenChange({
	            key: item.props.eventKey,
	            item: e.item,
	            open: true
	          });
	        }
	      })();
	    }

	    this.onCommonItemHover(e);
	  },
	  onSelect: function onSelect(selectInfo) {
	    var props = this.props;
	    if (props.selectable) {
	      // root menu
	      var selectedKeys = this.state.selectedKeys;
	      var selectedKey = selectInfo.key;
	      if (props.multiple) {
	        selectedKeys = selectedKeys.concat([selectedKey]);
	      } else {
	        selectedKeys = [selectedKey];
	      }
	      if (!('selectedKeys' in props)) {
	        this.setState({
	          selectedKeys: selectedKeys
	        });
	      }
	      props.onSelect((0, _objectAssign2["default"])({}, selectInfo, {
	        selectedKeys: selectedKeys
	      }));
	    }
	  },
	  onClick: function onClick(e) {
	    var props = this.props;
	    props.onClick(e);
	  },
	  onOpenChange: function onOpenChange(e) {
	    var props = this.props;
	    var openKeys = this.state.openKeys;
	    var changed = true;
	    if (e.open) {
	      changed = openKeys.indexOf(e.key) === -1;
	      if (changed) {
	        openKeys = openKeys.concat(e.key);
	      }
	    } else {
	      var index = openKeys.indexOf(e.key);
	      changed = index !== -1;
	      if (changed) {
	        openKeys = openKeys.concat();
	        openKeys.splice(index, 1);
	      }
	    }
	    if (changed) {
	      // hack, synchronous call from onTitleMouseEnter
	      this.state.openKeys = openKeys;
	      if (!('openKeys' in this.props)) {
	        // hack: batch does not update state
	        this.setState({ openKeys: openKeys });
	      }
	      var info = (0, _objectAssign2["default"])({ openKeys: openKeys }, e);
	      if (e.open) {
	        props.onOpen(info);
	      } else {
	        props.onClose(info);
	      }
	    }
	  },
	  onDeselect: function onDeselect(selectInfo) {
	    var props = this.props;
	    if (props.selectable) {
	      var selectedKeys = this.state.selectedKeys.concat();
	      var selectedKey = selectInfo.key;
	      var index = selectedKeys.indexOf(selectedKey);
	      if (index !== -1) {
	        selectedKeys.splice(index, 1);
	      }
	      if (!('selectedKeys' in props)) {
	        this.setState({
	          selectedKeys: selectedKeys
	        });
	      }
	      props.onDeselect((0, _objectAssign2["default"])({}, selectInfo, {
	        selectedKeys: selectedKeys
	      }));
	    }
	  },
	  getOpenTransitionName: function getOpenTransitionName() {
	    var props = this.props;
	    var transitionName = props.openTransitionName;
	    var animationName = props.openAnimation;
	    if (!transitionName && typeof animationName === 'string') {
	      transitionName = props.prefixCls + '-open-' + animationName;
	    }
	    return transitionName;
	  },
	  isInlineMode: function isInlineMode() {
	    return this.props.mode === 'inline';
	  },
	  lastOpenSubMenu: function lastOpenSubMenu() {
	    var _this2 = this;

	    var lastOpen = [];
	    if (this.state.openKeys.length) {
	      lastOpen = this.getFlatInstanceArray().filter(function (c) {
	        return c && _this2.state.openKeys.indexOf(c.props.eventKey) !== -1;
	      });
	    }
	    return lastOpen[0];
	  },
	  renderMenuItem: function renderMenuItem(c, i, subIndex) {
	    if (!c) return null;
	    var key = (0, _util.getKeyFromChildrenIndex)(c, this.props.eventKey, i);
	    var state = this.state;
	    var extraProps = {
	      openKeys: state.openKeys,
	      open: state.openKeys.indexOf(key) !== -1,
	      selectedKeys: state.selectedKeys,
	      selected: state.selectedKeys.indexOf(key) !== -1,
	      openSubMenuOnMouseEnter: this.props.openSubMenuOnMouseEnter
	    };
	    return this.renderCommonMenuItem(c, i, subIndex, extraProps);
	  },
	  render: function render() {
	    var props = (0, _objectAssign2["default"])({}, this.props);
	    props.className += ' ' + props.prefixCls + '-root';
	    return this.renderRoot(props);
	  }
	});

	exports["default"] = Menu;
	module.exports = exports['default'];

/***/ },
/* 582 */
/***/ function(module, exports, __webpack_require__, __webpack_module_template_argument_0__, __webpack_module_template_argument_1__, __webpack_module_template_argument_2__, __webpack_module_template_argument_3__, __webpack_module_template_argument_4__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

	var _react = __webpack_require__(7);

	var _react2 = _interopRequireDefault(_react);

	var _reactDom = __webpack_require__(8);

	var _reactDom2 = _interopRequireDefault(_reactDom);

	var _rcUtil = __webpack_require__(__webpack_module_template_argument_0__);

	var _classnames = __webpack_require__(19);

	var _classnames2 = _interopRequireDefault(_classnames);

	var _domScrollIntoView = __webpack_require__(__webpack_module_template_argument_1__);

	var _domScrollIntoView2 = _interopRequireDefault(_domScrollIntoView);

	var _objectAssign = __webpack_require__(__webpack_module_template_argument_2__);

	var _objectAssign2 = _interopRequireDefault(_objectAssign);

	var _util = __webpack_require__(__webpack_module_template_argument_3__);

	var _DOMWrap = __webpack_require__(__webpack_module_template_argument_4__);

	var _DOMWrap2 = _interopRequireDefault(_DOMWrap);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

	function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

	function allDisabled(arr) {
	  if (!arr.length) {
	    return true;
	  }
	  return arr.every(function (c) {
	    return !!c.props.disabled;
	  });
	}

	function getActiveKey(props, originalActiveKey) {
	  var activeKey = originalActiveKey;
	  var children = props.children;
	  var eventKey = props.eventKey;
	  if (activeKey) {
	    var found = void 0;
	    (0, _util.loopMenuItem)(children, function (c, i) {
	      if (!c.props.disabled && activeKey === (0, _util.getKeyFromChildrenIndex)(c, eventKey, i)) {
	        found = true;
	      }
	    });
	    if (found) {
	      return activeKey;
	    }
	  }
	  activeKey = null;
	  if (props.defaultActiveFirst) {
	    (0, _util.loopMenuItem)(children, function (c, i) {
	      if (!activeKey && !c.props.disabled) {
	        activeKey = (0, _util.getKeyFromChildrenIndex)(c, eventKey, i);
	      }
	    });
	    return activeKey;
	  }
	  return activeKey;
	}

	function saveRef(index, subIndex, c) {
	  if (c) {
	    if (subIndex !== undefined) {
	      this.instanceArray[index] = this.instanceArray[index] || [];
	      this.instanceArray[index][subIndex] = c;
	    } else {
	      this.instanceArray[index] = c;
	    }
	  }
	}

	var MenuMixin = {
	  propTypes: {
	    focusable: _react.PropTypes.bool,
	    multiple: _react.PropTypes.bool,
	    style: _react.PropTypes.object,
	    defaultActiveFirst: _react.PropTypes.bool,
	    visible: _react.PropTypes.bool,
	    activeKey: _react.PropTypes.string,
	    selectedKeys: _react.PropTypes.arrayOf(_react.PropTypes.string),
	    defaultSelectedKeys: _react.PropTypes.arrayOf(_react.PropTypes.string),
	    defaultOpenKeys: _react.PropTypes.arrayOf(_react.PropTypes.string),
	    openKeys: _react.PropTypes.arrayOf(_react.PropTypes.string),
	    children: _react.PropTypes.any
	  },

	  getDefaultProps: function getDefaultProps() {
	    return {
	      prefixCls: 'rc-menu',
	      className: '',
	      mode: 'vertical',
	      level: 1,
	      inlineIndent: 24,
	      visible: true,
	      focusable: true,
	      style: {}
	    };
	  },
	  getInitialState: function getInitialState() {
	    var props = this.props;
	    return {
	      activeKey: getActiveKey(props, props.activeKey)
	    };
	  },
	  componentWillReceiveProps: function componentWillReceiveProps(nextProps) {
	    var props = void 0;
	    if ('activeKey' in nextProps) {
	      props = {
	        activeKey: getActiveKey(nextProps, nextProps.activeKey)
	      };
	    } else {
	      var originalActiveKey = this.state.activeKey;
	      var activeKey = getActiveKey(nextProps, originalActiveKey);
	      // fix: this.setState(), parent.render(),
	      if (activeKey !== originalActiveKey) {
	        props = {
	          activeKey: activeKey
	        };
	      }
	    }
	    if (props) {
	      this.setState(props);
	    }
	  },
	  shouldComponentUpdate: function shouldComponentUpdate(nextProps) {
	    return this.props.visible || nextProps.visible;
	  },
	  componentWillMount: function componentWillMount() {
	    this.instanceArray = [];
	  },


	  // all keyboard events callbacks run from here at first
	  onKeyDown: function onKeyDown(e) {
	    var _this = this;

	    var keyCode = e.keyCode;
	    var handled = void 0;
	    this.getFlatInstanceArray().forEach(function (obj) {
	      if (obj && obj.props.active) {
	        handled = obj.onKeyDown(e);
	      }
	    });
	    if (handled) {
	      return 1;
	    }
	    var activeItem = null;
	    if (keyCode === _rcUtil.KeyCode.UP || keyCode === _rcUtil.KeyCode.DOWN) {
	      activeItem = this.step(keyCode === _rcUtil.KeyCode.UP ? -1 : 1);
	    }
	    if (activeItem) {
	      e.preventDefault();
	      this.setState({
	        activeKey: activeItem.props.eventKey
	      }, function () {
	        (0, _domScrollIntoView2["default"])(_reactDom2["default"].findDOMNode(activeItem), _reactDom2["default"].findDOMNode(_this), {
	          onlyScrollIfNeeded: true
	        });
	      });
	      return 1;
	    } else if (activeItem === undefined) {
	      e.preventDefault();
	      this.setState({
	        activeKey: null
	      });
	      return 1;
	    }
	  },
	  onCommonItemHover: function onCommonItemHover(e) {
	    var mode = this.props.mode;
	    var key = e.key;
	    var hover = e.hover;
	    var trigger = e.trigger;

	    var activeKey = this.state.activeKey;
	    if (!trigger || hover || this.props.closeSubMenuOnMouseLeave || !e.item.isSubMenu || mode === 'inline') {
	      this.setState({
	        activeKey: hover ? key : null
	      });
	    } else {}
	    // keep active for sub menu for click active
	    // empty

	    // clear last open status
	    if (hover && mode !== 'inline') {
	      var activeItem = this.getFlatInstanceArray().filter(function (c) {
	        return c && c.props.eventKey === activeKey;
	      })[0];
	      if (activeItem && activeItem.isSubMenu && activeItem.props.eventKey !== key) {
	        this.onOpenChange({
	          item: activeItem,
	          key: activeItem.props.eventKey,
	          open: false
	        });
	      }
	    }
	  },
	  getFlatInstanceArray: function getFlatInstanceArray() {
	    var instanceArray = this.instanceArray;
	    var hasInnerArray = instanceArray.some(function (a) {
	      return Array.isArray(a);
	    });
	    if (hasInnerArray) {
	      instanceArray = [];
	      this.instanceArray.forEach(function (a) {
	        if (Array.isArray(a)) {
	          instanceArray.push.apply(instanceArray, a);
	        } else {
	          instanceArray.push(a);
	        }
	      });
	      this.instanceArray = instanceArray;
	    }
	    return instanceArray;
	  },
	  renderCommonMenuItem: function renderCommonMenuItem(child, i, subIndex, extraProps) {
	    var state = this.state;
	    var props = this.props;
	    var key = (0, _util.getKeyFromChildrenIndex)(child, props.eventKey, i);
	    var childProps = child.props;
	    var isActive = key === state.activeKey;
	    var newChildProps = (0, _objectAssign2["default"])({
	      mode: props.mode,
	      level: props.level,
	      inlineIndent: props.inlineIndent,
	      renderMenuItem: this.renderMenuItem,
	      rootPrefixCls: props.prefixCls,
	      index: i,
	      parentMenu: this,
	      ref: childProps.disabled ? undefined : (0, _rcUtil.createChainedFunction)(child.ref, saveRef.bind(this, i, subIndex)),
	      eventKey: key,
	      closeSubMenuOnMouseLeave: props.closeSubMenuOnMouseLeave,
	      onItemHover: this.onItemHover,
	      active: !childProps.disabled && isActive,
	      multiple: props.multiple,
	      onClick: this.onClick,
	      openTransitionName: this.getOpenTransitionName(),
	      openAnimation: props.openAnimation,
	      onOpenChange: this.onOpenChange,
	      onDeselect: this.onDeselect,
	      onDestroy: this.onDestroy,
	      onSelect: this.onSelect
	    }, extraProps);
	    if (props.mode === 'inline') {
	      newChildProps.closeSubMenuOnMouseLeave = newChildProps.openSubMenuOnMouseEnter = false;
	    }
	    return _react2["default"].cloneElement(child, newChildProps);
	  },
	  renderRoot: function renderRoot(props) {
	    var _classes;

	    this.instanceArray = [];
	    var classes = (_classes = {}, _defineProperty(_classes, props.prefixCls, 1), _defineProperty(_classes, props.prefixCls + '-' + props.mode, 1), _defineProperty(_classes, props.className, !!props.className), _classes);
	    var domProps = {
	      className: (0, _classnames2["default"])(classes),
	      role: 'menu',
	      'aria-activedescendant': ''
	    };
	    if (props.id) {
	      domProps.id = props.id;
	    }
	    if (props.focusable) {
	      domProps.tabIndex = '0';
	      domProps.onKeyDown = this.onKeyDown;
	    }
	    return(
	      // ESLint is not smart enough to know that the type of `children` was checked.
	      /* eslint-disable */
	      _react2["default"].createElement(
	        _DOMWrap2["default"],
	        _extends({ style: props.style,
	          tag: 'ul',
	          hiddenClassName: props.prefixCls + '-hidden',
	          visible: props.visible
	        }, domProps),
	        _react2["default"].Children.map(props.children, this.renderMenuItem)
	      )
	      /*eslint-enable */

	    );
	  },
	  step: function step(direction) {
	    var children = this.getFlatInstanceArray();
	    var activeKey = this.state.activeKey;
	    var len = children.length;
	    if (!len) {
	      return null;
	    }
	    if (direction < 0) {
	      children = children.concat().reverse();
	    }
	    // find current activeIndex
	    var activeIndex = -1;
	    children.every(function (c, ci) {
	      if (c && c.props.eventKey === activeKey) {
	        activeIndex = ci;
	        return false;
	      }
	      return true;
	    });
	    if (!this.props.defaultActiveFirst && activeIndex !== -1) {
	      if (allDisabled(children.slice(activeIndex, len - 1))) {
	        return undefined;
	      }
	    }
	    var start = (activeIndex + 1) % len;
	    var i = start;
	    for (;;) {
	      var child = children[i];
	      if (!child || child.props.disabled) {
	        i = (i + 1 + len) % len;
	        // complete a loop
	        if (i === start) {
	          return null;
	        }
	      } else {
	        return child;
	      }
	    }
	  }
	};

	exports["default"] = MenuMixin;
	module.exports = exports['default'];

/***/ },
/* 583 */
/***/ function(module, exports, __webpack_require__, __webpack_module_template_argument_0__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _react = __webpack_require__(7);

	var _react2 = _interopRequireDefault(_react);

	var _objectAssign = __webpack_require__(__webpack_module_template_argument_0__);

	var _objectAssign2 = _interopRequireDefault(_objectAssign);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

	var DOMWrap = _react2["default"].createClass({
	  displayName: 'DOMWrap',

	  propTypes: {
	    tag: _react.PropTypes.string
	  },

	  getDefaultProps: function getDefaultProps() {
	    return {
	      tag: 'div'
	    };
	  },
	  render: function render() {
	    var props = (0, _objectAssign2["default"])({}, this.props);
	    if (!props.visible) {
	      props.className = props.className || '';
	      props.className += ' ' + props.hiddenClassName;
	    }
	    var Tag = props.tag;
	    return _react2["default"].createElement(Tag, props);
	  }
	});

	exports["default"] = DOMWrap;
	module.exports = exports['default'];

/***/ },
/* 584 */
/***/ function(module, exports, __webpack_require__, __webpack_module_template_argument_0__, __webpack_module_template_argument_1__, __webpack_module_template_argument_2__, __webpack_module_template_argument_3__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

	var _SubPopupMenu = __webpack_require__(__webpack_module_template_argument_0__);

	var _SubPopupMenu2 = _interopRequireDefault(_SubPopupMenu);

	var _react = __webpack_require__(7);

	var _react2 = _interopRequireDefault(_react);

	var _rcUtil = __webpack_require__(__webpack_module_template_argument_1__);

	var _classnames = __webpack_require__(19);

	var _classnames2 = _interopRequireDefault(_classnames);

	var _util = __webpack_require__(__webpack_module_template_argument_2__);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

	function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

	/* eslint react/no-is-mounted:0 */

	var SubMenu = _react2["default"].createClass({
	  displayName: 'SubMenu',

	  propTypes: {
	    parentMenu: _react.PropTypes.object,
	    title: _react.PropTypes.node,
	    onClick: _react.PropTypes.func,
	    onOpenChange: _react.PropTypes.func,
	    rootPrefixCls: _react.PropTypes.string,
	    eventKey: _react.PropTypes.string,
	    multiple: _react.PropTypes.bool,
	    active: _react.PropTypes.bool,
	    open: _react.PropTypes.bool,
	    onSelect: _react.PropTypes.func,
	    closeSubMenuOnMouseLeave: _react.PropTypes.bool,
	    openSubMenuOnMouseEnter: _react.PropTypes.bool,
	    onDeselect: _react.PropTypes.func,
	    onDestroy: _react.PropTypes.func,
	    onItemHover: _react.PropTypes.func,
	    onMouseEnter: _react.PropTypes.func,
	    onMouseLeave: _react.PropTypes.func,
	    onTitleMouseEnter: _react.PropTypes.func,
	    onTitleMouseLeave: _react.PropTypes.func,
	    onTitleClick: _react.PropTypes.func
	  },

	  mixins: [__webpack_require__(__webpack_module_template_argument_3__)],

	  getDefaultProps: function getDefaultProps() {
	    return {
	      onMouseEnter: _util.noop,
	      onMouseLeave: _util.noop,
	      onTitleMouseEnter: _util.noop,
	      onTitleMouseLeave: _util.noop,
	      onTitleClick: _util.noop,
	      title: ''
	    };
	  },
	  getInitialState: function getInitialState() {
	    this.isSubMenu = 1;
	    return {
	      defaultActiveFirst: false
	    };
	  },
	  componentWillUnmount: function componentWillUnmount() {
	    var props = this.props;
	    if (props.onDestroy) {
	      props.onDestroy(props.eventKey);
	    }
	    if (props.parentMenu.subMenuInstance === this) {
	      this.clearSubMenuTimers();
	    }
	  },
	  onDestroy: function onDestroy(key) {
	    this.props.onDestroy(key);
	  },
	  onKeyDown: function onKeyDown(e) {
	    var keyCode = e.keyCode;
	    var menu = this.menuInstance;

	    if (keyCode === _rcUtil.KeyCode.ENTER) {
	      this.onTitleClick(e);
	      this.setState({
	        defaultActiveFirst: true
	      });
	      return true;
	    }

	    if (keyCode === _rcUtil.KeyCode.RIGHT) {
	      if (this.props.open) {
	        menu.onKeyDown(e);
	      } else {
	        this.triggerOpenChange(true);
	        this.setState({
	          defaultActiveFirst: true
	        });
	      }
	      return true;
	    }
	    if (keyCode === _rcUtil.KeyCode.LEFT) {
	      var handled = void 0;
	      if (this.props.open) {
	        handled = menu.onKeyDown(e);
	      } else {
	        return undefined;
	      }
	      if (!handled) {
	        this.triggerOpenChange(false);
	        handled = true;
	      }
	      return handled;
	    }

	    if (this.props.open && (keyCode === _rcUtil.KeyCode.UP || keyCode === _rcUtil.KeyCode.DOWN)) {
	      return menu.onKeyDown(e);
	    }
	  },
	  onOpenChange: function onOpenChange(e) {
	    this.props.onOpenChange(this.addKeyPath(e));
	  },
	  onMouseEnter: function onMouseEnter(e) {
	    var props = this.props;
	    this.clearSubMenuLeaveTimer(props.parentMenu.subMenuInstance !== this);
	    props.onMouseEnter({
	      key: props.eventKey,
	      domEvent: e
	    });
	  },
	  onTitleMouseEnter: function onTitleMouseEnter(e) {
	    var props = this.props;
	    var parentMenu = props.parentMenu;
	    this.clearSubMenuTitleLeaveTimer(parentMenu.subMenuInstance !== this);
	    if (parentMenu.menuItemInstance) {
	      parentMenu.menuItemInstance.clearMenuItemMouseLeaveTimer(true);
	    }
	    props.onItemHover({
	      key: props.eventKey,
	      item: this,
	      hover: true,
	      trigger: 'mouseenter'
	    });
	    if (props.openSubMenuOnMouseEnter) {
	      this.triggerOpenChange(true);
	    }
	    this.setState({
	      defaultActiveFirst: false
	    });
	    props.onTitleMouseEnter({
	      key: props.eventKey,
	      domEvent: e
	    });
	  },
	  onTitleMouseLeave: function onTitleMouseLeave(e) {
	    var _this = this;

	    var props = this.props;

	    var parentMenu = props.parentMenu;
	    parentMenu.subMenuInstance = this;
	    parentMenu.subMenuTitleLeaveFn = function () {
	      var eventKey = props.eventKey;
	      if (_this.isMounted()) {
	        // leave whole sub tree
	        // still active
	        if (props.mode === 'inline' && props.active) {
	          props.onItemHover({
	            key: eventKey,
	            item: _this,
	            hover: false,
	            trigger: 'mouseleave'
	          });
	        }
	        props.onTitleMouseLeave({
	          key: props.eventKey,
	          domEvent: e
	        });
	      }
	    };
	    parentMenu.subMenuTitleLeaveTimer = setTimeout(parentMenu.subMenuTitleLeaveFn, 100);
	  },
	  onMouseLeave: function onMouseLeave(e) {
	    var _this2 = this;

	    var props = this.props;

	    var parentMenu = props.parentMenu;
	    parentMenu.subMenuInstance = this;
	    parentMenu.subMenuLeaveFn = function () {
	      var eventKey = props.eventKey;
	      if (_this2.isMounted()) {
	        // leave whole sub tree
	        // still active
	        if (props.mode !== 'inline') {
	          if (props.active) {
	            props.onItemHover({
	              key: eventKey,
	              item: _this2,
	              hover: false,
	              trigger: 'mouseleave'
	            });
	          }
	          if (props.open) {
	            if (props.closeSubMenuOnMouseLeave) {
	              _this2.triggerOpenChange(false);
	            }
	          }
	        }
	        // trigger mouseleave
	        props.onMouseLeave({
	          key: eventKey,
	          domEvent: e
	        });
	      }
	    };
	    // prevent popup menu and submenu gap
	    parentMenu.subMenuLeaveTimer = setTimeout(parentMenu.subMenuLeaveFn, 100);
	  },
	  onTitleClick: function onTitleClick(e) {
	    var props = this.props;

	    props.onTitleClick({
	      key: props.eventKey,
	      domEvent: e
	    });
	    if (props.openSubMenuOnMouseEnter) {
	      return;
	    }
	    this.triggerOpenChange(!props.open, 'click');
	    this.setState({
	      defaultActiveFirst: false
	    });
	  },
	  onSubMenuClick: function onSubMenuClick(info) {
	    this.props.onClick(this.addKeyPath(info));
	  },
	  onSelect: function onSelect(info) {
	    this.props.onSelect(info);
	  },
	  onDeselect: function onDeselect(info) {
	    this.props.onDeselect(info);
	  },
	  getPrefixCls: function getPrefixCls() {
	    return this.props.rootPrefixCls + '-submenu';
	  },
	  getActiveClassName: function getActiveClassName() {
	    return this.getPrefixCls() + '-active';
	  },
	  getDisabledClassName: function getDisabledClassName() {
	    return this.getPrefixCls() + '-disabled';
	  },
	  getOpenClassName: function getOpenClassName() {
	    return this.props.rootPrefixCls + '-submenu-open';
	  },
	  saveMenuInstance: function saveMenuInstance(c) {
	    this.menuInstance = c;
	  },
	  addKeyPath: function addKeyPath(info) {
	    return _extends({}, info, {
	      keyPath: (info.keyPath || []).concat(this.props.eventKey)
	    });
	  },
	  triggerOpenChange: function triggerOpenChange(open, type) {
	    var key = this.props.eventKey;
	    this.onOpenChange({
	      key: key,
	      item: this,
	      trigger: type,
	      open: open
	    });
	  },
	  clearSubMenuTimers: function clearSubMenuTimers(callFn) {
	    this.clearSubMenuLeaveTimer(callFn);
	    this.clearSubMenuTitleLeaveTimer(callFn);
	  },
	  clearSubMenuTitleLeaveTimer: function clearSubMenuTitleLeaveTimer(callFn) {
	    var parentMenu = this.props.parentMenu;
	    if (parentMenu.subMenuTitleLeaveTimer) {
	      clearTimeout(parentMenu.subMenuTitleLeaveTimer);
	      parentMenu.subMenuTitleLeaveTimer = null;
	      if (callFn && parentMenu.subMenuTitleLeaveFn) {
	        parentMenu.subMenuTitleLeaveFn();
	      }
	      parentMenu.subMenuTitleLeaveFn = null;
	    }
	  },
	  clearSubMenuLeaveTimer: function clearSubMenuLeaveTimer(callFn) {
	    var parentMenu = this.props.parentMenu;
	    if (parentMenu.subMenuLeaveTimer) {
	      clearTimeout(parentMenu.subMenuLeaveTimer);
	      parentMenu.subMenuLeaveTimer = null;
	      if (callFn && parentMenu.subMenuLeaveFn) {
	        parentMenu.subMenuLeaveFn();
	      }
	      parentMenu.subMenuLeaveFn = null;
	    }
	  },
	  renderChildren: function renderChildren(children) {
	    var props = this.props;
	    var baseProps = {
	      mode: props.mode === 'horizontal' ? 'vertical' : props.mode,
	      visible: props.open,
	      level: props.level + 1,
	      inlineIndent: props.inlineIndent,
	      focusable: false,
	      onClick: this.onSubMenuClick,
	      onSelect: this.onSelect,
	      onDeselect: this.onDeselect,
	      onDestroy: this.onDestroy,
	      selectedKeys: props.selectedKeys,
	      eventKey: props.eventKey + '-menu-',
	      openKeys: props.openKeys,
	      openTransitionName: props.openTransitionName,
	      openAnimation: props.openAnimation,
	      onOpenChange: this.onOpenChange,
	      closeSubMenuOnMouseLeave: props.closeSubMenuOnMouseLeave,
	      defaultActiveFirst: this.state.defaultActiveFirst,
	      multiple: props.multiple,
	      prefixCls: props.rootPrefixCls,
	      id: this._menuId,
	      ref: this.saveMenuInstance
	    };
	    return _react2["default"].createElement(
	      _SubPopupMenu2["default"],
	      baseProps,
	      children
	    );
	  },
	  render: function render() {
	    var _classes;

	    this.haveOpen = this.haveOpen || this.props.open;
	    var props = this.props;
	    var prefixCls = this.getPrefixCls();
	    var classes = (_classes = {}, _defineProperty(_classes, props.className, !!props.className), _defineProperty(_classes, prefixCls + '-' + props.mode, 1), _classes);

	    classes[this.getOpenClassName()] = this.props.open;
	    classes[this.getActiveClassName()] = props.active;
	    classes[this.getDisabledClassName()] = props.disabled;
	    this._menuId = this._menuId || (0, _rcUtil.guid)();
	    classes[prefixCls] = true;
	    classes[prefixCls + '-' + props.mode] = 1;
	    var titleClickEvents = {};
	    var mouseEvents = {};
	    var titleMouseEvents = {};
	    if (!props.disabled) {
	      titleClickEvents = {
	        onClick: this.onTitleClick
	      };
	      mouseEvents = {
	        onMouseLeave: this.onMouseLeave,
	        onMouseEnter: this.onMouseEnter
	      };
	      // only works in title, not outer li
	      titleMouseEvents = {
	        onMouseEnter: this.onTitleMouseEnter,
	        onMouseLeave: this.onTitleMouseLeave
	      };
	    }
	    var style = {};
	    if (props.mode === 'inline') {
	      style.paddingLeft = props.inlineIndent * props.level;
	    }
	    return _react2["default"].createElement(
	      'li',
	      _extends({ className: (0, _classnames2["default"])(classes) }, mouseEvents),
	      _react2["default"].createElement(
	        'div',
	        _extends({
	          style: style,
	          className: prefixCls + '-title'
	        }, titleMouseEvents, titleClickEvents, {
	          'aria-open': props.open,
	          'aria-owns': this._menuId,
	          'aria-haspopup': 'true'
	        }),
	        props.title
	      ),
	      this.renderChildren(props.children)
	    );
	  }
	});

	exports["default"] = SubMenu;
	module.exports = exports['default'];

/***/ },
/* 585 */
/***/ function(module, exports, __webpack_require__, __webpack_module_template_argument_0__, __webpack_module_template_argument_1__, __webpack_module_template_argument_2__, __webpack_module_template_argument_3__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	var _react = __webpack_require__(7);

	var _react2 = _interopRequireDefault(_react);

	var _MenuMixin = __webpack_require__(__webpack_module_template_argument_0__);

	var _MenuMixin2 = _interopRequireDefault(_MenuMixin);

	var _objectAssign = __webpack_require__(__webpack_module_template_argument_1__);

	var _objectAssign2 = _interopRequireDefault(_objectAssign);

	var _util = __webpack_require__(__webpack_module_template_argument_2__);

	var _rcAnimate = __webpack_require__(__webpack_module_template_argument_3__);

	var _rcAnimate2 = _interopRequireDefault(_rcAnimate);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

	var SubPopupMenu = _react2["default"].createClass({
	  displayName: 'SubPopupMenu',

	  propTypes: {
	    onSelect: _react.PropTypes.func,
	    onClick: _react.PropTypes.func,
	    onDeselect: _react.PropTypes.func,
	    onOpenChange: _react.PropTypes.func,
	    onDestroy: _react.PropTypes.func,
	    openTransitionName: _react.PropTypes.string,
	    openAnimation: _react.PropTypes.oneOfType([_react.PropTypes.string, _react.PropTypes.object]),
	    openKeys: _react.PropTypes.arrayOf(_react.PropTypes.string),
	    closeSubMenuOnMouseLeave: _react.PropTypes.bool,
	    visible: _react.PropTypes.bool,
	    children: _react.PropTypes.any
	  },

	  mixins: [_MenuMixin2["default"]],

	  onDeselect: function onDeselect(selectInfo) {
	    this.props.onDeselect(selectInfo);
	  },
	  onSelect: function onSelect(selectInfo) {
	    this.props.onSelect(selectInfo);
	  },
	  onClick: function onClick(e) {
	    this.props.onClick(e);
	  },
	  onOpenChange: function onOpenChange(e) {
	    this.props.onOpenChange(e);
	  },
	  onDestroy: function onDestroy(key) {
	    this.props.onDestroy(key);
	  },
	  onItemHover: function onItemHover(e) {
	    this.onCommonItemHover(e);
	  },
	  getOpenTransitionName: function getOpenTransitionName() {
	    return this.props.openTransitionName;
	  },
	  renderMenuItem: function renderMenuItem(c, i, subIndex) {
	    var props = this.props;
	    var key = (0, _util.getKeyFromChildrenIndex)(c, props.eventKey, i);
	    var extraProps = {
	      openKeys: props.openKeys,
	      selectedKeys: props.selectedKeys,
	      open: props.openKeys.indexOf(key) !== -1,
	      selected: props.selectedKeys.indexOf(key) !== -1,
	      openSubMenuOnMouseEnter: true
	    };
	    return this.renderCommonMenuItem(c, i, subIndex, extraProps);
	  },
	  render: function render() {
	    var renderFirst = this.renderFirst;
	    this.renderFirst = 1;
	    this.haveOpened = this.haveOpened || this.props.visible;
	    if (!this.haveOpened) {
	      return null;
	    }
	    var transitionAppear = true;
	    if (!renderFirst && this.props.visible) {
	      transitionAppear = false;
	    }
	    var props = (0, _objectAssign2["default"])({}, this.props);
	    props.className += ' ' + props.prefixCls + '-sub';
	    var animProps = {};
	    if (props.openTransitionName) {
	      animProps.transitionName = props.openTransitionName;
	    } else if (_typeof(props.openAnimation) === 'object') {
	      animProps.animation = (0, _objectAssign2["default"])({}, props.openAnimation);
	      if (!transitionAppear) {
	        delete animProps.animation.appear;
	      }
	    }
	    return _react2["default"].createElement(
	      _rcAnimate2["default"],
	      _extends({}, animProps, {
	        showProp: 'visible',
	        component: '',
	        transitionAppear: transitionAppear
	      }),
	      this.renderRoot(props)
	    );
	  }
	});

	exports["default"] = SubPopupMenu;
	module.exports = exports['default'];

/***/ },
/* 586 */
/***/ function(module, exports, __webpack_require__, __webpack_module_template_argument_0__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _rcUtil = __webpack_require__(__webpack_module_template_argument_0__);

	var _rcUtil2 = _interopRequireDefault(_rcUtil);

	var _reactDom = __webpack_require__(8);

	var _reactDom2 = _interopRequireDefault(_reactDom);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

	exports["default"] = {
	  componentDidMount: function componentDidMount() {
	    this.componentDidUpdate();
	  },
	  componentDidUpdate: function componentDidUpdate() {
	    if (this.props.mode !== 'inline') {
	      if (this.props.open) {
	        this.bindRootCloseHandlers();
	      } else {
	        this.unbindRootCloseHandlers();
	      }
	    }
	  },
	  handleDocumentKeyUp: function handleDocumentKeyUp(e) {
	    if (e.keyCode === _rcUtil.KeyCode.ESC) {
	      this.props.onItemHover({
	        key: this.props.eventKey,
	        item: this,
	        hover: false
	      });
	    }
	  },
	  handleDocumentClick: function handleDocumentClick(e) {
	    // If the click originated from within this component
	    // don't do anything.
	    if (_rcUtil2["default"].Dom.contains(_reactDom2["default"].findDOMNode(this), e.target)) {
	      return;
	    }
	    var props = this.props;
	    props.onItemHover({
	      hover: false,
	      item: this,
	      key: this.props.eventKey
	    });
	    this.triggerOpenChange(false);
	  },
	  bindRootCloseHandlers: function bindRootCloseHandlers() {
	    if (!this._onDocumentClickListener) {
	      this._onDocumentClickListener = _rcUtil2["default"].Dom.addEventListener(document, 'click', this.handleDocumentClick);
	      this._onDocumentKeyupListener = _rcUtil2["default"].Dom.addEventListener(document, 'keyup', this.handleDocumentKeyUp);
	    }
	  },
	  unbindRootCloseHandlers: function unbindRootCloseHandlers() {
	    if (this._onDocumentClickListener) {
	      this._onDocumentClickListener.remove();
	      this._onDocumentClickListener = null;
	    }

	    if (this._onDocumentKeyupListener) {
	      this._onDocumentKeyupListener.remove();
	      this._onDocumentKeyupListener = null;
	    }
	  },
	  componentWillUnmount: function componentWillUnmount() {
	    this.unbindRootCloseHandlers();
	  }
	};
	module.exports = exports['default'];

/***/ },
/* 587 */
/***/ function(module, exports, __webpack_require__, __webpack_module_template_argument_0__, __webpack_module_template_argument_1__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

	var _react = __webpack_require__(7);

	var _react2 = _interopRequireDefault(_react);

	var _rcUtil = __webpack_require__(__webpack_module_template_argument_0__);

	var _classnames = __webpack_require__(19);

	var _classnames2 = _interopRequireDefault(_classnames);

	var _util = __webpack_require__(__webpack_module_template_argument_1__);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

	/* eslint react/no-is-mounted:0 */

	var MenuItem = _react2["default"].createClass({
	  displayName: 'MenuItem',

	  propTypes: {
	    rootPrefixCls: _react.PropTypes.string,
	    eventKey: _react.PropTypes.string,
	    active: _react.PropTypes.bool,
	    selected: _react.PropTypes.bool,
	    disabled: _react.PropTypes.bool,
	    title: _react.PropTypes.string,
	    onSelect: _react.PropTypes.func,
	    onClick: _react.PropTypes.func,
	    onDeselect: _react.PropTypes.func,
	    parentMenu: _react.PropTypes.object,
	    onItemHover: _react.PropTypes.func,
	    onDestroy: _react.PropTypes.func,
	    onMouseEnter: _react.PropTypes.func,
	    onMouseLeave: _react.PropTypes.func
	  },

	  getDefaultProps: function getDefaultProps() {
	    return {
	      onSelect: _util.noop,
	      onMouseEnter: _util.noop,
	      onMouseLeave: _util.noop
	    };
	  },
	  componentWillUnmount: function componentWillUnmount() {
	    var props = this.props;
	    if (props.onDestroy) {
	      props.onDestroy(props.eventKey);
	    }
	    if (props.parentMenu.menuItemInstance === this) {
	      this.clearMenuItemMouseLeaveTimer();
	    }
	  },
	  onKeyDown: function onKeyDown(e) {
	    var keyCode = e.keyCode;
	    if (keyCode === _rcUtil.KeyCode.ENTER) {
	      this.onClick(e);
	      return true;
	    }
	  },
	  onMouseLeave: function onMouseLeave(e) {
	    var _this = this;

	    var props = this.props;
	    var eventKey = props.eventKey;
	    var parentMenu = props.parentMenu;
	    parentMenu.menuItemInstance = this;
	    parentMenu.menuItemMouseLeaveFn = function () {
	      if (_this.isMounted() && props.active) {
	        props.onItemHover({
	          key: eventKey,
	          item: _this,
	          hover: false,
	          trigger: 'mouseleave'
	        });
	      }
	    };
	    parentMenu.menuItemMouseLeaveTimer = setTimeout(parentMenu.menuItemMouseLeaveFn, 30);
	    props.onMouseLeave({
	      key: eventKey,
	      domEvent: e
	    });
	  },
	  onMouseEnter: function onMouseEnter(e) {
	    var props = this.props;
	    var parentMenu = props.parentMenu;
	    this.clearMenuItemMouseLeaveTimer(parentMenu.menuItemInstance !== this);
	    if (parentMenu.subMenuInstance) {
	      parentMenu.subMenuInstance.clearSubMenuTimers(true);
	    }
	    var eventKey = props.eventKey;
	    props.onItemHover({
	      key: eventKey,
	      item: this,
	      hover: true,
	      trigger: 'mouseenter'
	    });
	    props.onMouseEnter({
	      key: eventKey,
	      domEvent: e
	    });
	  },
	  onClick: function onClick(e) {
	    var props = this.props;
	    var eventKey = props.eventKey;
	    var info = {
	      key: eventKey,
	      keyPath: [eventKey],
	      item: this,
	      domEvent: e
	    };
	    props.onClick(info);
	    if (props.multiple) {
	      if (props.selected) {
	        props.onDeselect(info);
	      } else {
	        props.onSelect(info);
	      }
	    } else if (!props.selected) {
	      props.onSelect(info);
	    }
	  },
	  getPrefixCls: function getPrefixCls() {
	    return this.props.rootPrefixCls + '-item';
	  },
	  getActiveClassName: function getActiveClassName() {
	    return this.getPrefixCls() + '-active';
	  },
	  getSelectedClassName: function getSelectedClassName() {
	    return this.getPrefixCls() + '-selected';
	  },
	  getDisabledClassName: function getDisabledClassName() {
	    return this.getPrefixCls() + '-disabled';
	  },
	  clearMenuItemMouseLeaveTimer: function clearMenuItemMouseLeaveTimer(callFn) {
	    var props = this.props;
	    var parentMenu = props.parentMenu;
	    if (parentMenu.menuItemMouseLeaveTimer) {
	      clearTimeout(parentMenu.menuItemMouseLeaveTimer);
	      parentMenu.menuItemMouseLeaveTimer = null;
	      if (callFn && parentMenu.menuItemMouseLeaveFn) {
	        parentMenu.menuItemMouseLeaveFn();
	      }
	      parentMenu.menuItemMouseLeaveFn = null;
	    }
	  },
	  render: function render() {
	    var props = this.props;
	    var classes = {};
	    classes[this.getActiveClassName()] = !props.disabled && props.active;
	    classes[this.getSelectedClassName()] = props.selected;
	    classes[this.getDisabledClassName()] = props.disabled;
	    classes[this.getPrefixCls()] = true;
	    classes[props.className] = !!props.className;
	    var attrs = _extends({}, props.attribute, {
	      title: props.title,
	      className: (0, _classnames2["default"])(classes),
	      role: 'menuitem',
	      'aria-selected': props.selected,
	      'aria-disabled': props.disabled
	    });
	    var mouseEvent = {};
	    if (!props.disabled) {
	      mouseEvent = {
	        onClick: this.onClick,
	        onMouseLeave: this.onMouseLeave,
	        onMouseEnter: this.onMouseEnter
	      };
	    }
	    var style = _extends({}, props.style);
	    if (props.mode === 'inline') {
	      style.paddingLeft = props.inlineIndent * props.level;
	    }
	    return _react2["default"].createElement(
	      'li',
	      _extends({
	        style: style
	      }, attrs, mouseEvent),
	      props.children
	    );
	  }
	});

	exports["default"] = MenuItem;
	module.exports = exports['default'];

/***/ },
/* 588 */
/***/ function(module, exports, __webpack_require__, __webpack_module_template_argument_0__, __webpack_module_template_argument_1__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

	var _rcTrigger = __webpack_require__(__webpack_module_template_argument_0__);

	var _rcTrigger2 = _interopRequireDefault(_rcTrigger);

	var _react = __webpack_require__(7);

	var _react2 = _interopRequireDefault(_react);

	var _classnames = __webpack_require__(19);

	var _classnames2 = _interopRequireDefault(_classnames);

	var _DropdownMenu = __webpack_require__(__webpack_module_template_argument_1__);

	var _DropdownMenu2 = _interopRequireDefault(_DropdownMenu);

	var _reactDom = __webpack_require__(8);

	var _reactDom2 = _interopRequireDefault(_reactDom);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

	function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

	function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

	var BUILT_IN_PLACEMENTS = {
	  bottomLeft: {
	    points: ['tl', 'bl'],
	    offset: [0, 4],
	    overflow: {
	      adjustX: 0,
	      adjustY: 1
	    }
	  },
	  topLeft: {
	    points: ['bl', 'tl'],
	    offset: [0, -4],
	    overflow: {
	      adjustX: 0,
	      adjustY: 1
	    }
	  }
	};

	var SelectTrigger = _react2["default"].createClass({
	  displayName: 'SelectTrigger',

	  propTypes: {
	    onPopupFocus: _react.PropTypes.func,
	    dropdownMatchSelectWidth: _react.PropTypes.bool,
	    dropdownAlign: _react.PropTypes.object,
	    visible: _react.PropTypes.bool,
	    multiple: _react.PropTypes.bool,
	    inputValue: _react.PropTypes.string,
	    filterOption: _react.PropTypes.any,
	    options: _react.PropTypes.any,
	    prefixCls: _react.PropTypes.string,
	    popupClassName: _react.PropTypes.string,
	    children: _react.PropTypes.any
	  },

	  componentDidUpdate: function componentDidUpdate() {
	    var _props = this.props;
	    var visible = _props.visible;
	    var dropdownMatchSelectWidth = _props.dropdownMatchSelectWidth;

	    if (visible) {
	      var dropdownDOMNode = this.getPopupDOMNode();
	      if (dropdownDOMNode) {
	        var widthProp = dropdownMatchSelectWidth ? 'width' : 'minWidth';
	        dropdownDOMNode.style[widthProp] = _reactDom2["default"].findDOMNode(this).offsetWidth + 'px';
	      }
	    }
	  },
	  getInnerMenu: function getInnerMenu() {
	    return this.popupMenu && this.popupMenu.refs.menu;
	  },
	  getPopupDOMNode: function getPopupDOMNode() {
	    return this.refs.trigger.getPopupDomNode();
	  },
	  getDropdownElement: function getDropdownElement(newProps) {
	    var props = this.props;
	    return _react2["default"].createElement(_DropdownMenu2["default"], _extends({
	      ref: this.saveMenu
	    }, newProps, {
	      prefixCls: this.getDropdownPrefixCls(),
	      onMenuSelect: props.onMenuSelect,
	      onMenuDeselect: props.onMenuDeselect,
	      value: props.value,
	      defaultActiveFirstOption: props.defaultActiveFirstOption,
	      dropdownMenuStyle: props.dropdownMenuStyle
	    }));
	  },
	  getDropdownTransitionName: function getDropdownTransitionName() {
	    var props = this.props;
	    var transitionName = props.transitionName;
	    if (!transitionName && props.animation) {
	      transitionName = this.getDropdownPrefixCls() + '-' + props.animation;
	    }
	    return transitionName;
	  },
	  getDropdownPrefixCls: function getDropdownPrefixCls() {
	    return this.props.prefixCls + '-dropdown';
	  },
	  saveMenu: function saveMenu(menu) {
	    this.popupMenu = menu;
	  },
	  render: function render() {
	    var _popupClassName;

	    var _props2 = this.props;
	    var onPopupFocus = _props2.onPopupFocus;

	    var props = _objectWithoutProperties(_props2, ['onPopupFocus']);

	    var multiple = props.multiple;
	    var visible = props.visible;
	    var inputValue = props.inputValue;
	    var dropdownAlign = props.dropdownAlign;

	    var dropdownPrefixCls = this.getDropdownPrefixCls();
	    var popupClassName = (_popupClassName = {}, _defineProperty(_popupClassName, props.dropdownClassName, !!props.dropdownClassName), _defineProperty(_popupClassName, dropdownPrefixCls + '--' + (multiple ? 'multiple' : 'single'), 1), _popupClassName);
	    var popupElement = this.getDropdownElement({
	      menuItems: props.options,
	      onPopupFocus: onPopupFocus,
	      multiple: multiple,
	      inputValue: inputValue,
	      visible: visible
	    });
	    return _react2["default"].createElement(
	      _rcTrigger2["default"],
	      _extends({}, props, {
	        showAction: props.disabled ? [] : ['click'],
	        hideAction: props.disabled ? [] : ['blur'],
	        ref: 'trigger',
	        popupPlacement: 'bottomLeft',
	        builtinPlacements: BUILT_IN_PLACEMENTS,
	        prefixCls: dropdownPrefixCls,
	        popupTransitionName: this.getDropdownTransitionName(),
	        onPopupVisibleChange: props.onDropdownVisibleChange,
	        popup: popupElement,
	        popupAlign: dropdownAlign,
	        popupVisible: visible,
	        getPopupContainer: props.getPopupContainer,
	        popupClassName: (0, _classnames2["default"])(popupClassName),
	        popupStyle: props.dropdownStyle
	      }),
	      props.children
	    );
	  }
	});

	exports["default"] = SelectTrigger;
	module.exports = exports['default'];

/***/ },
/* 589 */
/***/ function(module, exports, __webpack_require__, __webpack_module_template_argument_0__, __webpack_module_template_argument_1__, __webpack_module_template_argument_2__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

	var _react = __webpack_require__(7);

	var _react2 = _interopRequireDefault(_react);

	var _reactDom = __webpack_require__(8);

	var _util = __webpack_require__(__webpack_module_template_argument_0__);

	var _rcMenu = __webpack_require__(__webpack_module_template_argument_1__);

	var _rcMenu2 = _interopRequireDefault(_rcMenu);

	var _domScrollIntoView = __webpack_require__(__webpack_module_template_argument_2__);

	var _domScrollIntoView2 = _interopRequireDefault(_domScrollIntoView);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

	var DropdownMenu = _react2["default"].createClass({
	  displayName: 'DropdownMenu',

	  propTypes: {
	    defaultActiveFirstOption: _react.PropTypes.bool,
	    value: _react.PropTypes.any,
	    dropdownMenuStyle: _react.PropTypes.object,
	    multiple: _react.PropTypes.bool,
	    onPopupFocus: _react.PropTypes.func,
	    onMenuDeSelect: _react.PropTypes.func,
	    onMenuSelect: _react.PropTypes.func,
	    prefixCls: _react.PropTypes.string,
	    menuItems: _react.PropTypes.any,
	    inputValue: _react.PropTypes.string,
	    visible: _react.PropTypes.bool
	  },

	  componentWillMount: function componentWillMount() {
	    this.lastInputValue = this.props.inputValue;
	  },
	  componentDidMount: function componentDidMount() {
	    this.scrollActiveItemToView();
	    this.lastVisible = this.props.visible;
	  },
	  shouldComponentUpdate: function shouldComponentUpdate(nextProps) {
	    if (!nextProps.visible) {
	      this.lastVisible = false;
	    }
	    // freeze when hide
	    return nextProps.visible;
	  },
	  componentDidUpdate: function componentDidUpdate(prevProps) {
	    var props = this.props;
	    if (!prevProps.visible && props.visible) {
	      this.scrollActiveItemToView();
	    }
	    this.lastVisible = props.visible;
	    this.lastInputValue = props.inputValue;
	  },
	  scrollActiveItemToView: function scrollActiveItemToView() {
	    // scroll into view
	    var itemComponent = (0, _reactDom.findDOMNode)(this.firstActiveItem);
	    if (itemComponent) {
	      (0, _domScrollIntoView2["default"])(itemComponent, (0, _reactDom.findDOMNode)(this.refs.menu), {
	        onlyScrollIfNeeded: true
	      });
	    }
	  },
	  renderMenu: function renderMenu() {
	    var _this = this;

	    var props = this.props;
	    var menuItems = props.menuItems;
	    var defaultActiveFirstOption = props.defaultActiveFirstOption;
	    var value = props.value;
	    var prefixCls = props.prefixCls;
	    var multiple = props.multiple;
	    var onMenuSelect = props.onMenuSelect;
	    var inputValue = props.inputValue;

	    if (menuItems && menuItems.length) {
	      var _ret = function () {
	        var menuProps = {};
	        if (multiple) {
	          menuProps.onDeselect = props.onMenuDeselect;
	          menuProps.onSelect = onMenuSelect;
	        } else {
	          menuProps.onClick = onMenuSelect;
	        }

	        var selectedKeys = (0, _util.getSelectKeys)(menuItems, value);
	        var activeKeyProps = {};

	        var clonedMenuItems = menuItems;
	        if (selectedKeys.length) {
	          (function () {
	            if (props.visible && !_this.lastVisible) {
	              activeKeyProps.activeKey = selectedKeys[0];
	            }
	            var foundFirst = false;
	            // set firstActiveItem via cloning menus
	            // for scroll into view
	            var clone = function clone(item) {
	              if (!foundFirst && selectedKeys.indexOf(item.key) !== -1) {
	                foundFirst = true;
	                return (0, _react.cloneElement)(item, {
	                  ref: function ref(_ref) {
	                    _this.firstActiveItem = _ref;
	                  }
	                });
	              }
	              return item;
	            };

	            clonedMenuItems = menuItems.map(function (item) {
	              if (item.type === _rcMenu.ItemGroup) {
	                var children = item.props.children.map(clone);
	                return (0, _react.cloneElement)(item, {}, children);
	              }
	              return clone(item);
	            });
	          })();
	        }

	        // clear activeKey when inputValue change
	        if (inputValue !== _this.lastInputValue) {
	          activeKeyProps.activeKey = '';
	        }

	        return {
	          v: _react2["default"].createElement(
	            _rcMenu2["default"],
	            _extends({
	              ref: 'menu',
	              style: _this.props.dropdownMenuStyle,
	              defaultActiveFirst: defaultActiveFirstOption
	            }, activeKeyProps, {
	              multiple: multiple,
	              focusable: false
	            }, menuProps, {
	              selectedKeys: selectedKeys,
	              prefixCls: prefixCls + '-menu'
	            }),
	            clonedMenuItems
	          )
	        };
	      }();

	      if ((typeof _ret === 'undefined' ? 'undefined' : _typeof(_ret)) === "object") return _ret.v;
	    }
	    return null;
	  },
	  render: function render() {
	    return _react2["default"].createElement(
	      'div',
	      {
	        style: { overflow: 'auto' },
	        onFocus: this.props.onPopupFocus,
	        onMouseDown: _util.preventDefaultEvent
	      },
	      this.renderMenu()
	    );
	  }
	});

	exports["default"] = DropdownMenu;
	module.exports = exports['default'];

/***/ },
/* 590 */
/***/ function(module, exports, __webpack_require__, __webpack_module_template_argument_0__, __webpack_module_template_argument_1__, __webpack_module_template_argument_2__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

	var _react = __webpack_require__(7);

	var _react2 = _interopRequireDefault(_react);

	var _OptGroup = __webpack_require__(__webpack_module_template_argument_0__);

	var _OptGroup2 = _interopRequireDefault(_OptGroup);

	var _util = __webpack_require__(__webpack_module_template_argument_1__);

	var _rcMenu = __webpack_require__(__webpack_module_template_argument_2__);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

	exports["default"] = {
	  filterOption: function filterOption(input, child) {
	    if (!input) {
	      return true;
	    }
	    var filterOption = this.props.filterOption;
	    if (!filterOption) {
	      return true;
	    }
	    if (child.props.disabled) {
	      return false;
	    }
	    return filterOption.call(this, input, child);
	  },
	  renderFilterOptions: function renderFilterOptions(inputValue) {
	    return this.renderFilterOptionsFromChildren(this.props.children, true, inputValue);
	  },
	  renderFilterOptionsFromChildren: function renderFilterOptionsFromChildren(children, showNotFound, iv) {
	    var _this = this;

	    var sel = [];
	    var props = this.props;
	    var inputValue = iv === undefined ? this.state.inputValue : iv;
	    var childrenKeys = [];
	    var tags = props.tags;
	    _react2["default"].Children.forEach(children, function (child) {
	      if (child.type === _OptGroup2["default"]) {
	        var innerItems = _this.renderFilterOptionsFromChildren(child.props.children, false);
	        if (innerItems.length) {
	          var label = child.props.label;
	          var key = child.key;
	          if (!key && typeof label === 'string') {
	            key = label;
	          } else if (!label && key) {
	            label = key;
	          }
	          sel.push(_react2["default"].createElement(
	            _rcMenu.ItemGroup,
	            { key: key, title: label },
	            innerItems
	          ));
	        }
	        return;
	      }
	      var childValue = (0, _util.getValuePropValue)(child);
	      if (_this.filterOption(inputValue, child)) {
	        sel.push(_react2["default"].createElement(_rcMenu.Item, _extends({
	          style: _util.UNSELECTABLE_STYLE,
	          attribute: _util.UNSELECTABLE_ATTRIBUTE,
	          value: childValue,
	          key: childValue
	        }, child.props)));
	      }
	      if (tags && !child.props.disabled) {
	        childrenKeys.push(childValue);
	      }
	    });
	    if (tags) {
	      // tags value must be string
	      var value = this.state.value || [];
	      value = value.filter(function (singleValue) {
	        return childrenKeys.indexOf(singleValue.key) === -1 && (!inputValue || String(singleValue.key).indexOf(String(inputValue)) > -1);
	      });
	      sel = sel.concat(value.map(function (singleValue) {
	        var key = singleValue.key;
	        return _react2["default"].createElement(
	          _rcMenu.Item,
	          {
	            style: _util.UNSELECTABLE_STYLE,
	            attribute: _util.UNSELECTABLE_ATTRIBUTE,
	            value: key,
	            key: key
	          },
	          key
	        );
	      }));
	      if (inputValue) {
	        var notFindInputItem = sel.every(function (option) {
	          return (0, _util.getValuePropValue)(option) !== inputValue;
	        });
	        if (notFindInputItem) {
	          sel.unshift(_react2["default"].createElement(
	            _rcMenu.Item,
	            {
	              style: _util.UNSELECTABLE_STYLE,
	              attribute: _util.UNSELECTABLE_ATTRIBUTE,
	              value: inputValue,
	              key: inputValue
	            },
	            inputValue
	          ));
	        }
	      }
	    }
	    if (!sel.length && showNotFound && props.notFoundContent) {
	      sel = [_react2["default"].createElement(
	        _rcMenu.Item,
	        {
	          style: _util.UNSELECTABLE_STYLE,
	          attribute: _util.UNSELECTABLE_ATTRIBUTE,
	          disabled: true,
	          value: 'NOT_FOUND',
	          key: 'NOT_FOUND'
	        },
	        props.notFoundContent
	      )];
	    }
	    return sel;
	  }
	};
	module.exports = exports['default'];

/***/ },
/* 591 */
/***/ function(module, exports, __webpack_require__, __webpack_module_template_argument_0__) {

	'use strict';

	/**
	 * Radiogroup Component for uxcore
	 * @author 
	 *
	 * Copyright 2014-2015, Uxcore Team, Alinw.
	 * All rights reserved.
	 */

	module.exports = __webpack_require__(__webpack_module_template_argument_0__);

/***/ },
/* 592 */
/***/ function(module, exports, __webpack_require__, __webpack_module_template_argument_0__) {

	'use strict';

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	/**
	* thanks for https://github.com/chenglou/react-radio-group
	* @author: zhouquan.yezq
	* @time  : 5/25 2015
	*/

	var React = __webpack_require__(7);
	var ReactDOM = __webpack_require__(8);
	var Item = __webpack_require__(__webpack_module_template_argument_0__);
	var classnames = __webpack_require__(19);

	var Radiogroup = function (_React$Component) {
	    _inherits(Radiogroup, _React$Component);

	    function Radiogroup(props) {
	        _classCallCheck(this, Radiogroup);

	        var _this = _possibleConstructorReturn(this, _React$Component.call(this, props));

	        _this.state = {
	            defaultValue: props.defaultValue
	        };
	        return _this;
	    }

	    Radiogroup.prototype._handleChange = function _handleChange(value) {
	        var me = this;
	        me.props.onChange(value);
	    };

	    Radiogroup.prototype._processChild = function _processChild() {
	        var me = this;
	        var length = React.Children.count(me.props.children);
	        if (!length) return false;
	        var elements = React.Children.map(me.props.children, function (child, index) {
	            if (!!child.type && child.type.displayName == "RadiogroupItem") {
	                return React.cloneElement(child, {
	                    onChange: me._handleChange.bind(me),
	                    key: index,
	                    checked: me.props.value == child.props.value
	                });
	            }
	        });
	        return elements;
	    };

	    Radiogroup.prototype.render = function render() {
	        var _classnames;

	        var me = this;
	        return React.createElement(
	            'div',
	            { className: classnames((_classnames = {
	                    "kuma-radio-group": true
	                }, _classnames[me.props.className] = !!me.props.className, _classnames)) },
	            me._processChild()
	        );
	    };

	    return Radiogroup;
	}(React.Component);

	Radiogroup.displayName = "Radiogroup";
	Radiogroup.propTypes = {
	    value: React.PropTypes.string,
	    onChange: React.PropTypes.func
	};
	Radiogroup.defaultProps = {
	    value: "",
	    onChange: function onChange() {}
	};

	Radiogroup.Item = Item;

	module.exports = Radiogroup;

/***/ },
/* 593 */
/***/ function(module, exports, __webpack_require__, __webpack_module_template_argument_0__) {

	/**
	 * Formatter Component for uxcore
	 * @author guanghong.wsj
	 *
	 * Copyright 2014-2015, Uxcore Team, Alinw.
	 * All rights reserved.
	 */

	module.exports = __webpack_require__(__webpack_module_template_argument_0__);

/***/ },
/* 594 */
/***/ function(module, exports, __webpack_require__, __webpack_module_template_argument_0__, __webpack_module_template_argument_1__) {

	var pSlice = Array.prototype.slice;
	var objectKeys = __webpack_require__(__webpack_module_template_argument_0__);
	var isArguments = __webpack_require__(__webpack_module_template_argument_1__);

	var deepEqual = module.exports = function (actual, expected, opts) {
	  if (!opts) opts = {};
	  // 7.1. All identical values are equivalent, as determined by ===.
	  if (actual === expected) {
	    return true;

	  } else if (actual instanceof Date && expected instanceof Date) {
	    return actual.getTime() === expected.getTime();

	  // 7.3. Other pairs that do not both pass typeof value == 'object',
	  // equivalence is determined by ==.
	  } else if (!actual || !expected || typeof actual != 'object' && typeof expected != 'object') {
	    return opts.strict ? actual === expected : actual == expected;

	  // 7.4. For all other Object pairs, including Array objects, equivalence is
	  // determined by having the same number of owned properties (as verified
	  // with Object.prototype.hasOwnProperty.call), the same set of keys
	  // (although not necessarily the same order), equivalent values for every
	  // corresponding key, and an identical 'prototype' property. Note: this
	  // accounts for both named and indexed properties on Arrays.
	  } else {
	    return objEquiv(actual, expected, opts);
	  }
	}

	function isUndefinedOrNull(value) {
	  return value === null || value === undefined;
	}

	function isBuffer (x) {
	  if (!x || typeof x !== 'object' || typeof x.length !== 'number') return false;
	  if (typeof x.copy !== 'function' || typeof x.slice !== 'function') {
	    return false;
	  }
	  if (x.length > 0 && typeof x[0] !== 'number') return false;
	  return true;
	}

	function objEquiv(a, b, opts) {
	  var i, key;
	  if (isUndefinedOrNull(a) || isUndefinedOrNull(b))
	    return false;
	  // an identical 'prototype' property.
	  if (a.prototype !== b.prototype) return false;
	  //~~~I've managed to break Object.keys through screwy arguments passing.
	  //   Converting to array solves the problem.
	  if (isArguments(a)) {
	    if (!isArguments(b)) {
	      return false;
	    }
	    a = pSlice.call(a);
	    b = pSlice.call(b);
	    return deepEqual(a, b, opts);
	  }
	  if (isBuffer(a)) {
	    if (!isBuffer(b)) {
	      return false;
	    }
	    if (a.length !== b.length) return false;
	    for (i = 0; i < a.length; i++) {
	      if (a[i] !== b[i]) return false;
	    }
	    return true;
	  }
	  try {
	    var ka = objectKeys(a),
	        kb = objectKeys(b);
	  } catch (e) {//happens when one is a string literal and the other isn't
	    return false;
	  }
	  // having the same number of owned properties (keys incorporates
	  // hasOwnProperty)
	  if (ka.length != kb.length)
	    return false;
	  //the same set of keys (although not necessarily the same order),
	  ka.sort();
	  kb.sort();
	  //~~~cheap key test
	  for (i = ka.length - 1; i >= 0; i--) {
	    if (ka[i] != kb[i])
	      return false;
	  }
	  //equivalent values for every corresponding key, and
	  //~~~possibly expensive deep test
	  for (i = ka.length - 1; i >= 0; i--) {
	    key = ka[i];
	    if (!deepEqual(a[key], b[key], opts)) return false;
	  }
	  return typeof a === typeof b;
	}


/***/ },
/* 595 */
/***/ function(module, exports, __webpack_require__, __webpack_module_template_argument_0__) {

	'use strict';

	/**
	 * Validator Component for uxcore
	 * @author eternalsky
	 *
	 * Copyright 2014-2015, Uxcore Team, Alinw.
	 * All rights reserved.
	 */

	module.exports = __webpack_require__(__webpack_module_template_argument_0__);

/***/ }
/******/ ])));
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidXhjb3JlLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vL3dlYnBhY2svYm9vdHN0cmFwIDRmZmNiYzk0ZTQwNTIyYTAxZDlmIiwid2VicGFjazovLy9saWJfX3V4Y29yZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3V4Y29yZS10YWJsZS9idWlsZC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L3V4Y29yZS10YWJsZS9idWlsZC9UYWJsZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3V4Y29yZS10YWJsZS9idWlsZC9IZWFkZXIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi91eGNvcmUtdGFibGUvYnVpbGQvQ2VsbC9DaGVja0JveC5qcyIsIndlYnBhY2s6Ly8vLi9+L3V4Y29yZS10YWJsZS9+L3V4Y29yZS1jb25zdC9idWlsZC9Db25zdC5qcyIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJ3aW5kb3cuUmVhY3RcIiIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJ3aW5kb3cuUmVhY3RET00gfHwgd2luZG93LlJlYWN0XCIiLCJ3ZWJwYWNrOi8vLy4vfi91eGNvcmUtdGFibGUvfi9vYmplY3QtYXNzaWduL2luZGV4LmpzIiwid2VicGFjazovLy8uL34vdXhjb3JlLXRhYmxlL34vdXhjb3JlLW1lbnUvYnVpbGQvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi91eGNvcmUtdGFibGUvfi91eGNvcmUtbWVudS9idWlsZC9NZW51LmpzIiwid2VicGFjazovLy8uL34vdXhjb3JlLXRhYmxlL34vdXhjb3JlLW1lbnUvfi9yYy1tZW51L2xpYi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L3V4Y29yZS10YWJsZS9+L3V4Y29yZS1tZW51L34vcmMtbWVudS9saWIvTWVudS5qcyIsIndlYnBhY2s6Ly8vLi9+L3V4Y29yZS10YWJsZS9+L3V4Y29yZS1tZW51L34vcmMtbWVudS9saWIvTWVudU1peGluLmpzIiwid2VicGFjazovLy8uL34vdXhjb3JlLXRhYmxlL34vdXhjb3JlLW1lbnUvfi9yYy1tZW51L34vcmMtdXRpbC9saWIvZ3VpZC5qcyIsIndlYnBhY2s6Ly8vLi9+L3V4Y29yZS10YWJsZS9+L3V4Y29yZS1tZW51L34vcmMtbWVudS9+L3JjLXV0aWwvfi91dGlsLWRlcHJlY2F0ZS9icm93c2VyLmpzIiwid2VicGFjazovLy8uL34vY2xhc3NuYW1lcy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L3V4Y29yZS10YWJsZS9+L3V4Y29yZS1tZW51L34vcmMtbWVudS9+L3JjLXV0aWwvbGliL0tleUNvZGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi91eGNvcmUtdGFibGUvfi91eGNvcmUtbWVudS9+L3JjLW1lbnUvfi9yYy11dGlsL34vc2hhbGxvd2VxdWFsL34vbG9kYXNoLmtleXMvfi9sb2Rhc2guX2dldG5hdGl2ZS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L3V4Y29yZS10YWJsZS9+L3V4Y29yZS1tZW51L34vcmMtbWVudS9+L3JjLXV0aWwvfi9zaGFsbG93ZXF1YWwvfi9sb2Rhc2gua2V5cy9+L2xvZGFzaC5pc2FyZ3VtZW50cy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L3V4Y29yZS10YWJsZS9+L3V4Y29yZS1tZW51L34vcmMtbWVudS9+L3JjLXV0aWwvfi9zaGFsbG93ZXF1YWwvfi9sb2Rhc2gua2V5cy9+L2xvZGFzaC5pc2FycmF5L2luZGV4LmpzIiwid2VicGFjazovLy8uL34vdXhjb3JlLXRhYmxlL34vdXhjb3JlLW1lbnUvfi9yYy1tZW51L34vcmMtdXRpbC9saWIvY3JlYXRlQ2hhaW5lZEZ1bmN0aW9uLmpzIiwid2VicGFjazovLy8uL34vdXhjb3JlLXRhYmxlL34vdXhjb3JlLW1lbnUvfi9yYy1tZW51L34vcmMtdXRpbC9+L2FkZC1kb20tZXZlbnQtbGlzdGVuZXIvbGliL0V2ZW50QmFzZU9iamVjdC5qcyIsIndlYnBhY2s6Ly8vLi9+L3V4Y29yZS10YWJsZS9+L3V4Y29yZS1tZW51L34vcmMtbWVudS9+L3JjLXV0aWwvbGliL0RvbS9jb250YWlucy5qcyIsIndlYnBhY2s6Ly8vLi9+L3V4Y29yZS10YWJsZS9+L3V4Y29yZS1tZW51L34vcmMtbWVudS9+L3JjLXV0aWwvbGliL0NoaWxkcmVuL3RvQXJyYXkuanMiLCJ3ZWJwYWNrOi8vLy4vfi91eGNvcmUtdGFibGUvfi91eGNvcmUtbWVudS9+L3JjLW1lbnUvfi9yYy11dGlsL2xpYi9DaGlsZHJlbi9tYXBTZWxmLmpzIiwid2VicGFjazovLy8uL34vdXhjb3JlLXRhYmxlL34vdXhjb3JlLW1lbnUvfi9yYy1tZW51L34vZG9tLXNjcm9sbC1pbnRvLXZpZXcvbGliL3V0aWwuanMiLCJ3ZWJwYWNrOi8vLy4vfi91eGNvcmUtdGFibGUvfi91eGNvcmUtbWVudS9+L3JjLW1lbnUvbGliL3V0aWwuanMiLCJ3ZWJwYWNrOi8vLy4vfi91eGNvcmUtdGFibGUvfi91eGNvcmUtbWVudS9+L3JjLW1lbnUvbGliL0RPTVdyYXAuanMiLCJ3ZWJwYWNrOi8vLy4vfi91eGNvcmUtdGFibGUvfi91eGNvcmUtbWVudS9+L3JjLW1lbnUvbGliL1N1Yk1lbnUuanMiLCJ3ZWJwYWNrOi8vLy4vfi91eGNvcmUtdGFibGUvfi91eGNvcmUtbWVudS9+L3JjLW1lbnUvbGliL1N1YlBvcHVwTWVudS5qcyIsIndlYnBhY2s6Ly8vLi9+L3V4Y29yZS10YWJsZS9+L3V4Y29yZS1tZW51L34vcmMtbWVudS9+L3JjLWFuaW1hdGUvbGliL0NoaWxkcmVuVXRpbHMuanMiLCJ3ZWJwYWNrOi8vLy4vfi91eGNvcmUtdGFibGUvfi91eGNvcmUtbWVudS9+L3JjLW1lbnUvfi9yYy1hbmltYXRlL34vY3NzLWFuaW1hdGlvbi9saWIvRXZlbnQuanMiLCJ3ZWJwYWNrOi8vLy4vfi91eGNvcmUtdGFibGUvfi91eGNvcmUtbWVudS9+L3JjLW1lbnUvfi9yYy1hbmltYXRlL34vY3NzLWFuaW1hdGlvbi9+L2NvbXBvbmVudC1jbGFzc2VzL34vY29tcG9uZW50LWluZGV4b2YvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi91eGNvcmUtdGFibGUvfi91eGNvcmUtbWVudS9+L3JjLW1lbnUvfi9yYy1hbmltYXRlL2xpYi91dGlsLmpzIiwid2VicGFjazovLy8uL34vdXhjb3JlLXRhYmxlL34vdXhjb3JlLW1lbnUvfi9yYy1tZW51L2xpYi9TdWJNZW51U3RhdGVNaXhpbi5qcyIsIndlYnBhY2s6Ly8vLi9+L3V4Y29yZS10YWJsZS9+L3V4Y29yZS1tZW51L34vcmMtbWVudS9saWIvTWVudUl0ZW0uanMiLCJ3ZWJwYWNrOi8vLy4vfi91eGNvcmUtdGFibGUvfi91eGNvcmUtbWVudS9+L3JjLW1lbnUvbGliL01lbnVJdGVtR3JvdXAuanMiLCJ3ZWJwYWNrOi8vLy4vfi91eGNvcmUtdGFibGUvfi91eGNvcmUtbWVudS9+L3JjLW1lbnUvbGliL0RpdmlkZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi91eGNvcmUtdGFibGUvfi91eGNvcmUtZHJvcGRvd24vYnVpbGQvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi91eGNvcmUtdGFibGUvfi91eGNvcmUtZHJvcGRvd24vYnVpbGQvRHJvcGRvd24uanMiLCJ3ZWJwYWNrOi8vLy4vfi91eGNvcmUtdGFibGUvfi91eGNvcmUtZHJvcGRvd24vfi9yYy1kcm9wZG93bi9saWIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi91eGNvcmUtdGFibGUvfi91eGNvcmUtZHJvcGRvd24vfi9yYy1kcm9wZG93bi9saWIvRHJvcGRvd24uanMiLCJ3ZWJwYWNrOi8vLy4vfi91eGNvcmUtdGFibGUvfi91eGNvcmUtZHJvcGRvd24vfi9yYy1kcm9wZG93bi9+L3JjLXRyaWdnZXIvfi9yYy1hbGlnbi9+L2RvbS1hbGlnbi9saWIvdXRpbHMuanMiLCJ3ZWJwYWNrOi8vLy4vfi91eGNvcmUtdGFibGUvfi91eGNvcmUtZHJvcGRvd24vfi9yYy1kcm9wZG93bi9+L3JjLXRyaWdnZXIvfi9yYy1hbGlnbi9+L2RvbS1hbGlnbi9saWIvZ2V0QWxpZ25PZmZzZXQuanMiLCJ3ZWJwYWNrOi8vLy4vfi91eGNvcmUtdGFibGUvfi91eGNvcmUtZHJvcGRvd24vfi9yYy1kcm9wZG93bi9+L3JjLXRyaWdnZXIvfi9yYy1hbGlnbi9saWIvaXNXaW5kb3cuanMiLCJ3ZWJwYWNrOi8vLy4vfi91eGNvcmUtdGFibGUvfi91eGNvcmUtZHJvcGRvd24vfi9yYy1kcm9wZG93bi9+L3JjLXRyaWdnZXIvbGliL0xhenlSZW5kZXJCb3guanMiLCJ3ZWJwYWNrOi8vLy4vfi91eGNvcmUtdGFibGUvfi91eGNvcmUtZHJvcGRvd24vfi9yYy1kcm9wZG93bi9+L3JjLXRyaWdnZXIvbGliL3V0aWxzLmpzIiwid2VicGFjazovLy8uL34vdXhjb3JlLXRhYmxlL34vdXhjb3JlLWRyb3Bkb3duL34vcmMtZHJvcGRvd24vbGliL3BsYWNlbWVudHMuanMiLCJ3ZWJwYWNrOi8vLy4vfi91eGNvcmUtdGFibGUvfi91eGNvcmUtdG9vbHRpcC9+L3JjLXRvb2x0aXAvbGliL3BsYWNlbWVudHMuanMiLCJ3ZWJwYWNrOi8vLy4vfi91eGNvcmUtdGFibGUvYnVpbGQvVGJvZHkuanMiLCJ3ZWJwYWNrOi8vLy4vfi91eGNvcmUtdGFibGUvYnVpbGQvUm93LmpzIiwid2VicGFjazovLy8uL34vdXhjb3JlLXRhYmxlL2J1aWxkL0NlbGwvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi91eGNvcmUtdGFibGUvYnVpbGQvQ2VsbC9SYWRpby5qcyIsIndlYnBhY2s6Ly8vLi9+L3V4Y29yZS10YWJsZS9idWlsZC9DZWxsL1RleHRGaWVsZC5qcyIsIndlYnBhY2s6Ly8vLi9+L3V4Y29yZS10YWJsZS9idWlsZC9DZWxsL0NlbGxGaWVsZC5qcyIsIndlYnBhY2s6Ly8vLi9+L3V4Y29yZS10YWJsZS9idWlsZC9DZWxsL1NlbGVjdEZpZWxkLmpzIiwid2VicGFjazovLy8uL34vdXhjb3JlLXRhYmxlL34vdXhjb3JlLXNlbGVjdDIvfi9yYy1zZWxlY3QvbGliL09wdEdyb3VwLmpzIiwid2VicGFjazovLy8uL34vdXhjb3JlLXRhYmxlL34vdXhjb3JlLXNlbGVjdDIvfi9yYy1zZWxlY3Qvfi9yYy1tZW51L2xpYi91dGlsLmpzIiwid2VicGFjazovLy8uL34vdXhjb3JlLXRhYmxlL34vdXhjb3JlLXNlbGVjdDIvfi9yYy1zZWxlY3Qvfi9yYy1tZW51L2xpYi9NZW51SXRlbUdyb3VwLmpzIiwid2VicGFjazovLy8uL34vdXhjb3JlLXRhYmxlL34vdXhjb3JlLXNlbGVjdDIvfi9yYy1zZWxlY3Qvfi9yYy1tZW51L2xpYi9EaXZpZGVyLmpzIiwid2VicGFjazovLy8uL34vdXhjb3JlLXRhYmxlL34vdXhjb3JlLXNlbGVjdDIvfi9yYy1zZWxlY3QvbGliL09wdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9+L3V4Y29yZS10YWJsZS9idWlsZC9DZWxsL1JhZGlvRmllbGQuanMiLCJ3ZWJwYWNrOi8vLy4vfi91eGNvcmUtdGFibGUvfi91eGNvcmUtcmFkaW9ncm91cC9idWlsZC9SYWRpb2dyb3VwSXRlbS5qcyIsIndlYnBhY2s6Ly8vLi9+L3V4Y29yZS10YWJsZS9idWlsZC9DZWxsL1V0aWwuanMiLCJ3ZWJwYWNrOi8vLy4vfi91eGNvcmUtdGFibGUvfi91eGNvcmUtZm9ybWF0dGVyL3NyYy9Gb3JtYXR0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi91eGNvcmUtdGFibGUvfi9kZWVwY29weS9kZWVwY29weS5qcyIsIndlYnBhY2s6Ly8vL3Vzci9sb2NhbC9saWIvfi8ubnBtaW5zdGFsbC9wcm9jZXNzLzAuMTEuMy9wcm9jZXNzL2Jyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vLy91c3IvbG9jYWwvbGliL34vLm5wbWluc3RhbGwvYnVmZmVyLzMuNi4wL2J1ZmZlci9pbmRleC5qcyIsIndlYnBhY2s6Ly8vL3Vzci9sb2NhbC9saWIvfi8ubnBtaW5zdGFsbC9iYXNlNjQtanMvMC4wLjgvYmFzZTY0LWpzL2xpYi9iNjQuanMiLCJ3ZWJwYWNrOi8vLy91c3IvbG9jYWwvbGliL34vLm5wbWluc3RhbGwvaWVlZTc1NC8xLjEuNi9pZWVlNzU0L2luZGV4LmpzIiwid2VicGFjazovLy8vdXNyL2xvY2FsL2xpYi9+Ly5ucG1pbnN0YWxsL2lzYXJyYXkvMS4wLjAvaXNhcnJheS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vL3Vzci9sb2NhbC9saWIvfi8ubnBtaW5zdGFsbC91dGlsLzAuMTAuMy91dGlsL3V0aWwuanMiLCJ3ZWJwYWNrOi8vLy91c3IvbG9jYWwvbGliL34vLm5wbWluc3RhbGwvdXRpbC8wLjEwLjMvdXRpbC9zdXBwb3J0L2lzQnVmZmVyQnJvd3Nlci5qcyIsIndlYnBhY2s6Ly8vL3Vzci9sb2NhbC9saWIvfi8ubnBtaW5zdGFsbC9pbmhlcml0cy8yLjAuMS9pbmhlcml0cy9pbmhlcml0c19icm93c2VyLmpzIiwid2VicGFjazovLy8uL34vdXhjb3JlLXRhYmxlL34vZGVlcC1lcXVhbC9saWIva2V5cy5qcyIsIndlYnBhY2s6Ly8vLi9+L3V4Y29yZS10YWJsZS9+L2RlZXAtZXF1YWwvbGliL2lzX2FyZ3VtZW50cy5qcyIsIndlYnBhY2s6Ly8vLi9+L3V4Y29yZS10YWJsZS9idWlsZC9NYXNrLmpzIiwid2VicGFjazovLy8uL34vdXhjb3JlLXRhYmxlL2J1aWxkL3V0aWwuanMiLCJ3ZWJwYWNrOi8vLy4vfi91eGNvcmUtdGFibGUvYnVpbGQvQWN0aW9uQmFyLmpzIiwid2VicGFjazovLy8uL34vdXhjb3JlLXRhYmxlL2J1aWxkL1NlYXJjaEJhci5qcyIsIndlYnBhY2s6Ly8vLi9+L3V4Y29yZS1idXR0b24vYnVpbGQvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi91eGNvcmUtYnV0dG9uL2J1aWxkL0J1dHRvbi5qcyIsIndlYnBhY2s6Ly8vLi9+L3V4Y29yZS1idXR0b24vYnVpbGQvQnV0dG9uR3JvdXAuanMiLCJ3ZWJwYWNrOi8vLy4vfi91eGNvcmUtdGFibGUvfi91eGNvcmUtcGFnaW5hdGlvbi9idWlsZC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L3V4Y29yZS10YWJsZS9+L3V4Y29yZS1wYWdpbmF0aW9uL2J1aWxkL1BhZ2luYXRpb24uanMiLCJ3ZWJwYWNrOi8vLy4vfi91eGNvcmUtdGFibGUvfi91eGNvcmUtcGFnaW5hdGlvbi9idWlsZC9QYWdlci5qcyIsIndlYnBhY2s6Ly8vLi9+L3V4Y29yZS10YWJsZS9+L3V4Y29yZS1wYWdpbmF0aW9uL2J1aWxkL09wdGlvbnMuanMiLCJ3ZWJwYWNrOi8vLy4vfi91eGNvcmUtdGFibGUvfi91eGNvcmUtcGFnaW5hdGlvbi9idWlsZC9LZXlDb2RlLmpzIiwid2VicGFjazovLy8uL34vdXhjb3JlLXRhYmxlL34vdXhjb3JlLXBhZ2luYXRpb24vYnVpbGQvbG9jYWxlLmpzIiwid2VicGFjazovLy8uL34vdXhjb3JlLWZvcm0vYnVpbGQvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi91eGNvcmUtZm9ybS9idWlsZC9Gb3JtLmpzIiwid2VicGFjazovLy8uL34vdXhjb3JlLWZvcm0vfi91eGNvcmUtZm9ybS1yb3cvYnVpbGQvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi91eGNvcmUtZm9ybS9+L3V4Y29yZS1mb3JtLXJvdy9idWlsZC9Gb3JtUm93LmpzIiwid2VicGFjazovLy8uL34vdXhjb3JlLWZvcm0vYnVpbGQvRm9ybVJvd1RpdGxlLmpzIiwid2VicGFjazovLy8uL34vdXhjb3JlLWZvcm0vfi91eGNvcmUtZm9ybS1maWVsZC9idWlsZC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L3V4Y29yZS1mb3JtL34vdXhjb3JlLWZvcm0tZmllbGQvYnVpbGQvRm9ybUZpZWxkLmpzIiwid2VicGFjazovLy8uL34vdXhjb3JlLWZvcm0vfi91eGNvcmUtZm9ybS1maWVsZC9+L29iamVjdC1hc3NpZ24vaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi91eGNvcmUtZm9ybS9idWlsZC9WYWxpZGF0b3JzLmpzIiwid2VicGFjazovLy8uL34vdXhjb3JlLWZvcm0vfi91eGNvcmUtdmFsaWRhdG9yL2J1aWxkL1ZhbGlkYXRvci5qcyIsIndlYnBhY2s6Ly8vLi9+L3V4Y29yZS1mb3JtL2J1aWxkL0tleUNvZGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi91eGNvcmUtZm9ybS9+L3V4Y29yZS10ZXh0YXJlYS1mb3JtLWZpZWxkL2J1aWxkL2luZGV4LmpzIiwid2VicGFjazovLy8uL34vdXhjb3JlLWZvcm0vfi91eGNvcmUtdGV4dGFyZWEtZm9ybS1maWVsZC9idWlsZC9UZXh0YXJlYUZvcm1GaWVsZC5qcyIsIndlYnBhY2s6Ly8vLi9+L3V4Y29yZS1mb3JtL34vdXhjb3JlLXRleHRhcmVhLWZvcm0tZmllbGQvfi9hdXRvc2l6ZS9kaXN0L2F1dG9zaXplLmpzIiwid2VicGFjazovLy8uL34vdXhjb3JlLWZvcm0vfi91eGNvcmUtaW5wdXQtZm9ybS1maWVsZC9idWlsZC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L3V4Y29yZS1mb3JtL34vdXhjb3JlLWlucHV0LWZvcm0tZmllbGQvYnVpbGQvSW5wdXRGb3JtRmllbGQuanMiLCJ3ZWJwYWNrOi8vLy4vfi91eGNvcmUtZm9ybS9+L3V4Y29yZS1pbnB1dC1mb3JtLWZpZWxkL2J1aWxkL3V0aWwuanMiLCJ3ZWJwYWNrOi8vLy4vfi91eGNvcmUtZm9ybS9idWlsZC9Gb3JtRmllbGQvUmFkaW9Hcm91cEZvcm1GaWVsZC5qcyIsIndlYnBhY2s6Ly8vLi9+L3V4Y29yZS1mb3JtL34vdXhjb3JlLXNlbGVjdC1mb3JtLWZpZWxkL2J1aWxkL2luZGV4LmpzIiwid2VicGFjazovLy8uL34vdXhjb3JlLWZvcm0vfi91eGNvcmUtc2VsZWN0LWZvcm0tZmllbGQvYnVpbGQvU2VsZWN0Rm9ybUZpZWxkLmpzIiwid2VicGFjazovLy8uL34vdXhjb3JlLWZvcm0vfi91eGNvcmUtc2VsZWN0LWZvcm0tZmllbGQvfi91eGNvcmUtdmFsaWRhdG9yL2J1aWxkL1ZhbGlkYXRvci5qcyIsIndlYnBhY2s6Ly8vLi9+L3V4Y29yZS1mb3JtL2J1aWxkL0Zvcm1GaWVsZC9OdW1iZXJJbnB1dEZvcm1GaWVsZC5qcyIsIndlYnBhY2s6Ly8vLi9+L3V4Y29yZS1mb3JtL2J1aWxkL0Zvcm1GaWVsZC9JbnB1dEZvcm1GaWVsZC5qcyIsIndlYnBhY2s6Ly8vLi9+L3V4Y29yZS1mb3JtL34vdXhjb3JlLWRhdGUtZm9ybS1maWVsZC9idWlsZC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L3V4Y29yZS1mb3JtL34vdXhjb3JlLWRhdGUtZm9ybS1maWVsZC9idWlsZC9EYXRlRm9ybUZpZWxkLmpzIiwid2VicGFjazovLy8uL34vdXhjb3JlLWZvcm0vfi91eGNvcmUtZGF0ZS1mb3JtLWZpZWxkL34vdXhjb3JlLWNhbGVuZGFyL2J1aWxkL2luZGV4LmpzIiwid2VicGFjazovLy8uL34vdXhjb3JlLWZvcm0vfi91eGNvcmUtZGF0ZS1mb3JtLWZpZWxkL34vdXhjb3JlLWNhbGVuZGFyL2J1aWxkL0NhbGVuZGFyLmpzIiwid2VicGFjazovLy8uL34vdXhjb3JlLWZvcm0vfi91eGNvcmUtZGF0ZS1mb3JtLWZpZWxkL34vdXhjb3JlLWNhbGVuZGFyL2J1aWxkL1JjQ2FsZW5kYXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi91eGNvcmUtZm9ybS9+L3V4Y29yZS1kYXRlLWZvcm0tZmllbGQvfi91eGNvcmUtY2FsZW5kYXIvfi9ncmVnb3JpYW4tY2FsZW5kYXIvbGliL2dyZWdvcmlhbi1jYWxlbmRhci5qcyIsIndlYnBhY2s6Ly8vLi9+L3V4Y29yZS1mb3JtL34vdXhjb3JlLWRhdGUtZm9ybS1maWVsZC9+L3V4Y29yZS1jYWxlbmRhci9+L2dyZWdvcmlhbi1jYWxlbmRhci9saWIvdXRpbHMuanMiLCJ3ZWJwYWNrOi8vLy4vfi91eGNvcmUtZm9ybS9+L3V4Y29yZS1kYXRlLWZvcm0tZmllbGQvfi91eGNvcmUtY2FsZW5kYXIvfi9ncmVnb3JpYW4tY2FsZW5kYXIvbGliL2NvbnN0LmpzIiwid2VicGFjazovLy8uL34vdXhjb3JlLWZvcm0vfi91eGNvcmUtZGF0ZS1mb3JtLWZpZWxkL34vdXhjb3JlLWNhbGVuZGFyL34vZ3JlZ29yaWFuLWNhbGVuZGFyL2xpYi9sb2NhbGUvZW5fVVMuanMiLCJ3ZWJwYWNrOi8vLy4vfi91eGNvcmUtZm9ybS9+L3V4Y29yZS1kYXRlLWZvcm0tZmllbGQvfi91eGNvcmUtY2FsZW5kYXIvYnVpbGQvZGF0ZS9EYXRlVGFibGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi91eGNvcmUtZm9ybS9+L3V4Y29yZS1kYXRlLWZvcm0tZmllbGQvfi91eGNvcmUtY2FsZW5kYXIvYnVpbGQvZGF0ZS9EYXRlVEhlYWQuanMiLCJ3ZWJwYWNrOi8vLy4vfi91eGNvcmUtZm9ybS9+L3V4Y29yZS1kYXRlLWZvcm0tZmllbGQvfi91eGNvcmUtY2FsZW5kYXIvYnVpbGQvZGF0ZS9EYXRlQ29uc3RhbnRzLmpzIiwid2VicGFjazovLy8uL34vdXhjb3JlLWZvcm0vfi91eGNvcmUtZGF0ZS1mb3JtLWZpZWxkL34vdXhjb3JlLWNhbGVuZGFyL2J1aWxkL2RhdGUvRGF0ZVRCb2R5LmpzIiwid2VicGFjazovLy8uL34vdXhjb3JlLWZvcm0vfi91eGNvcmUtZGF0ZS1mb3JtLWZpZWxkL34vdXhjb3JlLWNhbGVuZGFyL34vcmMtY2FsZW5kYXIvbGliL2RhdGUvRGF0ZUNvbnN0YW50cy5qcyIsIndlYnBhY2s6Ly8vLi9+L3V4Y29yZS1mb3JtL34vdXhjb3JlLWRhdGUtZm9ybS1maWVsZC9+L3V4Y29yZS1jYWxlbmRhci9+L3JjLWNhbGVuZGFyL2xpYi91dGlsL2luZGV4LmpzIiwid2VicGFjazovLy8uL34vdXhjb3JlLWZvcm0vfi91eGNvcmUtZGF0ZS1mb3JtLWZpZWxkL34vdXhjb3JlLWNhbGVuZGFyL34vZ3JlZ29yaWFuLWNhbGVuZGFyLWZvcm1hdC9saWIvZ3JlZ29yaWFuLWNhbGVuZGFyLWZvcm1hdC5qcyIsIndlYnBhY2s6Ly8vLi9+L3V4Y29yZS1mb3JtL34vdXhjb3JlLWRhdGUtZm9ybS1maWVsZC9+L3V4Y29yZS1jYWxlbmRhci9+L2dyZWdvcmlhbi1jYWxlbmRhci1mb3JtYXQvbGliL2xvY2FsZS9lbl9VUy5qcyIsIndlYnBhY2s6Ly8vLi9+L3V4Y29yZS1mb3JtL34vdXhjb3JlLWRhdGUtZm9ybS1maWVsZC9+L3V4Y29yZS1jYWxlbmRhci9+L2dyZWdvcmlhbi1jYWxlbmRhci1mb3JtYXQvfi93YXJuaW5nL2Jyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi91eGNvcmUtZm9ybS9+L3V4Y29yZS1kYXRlLWZvcm0tZmllbGQvfi91eGNvcmUtY2FsZW5kYXIvfi9yYy1jYWxlbmRhci9saWIvY2FsZW5kYXIvQ2FsZW5kYXJIZWFkZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi91eGNvcmUtZm9ybS9+L3V4Y29yZS1kYXRlLWZvcm0tZmllbGQvfi91eGNvcmUtY2FsZW5kYXIvfi9yYy1jYWxlbmRhci9saWIvbW9udGgvTW9udGhQYW5lbC5qcyIsIndlYnBhY2s6Ly8vLi9+L3V4Y29yZS1mb3JtL34vdXhjb3JlLWRhdGUtZm9ybS1maWVsZC9+L3V4Y29yZS1jYWxlbmRhci9+L3JjLWNhbGVuZGFyL2xpYi95ZWFyL1llYXJQYW5lbC5qcyIsIndlYnBhY2s6Ly8vLi9+L3V4Y29yZS1mb3JtL34vdXhjb3JlLWRhdGUtZm9ybS1maWVsZC9+L3V4Y29yZS1jYWxlbmRhci9+L3JjLWNhbGVuZGFyL2xpYi9kZWNhZGUvRGVjYWRlUGFuZWwuanMiLCJ3ZWJwYWNrOi8vLy4vfi91eGNvcmUtZm9ybS9+L3V4Y29yZS1kYXRlLWZvcm0tZmllbGQvfi91eGNvcmUtY2FsZW5kYXIvfi9yYy1jYWxlbmRhci9saWIvbW9udGgvTW9udGhUYWJsZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3V4Y29yZS1mb3JtL34vdXhjb3JlLWRhdGUtZm9ybS1maWVsZC9+L3V4Y29yZS1jYWxlbmRhci9+L3JjLWNhbGVuZGFyL2xpYi9jYWxlbmRhci9DYWxlbmRhckZvb3Rlci5qcyIsIndlYnBhY2s6Ly8vLi9+L3V4Y29yZS1mb3JtL34vdXhjb3JlLWRhdGUtZm9ybS1maWVsZC9+L3V4Y29yZS1jYWxlbmRhci9+L3JjLWNhbGVuZGFyL2xpYi9jYWxlbmRhci9Ub2RheUJ1dHRvbi5qcyIsIndlYnBhY2s6Ly8vLi9+L3V4Y29yZS1mb3JtL34vdXhjb3JlLWRhdGUtZm9ybS1maWVsZC9+L3V4Y29yZS1jYWxlbmRhci9+L3JjLWNhbGVuZGFyL2xpYi9jYWxlbmRhci9Pa0J1dHRvbi5qcyIsIndlYnBhY2s6Ly8vLi9+L3V4Y29yZS1mb3JtL34vdXhjb3JlLWRhdGUtZm9ybS1maWVsZC9+L3V4Y29yZS1jYWxlbmRhci9+L3JjLWNhbGVuZGFyL2xpYi9taXhpbi9DYWxlbmRhck1peGluLmpzIiwid2VicGFjazovLy8uL34vdXhjb3JlLWZvcm0vfi91eGNvcmUtZGF0ZS1mb3JtLWZpZWxkL34vdXhjb3JlLWNhbGVuZGFyL34vcmMtY2FsZW5kYXIvbGliL21peGluL0NvbW1vbk1peGluLmpzIiwid2VicGFjazovLy8uL34vdXhjb3JlLWZvcm0vfi91eGNvcmUtZGF0ZS1mb3JtLWZpZWxkL34vdXhjb3JlLWNhbGVuZGFyL34vcmMtY2FsZW5kYXIvbGliL2xvY2FsZS9lbl9VUy5qcyIsIndlYnBhY2s6Ly8vLi9+L3V4Y29yZS1mb3JtL34vdXhjb3JlLWRhdGUtZm9ybS1maWVsZC9+L3V4Y29yZS1jYWxlbmRhci9+L3JjLWNhbGVuZGFyL2xpYi9kYXRlL0RhdGVJbnB1dC5qcyIsIndlYnBhY2s6Ly8vLi9+L3V4Y29yZS1mb3JtL34vdXhjb3JlLWRhdGUtZm9ybS1maWVsZC9+L3V4Y29yZS1jYWxlbmRhci9+L3JjLWNhbGVuZGFyL2xpYi9QaWNrZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi91eGNvcmUtZm9ybS9+L3V4Y29yZS1kYXRlLWZvcm0tZmllbGQvfi91eGNvcmUtY2FsZW5kYXIvfi9yYy1jYWxlbmRhci9saWIvcGlja2VyL3BsYWNlbWVudHMuanMiLCJ3ZWJwYWNrOi8vLy4vfi91eGNvcmUtZm9ybS9+L3V4Y29yZS1kYXRlLWZvcm0tZmllbGQvfi91eGNvcmUtY2FsZW5kYXIvfi9yYy1jYWxlbmRhci9saWIvTW9udGhDYWxlbmRhci5qcyIsIndlYnBhY2s6Ly8vLi9+L3V4Y29yZS1mb3JtL34vdXhjb3JlLWRhdGUtZm9ybS1maWVsZC9+L3V4Y29yZS1jYWxlbmRhci9idWlsZC9ZZWFyQ2FsZW5kYXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi91eGNvcmUtZm9ybS9+L3V4Y29yZS1kYXRlLWZvcm0tZmllbGQvfi91eGNvcmUtY2FsZW5kYXIvfi9yYy10aW1lLXBpY2tlci9saWIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi91eGNvcmUtZm9ybS9+L3V4Y29yZS1kYXRlLWZvcm0tZmllbGQvfi91eGNvcmUtY2FsZW5kYXIvfi9yYy10aW1lLXBpY2tlci9saWIvVGltZVBpY2tlci5qcyIsIndlYnBhY2s6Ly8vLi9+L3V4Y29yZS1mb3JtL34vdXhjb3JlLWRhdGUtZm9ybS1maWVsZC9+L3V4Y29yZS1jYWxlbmRhci9+L3JjLXRpbWUtcGlja2VyL2xpYi9tb2R1bGUvUGFuZWwuanMiLCJ3ZWJwYWNrOi8vLy4vfi91eGNvcmUtZm9ybS9+L3V4Y29yZS1kYXRlLWZvcm0tZmllbGQvfi91eGNvcmUtY2FsZW5kYXIvfi9yYy10aW1lLXBpY2tlci9saWIvbWl4aW4vQ29tbW9uTWl4aW4uanMiLCJ3ZWJwYWNrOi8vLy4vfi91eGNvcmUtZm9ybS9+L3V4Y29yZS1kYXRlLWZvcm0tZmllbGQvfi91eGNvcmUtY2FsZW5kYXIvfi9yYy10aW1lLXBpY2tlci9saWIvbG9jYWxlL2VuX1VTLmpzIiwid2VicGFjazovLy8uL34vdXhjb3JlLWZvcm0vfi91eGNvcmUtZGF0ZS1mb3JtLWZpZWxkL34vdXhjb3JlLWNhbGVuZGFyL34vcmMtdGltZS1waWNrZXIvbGliL21vZHVsZS9IZWFkZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi91eGNvcmUtZm9ybS9+L3V4Y29yZS1kYXRlLWZvcm0tZmllbGQvfi91eGNvcmUtY2FsZW5kYXIvfi9yYy10aW1lLXBpY2tlci9saWIvdXRpbC9zZWxlY3Rpb24uanMiLCJ3ZWJwYWNrOi8vLy4vfi91eGNvcmUtZm9ybS9+L3V4Y29yZS1kYXRlLWZvcm0tZmllbGQvfi91eGNvcmUtY2FsZW5kYXIvfi9yYy10aW1lLXBpY2tlci9saWIvbW9kdWxlL0NvbWJvYm94LmpzIiwid2VicGFjazovLy8uL34vdXhjb3JlLWZvcm0vfi91eGNvcmUtZGF0ZS1mb3JtLWZpZWxkL34vdXhjb3JlLWNhbGVuZGFyL34vcmMtdGltZS1waWNrZXIvbGliL21vZHVsZS9TZWxlY3QuanMiLCJ3ZWJwYWNrOi8vLy4vfi91eGNvcmUtZm9ybS9+L3V4Y29yZS1kYXRlLWZvcm0tZmllbGQvfi91eGNvcmUtY2FsZW5kYXIvfi9yYy10aW1lLXBpY2tlci9saWIvdXRpbC9wbGFjZW1lbnRzLmpzIiwid2VicGFjazovLy8uL34vdXhjb3JlLWZvcm0vfi91eGNvcmUtZGF0ZS1mb3JtLWZpZWxkL34vdXhjb3JlLWNhbGVuZGFyL34vcmMtdGltZS1waWNrZXIvbGliL3V0aWwvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi91eGNvcmUtZm9ybS9+L3V4Y29yZS1kYXRlLWZvcm0tZmllbGQvfi91eGNvcmUtY2FsZW5kYXIvYnVpbGQvdXRpbC5qcyIsIndlYnBhY2s6Ly8vLi9+L3V4Y29yZS1mb3JtL34vdXhjb3JlLWRhdGUtZm9ybS1maWVsZC9+L3V4Y29yZS1jYWxlbmRhci9idWlsZC9sb2NhbGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi91eGNvcmUtZm9ybS9+L3V4Y29yZS1kYXRlLWZvcm0tZmllbGQvfi91eGNvcmUtY2FsZW5kYXIvfi9ncmVnb3JpYW4tY2FsZW5kYXIvbGliL2xvY2FsZS96aF9DTi5qcyIsIndlYnBhY2s6Ly8vLi9+L3V4Y29yZS1mb3JtL34vdXhjb3JlLWRhdGUtZm9ybS1maWVsZC9+L3V4Y29yZS1jYWxlbmRhci9+L3JjLWNhbGVuZGFyL2xpYi9sb2NhbGUvemhfQ04uanMiLCJ3ZWJwYWNrOi8vLy4vfi91eGNvcmUtZm9ybS9+L3V4Y29yZS1kYXRlLWZvcm0tZmllbGQvfi91eGNvcmUtY2FsZW5kYXIvfi9ncmVnb3JpYW4tY2FsZW5kYXItZm9ybWF0L2xpYi9sb2NhbGUvemhfQ04uanMiLCJ3ZWJwYWNrOi8vLy4vfi91eGNvcmUtZm9ybS9+L3V4Y29yZS1kYXRlLWZvcm0tZmllbGQvfi91eGNvcmUtY2FsZW5kYXIvfi9yYy10aW1lLXBpY2tlci9saWIvbG9jYWxlL3poX0NOLmpzIiwid2VicGFjazovLy8uL34vdXhjb3JlLWZvcm0vYnVpbGQvRm9ybUZpZWxkL0NoZWNrYm94R3JvdXBGb3JtRmllbGQuanMiLCJ3ZWJwYWNrOi8vLy4vfi91eGNvcmUtZm9ybS9+L3V4Y29yZS1jaGVja2JveC1ncm91cC9idWlsZC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L3V4Y29yZS1mb3JtL34vdXhjb3JlLWNoZWNrYm94LWdyb3VwL2J1aWxkL0NoZWNrYm94R3JvdXAuanMiLCJ3ZWJwYWNrOi8vLy4vfi91eGNvcmUtZm9ybS9+L3V4Y29yZS1jaGVja2JveC1ncm91cC9idWlsZC9DaGVja2JveEl0ZW0uanMiLCJ3ZWJwYWNrOi8vLy4vfi91eGNvcmUtZm9ybS9idWlsZC9Gb3JtRmllbGQvQ2FzY2FkZVNlbGVjdEZvcm1GaWVsZC5qcyIsIndlYnBhY2s6Ly8vLi9+L3V4Y29yZS1mb3JtL34vdXhjb3JlLW90aGVyLWZvcm0tZmllbGQvYnVpbGQvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi91eGNvcmUtZm9ybS9+L3V4Y29yZS1vdGhlci1mb3JtLWZpZWxkL2J1aWxkL090aGVyRm9ybUZpZWxkLmpzIiwid2VicGFjazovLy8uL34vdXhjb3JlLWZvcm0vYnVpbGQvRm9ybUZpZWxkL0J1dHRvbkdyb3VwRm9ybUZpZWxkLmpzIiwid2VicGFjazovLy8uL34vdXhjb3JlLWZvcm0vYnVpbGQvRm9ybUZpZWxkL0VkaXRvckZvcm1GaWVsZC5qcyIsIndlYnBhY2s6Ly8vLi9+L3V4Y29yZS1mb3JtL34vdXhjb3JlLXRpbnltY2UvYnVpbGQvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi91eGNvcmUtZm9ybS9+L3V4Y29yZS10aW55bWNlL2J1aWxkL1RpbnltY2UuanMiLCJ3ZWJwYWNrOi8vLy4vfi91eGNvcmUtZm9ybS9+L3V4Y29yZS10aW55bWNlL2J1aWxkL3V0aWwuanMiLCJ3ZWJwYWNrOi8vLy4vfi91eGNvcmUtZm9ybS9+L3V4Y29yZS10aW55bWNlL2J1aWxkL2VkaXRvckNvbmZpZy5qcyIsIndlYnBhY2s6Ly8vLi9+L3V4Y29yZS1mb3JtL2J1aWxkL0Zvcm1GaWVsZC9TZWFyY2hGb3JtRmllbGQuanMiLCJ3ZWJwYWNrOi8vLy4vfi91eGNvcmUtdGFibGUvfi91eGNvcmUtY29uc3QvYnVpbGQvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi91eGNvcmUtdGFibGUvfi91eGNvcmUtbWVudS9+L3JjLW1lbnUvfi9yYy11dGlsL2xpYi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L3V4Y29yZS10YWJsZS9+L3V4Y29yZS1tZW51L34vcmMtbWVudS9+L3JjLXV0aWwvbGliL2NsYXNzU2V0LmpzIiwid2VicGFjazovLy8uL34vdXhjb3JlLXRhYmxlL34vdXhjb3JlLW1lbnUvfi9yYy1tZW51L34vcmMtdXRpbC9saWIvam9pbkNsYXNzZXMuanMiLCJ3ZWJwYWNrOi8vLy4vfi91eGNvcmUtdGFibGUvfi91eGNvcmUtbWVudS9+L3JjLW1lbnUvfi9yYy11dGlsL2xpYi9QdXJlUmVuZGVyTWl4aW4uanMiLCJ3ZWJwYWNrOi8vLy4vfi91eGNvcmUtdGFibGUvfi91eGNvcmUtbWVudS9+L3JjLW1lbnUvfi9yYy11dGlsL34vc2hhbGxvd2VxdWFsL21vZHVsZXMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi91eGNvcmUtdGFibGUvfi91eGNvcmUtbWVudS9+L3JjLW1lbnUvfi9yYy11dGlsL34vc2hhbGxvd2VxdWFsL34vbG9kYXNoLmtleXMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi91eGNvcmUtdGFibGUvfi91eGNvcmUtbWVudS9+L3JjLW1lbnUvfi9yYy11dGlsL2xpYi9Eb20vYWRkRXZlbnRMaXN0ZW5lci5qcyIsIndlYnBhY2s6Ly8vLi9+L3V4Y29yZS10YWJsZS9+L3V4Y29yZS1tZW51L34vcmMtbWVudS9+L3JjLXV0aWwvfi9hZGQtZG9tLWV2ZW50LWxpc3RlbmVyL2xpYi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L3V4Y29yZS10YWJsZS9+L3V4Y29yZS1tZW51L34vcmMtbWVudS9+L3JjLXV0aWwvfi9hZGQtZG9tLWV2ZW50LWxpc3RlbmVyL2xpYi9FdmVudE9iamVjdC5qcyIsIndlYnBhY2s6Ly8vLi9+L3V4Y29yZS10YWJsZS9+L3V4Y29yZS1tZW51L34vcmMtbWVudS9+L2RvbS1zY3JvbGwtaW50by12aWV3L2xpYi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L3V4Y29yZS10YWJsZS9+L3V4Y29yZS1tZW51L34vcmMtbWVudS9+L2RvbS1zY3JvbGwtaW50by12aWV3L2xpYi9kb20tc2Nyb2xsLWludG8tdmlldy5qcyIsIndlYnBhY2s6Ly8vLi9+L3V4Y29yZS10YWJsZS9+L3V4Y29yZS1tZW51L34vcmMtbWVudS9+L3JjLWFuaW1hdGUvbGliL2luZGV4LmpzIiwid2VicGFjazovLy8uL34vdXhjb3JlLXRhYmxlL34vdXhjb3JlLW1lbnUvfi9yYy1tZW51L34vcmMtYW5pbWF0ZS9saWIvQW5pbWF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3V4Y29yZS10YWJsZS9+L3V4Y29yZS1tZW51L34vcmMtbWVudS9+L3JjLWFuaW1hdGUvbGliL0FuaW1hdGVDaGlsZC5qcyIsIndlYnBhY2s6Ly8vLi9+L3V4Y29yZS10YWJsZS9+L3V4Y29yZS1tZW51L34vcmMtbWVudS9+L3JjLWFuaW1hdGUvfi9jc3MtYW5pbWF0aW9uL2xpYi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L3V4Y29yZS10YWJsZS9+L3V4Y29yZS1tZW51L34vcmMtbWVudS9+L3JjLWFuaW1hdGUvfi9jc3MtYW5pbWF0aW9uL34vY29tcG9uZW50LWNsYXNzZXMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi91eGNvcmUtdGFibGUvfi91eGNvcmUtZHJvcGRvd24vfi9yYy1kcm9wZG93bi9+L3JjLXRyaWdnZXIvbGliL2luZGV4LmpzIiwid2VicGFjazovLy8uL34vdXhjb3JlLXRhYmxlL34vdXhjb3JlLWRyb3Bkb3duL34vcmMtZHJvcGRvd24vfi9yYy10cmlnZ2VyL2xpYi9UcmlnZ2VyLmpzIiwid2VicGFjazovLy8uL34vdXhjb3JlLXRhYmxlL34vdXhjb3JlLWRyb3Bkb3duL34vcmMtZHJvcGRvd24vfi9yYy10cmlnZ2VyL2xpYi9Qb3B1cC5qcyIsIndlYnBhY2s6Ly8vLi9+L3V4Y29yZS10YWJsZS9+L3V4Y29yZS1kcm9wZG93bi9+L3JjLWRyb3Bkb3duL34vcmMtdHJpZ2dlci9+L3JjLWFsaWduL2xpYi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L3V4Y29yZS10YWJsZS9+L3V4Y29yZS1kcm9wZG93bi9+L3JjLWRyb3Bkb3duL34vcmMtdHJpZ2dlci9+L3JjLWFsaWduL2xpYi9BbGlnbi5qcyIsIndlYnBhY2s6Ly8vLi9+L3V4Y29yZS10YWJsZS9+L3V4Y29yZS1kcm9wZG93bi9+L3JjLWRyb3Bkb3duL34vcmMtdHJpZ2dlci9+L3JjLWFsaWduL34vZG9tLWFsaWduL2xpYi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L3V4Y29yZS10YWJsZS9+L3V4Y29yZS1kcm9wZG93bi9+L3JjLWRyb3Bkb3duL34vcmMtdHJpZ2dlci9+L3JjLWFsaWduL34vZG9tLWFsaWduL2xpYi9nZXRPZmZzZXRQYXJlbnQuanMiLCJ3ZWJwYWNrOi8vLy4vfi91eGNvcmUtdGFibGUvfi91eGNvcmUtZHJvcGRvd24vfi9yYy1kcm9wZG93bi9+L3JjLXRyaWdnZXIvfi9yYy1hbGlnbi9+L2RvbS1hbGlnbi9saWIvZ2V0VmlzaWJsZVJlY3RGb3JFbGVtZW50LmpzIiwid2VicGFjazovLy8uL34vdXhjb3JlLXRhYmxlL34vdXhjb3JlLWRyb3Bkb3duL34vcmMtZHJvcGRvd24vfi9yYy10cmlnZ2VyL34vcmMtYWxpZ24vfi9kb20tYWxpZ24vbGliL2FkanVzdEZvclZpZXdwb3J0LmpzIiwid2VicGFjazovLy8uL34vdXhjb3JlLXRhYmxlL34vdXhjb3JlLWRyb3Bkb3duL34vcmMtZHJvcGRvd24vfi9yYy10cmlnZ2VyL34vcmMtYWxpZ24vfi9kb20tYWxpZ24vbGliL2dldFJlZ2lvbi5qcyIsIndlYnBhY2s6Ly8vLi9+L3V4Y29yZS10YWJsZS9+L3V4Y29yZS1kcm9wZG93bi9+L3JjLWRyb3Bkb3duL34vcmMtdHJpZ2dlci9+L3JjLWFsaWduL34vZG9tLWFsaWduL2xpYi9nZXRFbEZ1dHVyZVBvcy5qcyIsIndlYnBhY2s6Ly8vLi9+L3V4Y29yZS10YWJsZS9+L3V4Y29yZS1kcm9wZG93bi9+L3JjLWRyb3Bkb3duL34vcmMtdHJpZ2dlci9saWIvUG9wdXBJbm5lci5qcyIsIndlYnBhY2s6Ly8vLi9+L3V4Y29yZS10YWJsZS9+L3V4Y29yZS10b29sdGlwL2J1aWxkL2luZGV4LmpzIiwid2VicGFjazovLy8uL34vdXhjb3JlLXRhYmxlL34vdXhjb3JlLXRvb2x0aXAvYnVpbGQvVG9vbHRpcC5qcyIsIndlYnBhY2s6Ly8vLi9+L3V4Y29yZS10YWJsZS9+L3V4Y29yZS10b29sdGlwL34vcmMtdG9vbHRpcC9saWIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi91eGNvcmUtdGFibGUvfi91eGNvcmUtdG9vbHRpcC9+L3JjLXRvb2x0aXAvbGliL1Rvb2x0aXAuanMiLCJ3ZWJwYWNrOi8vLy4vfi91eGNvcmUtdGFibGUvfi91eGNvcmUtc2VsZWN0Mi9idWlsZC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L3V4Y29yZS10YWJsZS9+L3V4Y29yZS1zZWxlY3QyL2J1aWxkL1NlbGVjdDIuanMiLCJ3ZWJwYWNrOi8vLy4vfi91eGNvcmUtdGFibGUvfi91eGNvcmUtc2VsZWN0Mi9+L3JjLXNlbGVjdC9saWIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi91eGNvcmUtdGFibGUvfi91eGNvcmUtc2VsZWN0Mi9+L3JjLXNlbGVjdC9saWIvU2VsZWN0LmpzIiwid2VicGFjazovLy8uL34vdXhjb3JlLXRhYmxlL34vdXhjb3JlLXNlbGVjdDIvfi9yYy1zZWxlY3QvbGliL3V0aWwuanMiLCJ3ZWJwYWNrOi8vLy4vfi91eGNvcmUtdGFibGUvfi91eGNvcmUtc2VsZWN0Mi9+L3JjLXNlbGVjdC9+L3JjLW1lbnUvbGliL2luZGV4LmpzIiwid2VicGFjazovLy8uL34vdXhjb3JlLXRhYmxlL34vdXhjb3JlLXNlbGVjdDIvfi9yYy1zZWxlY3Qvfi9yYy1tZW51L2xpYi9NZW51LmpzIiwid2VicGFjazovLy8uL34vdXhjb3JlLXRhYmxlL34vdXhjb3JlLXNlbGVjdDIvfi9yYy1zZWxlY3Qvfi9yYy1tZW51L2xpYi9NZW51TWl4aW4uanMiLCJ3ZWJwYWNrOi8vLy4vfi91eGNvcmUtdGFibGUvfi91eGNvcmUtc2VsZWN0Mi9+L3JjLXNlbGVjdC9+L3JjLW1lbnUvbGliL0RPTVdyYXAuanMiLCJ3ZWJwYWNrOi8vLy4vfi91eGNvcmUtdGFibGUvfi91eGNvcmUtc2VsZWN0Mi9+L3JjLXNlbGVjdC9+L3JjLW1lbnUvbGliL1N1Yk1lbnUuanMiLCJ3ZWJwYWNrOi8vLy4vfi91eGNvcmUtdGFibGUvfi91eGNvcmUtc2VsZWN0Mi9+L3JjLXNlbGVjdC9+L3JjLW1lbnUvbGliL1N1YlBvcHVwTWVudS5qcyIsIndlYnBhY2s6Ly8vLi9+L3V4Y29yZS10YWJsZS9+L3V4Y29yZS1zZWxlY3QyL34vcmMtc2VsZWN0L34vcmMtbWVudS9saWIvU3ViTWVudVN0YXRlTWl4aW4uanMiLCJ3ZWJwYWNrOi8vLy4vfi91eGNvcmUtdGFibGUvfi91eGNvcmUtc2VsZWN0Mi9+L3JjLXNlbGVjdC9+L3JjLW1lbnUvbGliL01lbnVJdGVtLmpzIiwid2VicGFjazovLy8uL34vdXhjb3JlLXRhYmxlL34vdXhjb3JlLXNlbGVjdDIvfi9yYy1zZWxlY3QvbGliL1NlbGVjdFRyaWdnZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi91eGNvcmUtdGFibGUvfi91eGNvcmUtc2VsZWN0Mi9+L3JjLXNlbGVjdC9saWIvRHJvcGRvd25NZW51LmpzIiwid2VicGFjazovLy8uL34vdXhjb3JlLXRhYmxlL34vdXhjb3JlLXNlbGVjdDIvfi9yYy1zZWxlY3QvbGliL0ZpbHRlck1peGluLmpzIiwid2VicGFjazovLy8uL34vdXhjb3JlLXRhYmxlL34vdXhjb3JlLXJhZGlvZ3JvdXAvYnVpbGQvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi91eGNvcmUtdGFibGUvfi91eGNvcmUtcmFkaW9ncm91cC9idWlsZC9SYWRpb2dyb3VwLmpzIiwid2VicGFjazovLy8uL34vdXhjb3JlLXRhYmxlL34vdXhjb3JlLWZvcm1hdHRlci9zcmMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi91eGNvcmUtdGFibGUvfi9kZWVwLWVxdWFsL2luZGV4LmpzIiwid2VicGFjazovLy8uL34vdXhjb3JlLWZvcm0vfi91eGNvcmUtdmFsaWRhdG9yL2J1aWxkL2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIiBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbiBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbiBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cbiBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKVxuIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuXG4gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbiBcdFx0XHRleHBvcnRzOiB7fSxcbiBcdFx0XHRpZDogbW9kdWxlSWQsXG4gXHRcdFx0bG9hZGVkOiBmYWxzZVxuIFx0XHR9O1xuXG4gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4gXHRcdG1vZHVsZS5sb2FkZWQgPSB0cnVlO1xuXG4gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbiBcdH1cblxuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbiBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cbiBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuXG4gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbiBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogd2VicGFjay9ib290c3RyYXAgNGZmY2JjOTRlNDA1MjJhMDFkOWZcbiAqKi8iLCJ3aW5kb3dbXCJVeGNvcmVcIl09e1xuXCJUYWJsZVwiOnJlcXVpcmUoXCJ1eGNvcmUtdGFibGVcIiksXG5cIkZvcm1cIjpyZXF1aXJlKFwidXhjb3JlLWZvcm1cIiksXG5cIkJ1dHRvblwiOnJlcXVpcmUoXCJ1eGNvcmUtYnV0dG9uXCIpLFxufTtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiBsaWJfX3V4Y29yZS5qc1xuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBUYWJsZSBDb21wb25lbnQgZm9yIHV4Y29yZVxuICogQGF1dGhvciB6aG91cXVhbi55ZXpxXG4gKlxuICogQ29weXJpZ2h0IDIwMTQtMjAxNSwgVXhjb3JlIFRlYW0sIEFsaW53LlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vVGFibGUnKTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi91eGNvcmUtdGFibGUvYnVpbGQvaW5kZXguanNcbiAqKiBtb2R1bGUgaWQgPSAxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhvYmosIGtleXMpIHsgdmFyIHRhcmdldCA9IHt9OyBmb3IgKHZhciBpIGluIG9iaikgeyBpZiAoa2V5cy5pbmRleE9mKGkpID49IDApIGNvbnRpbnVlOyBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGkpKSBjb250aW51ZTsgdGFyZ2V0W2ldID0gb2JqW2ldOyB9IHJldHVybiB0YXJnZXQ7IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG4vKipcbiAqIFRhYmxlIENvbXBvbmVudCBmb3IgdXhjb3JlXG4gKiBAYXV0aG9yIHpob3VxdWFuLnllenFcbiAqXG4gKiBDb3B5cmlnaHQgMjAxNC0yMDE1LCBVWENvcmUgVGVhbSwgQWxpbncuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICovXG5cbnZhciBIZWFkZXIgPSByZXF1aXJlKFwiLi9IZWFkZXJcIik7XG52YXIgVGJvZHkgPSByZXF1aXJlKFwiLi9UYm9keVwiKTtcbnZhciBBY3Rpb25CYXIgPSByZXF1aXJlKFwiLi9BY3Rpb25CYXJcIik7XG52YXIgQ2VsbEZpZWxkID0gcmVxdWlyZSgnLi9DZWxsL0NlbGxGaWVsZCcpO1xudmFyIFBhZ2luYXRpb24gPSByZXF1aXJlKFwidXhjb3JlLXBhZ2luYXRpb25cIik7XG52YXIgQ29uc3QgPSByZXF1aXJlKCd1eGNvcmUtY29uc3QnKTtcbnZhciBhc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG52YXIgZGVlcGNvcHkgPSByZXF1aXJlKCdkZWVwY29weScpO1xudmFyIGRlZXBFcXVhbCA9IHJlcXVpcmUoJ2RlZXAtZXF1YWwnKTtcbnZhciBjbGFzc25hbWVzID0gcmVxdWlyZShcImNsYXNzbmFtZXNcIik7XG5cbnZhciBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG52YXIgUmVhY3RET00gPSByZXF1aXJlKCdyZWFjdC1kb20nKTtcblxudmFyIFRhYmxlID0gZnVuY3Rpb24gKF9SZWFjdCRDb21wb25lbnQpIHtcbiAgICBfaW5oZXJpdHMoVGFibGUsIF9SZWFjdCRDb21wb25lbnQpO1xuXG4gICAgZnVuY3Rpb24gVGFibGUocHJvcHMpIHtcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFRhYmxlKTtcblxuICAgICAgICB2YXIgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfUmVhY3QkQ29tcG9uZW50LmNhbGwodGhpcywgcHJvcHMpKTtcblxuICAgICAgICBfdGhpcy51aWQgPSAwO1xuICAgICAgICBfdGhpcy5maWVsZHMgPSB7fTtcbiAgICAgICAgX3RoaXMuc3RhdGUgPSB7XG4gICAgICAgICAgICBkYXRhOiBfdGhpcy5hZGRWYWx1ZXNJbkRhdGEoZGVlcGNvcHkoX3RoaXMucHJvcHMuanN4ZGF0YSkpLCAvLyBjaGVja2JveCDlhoXpg6jkuqTkupJcbiAgICAgICAgICAgIGNvbHVtbnM6IF90aGlzLnByb2Nlc3NDb2x1bW4oKSwgLy8gY29sdW1uIOWGhemDqOS6pOS6klxuICAgICAgICAgICAgc2hvd01hc2s6IHByb3BzLnNob3dNYXNrLCAvLyBmZXRjaERhdGEg5pe255qE5YaF6YOo54q25oCB5pS55Y+YXG4gICAgICAgICAgICBwYWdlU2l6ZTogcHJvcHMucGFnZVNpemUsIC8vIHBhZ2luYXRpb24g55u45YWzXG4gICAgICAgICAgICBjdXJyZW50UGFnZTogcHJvcHMuY3VycmVudFBhZ2UsIC8vIHBhZ2luYXRpb24g55u45YWzXG4gICAgICAgICAgICBhY3RpdmVDb2x1bW46IG51bGwsXG4gICAgICAgICAgICBzZWFyY2hUeHQ6IFwiXCIsXG4gICAgICAgICAgICBwYXNzZWREYXRhOiBudWxsLFxuICAgICAgICAgICAgcGFyYW1zOiBudWxsLFxuICAgICAgICAgICAgc2VsZWN0ZWQ6IFtdLFxuICAgICAgICAgICAgZXhwYW5kZWQ6IGZhbHNlXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG5cbiAgICBUYWJsZS5wcm90b3R5cGUuY29tcG9uZW50V2lsbE1vdW50ID0gZnVuY3Rpb24gY29tcG9uZW50V2lsbE1vdW50KCkge1xuICAgICAgICBpZiAodGhpcy5wcm9wcy5mZXRjaERhdGFPbk1vdW50KSB7XG4gICAgICAgICAgICB0aGlzLmZldGNoRGF0YSgpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIFRhYmxlLnByb3RvdHlwZS5jb21wb25lbnREaWRNb3VudCA9IGZ1bmN0aW9uIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgICAgICB2YXIgbWUgPSB0aGlzO1xuICAgICAgICBtZS5lbCA9IFJlYWN0RE9NLmZpbmRET01Ob2RlKG1lKTtcbiAgICAgICAgaWYgKCEhbWUuc3RhdGUuZGF0YSAmJiAhIW1lLnN0YXRlLmRhdGEuZGF0YXMpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcIlRhYmxlOiAnY29udGVudC5kYXRhJyByYXRoZXIgdGhhbiAnY29udGVudC5kYXRhcycgaXMgcmVjb21tZW5kZWQsIHRoZSBzdXBwb3J0IGZvciAnY29udGVudC5kYXRhcycgd2lsbCBiZSBlbmQgZnJvbSB2ZXIuIDEuNS4wXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZS5wcm9wcy5zdWJDb21wKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJUYWJsZTogc3ViQ29tcCBpcyBkZXByZWNhdGVkLCB1c2UgcmVuZGVyU3ViQ29tcCBpbnN0ZWFkLlwiKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBUYWJsZS5wcm90b3R5cGUuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyA9IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMobmV4dFByb3BzKSB7XG4gICAgICAgIHZhciBtZSA9IHRoaXM7XG4gICAgICAgIHZhciBuZXdEYXRhID0ge307XG4gICAgICAgIGlmICghIW5leHRQcm9wcy5qc3hkYXRhICYmICEhbWUucHJvcHMuanN4ZGF0YSAmJiAhbWUuX2lzRXF1YWwobmV4dFByb3BzLmpzeGRhdGEsIG1lLnByb3BzLmpzeGRhdGEpKSB7XG4gICAgICAgICAgICAvLyBEYXRhIGhhcyBjaGFuZ2VkLCBzbyB1aWQgd2hpY2ggaXMgdXNlZCB0byBtYXJrIHRoZSBkYXRhIHNob3VsZCBiZSByZXNldC5cbiAgICAgICAgICAgIG1lLnVpZCA9IDA7XG4gICAgICAgICAgICBuZXdEYXRhWydkYXRhJ10gPSBtZS5hZGRWYWx1ZXNJbkRhdGEoZGVlcGNvcHkobmV4dFByb3BzLmpzeGRhdGEpKTtcbiAgICAgICAgICAgIG1lLmRhdGEgPSBkZWVwY29weShuZXdEYXRhWydkYXRhJ10pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuZXh0UHJvcHMucGFnZVNpemUgIT0gbWUucHJvcHMucGFnZVNpemUpIHtcbiAgICAgICAgICAgIG5ld0RhdGFbJ3BhZ2VTaXplJ10gPSBuZXh0UHJvcHMucGFnZVNpemU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5leHRQcm9wcy5jdXJyZW50UGFnZSAhPSBtZS5wcm9wcy5jdXJyZW50UGFnZSkge1xuICAgICAgICAgICAgbmV3RGF0YVsnY3VycmVudFBhZ2UnXSA9IG5leHRQcm9wcy5jdXJyZW50UGFnZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoISFuZXh0UHJvcHMuanN4Y29sdW1ucyAmJiAhIW1lLnByb3BzLmpzeGNvbHVtbnMgJiYgIW1lLl9pc0VxdWFsKG5leHRQcm9wcy5qc3hjb2x1bW5zLCBtZS5wcm9wcy5qc3hjb2x1bW5zKSkge1xuICAgICAgICAgICAgbmV3RGF0YVsnY29sdW1ucyddID0gbWUucHJvY2Vzc0NvbHVtbihuZXh0UHJvcHMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuZXh0UHJvcHMuc2hvd01hc2sgIT0gbWUucHJvcHMuc2hvd01hc2spIHtcbiAgICAgICAgICAgIG5ld0RhdGFbJ3Nob3dNYXNrJ10gPSBuZXh0UHJvcHMuc2hvd01hc2s7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5leHRQcm9wcy5mZXRjaFVybCAhPT0gbWUucHJvcHMuZmV0Y2hVcmwpIHtcbiAgICAgICAgICAgIG1lLmZldGNoRGF0YSgndXJsQ2hhbmdlJyk7XG4gICAgICAgIH1cbiAgICAgICAgbWUuc2V0U3RhdGUobmV3RGF0YSk7XG4gICAgfTtcblxuICAgIFRhYmxlLnByb3RvdHlwZS5jb21wb25lbnRXaWxsVW5tb3VudCA9IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgICAgICB2YXIgbWUgPSB0aGlzO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBGb3IgaW5saW5lIGVkaXRcbiAgICAgKiByZWNlaXZlIGNoYW5nZXMgZnJvbSBjZWxsIGZpZWxkIGFuZCBjaGFuZ2Ugc3RhdGUuZGF0YVxuICAgICAqIGluZm9ybSB1c2VycyBvZiB0aGUgY2hhbmdlIHdpdGggZGF0YUtleSAmIHBhc3NcbiAgICAgKi9cblxuICAgIFRhYmxlLnByb3RvdHlwZS5oYW5kbGVEYXRhQ2hhbmdlID0gZnVuY3Rpb24gaGFuZGxlRGF0YUNoYW5nZShvYmopIHtcbiAgICAgICAgdmFyIG1lID0gdGhpcztcbiAgICAgICAgdmFyIGpzeGlkID0gb2JqLmpzeGlkO1xuICAgICAgICB2YXIgY29sdW1uID0gb2JqLmNvbHVtbjtcbiAgICAgICAgdmFyIHZhbHVlID0gb2JqLnZhbHVlO1xuICAgICAgICB2YXIgdGV4dCA9IG9iai50ZXh0O1xuICAgICAgICB2YXIgcGFzcyA9IG9iai5wYXNzO1xuXG4gICAgICAgIHZhciBkYXRhS2V5ID0gY29sdW1uLmRhdGFLZXk7XG4gICAgICAgIHZhciBlZGl0S2V5ID0gY29sdW1uLmVkaXRLZXkgfHwgZGF0YUtleTtcbiAgICAgICAgdmFyIGRhdGEgPSBkZWVwY29weShtZS5zdGF0ZS5kYXRhKTtcbiAgICAgICAgdmFyIGNoYW5nZWREYXRhID0ge307XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5kYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoZGF0YS5kYXRhW2ldLmpzeGlkID09IGpzeGlkKSB7XG4gICAgICAgICAgICAgICAgZGF0YS5kYXRhW2ldW2RhdGFLZXldID0gdGV4dDtcbiAgICAgICAgICAgICAgICBkYXRhLmRhdGFbaV1bZWRpdEtleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICBjaGFuZ2VkRGF0YSA9IGRhdGEuZGF0YVtpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIG1lLnNldFN0YXRlKHtcbiAgICAgICAgICAgIGRhdGE6IGRhdGFcbiAgICAgICAgfSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgbWUucHJvcHMub25DaGFuZ2Uoe1xuICAgICAgICAgICAgICAgIGRhdGE6IG1lLnN0YXRlLmRhdGEsXG4gICAgICAgICAgICAgICAgZWRpdEtleTogZWRpdEtleSxcbiAgICAgICAgICAgICAgICBkYXRhS2V5OiBkYXRhS2V5LFxuICAgICAgICAgICAgICAgIGNoYW5nZWREYXRhOiBjaGFuZ2VkRGF0YSxcbiAgICAgICAgICAgICAgICBwYXNzOiBwYXNzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIHJlZ2lzdGVyIENlbGxGaWVsZCB0byBUYWJsZSBmb3IgdGhlIGdsb2JhbCB2YWxpZGF0aW9uXG4gICAgICogQHBhcmFtIGZpZWxkIHtlbGVtZW50fSB0aGUgY2VsbCBmaWVsZCB0byBiZSByZWdpc3RlcmVkXG4gICAgICovXG5cbiAgICBUYWJsZS5wcm90b3R5cGUuYXR0YWNoQ2VsbEZpZWxkID0gZnVuY3Rpb24gYXR0YWNoQ2VsbEZpZWxkKHZhbGlkYXRlLCBuYW1lKSB7XG4gICAgICAgIHZhciBtZSA9IHRoaXM7XG4gICAgICAgIGlmICghbmFtZSkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIlRhYmxlOiBkYXRhS2V5IGNhbiBub3QgYmUgdW5kZWZpbmVkLCBjaGVjayB0aGUgY29sdW1uIGNvbmZpZ1wiKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1lLmZpZWxkc1tuYW1lXSA9IHZhbGlkYXRlO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIGNhbmNlbCB0aGUgQ2VsbEZpZWxkIHdoZW4gaXQgaXMgdW5tb3VudGVkLlxuICAgICAqIEBwYXJhbSBmaWVsZCB7ZWxlbWVudH0gdGhlIGNlbGwgZmllbGQgdG8gYmUgY2FuY2VsZWQuXG4gICAgICovXG5cbiAgICBUYWJsZS5wcm90b3R5cGUuZGV0YWNoQ2VsbEZpZWxkID0gZnVuY3Rpb24gZGV0YWNoQ2VsbEZpZWxkKG5hbWUpIHtcbiAgICAgICAgZGVsZXRlIHRoaXMuZmllbGRzW25hbWVdO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBzaW1wbGUgbWV0aG9kIHRvIGNvbXBhcmUgdHdvIGRhdGFzLCBcbiAgICAgKiBvbmx5IHN1cHBvcnQgdGhlIGRhdGEgd2hpY2ggSlNPTiBjYW4gcGFyc2UuXG4gICAgICovXG5cbiAgICBUYWJsZS5wcm90b3R5cGUuX2lzRXF1YWwgPSBmdW5jdGlvbiBfaXNFcXVhbChhLCBiKSB7XG4gICAgICAgIHJldHVybiBkZWVwRXF1YWwoYSwgYik7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIGdldCBRdWVyeSBPYmplY3QgYnkgY29tYmluaW5nIGRhdGEgZnJvbSBzZWFyY2hCYXIsIGNvbHVtbiBvcmRlciwgcGFnaW5hdGlvblxuICAgICAqIGFuZCBmZXRjaFBhcmFtcy5cbiAgICAgKiBAcGFyYW0gZnJvbSB7c3RyaW5nfSB1c2VkIGluIHByb3BzLmJlZm9yZUZldGNoXG4gICAgICovXG5cbiAgICBUYWJsZS5wcm90b3R5cGUuZ2V0UXVlcnlPYmogPSBmdW5jdGlvbiBnZXRRdWVyeU9iaihmcm9tKSB7XG5cbiAgICAgICAgdmFyIG1lID0gdGhpcyxcbiAgICAgICAgICAgIHF1ZXJ5T2JqID0ge307XG4gICAgICAgIGlmIChtZS5wcm9wcy5wYXNzZWREYXRhKSB7XG4gICAgICAgICAgICB2YXIgcXVlcnlLZXlzID0gbWUucHJvcHMucXVlcnlLZXlzO1xuICAgICAgICAgICAgaWYgKCFxdWVyeUtleXMpIHtcbiAgICAgICAgICAgICAgICBxdWVyeU9iaiA9IG1lLnByb3BzLnBhc3NlZERhdGE7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHF1ZXJ5S2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1lLnByb3BzLnBhc3NlZERhdGFba2V5XSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBxdWVyeU9ialtrZXldID0gbWUucHJvcHMucGFzc2VkRGF0YVtrZXldO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBwYWdpbmF0aW9uXG4gICAgICAgIHF1ZXJ5T2JqID0gYXNzaWduKHt9LCBxdWVyeU9iaiwge1xuICAgICAgICAgICAgcGFnZVNpemU6IG1lLnN0YXRlLnBhZ2VTaXplLFxuICAgICAgICAgICAgY3VycmVudFBhZ2U6IG1lLnN0YXRlLmN1cnJlbnRQYWdlXG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIGNvbHVtbiBvcmRlclxuICAgICAgICB2YXIgYWN0aXZlQ29sdW1uID0gbWUuc3RhdGUuYWN0aXZlQ29sdW1uO1xuICAgICAgICB2YXIgb3JkZXJUeXBlID0gbWUuc3RhdGUub3JkZXJUeXBlO1xuICAgICAgICBpZiAoISFhY3RpdmVDb2x1bW4pIHtcbiAgICAgICAgICAgIHF1ZXJ5T2JqID0gYXNzaWduKHt9LCBxdWVyeU9iaiwge1xuICAgICAgICAgICAgICAgIG9yZGVyQ29sdW1uOiBhY3RpdmVDb2x1bW4uZGF0YUtleVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoISFvcmRlclR5cGUgJiYgb3JkZXJUeXBlICE9ICdub25lJykge1xuICAgICAgICAgICAgICAgIHF1ZXJ5T2JqLm9yZGVyVHlwZSA9IG9yZGVyVHlwZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHNlYXJjaCBxdWVyeVxuICAgICAgICB2YXIgc2VhcmNoVHh0ID0gbWUuc3RhdGUuc2VhcmNoVHh0O1xuICAgICAgICBpZiAoISFzZWFyY2hUeHQpIHtcbiAgICAgICAgICAgIHF1ZXJ5T2JqID0gYXNzaWduKHt9LCBxdWVyeU9iaiwge1xuICAgICAgICAgICAgICAgIHNlYXJjaFR4dDogc2VhcmNoVHh0XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGZldGNoUGFyYW1zIGhhcyB0aGUgdG9wIHByaW9yaXR5XG4gICAgICAgIGlmICghIW1lLnByb3BzLmZldGNoUGFyYW1zKSB7XG4gICAgICAgICAgICBxdWVyeU9iaiA9IGFzc2lnbih7fSwgcXVlcnlPYmosIG1lLnByb3BzLmZldGNoUGFyYW1zKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBtZS5wcm9wcy5iZWZvcmVGZXRjaChxdWVyeU9iaiwgZnJvbSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIGZldGNoIERhdGEgdmlhIEFqYXhcbiAgICAgKiBAcGFyYW0gZnJvbSB7c3RyaW5nfSB0ZWxsIGZldGNoRGF0YSB3aGVyZSBpdCBpcyBpbnZva2VkLCB0aGUgcGFyYW0gd2lsbCBiZSBcbiAgICAgKiBwYXNzZWQgdG8gcHJvcHMuYmVmb3JlRmV0Y2ggaW4gb3JkZXIgdG8gaGVscCB0aGUgdXNlci5cbiAgICAgKi9cblxuICAgIFRhYmxlLnByb3RvdHlwZS5mZXRjaERhdGEgPSBmdW5jdGlvbiBmZXRjaERhdGEoZnJvbSkge1xuXG4gICAgICAgIHZhciBtZSA9IHRoaXM7XG4gICAgICAgIC8vIHJlc2V0IHVpZCBjYXVzZSB0YWJsZSBkYXRhIGhhcyBjaGFuZ2VkXG4gICAgICAgIG1lLnVpZCA9IDA7XG5cbiAgICAgICAgLy8gZmV0Y2hVcmwgaGFzIHRoZSB0b3AgcHJpb3JpdHkuXG4gICAgICAgIGlmICghIW1lLnByb3BzLmZldGNoVXJsKSB7XG4gICAgICAgICAgICBpZiAobWUuYWpheCkge1xuICAgICAgICAgICAgICAgIG1lLmFqYXguYWJvcnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghbWUuc3RhdGUuc2hvd01hc2spIHtcbiAgICAgICAgICAgICAgICBtZS5zZXRTdGF0ZSh7XG4gICAgICAgICAgICAgICAgICAgIHNob3dNYXNrOiB0cnVlXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgYWpheE9wdGlvbnMgPSB7XG4gICAgICAgICAgICAgICAgdXJsOiBtZS5wcm9wcy5mZXRjaFVybCxcbiAgICAgICAgICAgICAgICBkYXRhOiBtZS5nZXRRdWVyeU9iaihmcm9tKSxcbiAgICAgICAgICAgICAgICBjYWNoZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgZGF0YVR5cGU6IFwianNvblwiLFxuICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IGZ1bmN0aW9uIHN1Y2Nlc3MocmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQuc3VjY2VzcyA9PT0gdHJ1ZSB8fCByZXN1bHQuaGFzRXJyb3IgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgX2RhdGEgPSByZXN1bHQuY29udGVudDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwcm9jZXNzZWREYXRhID0gbWUuYWRkVmFsdWVzSW5EYXRhKG1lLnByb3BzLnByb2Nlc3NEYXRhKGRlZXBjb3B5KF9kYXRhKSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHVwZGF0ZU9iaiA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBwcm9jZXNzZWREYXRhLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNob3dNYXNrOiBmYWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcm9jZXNzZWREYXRhLmN1cnJlbnRQYWdlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVPYmouY3VycmVudFBhZ2UgPSBwcm9jZXNzZWREYXRhLmN1cnJlbnRQYWdlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgbWUuZGF0YSA9IGRlZXBjb3B5KHByb2Nlc3NlZERhdGEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbWUuc2V0U3RhdGUodXBkYXRlT2JqKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lLnByb3BzLm9uRmV0Y2hFcnJvcihyZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgaWYgKC9cXC5qc29ucC8udGVzdChtZS5wcm9wcy5mZXRjaFVybCkpIHtcbiAgICAgICAgICAgICAgICBhamF4T3B0aW9ucy5kYXRhVHlwZSA9IFwianNvbnBcIjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbWUuYWpheCA9ICQuYWpheChhamF4T3B0aW9ucyk7XG4gICAgICAgIH0gZWxzZSBpZiAoISFtZS5wcm9wcy5wYXNzZWREYXRhKSB7XG5cbiAgICAgICAgICAgIGlmICghbWUucHJvcHMucXVlcnlLZXlzKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRhdGEgPSBtZS5hZGRWYWx1ZXNJbkRhdGEobWUucHJvcHMucHJvY2Vzc0RhdGEoZGVlcGNvcHkobWUucHJvcHMucGFzc2VkRGF0YSkpKTtcbiAgICAgICAgICAgICAgICBtZS5zZXRTdGF0ZSh7XG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IGRhdGFcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBtZS5kYXRhID0gZGVlcGNvcHkoZGF0YSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkYXRhID0ge307XG4gICAgICAgICAgICAgICAgICAgIG1lLnByb3BzLnF1ZXJ5S2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChrZXksIGluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobWUucHJvcHMucGFzc2VkRGF0YVtrZXldICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhW2tleV0gPSBtZS5wcm9wcy5wYXNzZWREYXRhW2tleV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcHJvY2Vzc2VkRGF0YSA9IG1lLmFkZFZhbHVlc0luRGF0YShtZS5wcm9wcy5wcm9jZXNzRGF0YShkZWVwY29weShkYXRhKSkpO1xuICAgICAgICAgICAgICAgICAgICBtZS5zZXRTdGF0ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBwcm9jZXNzZWREYXRhXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBtZS5kYXRhID0gZGVlcGNvcHkocHJvY2Vzc2VkRGF0YSk7XG4gICAgICAgICAgICAgICAgfSkoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICghIXRoaXMucHJvcHMuanN4ZGF0YSkge1xuICAgICAgICAgICAgdmFyIGRhdGEgPSB0aGlzLmFkZFZhbHVlc0luRGF0YShkZWVwY29weSh0aGlzLnByb3BzLmpzeGRhdGEpKTtcbiAgICAgICAgICAgIG1lLnNldFN0YXRlKHtcbiAgICAgICAgICAgICAgICBkYXRhOiBkYXRhXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIG1lLmRhdGEgPSBkZWVwY29weShkYXRhKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vZGVmYXVsdCB3aWxsIGNyZWF0ZSBvbmUgcm93XG4gICAgICAgICAgICB2YXIgZGF0YSA9IHtcbiAgICAgICAgICAgICAgICBkYXRhOiBbe1xuICAgICAgICAgICAgICAgICAgICBqc3hpZDogbWUudWlkKyssXG4gICAgICAgICAgICAgICAgICAgIF9fbW9kZV9fOiBDb25zdC5NT0RFLkVESVRcbiAgICAgICAgICAgICAgICB9XSxcbiAgICAgICAgICAgICAgICBcImN1cnJlbnRQYWdlXCI6IDEsXG4gICAgICAgICAgICAgICAgXCJ0b3RhbENvdW50XCI6IDBcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBtZS5kYXRhID0gZGVlcGNvcHkoZGF0YSk7XG4gICAgICAgICAgICBtZS5zZXRTdGF0ZSh7XG4gICAgICAgICAgICAgICAgXCJkYXRhXCI6IGRlZXBjb3B5KGRhdGEpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBUYWJsZS5wcm90b3R5cGUucHJvY2Vzc0NvbHVtbiA9IGZ1bmN0aW9uIHByb2Nlc3NDb2x1bW4ocHJvcHMpIHtcblxuICAgICAgICBwcm9wcyA9IHByb3BzIHx8IHRoaXMucHJvcHM7XG5cbiAgICAgICAgdmFyIG1lID0gdGhpcyxcbiAgICAgICAgICAgIGNvbHVtbnMgPSBkZWVwY29weShwcm9wcy5qc3hjb2x1bW5zKSxcbiAgICAgICAgICAgIGhhc0NoZWNrYm94Q29sdW1uID0gZmFsc2U7XG5cbiAgICAgICAgY29sdW1ucy5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtLCBpKSB7XG4gICAgICAgICAgICAvLyBvbmx5IG9uZSByb3dTZWxlY3RvciBjYW4gYmUgcmVuZGVyZWQgaW4gVGFibGUuXG4gICAgICAgICAgICBpZiAoaXRlbS50eXBlID09ICdjaGVja2JveCcgfHwgaXRlbS50eXBlID09ICdyYWRpb1NlbGVjdG9yJyB8fCBpdGVtLnR5cGUgPT0gJ2NoZWNrYm94U2VsZWN0b3InKSB7XG4gICAgICAgICAgICAgICAgaWYgKGl0ZW0udHlwZSA9PSAnY2hlY2tib3gnKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcInJvd1NlbGVjdG9yIHVzaW5nICd0eXBlOiBjaGVja2JveCcgaXMgZGVwcmVjYXRlZCwgdXNlICd0eXBlOiBjaGVja2JveFNlbGVjdG9yJyBpbnN0ZWFkLlwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaGFzQ2hlY2tib3hDb2x1bW4gPSB0cnVlO1xuICAgICAgICAgICAgICAgIG1lLmNoZWNrYm94Q29sdW1uID0gaXRlbTtcbiAgICAgICAgICAgICAgICBtZS5jaGVja2JveENvbHVtbktleSA9IGl0ZW0uZGF0YUtleTtcbiAgICAgICAgICAgICAgICBpdGVtLndpZHRoID0gaXRlbS53aWR0aCB8fCAzMjtcbiAgICAgICAgICAgICAgICBpdGVtLmFsaWduID0gaXRlbS5hbGlnbiB8fCAncmlnaHQnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBmaWx0ZXIgdGhlIGNvbHVtbiB3aGljaCBoYXMgYSBkYXRhS2V5ICdqc3hjaGVja2VkJyAmICdqc3h0cmVlSWNvbidcblxuICAgICAgICBjb2x1bW5zID0gY29sdW1ucy5maWx0ZXIoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICAgIHJldHVybiBpdGVtLmRhdGFLZXkgIT09ICdqc3hjaGVja2VkJyAmJiBpdGVtLmRhdGFLZXkgIT09ICdqc3h0cmVlSWNvbic7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIGlmIGhpZGRlbiBpcyBub3Qgc2V0LCBpdCdzIGZhbHNlXG4gICAgICAgIGNvbHVtbnMgPSBjb2x1bW5zLm1hcChmdW5jdGlvbiAoaXRlbSwgaW5kZXgpIHtcbiAgICAgICAgICAgIGl0ZW0uaGlkZGVuID0gISFpdGVtLmhpZGRlbjtcbiAgICAgICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoISFwcm9wcy5yb3dTZWxlY3Rpb24gJiAhaGFzQ2hlY2tib3hDb2x1bW4pIHtcbiAgICAgICAgICAgIG1lLmNoZWNrYm94Q29sdW1uID0geyBkYXRhS2V5OiAnanN4Y2hlY2tlZCcsIHdpZHRoOiA0NiwgdHlwZTogcHJvcHMucm93U2VsZWN0b3IsIGFsaWduOiAncmlnaHQnIH07XG4gICAgICAgICAgICBtZS5jaGVja2JveENvbHVtbktleSA9ICdqc3hjaGVja2VkJztcblxuICAgICAgICAgICAgY29sdW1ucyA9IFttZS5jaGVja2JveENvbHVtbl0uY29uY2F0KGNvbHVtbnMpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gbm8gcm93U2VsZWN0aW9uIGJ1dCBoYXMgcGFyZW50SGFzQ2hlY2tib3gsIHJlbmRlciBwbGFjZWhvbGRlclxuICAgICAgICBlbHNlIGlmICghIXByb3BzLnBhcmVudEhhc0NoZWNrYm94KSB7XG4gICAgICAgICAgICAgICAgY29sdW1ucyA9IFt7XG4gICAgICAgICAgICAgICAgICAgIGRhdGFLZXk6ICdqc3h3aGl0ZScsXG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiA0NixcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2VtcHR5J1xuICAgICAgICAgICAgICAgIH1dLmNvbmNhdChjb2x1bW5zKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICBpZiAoKCEhcHJvcHMuc3ViQ29tcCB8fCAhIXByb3BzLnJlbmRlclN1YkNvbXApICYmIHByb3BzLnJlbmRlck1vZGVsICE9PSAndHJlZScpIHtcbiAgICAgICAgICAgIGNvbHVtbnMgPSBbe1xuICAgICAgICAgICAgICAgIGRhdGFLZXk6ICdqc3h0cmVlSWNvbicsXG4gICAgICAgICAgICAgICAgd2lkdGg6IDM0LFxuICAgICAgICAgICAgICAgIHR5cGU6ICd0cmVlSWNvbidcbiAgICAgICAgICAgIH1dLmNvbmNhdChjb2x1bW5zKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBubyBzdWJDb21wIGJ1dCBoYXMgcGFzc2VkRGF0YSwgbWVhbnMgc3ViIG1vZGUsIHBhcmVudCBzaG91bGQgaGFzIHRyZWUgaWNvbixcbiAgICAgICAgLy8gcmVuZGVyIHRyZWUgaWNvbiBwbGFjZWhvbGRlclxuICAgICAgICBlbHNlIGlmICghIXByb3BzLnBhc3NlZERhdGEpIHtcbiAgICAgICAgICAgICAgICBjb2x1bW5zID0gW3tcbiAgICAgICAgICAgICAgICAgICAgZGF0YUtleTogJ2pzeHdoaXRlJyxcbiAgICAgICAgICAgICAgICAgICAgd2lkdGg6IDM0LFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnZW1wdHknXG4gICAgICAgICAgICAgICAgfV0uY29uY2F0KGNvbHVtbnMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjb2x1bW5zO1xuICAgIH07XG5cbiAgICBUYWJsZS5wcm90b3R5cGUuaGFuZGxlQ29sdW1uUGlja2VyQ2hhbmdlID0gZnVuY3Rpb24gaGFuZGxlQ29sdW1uUGlja2VyQ2hhbmdlKGNoZWNrZWRLZXlzKSB7XG4gICAgICAgIHZhciBfY29sdW1ucyA9IGRlZXBjb3B5KHRoaXMuc3RhdGUuY29sdW1ucyk7XG4gICAgICAgIHZhciBub3RSZW5kZXJDb2x1bW5zID0gWydqc3hjaGVja2VkJywgJ2pzeHRyZWVJY29uJywgJ2pzeHdoaXRlJ107XG5cbiAgICAgICAgX2NvbHVtbnMuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSwgaW5kZXgpIHtcbiAgICAgICAgICAgIGlmICgnZ3JvdXAnIGluIGl0ZW0pIHtcbiAgICAgICAgICAgICAgICBpdGVtLmNvbHVtbnMuZm9yRWFjaChmdW5jdGlvbiAoZWxlLCBpZHgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoZWNrZWRLZXlzLmluZGV4T2YoZWxlLmRhdGFLZXkpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxlLmhpZGRlbiA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxlLmhpZGRlbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGNoZWNrZWRLZXlzLmluZGV4T2YoaXRlbS5kYXRhS2V5KSAhPT0gLTEgfHwgbm90UmVuZGVyQ29sdW1ucy5pbmRleE9mKGl0ZW0uZGF0YUtleSkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW0uaGlkZGVuID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaXRlbS5oaWRkZW4gPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgY29sdW1uczogX2NvbHVtbnNcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIGNoYW5nZSBTZWxlY3RlZFJvd3MgZGF0YSB2aWEgY2hlY2tib3gsIHRoaXMgZnVuY3Rpb24gd2lsbCBwYXNzIHRvIHRoZSBDZWxsXG4gICAgICogQHBhcmFtIGNoZWNrZWQge2Jvb2xlYW59IHRoZSBjaGVja2JveCBzdGF0dXNcbiAgICAgKiBAcGFyYW0gcm93SW5kZXgge251bWJlcn0gdGhlIHJvdyBJbmRleFxuICAgICAqIEBwYXJhbSBmcm9tTW91bnQge2Jvb2xlYW59IG9uU2VsZWN0IGlzIGNhbGxlZCBmcm9tIGNlbGwgTW91bnQgaXMgbm90IGV4cGVjdGVkLlxuICAgICAqL1xuXG4gICAgVGFibGUucHJvdG90eXBlLmNoYW5nZVNlbGVjdGVkID0gZnVuY3Rpb24gY2hhbmdlU2VsZWN0ZWQoY2hlY2tlZCwgcm93SW5kZXgsIGZyb21Nb3VudCkge1xuXG4gICAgICAgIHZhciBtZSA9IHRoaXM7XG4gICAgICAgIHZhciBfY29udGVudCA9IGRlZXBjb3B5KHRoaXMuc3RhdGUuZGF0YSk7XG4gICAgICAgIHZhciBfZGF0YSA9IF9jb250ZW50LmRhdGFzIHx8IF9jb250ZW50LmRhdGE7XG5cbiAgICAgICAgbWUuY2hlY2tib3hDb2x1bW4udHlwZSA9PSAncmFkaW9TZWxlY3RvcicgPyBfZGF0YS5tYXAoZnVuY3Rpb24gKGl0ZW0sIGluZGV4KSB7XG4gICAgICAgICAgICBpZiAoaXRlbS5qc3hpZCA9PSByb3dJbmRleCkge1xuICAgICAgICAgICAgICAgIGl0ZW1bbWUuY2hlY2tib3hDb2x1bW5LZXldID0gY2hlY2tlZDtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaXRlbVttZS5jaGVja2JveENvbHVtbktleV0pIHtcbiAgICAgICAgICAgICAgICBpdGVtW21lLmNoZWNrYm94Q29sdW1uS2V5XSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KSA6IF9kYXRhLm1hcChmdW5jdGlvbiAoaXRlbSwgaW5kZXgpIHtcbiAgICAgICAgICAgIGlmIChpdGVtLmpzeGlkID09IHJvd0luZGV4KSB7XG4gICAgICAgICAgICAgICAgaXRlbVttZS5jaGVja2JveENvbHVtbktleV0gPSBjaGVja2VkO1xuICAgICAgICAgICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBtZS5zZXRTdGF0ZSh7XG4gICAgICAgICAgICBkYXRhOiBfY29udGVudFxuICAgICAgICB9LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoIWZyb21Nb3VudCkge1xuICAgICAgICAgICAgICAgIHZhciBkYXRhID0gbWUuc3RhdGUuZGF0YS5kYXRhcyB8fCBtZS5zdGF0ZS5kYXRhLmRhdGE7XG4gICAgICAgICAgICAgICAgdmFyIHNlbGVjdGVkUm93cyA9IGRhdGEuZmlsdGVyKGZ1bmN0aW9uIChpdGVtLCBpbmRleCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaXRlbVttZS5jaGVja2JveENvbHVtbktleV0gPT0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAhIW1lLnByb3BzLnJvd1NlbGVjdGlvbiAmJiAhIW1lLnByb3BzLnJvd1NlbGVjdGlvbi5vblNlbGVjdCAmJiBtZS5wcm9wcy5yb3dTZWxlY3Rpb24ub25TZWxlY3QoY2hlY2tlZCwgZGF0YVtyb3dJbmRleF0sIHNlbGVjdGVkUm93cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICBUYWJsZS5wcm90b3R5cGUuc2VsZWN0QWxsID0gZnVuY3Rpb24gc2VsZWN0QWxsKGNoZWNrZWQpIHtcblxuICAgICAgICB2YXIgbWUgPSB0aGlzO1xuICAgICAgICB2YXIgX2NvbnRlbnQgPSBkZWVwY29weShtZS5zdGF0ZS5kYXRhKTtcbiAgICAgICAgdmFyIF9kYXRhID0gX2NvbnRlbnQuZGF0YXMgfHwgX2NvbnRlbnQuZGF0YTtcbiAgICAgICAgdmFyIHJvd1NlbGVjdGlvbiA9IG1lLnByb3BzLnJvd1NlbGVjdGlvbjtcblxuICAgICAgICB2YXIgc2VsZWN0ZWRSb3dzID0gW107XG4gICAgICAgIF9kYXRhID0gX2RhdGEuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSwgaW5kZXgpIHtcbiAgICAgICAgICAgIHZhciBjb2x1bW4gPSBtZS5jaGVja2JveENvbHVtbjtcbiAgICAgICAgICAgIHZhciBrZXkgPSBtZS5jaGVja2JveENvbHVtbktleTtcbiAgICAgICAgICAgIGlmICghKCdpc0Rpc2FibGUnIGluIGNvbHVtbikgfHwgIWNvbHVtbi5pc0Rpc2FibGUoaXRlbSkpIHtcbiAgICAgICAgICAgICAgICBpdGVtW2tleV0gPSBjaGVja2VkO1xuICAgICAgICAgICAgICAgIHNlbGVjdGVkUm93cy5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoISFyb3dTZWxlY3Rpb24gJiYgISFyb3dTZWxlY3Rpb24ub25TZWxlY3RBbGwpIHtcbiAgICAgICAgICAgIHJvd1NlbGVjdGlvbi5vblNlbGVjdEFsbC5hcHBseShudWxsLCBbY2hlY2tlZCwgY2hlY2tlZCA/IHNlbGVjdGVkUm93cyA6IFtdXSk7XG4gICAgICAgIH1cbiAgICAgICAgbWUuc2V0U3RhdGUoe1xuICAgICAgICAgICAgZGF0YTogX2NvbnRlbnRcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIFRhYmxlLnByb3RvdHlwZS5vblBhZ2VDaGFuZ2UgPSBmdW5jdGlvbiBvblBhZ2VDaGFuZ2UoY3VycmVudCkge1xuICAgICAgICB2YXIgbWUgPSB0aGlzO1xuICAgICAgICBtZS5zZXRTdGF0ZSh7XG4gICAgICAgICAgICBjdXJyZW50UGFnZTogY3VycmVudFxuICAgICAgICB9LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBtZS5mZXRjaERhdGEoXCJwYWdpbmF0aW9uXCIpO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgVGFibGUucHJvdG90eXBlLmhhbmRsZVNob3dTaXplQ2hhbmdlID0gZnVuY3Rpb24gaGFuZGxlU2hvd1NpemVDaGFuZ2UoY3VycmVudCwgcGFnZVNpemUpIHtcbiAgICAgICAgdmFyIG1lID0gdGhpcztcbiAgICAgICAgbWUuc2V0U3RhdGUoe1xuICAgICAgICAgICAgY3VycmVudFBhZ2U6IGN1cnJlbnQsXG4gICAgICAgICAgICBwYWdlU2l6ZTogcGFnZVNpemVcbiAgICAgICAgfSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgbWUuZmV0Y2hEYXRhKFwicGFnaW5hdGlvblwiKTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIFRhYmxlLnByb3RvdHlwZS5yZW5kZXJQYWdlciA9IGZ1bmN0aW9uIHJlbmRlclBhZ2VyKCkge1xuICAgICAgICB2YXIgbWUgPSB0aGlzO1xuICAgICAgICB2YXIgX21lJHN0YXRlID0gbWUuc3RhdGU7XG4gICAgICAgIHZhciBkYXRhID0gX21lJHN0YXRlLmRhdGE7XG4gICAgICAgIHZhciBjdXJyZW50UGFnZSA9IF9tZSRzdGF0ZS5jdXJyZW50UGFnZTtcbiAgICAgICAgdmFyIHBhZ2VTaXplID0gX21lJHN0YXRlLnBhZ2VTaXplO1xuICAgICAgICB2YXIgX21lJHByb3BzID0gbWUucHJvcHM7XG4gICAgICAgIHZhciBzaG93UGFnZXJUb3RhbCA9IF9tZSRwcm9wcy5zaG93UGFnZXJUb3RhbDtcbiAgICAgICAgdmFyIHNob3dQYWdlciA9IF9tZSRwcm9wcy5zaG93UGFnZXI7XG4gICAgICAgIHZhciBsb2NhbGUgPSBfbWUkcHJvcHMubG9jYWxlO1xuICAgICAgICB2YXIgcGFnZXJTaXplT3B0aW9ucyA9IF9tZSRwcm9wcy5wYWdlclNpemVPcHRpb25zO1xuXG5cbiAgICAgICAgaWYgKHNob3dQYWdlciAmJiBkYXRhICYmIGRhdGEudG90YWxDb3VudCkge1xuICAgICAgICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgICAgICAgXCJkaXZcIixcbiAgICAgICAgICAgICAgICB7IGNsYXNzTmFtZTogXCJrdW1hLXV4dGFibGUtcGFnZVwiIH0sXG4gICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChQYWdpbmF0aW9uLCB7IGNsYXNzTmFtZTogXCJtaW5pXCIsIGxvY2FsZTogbG9jYWxlLCBzaG93U2l6ZUNoYW5nZXI6IHRydWUsIHNob3dUb3RhbDogc2hvd1BhZ2VyVG90YWwsIHRvdGFsOiBkYXRhLnRvdGFsQ291bnQsIG9uU2hvd1NpemVDaGFuZ2U6IG1lLmhhbmRsZVNob3dTaXplQ2hhbmdlLmJpbmQobWUpLFxuICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZTogbWUub25QYWdlQ2hhbmdlLmJpbmQobWUpLCBjdXJyZW50OiBjdXJyZW50UGFnZSwgcGFnZVNpemU6IHBhZ2VTaXplLCBzaXplT3B0aW9uczogcGFnZXJTaXplT3B0aW9ucyB9KVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBUYWJsZS5wcm90b3R5cGUuaGFuZGxlT3JkZXJDb2x1bW5DQiA9IGZ1bmN0aW9uIGhhbmRsZU9yZGVyQ29sdW1uQ0IodHlwZSwgY29sdW1uKSB7XG4gICAgICAgIHZhciBtZSA9IHRoaXM7XG4gICAgICAgIG1lLnNldFN0YXRlKHtcbiAgICAgICAgICAgIGFjdGl2ZUNvbHVtbjogY29sdW1uLFxuICAgICAgICAgICAgb3JkZXJUeXBlOiB0eXBlXG4gICAgICAgIH0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIG1lLmZldGNoRGF0YShcIm9yZGVyXCIpO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgVGFibGUucHJvdG90eXBlLmhhbmRsZUFjdGlvbkJhclNlYXJjaCA9IGZ1bmN0aW9uIGhhbmRsZUFjdGlvbkJhclNlYXJjaCh2YWx1ZSkge1xuICAgICAgICB2YXIgbWUgPSB0aGlzO1xuICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgIHNlYXJjaFR4dDogdmFsdWVcbiAgICAgICAgfSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgbWUuZmV0Y2hEYXRhKFwic2VhcmNoXCIpO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgVGFibGUucHJvdG90eXBlLmdldERhdGEgPSBmdW5jdGlvbiBnZXREYXRhKHZhbGlkYXRlKSB7XG4gICAgICAgIHZhciBtZSA9IHRoaXM7XG4gICAgICAgIHZhciBwYXNzID0gdHJ1ZTtcbiAgICAgICAgaWYgKHZhbGlkYXRlICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgZm9yIChuYW1lIGluIG1lLmZpZWxkcykge1xuICAgICAgICAgICAgICAgIHZhciBmaWVsZFBhc3MgPSBtZS5maWVsZHNbbmFtZV0oKTtcblxuICAgICAgICAgICAgICAgIC8vIGlmIG9uZSBmaWVsZCBmYWlscyB0byBwYXNzLCB0aGUgdGFibGUgZmFpbHMgdG8gcGFzc1xuICAgICAgICAgICAgICAgIGlmIChwYXNzKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhc3MgPSBmaWVsZFBhc3M7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChtZS5wcm9wcy5nZXRTYXZlZERhdGEpIHtcbiAgICAgICAgICAgIC8vIOa7pOmZpOWPr+iDveS4uuepuueahOWFg+e0oFxuICAgICAgICAgICAgdmFyIGRhdGEgPSBkZWVwY29weShtZS5kYXRhKTtcbiAgICAgICAgICAgIGRhdGEuZGF0YSA9IGRhdGEuZGF0YS5maWx0ZXIoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXRlbSAhPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZGF0YTogZGF0YSxcbiAgICAgICAgICAgICAgICBwYXNzOiBwYXNzXG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBkYXRhOiBtZS5zdGF0ZS5kYXRhLFxuICAgICAgICAgICAgICAgIHBhc3M6IHBhc3NcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgVGFibGUucHJvdG90eXBlLmhhc0ZpeENvbHVtbiA9IGZ1bmN0aW9uIGhhc0ZpeENvbHVtbigpIHtcbiAgICAgICAgdmFyIHByb3BzID0gdGhpcy5wcm9wcztcbiAgICAgICAgdmFyIF9jb2x1bW5zID0gcHJvcHMuanN4Y29sdW1ucy5maWx0ZXIoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICAgIGlmIChpdGVtLmZpeGVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoX2NvbHVtbnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG5cbiAgICBUYWJsZS5wcm90b3R5cGUucmVuZGVySGVhZGVyID0gZnVuY3Rpb24gcmVuZGVySGVhZGVyKHJlbmRlckhlYWRlclByb3BzKSB7XG5cbiAgICAgICAgaWYgKCF0aGlzLnByb3BzLnNob3dIZWFkZXIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmhhc0ZpeENvbHVtbigpKSB7XG4gICAgICAgICAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAgICAgICBcImRpdlwiLFxuICAgICAgICAgICAgICAgIHsgY2xhc3NOYW1lOiBcImt1bWEtdXh0YWJsZS1oZWFkZXItd3JhcHBlclwiIH0sXG4gICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChIZWFkZXIsIF9leHRlbmRzKHt9LCByZW5kZXJIZWFkZXJQcm9wcywgeyBmaXhlZENvbHVtbjogXCJmaXhlZFwiLCBrZXk6IFwiZ3JpZC1oZWFkZXItZml4ZWRcIiB9KSksXG4gICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChIZWFkZXIsIF9leHRlbmRzKHt9LCByZW5kZXJIZWFkZXJQcm9wcywgeyBmaXhlZENvbHVtbjogXCJzY3JvbGxcIiwga2V5OiBcImdyaWQtaGVhZGVyLXNjcm9sbFwiIH0pKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICAgICAgIFwiZGl2XCIsXG4gICAgICAgICAgICAgICAgeyBjbGFzc05hbWU6IFwia3VtYS11eHRhYmxlLWhlYWRlci13cmFwcGVyXCIgfSxcbiAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KEhlYWRlciwgX2V4dGVuZHMoe30sIHJlbmRlckhlYWRlclByb3BzLCB7IGZpeGVkQ29sdW1uOiBcIm5vXCIgfSkpXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIFRhYmxlLnByb3RvdHlwZS5yZW5kZXJUYm9keSA9IGZ1bmN0aW9uIHJlbmRlclRib2R5KHJlbmRlckJvZHlQcm9wcywgYm9keUhlaWdodCkge1xuXG4gICAgICAgIGlmICh0aGlzLmhhc0ZpeENvbHVtbigpKSB7XG4gICAgICAgICAgICB2YXIgc3ViQ29tcCA9IHJlbmRlckJvZHlQcm9wcy5zdWJDb21wO1xuXG4gICAgICAgICAgICB2YXIgZml4ZWRCb2R5UHJvcHMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMocmVuZGVyQm9keVByb3BzLCBbXCJzdWJDb21wXCJdKTtcblxuICAgICAgICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgICAgICAgXCJkaXZcIixcbiAgICAgICAgICAgICAgICB7IGNsYXNzTmFtZTogXCJrdW1hLXV4dGFibGUtYm9keS13cmFwcGVyXCIsIHN0eWxlOiB7IGhlaWdodDogYm9keUhlaWdodCB9IH0sXG4gICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChUYm9keSwgX2V4dGVuZHMoe30sIGZpeGVkQm9keVByb3BzLCB7IGZpeGVkQ29sdW1uOiBcImZpeGVkXCIsIGtleTogXCJncmlkLWJvZHktZml4ZWRcIiB9KSksXG4gICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChUYm9keSwgX2V4dGVuZHMoe30sIHJlbmRlckJvZHlQcm9wcywgeyBmaXhlZENvbHVtbjogXCJzY3JvbGxcIiwga2V5OiBcImdyaWQtYm9keS1zY3JvbGxcIiB9KSlcbiAgICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAgICAgICBcImRpdlwiLFxuICAgICAgICAgICAgICAgIHsgY2xhc3NOYW1lOiBcImt1bWEtdXh0YWJsZS1ib2R5LXdyYXBwZXJcIiwgc3R5bGU6IHsgaGVpZ2h0OiBib2R5SGVpZ2h0IH0gfSxcbiAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFRib2R5LCBfZXh0ZW5kcyh7fSwgcmVuZGVyQm9keVByb3BzLCB7IGZpeGVkQ29sdW1uOiBcIm5vXCIgfSkpXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIFRhYmxlLnByb3RvdHlwZS5nZXRJc1NlbGVjdEFsbCA9IGZ1bmN0aW9uIGdldElzU2VsZWN0QWxsKGRhdGEpIHtcbiAgICAgICAgdmFyIG1lID0gdGhpcztcbiAgICAgICAgdmFyIGNvbHVtbiA9IG1lLmNoZWNrYm94Q29sdW1uO1xuICAgICAgICBpZiAoIWNvbHVtbiB8fCBkYXRhLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGtleSA9IG1lLmNoZWNrYm94Q29sdW1uS2V5O1xuICAgICAgICB2YXIgaXNTZWxlY3RBbGwgPSB0cnVlO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmICgnaXNEaXNhYmxlJyBpbiBjb2x1bW4gJiYgY29sdW1uLmlzRGlzYWJsZShpdGVtKSB8fCBjb2x1bW4uZGlzYWJsZSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpc1NlbGVjdEFsbCA9IGRhdGFbaV1ba2V5XTtcbiAgICAgICAgICAgICAgICBpZiAoIWlzU2VsZWN0QWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaXNTZWxlY3RBbGw7XG4gICAgfTtcblxuICAgIFRhYmxlLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgICAgIHZhciBfY2xhc3NuYW1lcztcblxuICAgICAgICB2YXIgbWUgPSB0aGlzO1xuICAgICAgICB2YXIgcHJvcHMgPSB0aGlzLnByb3BzO1xuICAgICAgICB2YXIgc3RhdGUgPSB0aGlzLnN0YXRlO1xuXG4gICAgICAgIHZhciBib2R5SGVpZ2h0ID0gdW5kZWZpbmVkO1xuICAgICAgICAvLyBpZiB0YWJsZSBpcyBpbiBzdWIgbW9kZSwgcGVvcGxlIGFsd2F5cyB3YW50IHRvIGFsaWduIHRoZSBwYXJlbnRcbiAgICAgICAgLy8gYW5kIHRoZSBzdWIgdGFibGUsIHNvIHdpZHRoIHNob3VsZCBub3QgYmUgY2FyZWQuXG4gICAgICAgIHZhciBoZWFkZXJIZWlnaHQgPSBwcm9wcy5oZWFkZXJIZWlnaHQ7XG5cblxuICAgICAgICB2YXIgZGF0YSA9IHN0YXRlLmRhdGEgPyBzdGF0ZS5kYXRhLmRhdGFzIHx8IHN0YXRlLmRhdGEuZGF0YSA6IFtdO1xuICAgICAgICB2YXIgaXNTZWxlY3RBbGwgPSBtZS5nZXRJc1NlbGVjdEFsbChkYXRhKTtcblxuICAgICAgICB2YXIgX3N0eWxlID0ge1xuICAgICAgICAgICAgd2lkdGg6ICEhcHJvcHMucGFzc2VkRGF0YSA/IFwiYXV0b1wiIDogcHJvcHMud2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQ6IHByb3BzLmhlaWdodFxuICAgICAgICB9O1xuICAgICAgICB2YXIgYWN0aW9uQmFySGVpZ2h0ID0gcHJvcHMuYWN0aW9uQmFyID8gcHJvcHMuYWN0aW9uQmFySGVpZ2h0IDogMDtcbiAgICAgICAgdmFyIHBhZ2VySGVpZ2h0ID0gcHJvcHMuc2hvd1BhZ2VyICYmIHRoaXMuc3RhdGUuZGF0YSAmJiB0aGlzLnN0YXRlLmRhdGEudG90YWxDb3VudCA/IDUwIDogMDtcblxuICAgICAgICAvLyBkZWNpZGUgd2hldGhlciB0aGUgdGFibGUgaGFzIGNvbHVtbiBncm91cHNcbiAgICAgICAgdmFyIGhhc0dyb3VwID0gZmFsc2U7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5zdGF0ZS5jb2x1bW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoJ2dyb3VwJyBpbiB0aGlzLnN0YXRlLmNvbHVtbnNbaV0pIHtcbiAgICAgICAgICAgICAgICBoYXNHcm91cCA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBoZWFkZXJIZWlnaHQgPSBoZWFkZXJIZWlnaHQgfHwgKGhhc0dyb3VwID8gODAgOiA0MCk7XG5cbiAgICAgICAgaWYgKHByb3BzLmhlaWdodCA9PSAnYXV0bycpIHtcbiAgICAgICAgICAgIGJvZHlIZWlnaHQgPSAnYXV0byc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBib2R5SGVpZ2h0ID0gcHJvcHMuaGVpZ2h0ID09IFwiMTAwJVwiID8gcHJvcHMuaGVpZ2h0IDogcHJvcHMuaGVpZ2h0IC0gaGVhZGVySGVpZ2h0IC0gYWN0aW9uQmFySGVpZ2h0IC0gcGFnZXJIZWlnaHQ7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlbmRlckJvZHlQcm9wcyA9IHtcbiAgICAgICAgICAgIGNvbHVtbnM6IHN0YXRlLmNvbHVtbnMsXG4gICAgICAgICAgICBtYXNrOiBzdGF0ZS5zaG93TWFzayxcbiAgICAgICAgICAgIGRhdGE6IGRhdGEsXG4gICAgICAgICAgICByb3dTZWxlY3Rpb246IHByb3BzLnJvd1NlbGVjdGlvbixcbiAgICAgICAgICAgIGFkZFJvd0NsYXNzTmFtZTogcHJvcHMuYWRkUm93Q2xhc3NOYW1lLFxuICAgICAgICAgICAgc3ViQ29tcDogcHJvcHMuc3ViQ29tcCxcbiAgICAgICAgICAgIHJlbmRlclN1YkNvbXA6IHByb3BzLnJlbmRlclN1YkNvbXAsXG4gICAgICAgICAgICByb3dIZWlnaHQ6IHByb3BzLnJvd0hlaWdodCxcbiAgICAgICAgICAgIGxvYWRpbmdUZXh0OiBwcm9wcy5sb2FkaW5nVGV4dCxcbiAgICAgICAgICAgIGhlaWdodDogYm9keUhlaWdodCxcbiAgICAgICAgICAgIHdpZHRoOiBwcm9wcy53aWR0aCxcbiAgICAgICAgICAgIG1vZGU6IHByb3BzLm1vZGUsXG4gICAgICAgICAgICBsZXZlbHM6IHByb3BzLmxldmVscyxcbiAgICAgICAgICAgIHJvb3Q6IHRoaXMsXG4gICAgICAgICAgICByZW5kZXJNb2RlbDogcHJvcHMucmVuZGVyTW9kZWwsXG4gICAgICAgICAgICBjaGFuZ2VTZWxlY3RlZDogdGhpcy5jaGFuZ2VTZWxlY3RlZC5iaW5kKHRoaXMpLFxuICAgICAgICAgICAgaGFuZGxlRGF0YUNoYW5nZTogdGhpcy5oYW5kbGVEYXRhQ2hhbmdlLmJpbmQodGhpcyksXG4gICAgICAgICAgICBhdHRhY2hDZWxsRmllbGQ6IHRoaXMuYXR0YWNoQ2VsbEZpZWxkLmJpbmQodGhpcyksXG4gICAgICAgICAgICBkZXRhY2hDZWxsRmllbGQ6IHRoaXMuZGV0YWNoQ2VsbEZpZWxkLmJpbmQodGhpcyksXG4gICAgICAgICAgICBrZXk6ICdncmlkLWJvZHknXG4gICAgICAgIH0sXG4gICAgICAgICAgICByZW5kZXJIZWFkZXJQcm9wcyA9IHtcbiAgICAgICAgICAgIGNvbHVtbnM6IHN0YXRlLmNvbHVtbnMsXG4gICAgICAgICAgICBhY3RpdmVDb2x1bW46IHN0YXRlLmFjdGl2ZUNvbHVtbixcbiAgICAgICAgICAgIG9yZGVyVHlwZTogc3RhdGUub3JkZXJUeXBlLFxuICAgICAgICAgICAgc2hvd0NvbHVtblBpY2tlcjogcHJvcHMuc2hvd0NvbHVtblBpY2tlcixcbiAgICAgICAgICAgIHNob3dIZWFkZXJCb3JkZXI6IHByb3BzLnNob3dIZWFkZXJCb3JkZXIsXG4gICAgICAgICAgICBoZWFkZXJIZWlnaHQ6IHByb3BzLmhlYWRlckhlaWdodCxcbiAgICAgICAgICAgIHdpZHRoOiBwcm9wcy53aWR0aCxcbiAgICAgICAgICAgIG1vZGU6IHByb3BzLm1vZGUsXG4gICAgICAgICAgICBpc1NlbGVjdEFsbDogaXNTZWxlY3RBbGwsXG4gICAgICAgICAgICBzZWxlY3RBbGw6IHRoaXMuc2VsZWN0QWxsLmJpbmQodGhpcyksXG4gICAgICAgICAgICBvcmRlckNvbHVtbkNCOiB0aGlzLmhhbmRsZU9yZGVyQ29sdW1uQ0IuYmluZCh0aGlzKSxcbiAgICAgICAgICAgIGhhbmRsZUNvbHVtblBpY2tlckNoYW5nZTogdGhpcy5oYW5kbGVDb2x1bW5QaWNrZXJDaGFuZ2UuYmluZCh0aGlzKSxcbiAgICAgICAgICAgIGtleTogJ2dyaWQtaGVhZGVyJ1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBhY3Rpb25CYXIgPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgaWYgKHByb3BzLmFjdGlvbkJhciB8fCBwcm9wcy5zaG93U2VhcmNoKSB7XG4gICAgICAgICAgICB2YXIgcmVuZGVyQWN0aW9uUHJvcHMgPSB7XG4gICAgICAgICAgICAgICAgb25TZWFyY2g6IHRoaXMuaGFuZGxlQWN0aW9uQmFyU2VhcmNoLmJpbmQodGhpcyksXG4gICAgICAgICAgICAgICAgYWN0aW9uQmFyQ29uZmlnOiB0aGlzLnByb3BzLmFjdGlvbkJhcixcbiAgICAgICAgICAgICAgICBzaG93U2VhcmNoOiB0aGlzLnByb3BzLnNob3dTZWFyY2gsXG4gICAgICAgICAgICAgICAgc2VhcmNoQmFyUGxhY2Vob2xkZXI6IHRoaXMucHJvcHMuc2VhcmNoQmFyUGxhY2Vob2xkZXIsXG4gICAgICAgICAgICAgICAga2V5OiAnZ3JpZC1hY3Rpb25iYXInXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgYWN0aW9uQmFyID0gUmVhY3QuY3JlYXRlRWxlbWVudChBY3Rpb25CYXIsIHJlbmRlckFjdGlvblByb3BzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICAgXCJkaXZcIixcbiAgICAgICAgICAgIHsgY2xhc3NOYW1lOiBjbGFzc25hbWVzKChfY2xhc3NuYW1lcyA9IHt9LCBfY2xhc3NuYW1lc1twcm9wcy5qc3hwcmVmaXhDbHNdID0gdHJ1ZSwgX2NsYXNzbmFtZXNbXCJrdW1hLXN1YmdyaWQtbW9kZVwiXSA9ICEhcHJvcHMucGFzc2VkRGF0YSwgX2NsYXNzbmFtZXMpKSwgc3R5bGU6IF9zdHlsZSB9LFxuICAgICAgICAgICAgYWN0aW9uQmFyLFxuICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAgICAgICBcImRpdlwiLFxuICAgICAgICAgICAgICAgIHsgY2xhc3NOYW1lOiBcImt1bWEtdXh0YWJsZS1jb250ZW50XCIsIHN0eWxlOiB7IHdpZHRoOiAhIXByb3BzLnBhc3NlZERhdGEgPyBcImF1dG9cIiA6IHByb3BzLndpZHRoIH0gfSxcbiAgICAgICAgICAgICAgICB0aGlzLnJlbmRlckhlYWRlcihyZW5kZXJIZWFkZXJQcm9wcyksXG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJUYm9keShyZW5kZXJCb2R5UHJvcHMsIGJvZHlIZWlnaHQpXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgdGhpcy5yZW5kZXJQYWdlcigpXG4gICAgICAgICk7XG4gICAgfTtcblxuICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8gVXRpbCBNZXRob2QgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4gICAgLyoqXG4gICAgICogYWRkIHNvbWUgc3BlY2lmaWMgdmFsdWUgZm9yIGVhY2ggcm93IGRhdGEgd2hpY2ggd2lsbCBiZSB1c2VkIGluIG1hbmlwdWxhdGluZyBkYXRhICYgcmVuZGVyaW5nLlxuICAgICAqIHVzZWQgaW4gcmVjb3JkIEFQSS5cbiAgICAgKi9cblxuICAgIFRhYmxlLnByb3RvdHlwZS5hZGRKU1hJZHNGb3JSZWNvcmQgPSBmdW5jdGlvbiBhZGRKU1hJZHNGb3JSZWNvcmQob2JqQXV4KSB7XG4gICAgICAgIHZhciBtZSA9IHRoaXM7XG4gICAgICAgIGlmIChvYmpBdXggaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICAgICAgb2JqQXV4ID0gb2JqQXV4Lm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgICAgICAgIGlmIChpdGVtLmpzeGlkID09IHVuZGVmaW5lZCB8fCBpdGVtLmpzeGlkID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgaXRlbS5qc3hpZCA9IG1lLnVpZCsrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIWl0ZW0uX19tb2RlX18pIHtcbiAgICAgICAgICAgICAgICAgICAgaXRlbS5fX21vZGVfXyA9IENvbnN0Lk1PREUuRURJVDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG9iakF1eC5qc3hpZCA9IG1lLnVpZCsrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvYmpBdXg7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIGFkZCBzb21lIHNwZWNpZmljIHZhbHVlIGZvciBlYWNoIHJvdyBkYXRhIHdoaWNoIHdpbGwgYmUgdXNlZCBpbiBtYW5pcHVsYXRpbmcgZGF0YSAmIHJlbmRlcmluZy5cbiAgICAgKiB1c2VkIGluIG1ldGhvZCBmZXRjaERhdGFcbiAgICAgKi9cblxuICAgIFRhYmxlLnByb3RvdHlwZS5hZGRWYWx1ZXNJbkRhdGEgPSBmdW5jdGlvbiBhZGRWYWx1ZXNJbkRhdGEob2JqQXV4KSB7XG4gICAgICAgIGlmICghb2JqQXV4IHx8ICFvYmpBdXguZGF0YXMgJiYgIW9iakF1eC5kYXRhKSByZXR1cm47XG4gICAgICAgIHZhciBtZSA9IHRoaXM7XG4gICAgICAgIHZhciBkYXRhID0gb2JqQXV4LmRhdGFzIHx8IG9iakF1eC5kYXRhO1xuICAgICAgICBkYXRhLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgIG5vZGUuanN4aWQgPSBtZS51aWQrKztcbiAgICAgICAgICAgIG5vZGUuX19tb2RlX18gPSBub2RlLl9fbW9kZV9fIHx8IENvbnN0Lk1PREUuVklFVztcbiAgICAgICAgICAgIG1lLmFkZFZhbHVlc0luRGF0YShub2RlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBvYmpBdXg7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIG1lcmdlIGRhdGFcbiAgICAgKi9cblxuICAgIFRhYmxlLnByb3RvdHlwZS5tZXJnZURhdGEgPSBmdW5jdGlvbiBtZXJnZURhdGEoZGF0YSwgb2JqKSB7XG4gICAgICAgIHZhciBuZXdEYXRhID0gZGVlcGNvcHkoZGF0YSk7XG5cbiAgICAgICAgLy8gY29kZSBjb21wYXRpYmxlXG4gICAgICAgIGlmICghIW5ld0RhdGEuZGF0YXMpIHtcbiAgICAgICAgICAgIG5ld0RhdGEuZGF0YXMgPSBuZXdEYXRhLmRhdGFzLmNvbmNhdChvYmopO1xuICAgICAgICB9IGVsc2UgaWYgKCEhbmV3RGF0YS5kYXRhKSB7XG4gICAgICAgICAgICBuZXdEYXRhLmRhdGEgPSBuZXdEYXRhLmRhdGEuY29uY2F0KG9iaik7XG4gICAgICAgIH1cbiAgICAgICAgbmV3RGF0YS50b3RhbENvdW50Kys7XG4gICAgICAgIHJldHVybiBuZXdEYXRhO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBpbnNlcnQgc29tZSBkYXRhIGludG8gdGhpcy5zdGF0ZS5kYXRhXG4gICAgICogQHBhcmFtIG9iakF1eCB7QXJyYXkgb3IgT2JqZWN0fSBkYXR1bSBvciBkYXRhIG5lZWQgdG8gYmUgaW5zZXJ0ZWRcbiAgICAgKi9cblxuICAgIFRhYmxlLnByb3RvdHlwZS5pbnNlcnRSZWNvcmRzID0gZnVuY3Rpb24gaW5zZXJ0UmVjb3JkcyhvYmpBdXgpIHtcbiAgICAgICAgaWYgKCh0eXBlb2Ygb2JqQXV4ID09PSBcInVuZGVmaW5lZFwiID8gXCJ1bmRlZmluZWRcIiA6IF90eXBlb2Yob2JqQXV4KSkgIT09IFwib2JqZWN0XCIpIHJldHVybjtcbiAgICAgICAgdmFyIG1lID0gdGhpcztcbiAgICAgICAgaWYgKCEob2JqQXV4IGluc3RhbmNlb2YgQXJyYXkpKSB7XG4gICAgICAgICAgICBvYmpBdXggPSBbb2JqQXV4XTtcbiAgICAgICAgfVxuXG4gICAgICAgIG9iakF1eCA9IHRoaXMuYWRkSlNYSWRzRm9yUmVjb3JkKG9iakF1eCk7XG5cbiAgICAgICAgLy8gbWUuZGF0YSA9IG1lLm1lcmdlRGF0YShtZS5kYXRhLCBvYmpBdXgpO1xuICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgIGRhdGE6IG1lLm1lcmdlRGF0YShtZS5zdGF0ZS5kYXRhLCBvYmpBdXgpXG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge29iakF1eH0ge2E6J2InLGM6J2QnLGpzeGlkOicnfVxuICAgICAqL1xuXG5cbiAgICBUYWJsZS5wcm90b3R5cGUudXBkYXRlUmVjb3JkID0gZnVuY3Rpb24gdXBkYXRlUmVjb3JkKG9iakF1eCwgY2IpIHtcbiAgICAgICAgdmFyIF9kYXRhID0gdGhpcy5zdGF0ZS5kYXRhO1xuXG4gICAgICAgIGlmICghX2RhdGEpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChfZGF0YS5kYXRhIHx8IF9kYXRhLmRhdGFzKSB7XG4gICAgICAgICAgICB2YXIgZGF0YSA9IF9kYXRhLmRhdGEgfHwgX2RhdGEuZGF0YXM7XG5cbiAgICAgICAgICAgIGRhdGEgPSBkYXRhLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgICAgICAgIGlmIChpdGVtLmpzeGlkID09IG9iakF1eC5qc3hpZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gb2JqQXV4O1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKCEhX2RhdGEuZGF0YSkge1xuICAgICAgICAgICAgICAgIF9kYXRhLmRhdGEgPSBkYXRhO1xuICAgICAgICAgICAgfSBlbHNlIGlmICghIV9kYXRhLmRhdGFzKSB7XG4gICAgICAgICAgICAgICAgX2RhdGEuZGF0YXMgPSBkYXRhO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgZGF0YTogX2RhdGFcbiAgICAgICAgfSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgISFjYiAmJiBjYigpO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgVGFibGUucHJvdG90eXBlLnN5bmNSZWNvcmQgPSBmdW5jdGlvbiBzeW5jUmVjb3JkKG9iakF1eCkge1xuICAgICAgICB2YXIgbWUgPSB0aGlzO1xuICAgICAgICB2YXIgX2RhdGEgPSBtZS5kYXRhLmRhdGEgfHwgbWUuZGF0YS5kYXRhcztcblxuICAgICAgICBtZS51cGRhdGVSZWNvcmQob2JqQXV4LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgX3N0YXRlRGF0YSA9IG1lLnN0YXRlLmRhdGEuZGF0YSB8fCBtZS5zdGF0ZS5kYXRhLmRhdGFzO1xuICAgICAgICAgICAgLy8gX2RhdGEuZm9yRWFjaCgoaXRlbSwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgIC8vICAgICBpZiAoaXRlbS5qc3hpZCA9PSBvYmpBdXguanN4aWQpIHtcbiAgICAgICAgICAgIC8vICAgICAgICAgX2RhdGFbaW5kZXhdID0gX3N0YXRlRGF0YS5maWx0ZXIoKGVsZSkgPT4ge1xuICAgICAgICAgICAgLy8gICAgICAgICAgICAgcmV0dXJuIGVsZS5qc3hpZCA9PSBvYmpBdXguanN4aWRcbiAgICAgICAgICAgIC8vICAgICAgICAgfSlbMF07XG4gICAgICAgICAgICAvLyAgICAgfVxuICAgICAgICAgICAgLy8gfSk7XG4gICAgICAgICAgICBfc3RhdGVEYXRhLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0sIGluZGV4KSB7XG4gICAgICAgICAgICAgICAgaWYgKGl0ZW0uanN4aWQgPT0gb2JqQXV4LmpzeGlkKSB7XG4gICAgICAgICAgICAgICAgICAgIF9kYXRhW2luZGV4XSA9IGl0ZW07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICBUYWJsZS5wcm90b3R5cGUucmVtb3ZlUmVjb3JkcyA9IGZ1bmN0aW9uIHJlbW92ZVJlY29yZHMob2JqQXV4KSB7XG5cbiAgICAgICAgLy9hdCBsZWFzdCBvbmUgcmVjb3JkXG4gICAgICAgIHZhciBtZSA9IHRoaXM7XG4gICAgICAgIHZhciBjb250ZW50ID0gdGhpcy5zdGF0ZS5kYXRhO1xuICAgICAgICB2YXIgZGF0YSA9IGNvbnRlbnQuZGF0YSB8fCBjb250ZW50LmRhdGFzO1xuXG4gICAgICAgIC8vIGRlZXBjb3B5IHByb3RlY3RcbiAgICAgICAgdmFyIF9jb250ZW50ID0gZGVlcGNvcHkoY29udGVudCksXG4gICAgICAgICAgICBfZGF0YSA9IF9jb250ZW50LmRhdGEgfHwgX2NvbnRlbnQuZGF0YXM7XG5cbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmpBdXgpICE9PSBcIltvYmplY3QgQXJyYXldXCIpIHtcbiAgICAgICAgICAgIG9iakF1eCA9IFtvYmpBdXhdO1xuICAgICAgICB9XG5cbiAgICAgICAgb2JqQXV4Lm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgICAgX2RhdGEuZm9yRWFjaChmdW5jdGlvbiAoZWxlbWVudCwgaW5kZXgsIGFycmF5KSB7XG4gICAgICAgICAgICAgICAgaWYgKGVsZW1lbnQuanN4aWQgPT0gaXRlbS5qc3hpZCkge1xuICAgICAgICAgICAgICAgICAgICBfZGF0YS5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcblxuICAgICAgICBtZS5kYXRhID0gX2NvbnRlbnQ7XG5cbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICBkYXRhOiBfY29udGVudFxuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vIENVUkQgZm9yIFRhYmxlIC8vLy8vLy8vLy8vLy8vLy9cblxuICAgIFRhYmxlLnByb3RvdHlwZS5hZGRFbXB0eVJvdyA9IGZ1bmN0aW9uIGFkZEVtcHR5Um93KCkge1xuICAgICAgICB0aGlzLmluc2VydFJlY29yZHMoe30pO1xuICAgIH07XG5cbiAgICBUYWJsZS5wcm90b3R5cGUuYWRkUm93ID0gZnVuY3Rpb24gYWRkUm93KHJvd0RhdGEpIHtcbiAgICAgICAgdGhpcy5pbnNlcnRSZWNvcmRzKHJvd0RhdGEpO1xuICAgIH07XG5cbiAgICBUYWJsZS5wcm90b3R5cGUucmVzZXRSb3cgPSBmdW5jdGlvbiByZXNldFJvdyhyb3dEYXRhKSB7XG4gICAgICAgIHZhciBtZSA9IHRoaXM7XG4gICAgICAgIHZhciB1cGRhdGVEYXRhID0ge307XG4gICAgICAgIHZhciBfZGF0YSA9IG1lLmRhdGEuZGF0YXMgfHwgbWUuZGF0YS5kYXRhO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IF9kYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoX2RhdGFbaV0uanN4aWQgPT0gcm93RGF0YS5qc3hpZCkge1xuICAgICAgICAgICAgICAgIHVwZGF0ZURhdGEgPSBkZWVwY29weShfZGF0YVtpXSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdXBkYXRlRGF0YVsnX19tb2RlX18nXSA9IENvbnN0Lk1PREUuRURJVDtcbiAgICAgICAgdGhpcy51cGRhdGVSZWNvcmQodXBkYXRlRGF0YSk7XG4gICAgfTtcblxuICAgIFRhYmxlLnByb3RvdHlwZS5kZWxSb3cgPSBmdW5jdGlvbiBkZWxSb3cocm93RGF0YSkge1xuICAgICAgICB0aGlzLnJlbW92ZVJlY29yZHMocm93RGF0YSk7XG4gICAgfTtcblxuICAgIFRhYmxlLnByb3RvdHlwZS5lZGl0Um93ID0gZnVuY3Rpb24gZWRpdFJvdyhyb3dEYXRhKSB7XG4gICAgICAgIHJvd0RhdGEuX19tb2RlX18gPSBDb25zdC5NT0RFLkVESVQ7XG4gICAgICAgIHRoaXMudXBkYXRlUmVjb3JkKHJvd0RhdGEpO1xuICAgIH07XG5cbiAgICBUYWJsZS5wcm90b3R5cGUudmlld1JvdyA9IGZ1bmN0aW9uIHZpZXdSb3cocm93RGF0YSkge1xuICAgICAgICByb3dEYXRhLl9fbW9kZV9fID0gQ29uc3QuTU9ERS5WSUVXO1xuICAgICAgICB0aGlzLnVwZGF0ZVJlY29yZChyb3dEYXRhKTtcbiAgICB9O1xuXG4gICAgVGFibGUucHJvdG90eXBlLnNhdmVSb3cgPSBmdW5jdGlvbiBzYXZlUm93KHJvd0RhdGEpIHtcbiAgICAgICAgcm93RGF0YS5fX21vZGVfXyA9IENvbnN0Lk1PREUuVklFVztcbiAgICAgICAgcm93RGF0YS5fX2VkaXRlZF9fID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5zeW5jUmVjb3JkKHJvd0RhdGEpO1xuICAgIH07XG5cbiAgICBUYWJsZS5wcm90b3R5cGUuc2F2ZUFsbFJvdyA9IGZ1bmN0aW9uIHNhdmVBbGxSb3coKSB7XG4gICAgICAgIHZhciBtZSA9IHRoaXM7XG4gICAgICAgIHZhciBkYXRhID0gZGVlcGNvcHkobWUuc3RhdGUuZGF0YS5kYXRhIHx8IG1lLnN0YXRlLmRhdGEuZGF0YXMpO1xuICAgICAgICBkYXRhLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICAgIG1lLnNhdmVSb3coaXRlbSk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICBUYWJsZS5wcm90b3R5cGUuZWRpdEFsbFJvdyA9IGZ1bmN0aW9uIGVkaXRBbGxSb3coKSB7XG4gICAgICAgIHZhciBtZSA9IHRoaXM7XG4gICAgICAgIHZhciBkYXRhID0gZGVlcGNvcHkobWUuZGF0YS5kYXRhIHx8IG1lLmRhdGEuZGF0YXMpO1xuICAgICAgICBkYXRhLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICAgIG1lLmVkaXRSb3coaXRlbSk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICBUYWJsZS5wcm90b3R5cGUudG9nZ2xlU3ViQ29tcCA9IGZ1bmN0aW9uIHRvZ2dsZVN1YkNvbXAocm93RGF0YSkge1xuICAgICAgICB2YXIgX2NvbnRlbnQgPSBkZWVwY29weSh0aGlzLnN0YXRlLmRhdGEpO1xuICAgICAgICB2YXIgX2RhdGEgPSBfY29udGVudC5kYXRhIHx8IF9jb250ZW50LmRhdGFzO1xuXG4gICAgICAgIGlmIChfZGF0YSkge1xuICAgICAgICAgICAgX2RhdGEgPSBfZGF0YS5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICBpZiAoaXRlbS5qc3hpZCA9PSByb3dEYXRhLmpzeGlkKSB7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW0uc2hvd1N1YkNvbXAgPSAhaXRlbS5zaG93U3ViQ29tcDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICBkYXRhOiBfY29udGVudFxuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIFRhYmxlO1xufShSZWFjdC5Db21wb25lbnQpO1xuXG47XG5cblRhYmxlLmRlZmF1bHRQcm9wcyA9IHtcbiAgICBqc3hwcmVmaXhDbHM6IFwia3VtYS11eHRhYmxlXCIsXG4gICAgbG9jYWxlOiBcInpoLWNuXCIsXG4gICAgc2hvd0hlYWRlcjogdHJ1ZSxcbiAgICB3aWR0aDogXCJhdXRvXCIsXG4gICAgaGVpZ2h0OiBcImF1dG9cIixcbiAgICBtb2RlOiBDb25zdC5NT0RFLkVESVQsXG4gICAgcmVuZGVyTW9kZWw6ICcnLFxuICAgIGxldmVsczogMSxcbiAgICBhY3Rpb25CYXJIZWlnaHQ6IDQwLFxuICAgIGZldGNoRGF0YU9uTW91bnQ6IHRydWUsXG4gICAgZG91YmxlQ2xpY2tUb0VkaXQ6IHRydWUsXG4gICAgcm93U2VsZWN0b3I6ICdjaGVja2JveFNlbGVjdG9yJyxcbiAgICBzaG93UGFnZXI6IHRydWUsXG4gICAgc2hvd0NvbHVtblBpY2tlcjogdHJ1ZSxcbiAgICBzaG93SGVhZGVyQm9yZGVyOiBmYWxzZSxcbiAgICBzaG93UGFnZXJUb3RhbDogZmFsc2UsXG4gICAgc2hvd01hc2s6IGZhbHNlLFxuICAgIHNob3dTZWFyY2g6IGZhbHNlLFxuICAgIGdldFNhdmVkRGF0YTogdHJ1ZSxcbiAgICBwYWdlU2l6ZTogMTAsXG4gICAgcGFnZXJTaXplT3B0aW9uczogWzEwLCAyMCwgMzAsIDQwXSxcbiAgICByb3dIZWlnaHQ6IDc2LFxuICAgIGZldGNoUGFyYW1zOiB7fSxcbiAgICBjdXJyZW50UGFnZTogMSxcbiAgICBxdWVyeUtleXM6IFtdLFxuICAgIGVtcHR5VGV4dDogXCLmmoLml6DmlbDmja5cIixcbiAgICBzZWFyY2hCYXJQbGFjZWhvbGRlcjogXCLmkJzntKLooajmoLzlhoXlrrlcIixcbiAgICBsb2FkaW5nVGV4dDogXCJsb2FkaW5nXCIsXG4gICAgcHJvY2Vzc0RhdGE6IGZ1bmN0aW9uIHByb2Nlc3NEYXRhKGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfSxcbiAgICBiZWZvcmVGZXRjaDogZnVuY3Rpb24gYmVmb3JlRmV0Y2gob2JqKSB7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBvbkZldGNoRXJyb3I6IGZ1bmN0aW9uIG9uRmV0Y2hFcnJvcigpIHt9LFxuICAgIGFkZFJvd0NsYXNzTmFtZTogZnVuY3Rpb24gYWRkUm93Q2xhc3NOYW1lKCkge30sXG4gICAgb25DaGFuZ2U6IGZ1bmN0aW9uIG9uQ2hhbmdlKCkge31cbn07XG5cbi8vIGh0dHA6Ly9mYWNlYm9vay5naXRodWIuaW8vcmVhY3QvZG9jcy9yZXVzYWJsZS1jb21wb25lbnRzLmh0bWxcblRhYmxlLnByb3BUeXBlcyA9IHtcbiAgICAvKipcbiAgICAgKiBAdGl0bGUg5Zu96ZmF5YyWXG4gICAgICogQHZlRmllbGRTdHlsZSBibG9ja1xuICAgICAqL1xuICAgIGxvY2FsZTogUmVhY3QuUHJvcFR5cGVzLnN0cmluZyxcbiAgICAvKipcbiAgICAgKiBAdGl0bGUg5YiX6YWN572uXG4gICAgICovXG4gICAganN4Y29sdW1uczogUmVhY3QuUHJvcFR5cGVzLmFycmF5T2YoUmVhY3QuUHJvcFR5cGVzLm9iamVjdCksXG4gICAgLyoqXG4gICAgICogQHRpdGxlIOihqOagvOWuveW6plxuICAgICAqL1xuICAgIHdpZHRoOiBSZWFjdC5Qcm9wVHlwZXMub25lT2ZUeXBlKFtSZWFjdC5Qcm9wVHlwZXMuc3RyaW5nLCBSZWFjdC5Qcm9wVHlwZXMubnVtYmVyXSksXG4gICAgLyoqXG4gICAgICogQHRpdGxlIOihqOagvOmrmOW6plxuICAgICAqL1xuICAgIGhlaWdodDogUmVhY3QuUHJvcFR5cGVzLm9uZU9mVHlwZShbUmVhY3QuUHJvcFR5cGVzLnN0cmluZywgUmVhY3QuUHJvcFR5cGVzLm51bWJlcl0pLFxuICAgIC8qKlxuICAgICAqIEB0aXRsZSDooajlpLTpq5jluqZcbiAgICAgKi9cbiAgICBoZWFkZXJIZWlnaHQ6IFJlYWN0LlByb3BUeXBlcy5udW1iZXIsXG4gICAgLyoqXG4gICAgICogQHRpdGxlIOavj+mhteaYvuekuuadoeaVsFxuICAgICAqIEB2ZUZpZWxkU3R5bGUgYmxvY2tcbiAgICAgKi9cbiAgICBwYWdlU2l6ZTogUmVhY3QuUHJvcFR5cGVzLm51bWJlcixcbiAgICAvKipcbiAgICAgKiBAdGl0bGUg5ZOq5Lqb5Y+C5pWw5Lyg6YCS57uZIHN1YkNvbXAgKOWNs+WwhuW6n+mZpClcbiAgICAgKiBAdmVJZ25vcmVcbiAgICAgKi9cbiAgICBxdWVyeUtleXM6IFJlYWN0LlByb3BUeXBlcy5hcnJheSxcbiAgICAvKipcbiAgICAgKiBAdGl0bGUg5piv5ZCm5Zyo5Yid5aeL5YyW5pe26K+35rGC5pWw5o2uXG4gICAgICogQHZlRmllbGRTdHlsZSBibG9ja1xuICAgICAqL1xuICAgIGZldGNoRGF0YU9uTW91bnQ6IFJlYWN0LlByb3BUeXBlcy5ib29sLFxuICAgIC8qKlxuICAgICAqIEB0aXRsZSDmmK/lkKblj4zlh7vov5vlhaXnvJbovpHmqKHlvI9cbiAgICAgKiBAdmVGaWVsZFN0eWxlIGJsb2NrXG4gICAgICovXG4gICAgZG91YmxlQ2xpY2tUb0VkaXQ6IFJlYWN0LlByb3BUeXBlcy5ib29sLFxuICAgIC8qKlxuICAgICAqIEB0aXRsZSDmmK/lkKbmmL7npLrliJfpgInmi6nlmahcbiAgICAgKiBAdmVGaWVsZFN0eWxlIGJsb2NrXG4gICAgICovXG4gICAgc2hvd0NvbHVtblBpY2tlcjogUmVhY3QuUHJvcFR5cGVzLmJvb2wsXG4gICAgLyoqXG4gICAgICogQHRpdGxlIOaYr+WQpuaYvuekuuWIhumhtVxuICAgICAqIEB2ZUZpZWxkU3R5bGUgYmxvY2tcbiAgICAgKi9cbiAgICBzaG93UGFnZXI6IFJlYWN0LlByb3BUeXBlcy5ib29sLFxuICAgIC8qKlxuICAgICAqIEB0aXRsZSDliIbpobXkuK3mmK/lkKbmmL7npLrmgLvmnaHmlbBcbiAgICAgKiBAdmVGaWVsZFN0eWxlIGJsb2NrXG4gICAgICovXG4gICAgc2hvd1BhZ2VyVG90YWw6IFJlYWN0LlByb3BUeXBlcy5ib29sLFxuICAgIC8qKlxuICAgICAqIEB0aXRsZSAg5pi+56S655qE5Y+v6YCJIHBhZ2VTaXplXG4gICAgICogQHZlRmllbGRTdHlsZSBibG9ja1xuICAgICAqL1xuICAgIHBhZ2VyU2l6ZU9wdGlvbnM6IFJlYWN0LlByb3BUeXBlcy5hcnJheSxcbiAgICAvKipcbiAgICAgKiBAdGl0bGUg5piv5ZCm5pi+56S66KGo5qC85aS0XG4gICAgICogQHZlRmllbGRTdHlsZSBibG9ja1xuICAgICAqL1xuICAgIHNob3dIZWFkZXI6IFJlYWN0LlByb3BUeXBlcy5ib29sLFxuICAgIC8qKlxuICAgICAqIEB0aXRsZSDmmK/lkKbmmL7npLrpga7nvalcbiAgICAgKiBAdmVGaWVsZFN0eWxlIGJsb2NrXG4gICAgICogQHZlSWdub3JlXG4gICAgICovXG4gICAgc2hvd01hc2s6IFJlYWN0LlByb3BUeXBlcy5ib29sLFxuICAgIC8qKlxuICAgICAqIEB0aXRsZSDmmK/lkKbmmL7npLrmkJzntKLmoYZcbiAgICAgKiBAdmVGaWVsZFN0eWxlIGJsb2NrXG4gICAgICovXG4gICAgc2hvd1NlYXJjaDogUmVhY3QuUHJvcFR5cGVzLmJvb2wsXG4gICAgLyoqXG4gICAgICogQHRpdGxlIOaQnOe0ouahhuWNoOS9jeesplxuICAgICAqIEB2ZUZpZWxkU3R5bGUgYmxvY2tcbiAgICAgKi9cbiAgICBzZWFyY2hCYXJQbGFjZWhvbGRlcjogUmVhY3QuUHJvcFR5cGVzLnN0cmluZyxcbiAgICAvKipcbiAgICAgKiBAdGl0bGUg5Yqg6L295Lit5paH5qGIXG4gICAgICogQHZlRmllbGRTdHlsZSBibG9ja1xuICAgICAqL1xuICAgIGxvYWRpbmdUZXh0OiBSZWFjdC5Qcm9wVHlwZXMuc3RyaW5nLFxuICAgIC8qKlxuICAgICAqIEB0aXRsZSDlrZDnu4Tku7Yo5Y2z5bCG5bqf6ZmkKVxuICAgICAqIEB2ZUlnbm9yZVxuICAgICAqL1xuICAgIHN1YkNvbXA6IFJlYWN0LlByb3BUeXBlcy5lbGVtZW50LFxuICAgIC8qKlxuICAgICAqIEB0aXRsZSDml6DmlbDmja7ml7bnmoTmlofmoYhcbiAgICAgKiBAdmVGaWVsZFN0eWxlIGJsb2NrXG4gICAgICovXG4gICAgZW1wdHlUZXh0OiBSZWFjdC5Qcm9wVHlwZXMub25lT2ZUeXBlKFtSZWFjdC5Qcm9wVHlwZXMuc3RyaW5nLCBSZWFjdC5Qcm9wVHlwZXMuZWxlbWVudF0pLFxuICAgIC8qKlxuICAgICAqIEB0aXRsZSDmlbDmja7mupDvvIjmiYvliqjvvIlcbiAgICAgKiBAdmVGaWVsZFN0eWxlIGJsb2NrXG4gICAgICovXG4gICAganN4ZGF0YTogUmVhY3QuUHJvcFR5cGVzLm9iamVjdCxcbiAgICAvKipcbiAgICAgKiBAdGl0bGUg5pWw5o2u5rqQ77yIdXJs77yJXG4gICAgICogQHZlRmllbGRTdHlsZSBibG9ja1xuICAgICAqL1xuICAgIGZldGNoVXJsOiBSZWFjdC5Qcm9wVHlwZXMuc3RyaW5nLFxuICAgIC8qKlxuICAgICAqIEB0aXRsZSDor7fmsYLmkLrluKbnmoTlj4LmlbBcbiAgICAgKiBAdmVGaWVsZFN0eWxlIGJsb2NrXG4gICAgICovXG4gICAgZmV0Y2hQYXJhbXM6IFJlYWN0LlByb3BUeXBlcy5vYmplY3QsXG4gICAgLyoqXG4gICAgICogQHRpdGxlIOWIl+mAieaLqeWZqOeahOexu+Wei1xuICAgICAqIEB2ZUZpZWxkU3R5bGUgYmxvY2tcbiAgICAgKi9cbiAgICByb3dTZWxlY3RvcjogUmVhY3QuUHJvcFR5cGVzLnN0cmluZyxcbiAgICAvKipcbiAgICAgKiBAdGl0bGUg5pON5L2c5qCP6YWN572uXG4gICAgICogQHZlRmllbGRTdHlsZSBibG9ja1xuICAgICAqL1xuICAgIGFjdGlvbkJhcjogUmVhY3QuUHJvcFR5cGVzLm9uZU9mVHlwZShbUmVhY3QuUHJvcFR5cGVzLmFycmF5LCBSZWFjdC5Qcm9wVHlwZXMub2JqZWN0XSksXG4gICAgLyoqXG4gICAgICogQHRpdGxlIOWkhOeQhuaVsOaNrueahOWbnuiwg1xuICAgICAqL1xuICAgIHByb2Nlc3NEYXRhOiBSZWFjdC5Qcm9wVHlwZXMuZnVuYyxcbiAgICAvKipcbiAgICAgKiBAdGl0bGUg5Y+R6LW36K+35rGC5YmN55qE5Zue6LCDXG4gICAgICovXG4gICAgYmVmb3JlRmV0Y2g6IFJlYWN0LlByb3BUeXBlcy5mdW5jLFxuICAgIC8qKlxuICAgICAqIEB0aXRsZSDor7fmsYLlh7rplJnml7bnmoTlm57osINcbiAgICAgKi9cbiAgICBvbkZldGNoRXJyb3I6IFJlYWN0LlByb3BUeXBlcy5mdW5jLFxuICAgIC8qKlxuICAgICAqIEB0aXRsZSDmuLLmn5Pmr4/kuIDooYzliY3nlKjkuo7mt7vliqDnibnmrornsbvlkI3nmoTlm57osINcbiAgICAgKi9cbiAgICBhZGRSb3dDbGFzc05hbWU6IFJlYWN0LlByb3BUeXBlcy5mdW5jLFxuICAgIC8qKlxuICAgICAqIEB2ZUlnbm9yZVxuICAgICAqL1xuICAgIHBhc3NlZERhdGE6IFJlYWN0LlByb3BUeXBlcy5vYmplY3QsXG4gICAgLyoqXG4gICAgICogQHRpdGxlIGdldERhdGEg6I635Y+W55qE5piv5ZCm5piv5L+d5a2Y5LmL5ZCO55qE5pWw5o2uXG4gICAgICovXG4gICAgZ2V0U2F2ZWREYXRhOiBSZWFjdC5Qcm9wVHlwZXMuYm9vbCxcbiAgICAvKipcbiAgICAgKiBAdGl0bGUg6KGM5YaF57yW6L6R5pe26Kem5Y+R55qE5Zue6LCDXG4gICAgICovXG4gICAgb25DaGFuZ2U6IFJlYWN0LlByb3BUeXBlcy5mdW5jLFxuICAgIC8qKlxuICAgICAqIEB0aXRsZSDmmK/lkKbmmK/moJHmqKHlvI9cbiAgICAgKiBAdmVJZ25vcmVcbiAgICAgKi9cbiAgICByZW5kZXJNb2RlbDogUmVhY3QuUHJvcFR5cGVzLnN0cmluZyxcbiAgICAvKipcbiAgICAgKiBAdGl0bGUg5qCR55qE5bGC57qnXG4gICAgICogQHZlSWdub3JlXG4gICAgICovXG4gICAgbGV2ZWxzOiBSZWFjdC5Qcm9wVHlwZXMubnVtYmVyXG59O1xuXG5UYWJsZS5kaXNwbGF5TmFtZSA9IFwiVGFibGVcIjtcblRhYmxlLkNlbGxGaWVsZCA9IENlbGxGaWVsZDtcblRhYmxlLkNvbnN0YW50cyA9IENvbnN0O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFRhYmxlO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3V4Y29yZS10YWJsZS9idWlsZC9UYWJsZS5qc1xuICoqIG1vZHVsZSBpZCA9IDJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG4vKipcbiAqIENyZWF0ZWQgYnkgeHkgb24gMTUvNC8xMy5cbiAqL1xudmFyIENoZWNrQm94ID0gcmVxdWlyZSgnLi4vQ2VsbC9DaGVja0JveCcpO1xudmFyIGFzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcbnZhciBDb25zdCA9IHJlcXVpcmUoJ3V4Y29yZS1jb25zdCcpO1xudmFyIE1lbnUgPSByZXF1aXJlKCd1eGNvcmUtbWVudScpO1xudmFyIERyb3Bkb3duID0gcmVxdWlyZSgndXhjb3JlLWRyb3Bkb3duJyk7XG52YXIgVG9vbHRpcCA9IHJlcXVpcmUoJ3V4Y29yZS10b29sdGlwJyk7XG52YXIgY2xhc3NuYW1lcyA9IHJlcXVpcmUoJ2NsYXNzbmFtZXMnKTtcbnZhciBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG52YXIgUmVhY3RET00gPSByZXF1aXJlKCdyZWFjdC1kb20nKTtcblxudmFyIEhlYWRlciA9IGZ1bmN0aW9uIChfUmVhY3QkQ29tcG9uZW50KSB7XG4gICAgX2luaGVyaXRzKEhlYWRlciwgX1JlYWN0JENvbXBvbmVudCk7XG5cbiAgICBmdW5jdGlvbiBIZWFkZXIocHJvcHMpIHtcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEhlYWRlcik7XG5cbiAgICAgICAgdmFyIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX1JlYWN0JENvbXBvbmVudC5jYWxsKHRoaXMsIHByb3BzKSk7XG5cbiAgICAgICAgX3RoaXMuc3RhdGUgPSB7XG4gICAgICAgICAgICBwaWNrZXJEaXNwbGF5OiBmYWxzZVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuXG4gICAgSGVhZGVyLnByb3RvdHlwZS5oYW5kbGVDaGVja0JveENoYW5nZSA9IGZ1bmN0aW9uIGhhbmRsZUNoZWNrQm94Q2hhbmdlKCkge1xuICAgICAgICB2YXIgdiA9IHRoaXMucmVmcy5jaGVja2JveC5nZXRWYWx1ZSgpO1xuICAgICAgICB0aGlzLnByb3BzLnNlbGVjdEFsbC5hcHBseShudWxsLCBbdl0pO1xuICAgIH07XG5cbiAgICBIZWFkZXIucHJvdG90eXBlLmhhbmRsZVBpY2tlclNlbGVjdCA9IGZ1bmN0aW9uIGhhbmRsZVBpY2tlclNlbGVjdChpbmZvKSB7XG4gICAgICAgIHRoaXMucHJvcHMuaGFuZGxlQ29sdW1uUGlja2VyQ2hhbmdlKGluZm8uc2VsZWN0ZWRLZXlzKTtcbiAgICB9O1xuXG4gICAgSGVhZGVyLnByb3RvdHlwZS5oYW5kbGVQaWNrZXJEZXNlbGVjdCA9IGZ1bmN0aW9uIGhhbmRsZVBpY2tlckRlc2VsZWN0KGluZm8pIHtcbiAgICAgICAgdGhpcy5wcm9wcy5oYW5kbGVDb2x1bW5QaWNrZXJDaGFuZ2UoaW5mby5zZWxlY3RlZEtleXMpO1xuICAgIH07XG5cbiAgICBIZWFkZXIucHJvdG90eXBlLmhhbmRsZVBpY2tlclZpc2libGVDaGFuZ2UgPSBmdW5jdGlvbiBoYW5kbGVQaWNrZXJWaXNpYmxlQ2hhbmdlKHZpc2libGUpIHtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICBwaWNrZXJEaXNwbGF5OiB2aXNpYmxlXG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICBIZWFkZXIucHJvdG90eXBlLmhhbmRsZUNvbHVtbk9yZGVyID0gZnVuY3Rpb24gaGFuZGxlQ29sdW1uT3JkZXIoY29sdW1uKSB7XG4gICAgICAgIHZhciBtZSA9IHRoaXM7XG4gICAgICAgIHZhciBfbWUkcHJvcHMgPSBtZS5wcm9wcztcbiAgICAgICAgdmFyIG9yZGVyQ29sdW1uQ0IgPSBfbWUkcHJvcHMub3JkZXJDb2x1bW5DQjtcbiAgICAgICAgdmFyIGFjdGl2ZUNvbHVtbiA9IF9tZSRwcm9wcy5hY3RpdmVDb2x1bW47XG4gICAgICAgIHZhciBvcmRlclR5cGUgPSBfbWUkcHJvcHMub3JkZXJUeXBlO1xuXG4gICAgICAgIHZhciB0eXBlID0gJ2Rlc2MnO1xuICAgICAgICB2YXIgdHlwZU1hcCA9IHtcbiAgICAgICAgICAgIGRlc2M6ICdhc2MnLFxuICAgICAgICAgICAgYXNjOiAnbm9uZScsXG4gICAgICAgICAgICBub25lOiAnZGVzYydcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGFjdGl2ZUNvbHVtbiAmJiBjb2x1bW4uZGF0YUtleSA9PSBhY3RpdmVDb2x1bW4uZGF0YUtleSAmJiBvcmRlclR5cGUpIHtcbiAgICAgICAgICAgIHR5cGUgPSB0eXBlTWFwW29yZGVyVHlwZV07XG4gICAgICAgIH1cbiAgICAgICAgb3JkZXJDb2x1bW5DQiAmJiBvcmRlckNvbHVtbkNCKHR5cGUsIGNvbHVtbik7XG4gICAgfTtcblxuICAgIEhlYWRlci5wcm90b3R5cGUuZ2V0U2VsZWN0ZWRLZXlzID0gZnVuY3Rpb24gZ2V0U2VsZWN0ZWRLZXlzKCkge1xuICAgICAgICB2YXIgbWUgPSB0aGlzO1xuICAgICAgICB2YXIgY29sdW1ucyA9IG1lLnByb3BzLmNvbHVtbnM7XG5cbiAgICAgICAgdmFyIF9jb2x1bW5zID0gW107XG4gICAgICAgIHZhciBzZWxlY3RlZEtleXMgPSBbXTtcbiAgICAgICAgY29sdW1ucy5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtLCBpbmRleCkge1xuICAgICAgICAgICAgaWYgKCdncm91cCcgaW4gaXRlbSkge1xuICAgICAgICAgICAgICAgIF9jb2x1bW5zID0gX2NvbHVtbnMuY29uY2F0KGl0ZW0uY29sdW1ucyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIF9jb2x1bW5zLnB1c2goaXRlbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBfY29sdW1ucy5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtLCBpbmRleCkge1xuICAgICAgICAgICAgaWYgKCFpdGVtLmhpZGRlbikge1xuICAgICAgICAgICAgICAgIHNlbGVjdGVkS2V5cy5wdXNoKGl0ZW0uZGF0YUtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gc2VsZWN0ZWRLZXlzO1xuICAgIH07XG5cbiAgICBIZWFkZXIucHJvdG90eXBlLnJlbmRlckNvbHVtblNlbGVjdCA9IGZ1bmN0aW9uIHJlbmRlckNvbHVtblNlbGVjdCgpIHtcbiAgICAgICAgdmFyIG1lID0gdGhpcztcbiAgICAgICAgdmFyIGNvbHVtbnMgPSBtZS5wcm9wcy5jb2x1bW5zO1xuXG4gICAgICAgIHZhciBub3RSZW5kZXJDb2x1bW5zID0gWydqc3hjaGVja2VkJywgJ2pzeHRyZWVJY29uJywgJ2pzeHdoaXRlJ107XG4gICAgICAgIHZhciBvcHRpb25zID0gW107XG4gICAgICAgIGNvbHVtbnMuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSwgaW5kZXgpIHtcbiAgICAgICAgICAgIGlmIChub3RSZW5kZXJDb2x1bW5zLmluZGV4T2YoaXRlbS5kYXRhS2V5KSA9PSAtMSkge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMucHVzaChSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICAgICAgICAgICBNZW51Lkl0ZW0sXG4gICAgICAgICAgICAgICAgICAgIHsga2V5OiBpdGVtLmRhdGFLZXkgfSxcbiAgICAgICAgICAgICAgICAgICAgaXRlbS50aXRsZVxuICAgICAgICAgICAgICAgICkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgICBNZW51LFxuICAgICAgICAgICAgeyBtdWx0aXBsZTogdHJ1ZSwgc2VsZWN0ZWRLZXlzOiBtZS5nZXRTZWxlY3RlZEtleXMoKSwgb25TZWxlY3Q6IG1lLmhhbmRsZVBpY2tlclNlbGVjdC5iaW5kKG1lKSwgb25EZXNlbGVjdDogbWUuaGFuZGxlUGlja2VyRGVzZWxlY3QuYmluZChtZSkgfSxcbiAgICAgICAgICAgIG9wdGlvbnNcbiAgICAgICAgKTtcbiAgICB9O1xuXG4gICAgSGVhZGVyLnByb3RvdHlwZS5yZW5kZXJQaWNrZXIgPSBmdW5jdGlvbiByZW5kZXJQaWNrZXIoKSB7XG4gICAgICAgIHZhciBtZSA9IHRoaXM7XG4gICAgICAgIHZhciBwaWNrZXJEaXNwbGF5ID0gbWUuc3RhdGUucGlja2VyRGlzcGxheTtcblxuXG4gICAgICAgIHZhciBkcm9wZG93bkFsaWduID0ge1xuICAgICAgICAgICAgYm90dG9tUmlnaHQ6IHtcbiAgICAgICAgICAgICAgICBwb2ludHM6IFsnYnInLCAndHInXSxcbiAgICAgICAgICAgICAgICBvdmVyZmxvdzoge1xuICAgICAgICAgICAgICAgICAgICBhZGp1c3RYOiAxLFxuICAgICAgICAgICAgICAgICAgICBhZGp1c3RZOiAxXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBvZmZzZXQ6IFswLCAtNF0sXG4gICAgICAgICAgICAgICAgdGFyZ2V0T2Zmc2V0OiBbMCwgMF1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAgICdkaXYnLFxuICAgICAgICAgICAgeyBjbGFzc05hbWU6IGNsYXNzbmFtZXMoe1xuICAgICAgICAgICAgICAgICAgICBcImt1bWEtY29sdW1uLXBpY2tlci1jb250YWluZXJcIjogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgXCJoYXNHcm91cFwiOiBtZS5oYXNHcm91cFxuICAgICAgICAgICAgICAgIH0pIH0sXG4gICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICAgICAgIERyb3Bkb3duLFxuICAgICAgICAgICAgICAgIHsgdHJpZ2dlcjogWydjbGljayddLCBvdmVybGF5OiBtZS5yZW5kZXJDb2x1bW5TZWxlY3QoKSwgdmlzaWJsZTogcGlja2VyRGlzcGxheSwgb3ZlcmxheUNsYXNzTmFtZTogJ2t1bWEtdXh0YWJsZS1jb2x1bW4tcGlja2VyLWRyb3Bkb3duJyxcbiAgICAgICAgICAgICAgICAgICAgYWxpZ246IGRyb3Bkb3duQWxpZ24sIG9uVmlzaWJsZUNoYW5nZTogbWUuaGFuZGxlUGlja2VyVmlzaWJsZUNoYW5nZS5iaW5kKG1lKSB9LFxuICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoJ2knLCB7IGNsYXNzTmFtZTogJ2t1bWEtaWNvbiBrdW1hLWljb24tdGFyZ2V0LWxpc3Qga3VtYS1jb2x1bW4tcGlja2VyJyB9KVxuICAgICAgICAgICAgKVxuICAgICAgICApO1xuICAgIH07XG5cbiAgICBIZWFkZXIucHJvdG90eXBlLnJlbmRlck9yZGVySWNvbiA9IGZ1bmN0aW9uIHJlbmRlck9yZGVySWNvbihjb2x1bW4pIHtcbiAgICAgICAgdmFyIG1lID0gdGhpcztcbiAgICAgICAgdmFyIF9tZSRwcm9wczIgPSBtZS5wcm9wcztcbiAgICAgICAgdmFyIG9yZGVyVHlwZSA9IF9tZSRwcm9wczIub3JkZXJUeXBlO1xuICAgICAgICB2YXIgYWN0aXZlQ29sdW1uID0gX21lJHByb3BzMi5hY3RpdmVDb2x1bW47XG5cbiAgICAgICAgaWYgKGNvbHVtbi5vcmRlcmVkKSB7XG4gICAgICAgICAgICB2YXIgX2NsYXNzbmFtZXMsIF9jbGFzc25hbWVzMjtcblxuICAgICAgICAgICAgdmFyIGRlc2MgPSBcImljb25mb250ZG93blwiLFxuICAgICAgICAgICAgICAgIGFzYyA9IFwiaWNvbmZvbnR1cFwiO1xuICAgICAgICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgICAgICAgJ3NwYW4nLFxuICAgICAgICAgICAgICAgIHsgY2xhc3NOYW1lOiAna3VtYS11eHRhYmxlLWgtc29ydCcsIG9uQ2xpY2s6IG1lLmhhbmRsZUNvbHVtbk9yZGVyLmJpbmQobWUsIGNvbHVtbikgfSxcbiAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KCdpJywgeyBjbGFzc05hbWU6IGNsYXNzbmFtZXMoKF9jbGFzc25hbWVzID0ge30sIF9jbGFzc25hbWVzWydrdW1hLWljb24ga3VtYS1pY29uLScgKyBhc2NdID0gdHJ1ZSwgX2NsYXNzbmFtZXNbJ2FjdGl2ZSddID0gYWN0aXZlQ29sdW1uICYmIGFjdGl2ZUNvbHVtbi5kYXRhS2V5ID09PSBjb2x1bW4uZGF0YUtleSAmJiBvcmRlclR5cGUgPT0gJ2FzYycsIF9jbGFzc25hbWVzKSkgfSksXG4gICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudCgnaScsIHsgY2xhc3NOYW1lOiBjbGFzc25hbWVzKChfY2xhc3NuYW1lczIgPSB7fSwgX2NsYXNzbmFtZXMyWydrdW1hLWljb24ga3VtYS1pY29uLScgKyBkZXNjXSA9IHRydWUsIF9jbGFzc25hbWVzMlsnYWN0aXZlJ10gPSBhY3RpdmVDb2x1bW4gJiYgYWN0aXZlQ29sdW1uLmRhdGFLZXkgPT09IGNvbHVtbi5kYXRhS2V5ICYmIG9yZGVyVHlwZSA9PSAnZGVzYycsIF9jbGFzc25hbWVzMikpIH0pXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIEhlYWRlci5wcm90b3R5cGUucmVuZGVyTWVzc2FnZUljb24gPSBmdW5jdGlvbiByZW5kZXJNZXNzYWdlSWNvbihjb2x1bW4pIHtcbiAgICAgICAgaWYgKCFjb2x1bW4ubWVzc2FnZSkgcmV0dXJuO1xuICAgICAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAgIFRvb2x0aXAsXG4gICAgICAgICAgICB7IG92ZXJsYXk6IFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgICAgICAgICAgICdkaXYnLFxuICAgICAgICAgICAgICAgICAgICB7IGNsYXNzTmFtZTogJ2t1bWEtdXh0YWJsZS1jb2x1bW4tbWVzc2FnZScgfSxcbiAgICAgICAgICAgICAgICAgICAgY29sdW1uLm1lc3NhZ2VcbiAgICAgICAgICAgICAgICApIH0sXG4gICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KCdpJywgeyBjbGFzc05hbWU6ICdrdW1hLWljb24ga3VtYS1pY29uLWluZm9ybWF0aW9uJyB9KVxuICAgICAgICApO1xuICAgIH07XG5cbiAgICBIZWFkZXIucHJvdG90eXBlLnJlbmRlckNvbHVtbiA9IGZ1bmN0aW9uIHJlbmRlckNvbHVtbihpdGVtLCBpbmRleCwgaGFzR3JvdXAsIGxhc3QpIHtcbiAgICAgICAgaWYgKGl0ZW0uaGlkZGVuKSByZXR1cm47XG4gICAgICAgIHZhciBtZSA9IHRoaXM7XG4gICAgICAgIHZhciBkYXRhID0gbWUucHJvcHMuZGF0YTtcblxuICAgICAgICB2YXIgbm9Cb3JkZXJDb2x1bW4gPSBbJ2pzeGNoZWNrZWQnLCAnanN4dHJlZUljb24nLCAnanN4d2hpdGUnXTtcbiAgICAgICAgdmFyIF9zdHlsZSA9IHtcbiAgICAgICAgICAgIHdpZHRoOiBpdGVtLndpZHRoID8gaXRlbS53aWR0aCA6IDEwMCxcbiAgICAgICAgICAgIHRleHRBbGlnbjogaXRlbS5hbGlnbiA/IGl0ZW0uYWxpZ24gOiBcImxlZnRcIlxuICAgICAgICB9O1xuICAgICAgICB2YXIgX3YgPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgaWYgKGhhc0dyb3VwKSB7XG4gICAgICAgICAgICBhc3NpZ24oX3N0eWxlLCB7XG4gICAgICAgICAgICAgICAgaGVpZ2h0OiAxMDAsXG4gICAgICAgICAgICAgICAgbGluZUhlaWdodDogMTAwICsgJ3B4J1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXRlbS50eXBlID09ICdjaGVja2JveCcgfHwgaXRlbS50eXBlID09ICdjaGVja2JveFNlbGVjdG9yJykge1xuICAgICAgICAgICAgYXNzaWduKF9zdHlsZSwge1xuICAgICAgICAgICAgICAgIHBhZGRpbmdSaWdodDogNCxcbiAgICAgICAgICAgICAgICBwYWRkaW5nTGVmdDogMTIsXG4gICAgICAgICAgICAgICAgd2lkdGg6IGl0ZW0ud2lkdGggPyBpdGVtLndpZHRoIDogOTIsXG4gICAgICAgICAgICAgICAgYm9yZGVyUmlnaHQ6ICdub25lJ1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHZhciBjaGVja0JveFByb3BzID0ge1xuICAgICAgICAgICAgICAgIHJlZjogJ2NoZWNrYm94JyxcbiAgICAgICAgICAgICAgICBqc3hjaGVja2VkOiBtZS5wcm9wcy5pc1NlbGVjdEFsbCxcbiAgICAgICAgICAgICAgICBkaXNhYmxlOiBtZS5wcm9wcy5tb2RlICE9PSBDb25zdC5NT0RFLlZJRVcgPyBpdGVtLmRpc2FibGUgOiB0cnVlLFxuICAgICAgICAgICAgICAgIG9uY2hhbmdlOiBtZS5oYW5kbGVDaGVja0JveENoYW5nZS5iaW5kKG1lKVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgX3YgPSBSZWFjdC5jcmVhdGVFbGVtZW50KENoZWNrQm94LCBjaGVja0JveFByb3BzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIF92ID0gUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAgICAgICAnc3BhbicsXG4gICAgICAgICAgICAgICAgeyB0aXRsZTogaXRlbS50aXRsZSB9LFxuICAgICAgICAgICAgICAgIGl0ZW0udGl0bGVcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobm9Cb3JkZXJDb2x1bW4uaW5kZXhPZihpdGVtLmRhdGFLZXkpICE9PSAtMSB8fCBsYXN0KSB7XG4gICAgICAgICAgICBhc3NpZ24oX3N0eWxlLCB7XG4gICAgICAgICAgICAgICAgYm9yZGVyUmlnaHQ6ICdub25lJ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAgICdkaXYnLFxuICAgICAgICAgICAgeyBrZXk6IGluZGV4LCBjbGFzc05hbWU6IGNsYXNzbmFtZXMoe1xuICAgICAgICAgICAgICAgICAgICBcImt1bWEtdXh0YWJsZS1jZWxsXCI6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIFwic2hvdy1ib3JkZXJcIjogbWUucHJvcHMuc2hvd0hlYWRlckJvcmRlclxuICAgICAgICAgICAgICAgIH0pLCBzdHlsZTogX3N0eWxlIH0sXG4gICAgICAgICAgICBfdixcbiAgICAgICAgICAgIG1lLnJlbmRlck1lc3NhZ2VJY29uKGl0ZW0pLFxuICAgICAgICAgICAgbWUucmVuZGVyT3JkZXJJY29uKGl0ZW0pXG4gICAgICAgICk7XG4gICAgfTtcblxuICAgIEhlYWRlci5wcm90b3R5cGUucmVuZGVyQ29sdW1ucyA9IGZ1bmN0aW9uIHJlbmRlckNvbHVtbnMoX2NvbHVtbnMpIHtcbiAgICAgICAgdmFyIG1lID0gdGhpcztcbiAgICAgICAgdmFyIGNvbHVtbnMgPSBfY29sdW1ucy5tYXAoZnVuY3Rpb24gKGl0ZW0sIGluZGV4KSB7XG4gICAgICAgICAgICB2YXIgbGFzdCA9IGluZGV4ID09IF9jb2x1bW5zLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICBpZiAoJ2dyb3VwJyBpbiBpdGVtKSB7XG4gICAgICAgICAgICAgICAgLy8gRmlyc3QgZGV0ZXJtaW5lIHdoZXRoZXIgdGhlIGdyb3VwIHNob3VsZCBiZSByZW5kZXJlZCwgaWYgYWxsIGNvbHVtbnNcbiAgICAgICAgICAgICAgICAvLyBpcyBoaWRkZW4sIHRoZSBjb2x1bW4gZ3JvdXAgc2hvdWxkIG5vdCBiZSByZW5kZXJlZC5cbiAgICAgICAgICAgICAgICB2YXIgc2hvdWxkUmVuZGVyR3JvdXAgPSBpdGVtLmNvbHVtbnMuc29tZShmdW5jdGlvbiAoY29sdW1uLCBpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAhY29sdW1uLmhpZGRlbjtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAoc2hvdWxkUmVuZGVyR3JvdXApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgICAgICAgICAgICAgICAnZGl2JyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgY2xhc3NOYW1lOiAna3VtYS11eHRhYmxlLWhlYWRlci1jb2x1bW4tZ3JvdXAnLCBrZXk6IGluZGV4IH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdkaXYnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgY2xhc3NOYW1lOiAna3VtYS11eHRhYmxlLWhlYWRlci1ncm91cC1uYW1lJyB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0uZ3JvdXBcbiAgICAgICAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtLmNvbHVtbnMubWFwKGZ1bmN0aW9uIChjb2x1bW4sIGkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWUucmVuZGVyQ29sdW1uKGNvbHVtbiwgaSwgZmFsc2UsIGxhc3QpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBtZS5yZW5kZXJDb2x1bW4oaXRlbSwgaW5kZXgsIG1lLmhhc0dyb3VwLCBsYXN0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBjb2x1bW5zO1xuICAgIH07XG5cbiAgICBIZWFkZXIucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICAgICAgdmFyIHByb3BzID0gdGhpcy5wcm9wcyxcbiAgICAgICAgICAgIG1lID0gdGhpcyxcbiAgICAgICAgICAgIF9waWNrZXIgPSB1bmRlZmluZWQsXG4gICAgICAgICAgICBfd2lkdGggPSAwLFxuICAgICAgICAgICAgaGVhZGVyV3JhcENsYXNzTmFtZSA9IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIF9oZWFkZXJTdHlsZSA9IHt9LFxuICAgICAgICAgICAgX2NvbHVtbnMgPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgaWYgKHByb3BzLnNob3dDb2x1bW5QaWNrZXIgJiYgKHByb3BzLmZpeGVkQ29sdW1uID09ICdubycgfHwgcHJvcHMuZml4ZWRDb2x1bW4gPT0gJ3Njcm9sbCcpKSB7XG4gICAgICAgICAgICBfcGlja2VyID0gdGhpcy5yZW5kZXJQaWNrZXIoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwcm9wcy5maXhlZENvbHVtbiA9PSAnZml4ZWQnKSB7XG4gICAgICAgICAgICBfY29sdW1ucyA9IHByb3BzLmNvbHVtbnMuZmlsdGVyKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgICAgICAgaWYgKGl0ZW0uZml4ZWQgJiYgIWl0ZW0uaGlkZGVuKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghaXRlbS53aWR0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXRlbS53aWR0aCA9IDEwMDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBfd2lkdGggPSBpdGVtLndpZHRoICogMSArIF93aWR0aDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBhc3NpZ24oX2hlYWRlclN0eWxlLCB7XG4gICAgICAgICAgICAgICAgd2lkdGg6IF93aWR0aCxcbiAgICAgICAgICAgICAgICBtaW5XaWR0aDogX3dpZHRoXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGhlYWRlcldyYXBDbGFzc05hbWUgPSBcImt1bWEtdXh0YWJsZS1oZWFkZXItZml4ZWRcIjtcbiAgICAgICAgfSBlbHNlIGlmIChwcm9wcy5maXhlZENvbHVtbiA9PSAnc2Nyb2xsJykge1xuICAgICAgICAgICAgX2NvbHVtbnMgPSBwcm9wcy5jb2x1bW5zLmZpbHRlcihmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgICAgICAgIGlmICghaXRlbS5maXhlZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCFpdGVtLmhpZGRlbikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWl0ZW0ud2lkdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0ud2lkdGggPSAxMDA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgX3dpZHRoID0gaXRlbS53aWR0aCAqIDEgKyBfd2lkdGg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBhc3NpZ24oX2hlYWRlclN0eWxlLCB7XG4gICAgICAgICAgICAgICAgd2lkdGg6IHByb3BzLndpZHRoIC0gX3dpZHRoIC0gMyxcbiAgICAgICAgICAgICAgICBtaW5XaWR0aDogcHJvcHMud2lkdGggLSBfd2lkdGggLSAzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGhlYWRlcldyYXBDbGFzc05hbWUgPSBcImt1bWEtdXh0YWJsZS1oZWFkZXItc2Nyb2xsXCI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBfY29sdW1ucyA9IHByb3BzLmNvbHVtbnM7XG4gICAgICAgICAgICBoZWFkZXJXcmFwQ2xhc3NOYW1lID0gXCJrdW1hLXV4dGFibGUtaGVhZGVyLW5vXCI7XG4gICAgICAgIH1cbiAgICAgICAgbWUuaGFzR3JvdXAgPSBmYWxzZTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBfY29sdW1ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKCdncm91cCcgaW4gX2NvbHVtbnNbaV0pIHtcbiAgICAgICAgICAgICAgICBtZS5oYXNHcm91cCA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYXNzaWduKF9oZWFkZXJTdHlsZSwge1xuICAgICAgICAgICAgaGVpZ2h0OiBwcm9wcy5oZWFkZXJIZWlnaHQgPyBwcm9wcy5oZWFkZXJIZWlnaHQgOiBtZS5oYXNHcm91cCA/IDgwIDogNTAsXG4gICAgICAgICAgICBsaW5lSGVpZ2h0OiAocHJvcHMuaGVhZGVySGVpZ2h0ID8gcHJvcHMuaGVhZGVySGVpZ2h0IDogNTApICsgXCJweFwiXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAgICdkaXYnLFxuICAgICAgICAgICAgeyBjbGFzc05hbWU6IGhlYWRlcldyYXBDbGFzc05hbWUsIHN0eWxlOiBfaGVhZGVyU3R5bGUgfSxcbiAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgICAgICAgJ2RpdicsXG4gICAgICAgICAgICAgICAgeyBjbGFzc05hbWU6IHByb3BzLmpzeHByZWZpeENscyB9LFxuICAgICAgICAgICAgICAgIG1lLnJlbmRlckNvbHVtbnMoX2NvbHVtbnMpLFxuICAgICAgICAgICAgICAgIF9waWNrZXJcbiAgICAgICAgICAgIClcbiAgICAgICAgKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIEhlYWRlcjtcbn0oUmVhY3QuQ29tcG9uZW50KTtcblxuO1xuXG5IZWFkZXIucHJvcFR5cGVzID0ge307XG5cbkhlYWRlci5kZWZhdWx0UHJvcHMgPSB7XG4gICAganN4cHJlZml4Q2xzOiBcImt1bWEtdXh0YWJsZS1oZWFkZXJcIlxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBIZWFkZXI7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vdXhjb3JlLXRhYmxlL2J1aWxkL0hlYWRlci9pbmRleC5qc1xuICoqIG1vZHVsZSBpZCA9IDNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG4vKipcbiAqIEEgY2hlY2tib3ggZmllbGRcbiAqL1xuXG52YXIgQ29uc3QgPSByZXF1aXJlKCd1eGNvcmUtY29uc3QnKTtcbnZhciBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG52YXIgUmVhY3RET00gPSByZXF1aXJlKCdyZWFjdC1kb20nKTtcblxudmFyIENoZWNrQm94ID0gZnVuY3Rpb24gKF9SZWFjdCRDb21wb25lbnQpIHtcbiAgICBfaW5oZXJpdHMoQ2hlY2tCb3gsIF9SZWFjdCRDb21wb25lbnQpO1xuXG4gICAgZnVuY3Rpb24gQ2hlY2tCb3gocHJvcHMpIHtcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIENoZWNrQm94KTtcblxuICAgICAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX1JlYWN0JENvbXBvbmVudC5jYWxsKHRoaXMsIHByb3BzKSk7XG4gICAgfVxuXG4gICAgQ2hlY2tCb3gucHJvdG90eXBlLmhhbmRsZUNoYW5nZSA9IGZ1bmN0aW9uIGhhbmRsZUNoYW5nZShlKSB7XG4gICAgICAgIHZhciB2ID0gdGhpcy5nZXRWYWx1ZSgpO1xuICAgICAgICB2ID0gdiA/ICdjaGVja2VkJyA6ICcnO1xuICAgICAgICB0aGlzLnByb3BzLm9uY2hhbmdlLmFwcGx5KG51bGwsIFtlXSk7XG4gICAgfTtcblxuICAgIENoZWNrQm94LnByb3RvdHlwZS5nZXRWYWx1ZSA9IGZ1bmN0aW9uIGdldFZhbHVlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZWZzLmNoZWNrYm94LmNoZWNrZWQ7XG4gICAgfTtcblxuICAgIENoZWNrQm94LnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIoKSB7XG5cbiAgICAgICAgdmFyIHByb3BzID0gdGhpcy5wcm9wcztcblxuICAgICAgICBpZiAocHJvcHMubW9kZSAhPT0gQ29uc3QuTU9ERS5WSUVXKSB7XG4gICAgICAgICAgICB2YXIgcmVuZGVyUHJvcHMgPSB7XG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lOiBcImt1bWEtY2hlY2tib3hcIixcbiAgICAgICAgICAgICAgICBjaGVja2VkOiB0aGlzLnByb3BzLmpzeGNoZWNrZWQsXG4gICAgICAgICAgICAgICAgb25DaGFuZ2U6IHRoaXMuaGFuZGxlQ2hhbmdlLmJpbmQodGhpcylcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAoISFwcm9wcy5kaXNhYmxlKSB7XG4gICAgICAgICAgICAgICAgcmVuZGVyUHJvcHMuZGlzYWJsZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgICAgICAgJ2xhYmVsJyxcbiAgICAgICAgICAgICAgICB7IGNsYXNzTmFtZTogJ2t1bWEtdXh0YWJsZS1yb3ctc2VsZWN0b3InIH0sXG4gICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudCgnaW5wdXQnLCBfZXh0ZW5kcyh7IHR5cGU6ICdjaGVja2JveCcsIHJlZjogJ2NoZWNrYm94JyB9LCByZW5kZXJQcm9wcykpLFxuICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoJ3MnLCBudWxsKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgdmFyIHJlbmRlclByb3BzID0ge1xuICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogXCJrdW1hLWNoZWNrYm94XCIsXG4gICAgICAgICAgICAgICAgY2hlY2tlZDogdGhpcy5wcm9wcy5qc3hjaGVja2VkLFxuICAgICAgICAgICAgICAgIGRpc2FibGVkOiB0cnVlXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgICAgICAgJ2xhYmVsJyxcbiAgICAgICAgICAgICAgICB7IGNsYXNzTmFtZTogJ2t1bWEtdXh0YWJsZS1yb3ctc2VsZWN0b3InIH0sXG4gICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudCgnaW5wdXQnLCBfZXh0ZW5kcyh7IHR5cGU6ICdjaGVja2JveCcsIHJlZjogJ2NoZWNrYm94JyB9LCByZW5kZXJQcm9wcykpLFxuICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoJ3MnLCBudWxsKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICByZXR1cm4gQ2hlY2tCb3g7XG59KFJlYWN0LkNvbXBvbmVudCk7XG5cbjtcblxuQ2hlY2tCb3gucHJvcFR5cGVzID0ge307XG5cbkNoZWNrQm94LmRlZmF1bHRQcm9wcyA9IHt9O1xuXG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IENoZWNrQm94O1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vdXhjb3JlLXRhYmxlL2J1aWxkL0NlbGwvQ2hlY2tCb3guanNcbiAqKiBtb2R1bGUgaWQgPSA0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQ29uc3QgQ29tcG9uZW50IGZvciB1eGNvcmVcbiAqIEBhdXRob3IgemhvdXF1YW4ueWV6cVxuICpcbiAqIENvcHlyaWdodCAyMDE0LTIwMTUsIFV4Y29yZSBUZWFtLCBBbGludy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKi9cblxudmFyIENvbnN0ID0ge1xuICBNT0RFOiB7XG4gICAgVklFVzogJ3ZpZXcnLFxuICAgIEVESVQ6ICdlZGl0J1xuICB9LFxuICBFTlY6IHtcbiAgICBERUJVRzogJ2RlYnVnJyxcbiAgICBMSVZFOiAnbGl2ZSdcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBDb25zdDtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi91eGNvcmUtdGFibGUvfi91eGNvcmUtY29uc3QvYnVpbGQvQ29uc3QuanNcbiAqKiBtb2R1bGUgaWQgPSA2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IHdpbmRvdy5SZWFjdDtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIGV4dGVybmFsIFwid2luZG93LlJlYWN0XCJcbiAqKiBtb2R1bGUgaWQgPSA3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IHdpbmRvdy5SZWFjdERPTSB8fCB3aW5kb3cuUmVhY3Q7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiBleHRlcm5hbCBcIndpbmRvdy5SZWFjdERPTSB8fCB3aW5kb3cuUmVhY3RcIlxuICoqIG1vZHVsZSBpZCA9IDhcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0Jztcbi8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIHByb3BJc0VudW1lcmFibGUgPSBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xuXG5mdW5jdGlvbiB0b09iamVjdCh2YWwpIHtcblx0aWYgKHZhbCA9PT0gbnVsbCB8fCB2YWwgPT09IHVuZGVmaW5lZCkge1xuXHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ09iamVjdC5hc3NpZ24gY2Fubm90IGJlIGNhbGxlZCB3aXRoIG51bGwgb3IgdW5kZWZpbmVkJyk7XG5cdH1cblxuXHRyZXR1cm4gT2JqZWN0KHZhbCk7XG59XG5cbmZ1bmN0aW9uIHNob3VsZFVzZU5hdGl2ZSgpIHtcblx0dHJ5IHtcblx0XHRpZiAoIU9iamVjdC5hc3NpZ24pIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBEZXRlY3QgYnVnZ3kgcHJvcGVydHkgZW51bWVyYXRpb24gb3JkZXIgaW4gb2xkZXIgVjggdmVyc2lvbnMuXG5cblx0XHQvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD00MTE4XG5cdFx0dmFyIHRlc3QxID0gbmV3IFN0cmluZygnYWJjJyk7ICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG5cdFx0dGVzdDFbNV0gPSAnZGUnO1xuXHRcdGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0ZXN0MSlbMF0gPT09ICc1Jykge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTMwNTZcblx0XHR2YXIgdGVzdDIgPSB7fTtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IDEwOyBpKyspIHtcblx0XHRcdHRlc3QyWydfJyArIFN0cmluZy5mcm9tQ2hhckNvZGUoaSldID0gaTtcblx0XHR9XG5cdFx0dmFyIG9yZGVyMiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRlc3QyKS5tYXAoZnVuY3Rpb24gKG4pIHtcblx0XHRcdHJldHVybiB0ZXN0MltuXTtcblx0XHR9KTtcblx0XHRpZiAob3JkZXIyLmpvaW4oJycpICE9PSAnMDEyMzQ1Njc4OScpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0zMDU2XG5cdFx0dmFyIHRlc3QzID0ge307XG5cdFx0J2FiY2RlZmdoaWprbG1ub3BxcnN0Jy5zcGxpdCgnJykuZm9yRWFjaChmdW5jdGlvbiAobGV0dGVyKSB7XG5cdFx0XHR0ZXN0M1tsZXR0ZXJdID0gbGV0dGVyO1xuXHRcdH0pO1xuXHRcdGlmIChPYmplY3Qua2V5cyhPYmplY3QuYXNzaWduKHt9LCB0ZXN0MykpLmpvaW4oJycpICE9PVxuXHRcdFx0XHQnYWJjZGVmZ2hpamtsbW5vcHFyc3QnKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRydWU7XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHQvLyBXZSBkb24ndCBleHBlY3QgYW55IG9mIHRoZSBhYm92ZSB0byB0aHJvdywgYnV0IGJldHRlciB0byBiZSBzYWZlLlxuXHRcdHJldHVybiBmYWxzZTtcblx0fVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNob3VsZFVzZU5hdGl2ZSgpID8gT2JqZWN0LmFzc2lnbiA6IGZ1bmN0aW9uICh0YXJnZXQsIHNvdXJjZSkge1xuXHR2YXIgZnJvbTtcblx0dmFyIHRvID0gdG9PYmplY3QodGFyZ2V0KTtcblx0dmFyIHN5bWJvbHM7XG5cblx0Zm9yICh2YXIgcyA9IDE7IHMgPCBhcmd1bWVudHMubGVuZ3RoOyBzKyspIHtcblx0XHRmcm9tID0gT2JqZWN0KGFyZ3VtZW50c1tzXSk7XG5cblx0XHRmb3IgKHZhciBrZXkgaW4gZnJvbSkge1xuXHRcdFx0aWYgKGhhc093blByb3BlcnR5LmNhbGwoZnJvbSwga2V5KSkge1xuXHRcdFx0XHR0b1trZXldID0gZnJvbVtrZXldO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG5cdFx0XHRzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhmcm9tKTtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgc3ltYm9scy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRpZiAocHJvcElzRW51bWVyYWJsZS5jYWxsKGZyb20sIHN5bWJvbHNbaV0pKSB7XG5cdFx0XHRcdFx0dG9bc3ltYm9sc1tpXV0gPSBmcm9tW3N5bWJvbHNbaV1dO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHRvO1xufTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3V4Y29yZS10YWJsZS9+L29iamVjdC1hc3NpZ24vaW5kZXguanNcbiAqKiBtb2R1bGUgaWQgPSA5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogTWVudSBDb21wb25lbnQgZm9yIHV4Y29yZVxuICogQGF1dGhvciB2aW5jZW50LmJpYW5cbiAqXG4gKiBDb3B5cmlnaHQgMjAxNC0yMDE1LCBVeGNvcmUgVGVhbSwgQWxpbncuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9NZW51Jyk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vdXhjb3JlLXRhYmxlL34vdXhjb3JlLW1lbnUvYnVpbGQvaW5kZXguanNcbiAqKiBtb2R1bGUgaWQgPSAxMFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX3JlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxudmFyIF9yZWFjdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yZWFjdCk7XG5cbnZhciBfcmNNZW51ID0gcmVxdWlyZSgncmMtbWVudScpO1xuXG52YXIgX3JjTWVudTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yY01lbnUpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBcImRlZmF1bHRcIjogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfSAvKipcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIE1lbnUgQ29tcG9uZW50IGZvciB1eGNvcmVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBhdXRob3IgdmluY2VudC5iaWFuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQ29weXJpZ2h0IDIwMTQtMjAxNSwgVXhjb3JlIFRlYW0sIEFsaW53LlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuXG5cbnZhciBNZW51ID0gZnVuY3Rpb24gKF9SZWFjdCRDb21wb25lbnQpIHtcbiAgICBfaW5oZXJpdHMoTWVudSwgX1JlYWN0JENvbXBvbmVudCk7XG5cbiAgICBmdW5jdGlvbiBNZW51KCkge1xuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTWVudSk7XG5cbiAgICAgICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9SZWFjdCRDb21wb25lbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gICAgfVxuXG4gICAgTWVudS5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgICAgICBpZiAodGhpcy5wcm9wcy5tb2RlID09PSAnaW5saW5lJykge1xuICAgICAgICAgICAgcmV0dXJuIF9yZWFjdDJbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoX3JjTWVudTJbXCJkZWZhdWx0XCJdLCB0aGlzLnByb3BzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBfcmVhY3QyW1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KF9yY01lbnUyW1wiZGVmYXVsdFwiXSwgdGhpcy5wcm9wcyk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgcmV0dXJuIE1lbnU7XG59KF9yZWFjdDJbXCJkZWZhdWx0XCJdLkNvbXBvbmVudCk7XG5cbk1lbnUuZGVmYXVsdFByb3BzID0ge1xuICAgIHByZWZpeENsczogJ2t1bWEtbWVudSdcbn07XG5NZW51LnByb3BUeXBlcyA9IHtcbiAgICBwcmVmaXhDbHM6IF9yZWFjdDJbXCJkZWZhdWx0XCJdLlByb3BUeXBlcy5zdHJpbmdcbn07XG5cbk1lbnUuU3ViTWVudSA9IF9yY01lbnUuU3ViTWVudTtcbk1lbnUuSXRlbSA9IF9yY01lbnUuSXRlbTtcbk1lbnUuRGl2aWRlciA9IF9yY01lbnUuRGl2aWRlcjtcblxuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBNZW51O1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vdXhjb3JlLXRhYmxlL34vdXhjb3JlLW1lbnUvYnVpbGQvTWVudS5qc1xuICoqIG1vZHVsZSBpZCA9IDExXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbnZhciBfTWVudSA9IHJlcXVpcmUoJy4vTWVudScpO1xuXG52YXIgX01lbnUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfTWVudSk7XG5cbnZhciBfU3ViTWVudSA9IHJlcXVpcmUoJy4vU3ViTWVudScpO1xuXG52YXIgX1N1Yk1lbnUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfU3ViTWVudSk7XG5cbnZhciBfTWVudUl0ZW0gPSByZXF1aXJlKCcuL01lbnVJdGVtJyk7XG5cbnZhciBfTWVudUl0ZW0yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfTWVudUl0ZW0pO1xuXG52YXIgX01lbnVJdGVtR3JvdXAgPSByZXF1aXJlKCcuL01lbnVJdGVtR3JvdXAnKTtcblxudmFyIF9NZW51SXRlbUdyb3VwMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX01lbnVJdGVtR3JvdXApO1xuXG52YXIgX0RpdmlkZXIgPSByZXF1aXJlKCcuL0RpdmlkZXInKTtcblxudmFyIF9EaXZpZGVyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0RpdmlkZXIpO1xuXG5leHBvcnRzLlN1Yk1lbnUgPSBfU3ViTWVudTJbJ2RlZmF1bHQnXTtcbmV4cG9ydHMuSXRlbSA9IF9NZW51SXRlbTJbJ2RlZmF1bHQnXTtcbmV4cG9ydHMuTWVudUl0ZW0gPSBfTWVudUl0ZW0yWydkZWZhdWx0J107XG5leHBvcnRzLk1lbnVJdGVtR3JvdXAgPSBfTWVudUl0ZW1Hcm91cDJbJ2RlZmF1bHQnXTtcbmV4cG9ydHMuSXRlbUdyb3VwID0gX01lbnVJdGVtR3JvdXAyWydkZWZhdWx0J107XG5leHBvcnRzLkRpdmlkZXIgPSBfRGl2aWRlcjJbJ2RlZmF1bHQnXTtcbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IF9NZW51MlsnZGVmYXVsdCddO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3V4Y29yZS10YWJsZS9+L3V4Y29yZS1tZW51L34vcmMtbWVudS9saWIvaW5kZXguanNcbiAqKiBtb2R1bGUgaWQgPSAxMlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG52YXIgX3JlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxudmFyIF9yZWFjdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yZWFjdCk7XG5cbnZhciBfTWVudU1peGluID0gcmVxdWlyZSgnLi9NZW51TWl4aW4nKTtcblxudmFyIF9NZW51TWl4aW4yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfTWVudU1peGluKTtcblxudmFyIF9vYmplY3RBc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG5cbnZhciBfb2JqZWN0QXNzaWduMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX29iamVjdEFzc2lnbik7XG5cbnZhciBfdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xuXG52YXIgTWVudSA9IF9yZWFjdDJbJ2RlZmF1bHQnXS5jcmVhdGVDbGFzcyh7XG4gIGRpc3BsYXlOYW1lOiAnTWVudScsXG5cbiAgcHJvcFR5cGVzOiB7XG4gICAgb3BlblN1Yk1lbnVPbk1vdXNlRW50ZXI6IF9yZWFjdDJbJ2RlZmF1bHQnXS5Qcm9wVHlwZXMuYm9vbCxcbiAgICBjbG9zZVN1Yk1lbnVPbk1vdXNlTGVhdmU6IF9yZWFjdDJbJ2RlZmF1bHQnXS5Qcm9wVHlwZXMuYm9vbCxcbiAgICBzZWxlY3RlZEtleXM6IF9yZWFjdDJbJ2RlZmF1bHQnXS5Qcm9wVHlwZXMuYXJyYXlPZihfcmVhY3QyWydkZWZhdWx0J10uUHJvcFR5cGVzLnN0cmluZyksXG4gICAgZGVmYXVsdFNlbGVjdGVkS2V5czogX3JlYWN0MlsnZGVmYXVsdCddLlByb3BUeXBlcy5hcnJheU9mKF9yZWFjdDJbJ2RlZmF1bHQnXS5Qcm9wVHlwZXMuc3RyaW5nKSxcbiAgICBkZWZhdWx0T3BlbktleXM6IF9yZWFjdDJbJ2RlZmF1bHQnXS5Qcm9wVHlwZXMuYXJyYXlPZihfcmVhY3QyWydkZWZhdWx0J10uUHJvcFR5cGVzLnN0cmluZyksXG4gICAgb3BlbktleXM6IF9yZWFjdDJbJ2RlZmF1bHQnXS5Qcm9wVHlwZXMuYXJyYXlPZihfcmVhY3QyWydkZWZhdWx0J10uUHJvcFR5cGVzLnN0cmluZyksXG4gICAgbW9kZTogX3JlYWN0MlsnZGVmYXVsdCddLlByb3BUeXBlcy5zdHJpbmcsXG4gICAgb25DbGljazogX3JlYWN0MlsnZGVmYXVsdCddLlByb3BUeXBlcy5mdW5jLFxuICAgIG9uU2VsZWN0OiBfcmVhY3QyWydkZWZhdWx0J10uUHJvcFR5cGVzLmZ1bmMsXG4gICAgb25EZXNlbGVjdDogX3JlYWN0MlsnZGVmYXVsdCddLlByb3BUeXBlcy5mdW5jLFxuICAgIG9uRGVzdHJveTogX3JlYWN0MlsnZGVmYXVsdCddLlByb3BUeXBlcy5mdW5jLFxuICAgIG9wZW5UcmFuc2l0aW9uTmFtZTogX3JlYWN0MlsnZGVmYXVsdCddLlByb3BUeXBlcy5zdHJpbmcsXG4gICAgb3BlbkFuaW1hdGlvbjogX3JlYWN0MlsnZGVmYXVsdCddLlByb3BUeXBlcy5vbmVPZlR5cGUoW19yZWFjdDJbJ2RlZmF1bHQnXS5Qcm9wVHlwZXMuc3RyaW5nLCBfcmVhY3QyWydkZWZhdWx0J10uUHJvcFR5cGVzLm9iamVjdF0pLFxuICAgIGxldmVsOiBfcmVhY3QyWydkZWZhdWx0J10uUHJvcFR5cGVzLm51bWJlcixcbiAgICBldmVudEtleTogX3JlYWN0MlsnZGVmYXVsdCddLlByb3BUeXBlcy5zdHJpbmcsXG4gICAgc2VsZWN0YWJsZTogX3JlYWN0MlsnZGVmYXVsdCddLlByb3BUeXBlcy5ib29sLFxuICAgIGNoaWxkcmVuOiBfcmVhY3QyWydkZWZhdWx0J10uUHJvcFR5cGVzLmFueVxuICB9LFxuXG4gIG1peGluczogW19NZW51TWl4aW4yWydkZWZhdWx0J11dLFxuXG4gIGdldERlZmF1bHRQcm9wczogZnVuY3Rpb24gZ2V0RGVmYXVsdFByb3BzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBvcGVuU3ViTWVudU9uTW91c2VFbnRlcjogdHJ1ZSxcbiAgICAgIGNsb3NlU3ViTWVudU9uTW91c2VMZWF2ZTogdHJ1ZSxcbiAgICAgIHNlbGVjdGFibGU6IHRydWUsXG4gICAgICBvbkNsaWNrOiBfdXRpbC5ub29wLFxuICAgICAgb25TZWxlY3Q6IF91dGlsLm5vb3AsXG4gICAgICBvbk9wZW46IF91dGlsLm5vb3AsXG4gICAgICBvbkNsb3NlOiBfdXRpbC5ub29wLFxuICAgICAgb25EZXNlbGVjdDogX3V0aWwubm9vcCxcbiAgICAgIGRlZmF1bHRTZWxlY3RlZEtleXM6IFtdLFxuICAgICAgZGVmYXVsdE9wZW5LZXlzOiBbXVxuICAgIH07XG4gIH0sXG5cbiAgZ2V0SW5pdGlhbFN0YXRlOiBmdW5jdGlvbiBnZXRJbml0aWFsU3RhdGUoKSB7XG4gICAgdmFyIHByb3BzID0gdGhpcy5wcm9wcztcbiAgICB2YXIgc2VsZWN0ZWRLZXlzID0gcHJvcHMuZGVmYXVsdFNlbGVjdGVkS2V5cztcbiAgICB2YXIgb3BlbktleXMgPSBwcm9wcy5kZWZhdWx0T3BlbktleXM7XG4gICAgaWYgKCdzZWxlY3RlZEtleXMnIGluIHByb3BzKSB7XG4gICAgICBzZWxlY3RlZEtleXMgPSBwcm9wcy5zZWxlY3RlZEtleXMgfHwgW107XG4gICAgfVxuICAgIGlmICgnb3BlbktleXMnIGluIHByb3BzKSB7XG4gICAgICBvcGVuS2V5cyA9IHByb3BzLm9wZW5LZXlzIHx8IFtdO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgc2VsZWN0ZWRLZXlzOiBzZWxlY3RlZEtleXMsIG9wZW5LZXlzOiBvcGVuS2V5c1xuICAgIH07XG4gIH0sXG5cbiAgY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wczogZnVuY3Rpb24gY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhuZXh0UHJvcHMpIHtcbiAgICB2YXIgcHJvcHMgPSB7fTtcbiAgICBpZiAoJ3NlbGVjdGVkS2V5cycgaW4gbmV4dFByb3BzKSB7XG4gICAgICBwcm9wcy5zZWxlY3RlZEtleXMgPSBuZXh0UHJvcHMuc2VsZWN0ZWRLZXlzO1xuICAgIH1cbiAgICBpZiAoJ29wZW5LZXlzJyBpbiBuZXh0UHJvcHMpIHtcbiAgICAgIHByb3BzLm9wZW5LZXlzID0gbmV4dFByb3BzLm9wZW5LZXlzO1xuICAgIH1cbiAgICB0aGlzLnNldFN0YXRlKHByb3BzKTtcbiAgfSxcblxuICBvbkRlc3Ryb3k6IGZ1bmN0aW9uIG9uRGVzdHJveShrZXkpIHtcbiAgICB2YXIgc3RhdGUgPSB0aGlzLnN0YXRlO1xuICAgIHZhciBwcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgdmFyIHNlbGVjdGVkS2V5cyA9IHN0YXRlLnNlbGVjdGVkS2V5cztcbiAgICB2YXIgb3BlbktleXMgPSBzdGF0ZS5vcGVuS2V5cztcbiAgICB2YXIgaW5kZXggPSBzZWxlY3RlZEtleXMuaW5kZXhPZihrZXkpO1xuICAgIGlmICghKCdzZWxlY3RlZEtleXMnIGluIHByb3BzKSAmJiBpbmRleCAhPT0gLTEpIHtcbiAgICAgIHNlbGVjdGVkS2V5cy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIH1cbiAgICBpbmRleCA9IG9wZW5LZXlzLmluZGV4T2Yoa2V5KTtcbiAgICBpZiAoISgnb3BlbktleXMnIGluIHByb3BzKSAmJiBpbmRleCAhPT0gLTEpIHtcbiAgICAgIG9wZW5LZXlzLnNwbGljZShpbmRleCwgMSk7XG4gICAgfVxuICB9LFxuXG4gIG9uSXRlbUhvdmVyOiBmdW5jdGlvbiBvbkl0ZW1Ib3ZlcihlKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIHZhciBpdGVtID0gZS5pdGVtO1xuXG4gICAgLy8gc3BlY2lhbCBmb3IgdG9wIHN1YiBtZW51XG4gICAgaWYgKHRoaXMucHJvcHMubW9kZSAhPT0gJ2lubGluZScgJiYgIXRoaXMucHJvcHMuY2xvc2VTdWJNZW51T25Nb3VzZUxlYXZlICYmIGl0ZW0uaXNTdWJNZW51KSB7XG4gICAgICAoZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYWN0aXZlS2V5ID0gX3RoaXMuc3RhdGUuYWN0aXZlS2V5O1xuICAgICAgICB2YXIgYWN0aXZlSXRlbSA9IF90aGlzLmdldEZsYXRJbnN0YW5jZUFycmF5KCkuZmlsdGVyKGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgcmV0dXJuIGMgJiYgYy5wcm9wcy5ldmVudEtleSA9PT0gYWN0aXZlS2V5O1xuICAgICAgICB9KVswXTtcbiAgICAgICAgaWYgKGFjdGl2ZUl0ZW0gJiYgYWN0aXZlSXRlbS5wcm9wcy5vcGVuKSB7XG4gICAgICAgICAgX3RoaXMub25PcGVuQ2hhbmdlKHtcbiAgICAgICAgICAgIGtleTogaXRlbS5wcm9wcy5ldmVudEtleSxcbiAgICAgICAgICAgIGl0ZW06IGUuaXRlbSxcbiAgICAgICAgICAgIG9wZW46IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSkoKTtcbiAgICB9XG5cbiAgICB0aGlzLm9uQ29tbW9uSXRlbUhvdmVyKGUpO1xuICB9LFxuXG4gIG9uU2VsZWN0OiBmdW5jdGlvbiBvblNlbGVjdChzZWxlY3RJbmZvKSB7XG4gICAgdmFyIHByb3BzID0gdGhpcy5wcm9wcztcbiAgICBpZiAocHJvcHMuc2VsZWN0YWJsZSkge1xuICAgICAgLy8gcm9vdCBtZW51XG4gICAgICB2YXIgc2VsZWN0ZWRLZXlzID0gdGhpcy5zdGF0ZS5zZWxlY3RlZEtleXM7XG4gICAgICB2YXIgc2VsZWN0ZWRLZXkgPSBzZWxlY3RJbmZvLmtleTtcbiAgICAgIGlmIChwcm9wcy5tdWx0aXBsZSkge1xuICAgICAgICBzZWxlY3RlZEtleXMgPSBzZWxlY3RlZEtleXMuY29uY2F0KFtzZWxlY3RlZEtleV0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2VsZWN0ZWRLZXlzID0gW3NlbGVjdGVkS2V5XTtcbiAgICAgIH1cbiAgICAgIGlmICghKCdzZWxlY3RlZEtleXMnIGluIHByb3BzKSkge1xuICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICBzZWxlY3RlZEtleXM6IHNlbGVjdGVkS2V5c1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHByb3BzLm9uU2VsZWN0KCgwLCBfb2JqZWN0QXNzaWduMlsnZGVmYXVsdCddKSh7fSwgc2VsZWN0SW5mbywge1xuICAgICAgICBzZWxlY3RlZEtleXM6IHNlbGVjdGVkS2V5c1xuICAgICAgfSkpO1xuICAgIH1cbiAgfSxcblxuICBvbkNsaWNrOiBmdW5jdGlvbiBvbkNsaWNrKGUpIHtcbiAgICB2YXIgcHJvcHMgPSB0aGlzLnByb3BzO1xuICAgIHByb3BzLm9uQ2xpY2soZSk7XG4gIH0sXG5cbiAgb25PcGVuQ2hhbmdlOiBmdW5jdGlvbiBvbk9wZW5DaGFuZ2UoZSkge1xuICAgIHZhciBvcGVuS2V5cyA9IHRoaXMuc3RhdGUub3BlbktleXM7XG4gICAgdmFyIHByb3BzID0gdGhpcy5wcm9wcztcbiAgICB2YXIgY2hhbmdlZCA9IHRydWU7XG4gICAgaWYgKGUub3Blbikge1xuICAgICAgY2hhbmdlZCA9IG9wZW5LZXlzLmluZGV4T2YoZS5rZXkpID09PSAtMTtcbiAgICAgIGlmIChjaGFuZ2VkKSB7XG4gICAgICAgIG9wZW5LZXlzID0gb3BlbktleXMuY29uY2F0KGUua2V5KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGluZGV4ID0gb3BlbktleXMuaW5kZXhPZihlLmtleSk7XG4gICAgICBjaGFuZ2VkID0gaW5kZXggIT09IC0xO1xuICAgICAgaWYgKGNoYW5nZWQpIHtcbiAgICAgICAgb3BlbktleXMgPSBvcGVuS2V5cy5jb25jYXQoKTtcbiAgICAgICAgb3BlbktleXMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGNoYW5nZWQpIHtcbiAgICAgIGlmICghKCdvcGVuS2V5cycgaW4gdGhpcy5wcm9wcykpIHtcbiAgICAgICAgLy8gaGFjazogYmF0Y2ggZG9lcyBub3QgdXBkYXRlIHN0YXRlXG4gICAgICAgIHRoaXMuc3RhdGUub3BlbktleXMgPSBvcGVuS2V5cztcbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7IG9wZW5LZXlzOiBvcGVuS2V5cyB9KTtcbiAgICAgIH1cbiAgICAgIHZhciBpbmZvID0gKDAsIF9vYmplY3RBc3NpZ24yWydkZWZhdWx0J10pKHsgb3BlbktleXM6IG9wZW5LZXlzIH0sIGUpO1xuICAgICAgaWYgKGUub3Blbikge1xuICAgICAgICBwcm9wcy5vbk9wZW4oaW5mbyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwcm9wcy5vbkNsb3NlKGluZm8pO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICBvbkRlc2VsZWN0OiBmdW5jdGlvbiBvbkRlc2VsZWN0KHNlbGVjdEluZm8pIHtcbiAgICB2YXIgcHJvcHMgPSB0aGlzLnByb3BzO1xuICAgIGlmIChwcm9wcy5zZWxlY3RhYmxlKSB7XG4gICAgICB2YXIgc2VsZWN0ZWRLZXlzID0gdGhpcy5zdGF0ZS5zZWxlY3RlZEtleXMuY29uY2F0KCk7XG4gICAgICB2YXIgc2VsZWN0ZWRLZXkgPSBzZWxlY3RJbmZvLmtleTtcbiAgICAgIHZhciBpbmRleCA9IHNlbGVjdGVkS2V5cy5pbmRleE9mKHNlbGVjdGVkS2V5KTtcbiAgICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgICAgc2VsZWN0ZWRLZXlzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICB9XG4gICAgICBpZiAoISgnc2VsZWN0ZWRLZXlzJyBpbiBwcm9wcykpIHtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgc2VsZWN0ZWRLZXlzOiBzZWxlY3RlZEtleXNcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBwcm9wcy5vbkRlc2VsZWN0KCgwLCBfb2JqZWN0QXNzaWduMlsnZGVmYXVsdCddKSh7fSwgc2VsZWN0SW5mbywge1xuICAgICAgICBzZWxlY3RlZEtleXM6IHNlbGVjdGVkS2V5c1xuICAgICAgfSkpO1xuICAgIH1cbiAgfSxcblxuICBnZXRPcGVuVHJhbnNpdGlvbk5hbWU6IGZ1bmN0aW9uIGdldE9wZW5UcmFuc2l0aW9uTmFtZSgpIHtcbiAgICB2YXIgcHJvcHMgPSB0aGlzLnByb3BzO1xuICAgIHZhciB0cmFuc2l0aW9uTmFtZSA9IHByb3BzLm9wZW5UcmFuc2l0aW9uTmFtZTtcbiAgICB2YXIgYW5pbWF0aW9uTmFtZSA9IHByb3BzLm9wZW5BbmltYXRpb247XG4gICAgaWYgKCF0cmFuc2l0aW9uTmFtZSAmJiB0eXBlb2YgYW5pbWF0aW9uTmFtZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRyYW5zaXRpb25OYW1lID0gcHJvcHMucHJlZml4Q2xzICsgJy1vcGVuLScgKyBhbmltYXRpb25OYW1lO1xuICAgIH1cbiAgICByZXR1cm4gdHJhbnNpdGlvbk5hbWU7XG4gIH0sXG5cbiAgaXNJbmxpbmVNb2RlOiBmdW5jdGlvbiBpc0lubGluZU1vZGUoKSB7XG4gICAgcmV0dXJuIHRoaXMucHJvcHMubW9kZSA9PT0gJ2lubGluZSc7XG4gIH0sXG5cbiAgbGFzdE9wZW5TdWJNZW51OiBmdW5jdGlvbiBsYXN0T3BlblN1Yk1lbnUoKSB7XG4gICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICB2YXIgbGFzdE9wZW4gPSBbXTtcbiAgICBpZiAodGhpcy5zdGF0ZS5vcGVuS2V5cy5sZW5ndGgpIHtcbiAgICAgIGxhc3RPcGVuID0gdGhpcy5nZXRGbGF0SW5zdGFuY2VBcnJheSgpLmZpbHRlcihmdW5jdGlvbiAoYykge1xuICAgICAgICByZXR1cm4gYyAmJiBfdGhpczIuc3RhdGUub3BlbktleXMuaW5kZXhPZihjLnByb3BzLmV2ZW50S2V5KSAhPT0gLTE7XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGxhc3RPcGVuWzBdO1xuICB9LFxuXG4gIHJlbmRlck1lbnVJdGVtOiBmdW5jdGlvbiByZW5kZXJNZW51SXRlbShjLCBpLCBzdWJJbmRleCkge1xuICAgIHZhciBrZXkgPSAoMCwgX3V0aWwuZ2V0S2V5RnJvbUNoaWxkcmVuSW5kZXgpKGMsIHRoaXMucHJvcHMuZXZlbnRLZXksIGkpO1xuICAgIHZhciBzdGF0ZSA9IHRoaXMuc3RhdGU7XG4gICAgdmFyIGV4dHJhUHJvcHMgPSB7XG4gICAgICBvcGVuS2V5czogc3RhdGUub3BlbktleXMsXG4gICAgICBvcGVuOiBzdGF0ZS5vcGVuS2V5cy5pbmRleE9mKGtleSkgIT09IC0xLFxuICAgICAgc2VsZWN0ZWRLZXlzOiBzdGF0ZS5zZWxlY3RlZEtleXMsXG4gICAgICBzZWxlY3RlZDogc3RhdGUuc2VsZWN0ZWRLZXlzLmluZGV4T2Yoa2V5KSAhPT0gLTEsXG4gICAgICBvcGVuU3ViTWVudU9uTW91c2VFbnRlcjogdGhpcy5wcm9wcy5vcGVuU3ViTWVudU9uTW91c2VFbnRlclxuICAgIH07XG4gICAgcmV0dXJuIHRoaXMucmVuZGVyQ29tbW9uTWVudUl0ZW0oYywgaSwgc3ViSW5kZXgsIGV4dHJhUHJvcHMpO1xuICB9LFxuXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgIHZhciBwcm9wcyA9ICgwLCBfb2JqZWN0QXNzaWduMlsnZGVmYXVsdCddKSh7fSwgdGhpcy5wcm9wcyk7XG4gICAgcHJvcHMuY2xhc3NOYW1lICs9ICcgJyArIHByb3BzLnByZWZpeENscyArICctcm9vdCc7XG4gICAgcmV0dXJuIHRoaXMucmVuZGVyUm9vdChwcm9wcyk7XG4gIH1cbn0pO1xuXG5leHBvcnRzWydkZWZhdWx0J10gPSBNZW51O1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vdXhjb3JlLXRhYmxlL34vdXhjb3JlLW1lbnUvfi9yYy1tZW51L2xpYi9NZW51LmpzXG4gKiogbW9kdWxlIGlkID0gMTNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cblxudmFyIF9yZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5cbnZhciBfcmVhY3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmVhY3QpO1xuXG52YXIgX3JlYWN0RG9tID0gcmVxdWlyZSgncmVhY3QtZG9tJyk7XG5cbnZhciBfcmVhY3REb20yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmVhY3REb20pO1xuXG52YXIgX3JjVXRpbCA9IHJlcXVpcmUoJ3JjLXV0aWwnKTtcblxudmFyIF9jbGFzc25hbWVzID0gcmVxdWlyZSgnY2xhc3NuYW1lcycpO1xuXG52YXIgX2NsYXNzbmFtZXMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY2xhc3NuYW1lcyk7XG5cbnZhciBfZG9tU2Nyb2xsSW50b1ZpZXcgPSByZXF1aXJlKCdkb20tc2Nyb2xsLWludG8tdmlldycpO1xuXG52YXIgX2RvbVNjcm9sbEludG9WaWV3MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2RvbVNjcm9sbEludG9WaWV3KTtcblxudmFyIF9vYmplY3RBc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG5cbnZhciBfb2JqZWN0QXNzaWduMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX29iamVjdEFzc2lnbik7XG5cbnZhciBfdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xuXG52YXIgX0RPTVdyYXAgPSByZXF1aXJlKCcuL0RPTVdyYXAnKTtcblxudmFyIF9ET01XcmFwMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0RPTVdyYXApO1xuXG5mdW5jdGlvbiBhbGxEaXNhYmxlZChhcnIpIHtcbiAgaWYgKCFhcnIubGVuZ3RoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGFyci5ldmVyeShmdW5jdGlvbiAoYykge1xuICAgIHJldHVybiAhIWMucHJvcHMuZGlzYWJsZWQ7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBnZXRBY3RpdmVLZXkocHJvcHMsIG9yaWdpbmFsQWN0aXZlS2V5KSB7XG4gIHZhciBhY3RpdmVLZXkgPSBvcmlnaW5hbEFjdGl2ZUtleTtcbiAgdmFyIGNoaWxkcmVuID0gcHJvcHMuY2hpbGRyZW47XG4gIHZhciBldmVudEtleSA9IHByb3BzLmV2ZW50S2V5O1xuICBpZiAoYWN0aXZlS2V5KSB7XG4gICAgdmFyIGZvdW5kID0gdW5kZWZpbmVkO1xuICAgICgwLCBfdXRpbC5sb29wTWVudUl0ZW0pKGNoaWxkcmVuLCBmdW5jdGlvbiAoYywgaSkge1xuICAgICAgaWYgKCFjLnByb3BzLmRpc2FibGVkICYmIGFjdGl2ZUtleSA9PT0gKDAsIF91dGlsLmdldEtleUZyb21DaGlsZHJlbkluZGV4KShjLCBldmVudEtleSwgaSkpIHtcbiAgICAgICAgZm91bmQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGlmIChmb3VuZCkge1xuICAgICAgcmV0dXJuIGFjdGl2ZUtleTtcbiAgICB9XG4gIH1cbiAgYWN0aXZlS2V5ID0gbnVsbDtcbiAgaWYgKHByb3BzLmRlZmF1bHRBY3RpdmVGaXJzdCkge1xuICAgICgwLCBfdXRpbC5sb29wTWVudUl0ZW0pKGNoaWxkcmVuLCBmdW5jdGlvbiAoYywgaSkge1xuICAgICAgaWYgKCFhY3RpdmVLZXkgJiYgIWMucHJvcHMuZGlzYWJsZWQpIHtcbiAgICAgICAgYWN0aXZlS2V5ID0gKDAsIF91dGlsLmdldEtleUZyb21DaGlsZHJlbkluZGV4KShjLCBldmVudEtleSwgaSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGFjdGl2ZUtleTtcbiAgfVxuICByZXR1cm4gYWN0aXZlS2V5O1xufVxuXG5mdW5jdGlvbiBzYXZlUmVmKGluZGV4LCBzdWJJbmRleCwgYykge1xuICBpZiAoYykge1xuICAgIGlmIChzdWJJbmRleCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLmluc3RhbmNlQXJyYXlbaW5kZXhdID0gdGhpcy5pbnN0YW5jZUFycmF5W2luZGV4XSB8fCBbXTtcbiAgICAgIHRoaXMuaW5zdGFuY2VBcnJheVtpbmRleF1bc3ViSW5kZXhdID0gYztcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5pbnN0YW5jZUFycmF5W2luZGV4XSA9IGM7XG4gICAgfVxuICB9XG59XG5cbnZhciBNZW51TWl4aW4gPSB7XG4gIHByb3BUeXBlczoge1xuICAgIGZvY3VzYWJsZTogX3JlYWN0MlsnZGVmYXVsdCddLlByb3BUeXBlcy5ib29sLFxuICAgIG11bHRpcGxlOiBfcmVhY3QyWydkZWZhdWx0J10uUHJvcFR5cGVzLmJvb2wsXG4gICAgc3R5bGU6IF9yZWFjdDJbJ2RlZmF1bHQnXS5Qcm9wVHlwZXMub2JqZWN0LFxuICAgIGRlZmF1bHRBY3RpdmVGaXJzdDogX3JlYWN0MlsnZGVmYXVsdCddLlByb3BUeXBlcy5ib29sLFxuICAgIHZpc2libGU6IF9yZWFjdDJbJ2RlZmF1bHQnXS5Qcm9wVHlwZXMuYm9vbCxcbiAgICBhY3RpdmVLZXk6IF9yZWFjdDJbJ2RlZmF1bHQnXS5Qcm9wVHlwZXMuc3RyaW5nLFxuICAgIHNlbGVjdGVkS2V5czogX3JlYWN0MlsnZGVmYXVsdCddLlByb3BUeXBlcy5hcnJheU9mKF9yZWFjdDJbJ2RlZmF1bHQnXS5Qcm9wVHlwZXMuc3RyaW5nKSxcbiAgICBkZWZhdWx0U2VsZWN0ZWRLZXlzOiBfcmVhY3QyWydkZWZhdWx0J10uUHJvcFR5cGVzLmFycmF5T2YoX3JlYWN0MlsnZGVmYXVsdCddLlByb3BUeXBlcy5zdHJpbmcpLFxuICAgIGRlZmF1bHRPcGVuS2V5czogX3JlYWN0MlsnZGVmYXVsdCddLlByb3BUeXBlcy5hcnJheU9mKF9yZWFjdDJbJ2RlZmF1bHQnXS5Qcm9wVHlwZXMuc3RyaW5nKSxcbiAgICBvcGVuS2V5czogX3JlYWN0MlsnZGVmYXVsdCddLlByb3BUeXBlcy5hcnJheU9mKF9yZWFjdDJbJ2RlZmF1bHQnXS5Qcm9wVHlwZXMuc3RyaW5nKSxcbiAgICBjaGlsZHJlbjogX3JlYWN0MlsnZGVmYXVsdCddLlByb3BUeXBlcy5hbnlcbiAgfSxcblxuICBnZXREZWZhdWx0UHJvcHM6IGZ1bmN0aW9uIGdldERlZmF1bHRQcm9wcygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgcHJlZml4Q2xzOiAncmMtbWVudScsXG4gICAgICBjbGFzc05hbWU6ICcnLFxuICAgICAgbW9kZTogJ3ZlcnRpY2FsJyxcbiAgICAgIGxldmVsOiAxLFxuICAgICAgaW5saW5lSW5kZW50OiAyNCxcbiAgICAgIHZpc2libGU6IHRydWUsXG4gICAgICBmb2N1c2FibGU6IHRydWUsXG4gICAgICBzdHlsZToge31cbiAgICB9O1xuICB9LFxuXG4gIGdldEluaXRpYWxTdGF0ZTogZnVuY3Rpb24gZ2V0SW5pdGlhbFN0YXRlKCkge1xuICAgIHZhciBwcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgcmV0dXJuIHtcbiAgICAgIGFjdGl2ZUtleTogZ2V0QWN0aXZlS2V5KHByb3BzLCBwcm9wcy5hY3RpdmVLZXkpXG4gICAgfTtcbiAgfSxcblxuICBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzOiBmdW5jdGlvbiBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKG5leHRQcm9wcykge1xuICAgIHZhciBwcm9wcyA9IHVuZGVmaW5lZDtcbiAgICBpZiAoJ2FjdGl2ZUtleScgaW4gbmV4dFByb3BzKSB7XG4gICAgICBwcm9wcyA9IHtcbiAgICAgICAgYWN0aXZlS2V5OiBnZXRBY3RpdmVLZXkobmV4dFByb3BzLCBuZXh0UHJvcHMuYWN0aXZlS2V5KVxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIG9yaWdpbmFsQWN0aXZlS2V5ID0gdGhpcy5zdGF0ZS5hY3RpdmVLZXk7XG4gICAgICB2YXIgYWN0aXZlS2V5ID0gZ2V0QWN0aXZlS2V5KG5leHRQcm9wcywgb3JpZ2luYWxBY3RpdmVLZXkpO1xuICAgICAgLy8gZml4OiB0aGlzLnNldFN0YXRlKCksIHBhcmVudC5yZW5kZXIoKSxcbiAgICAgIGlmIChhY3RpdmVLZXkgIT09IG9yaWdpbmFsQWN0aXZlS2V5KSB7XG4gICAgICAgIHByb3BzID0ge1xuICAgICAgICAgIGFjdGl2ZUtleTogYWN0aXZlS2V5XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChwcm9wcykge1xuICAgICAgdGhpcy5zZXRTdGF0ZShwcm9wcyk7XG4gICAgfVxuICB9LFxuXG4gIHNob3VsZENvbXBvbmVudFVwZGF0ZTogZnVuY3Rpb24gc2hvdWxkQ29tcG9uZW50VXBkYXRlKG5leHRQcm9wcykge1xuICAgIHJldHVybiB0aGlzLnByb3BzLnZpc2libGUgfHwgbmV4dFByb3BzLnZpc2libGU7XG4gIH0sXG5cbiAgY29tcG9uZW50V2lsbE1vdW50OiBmdW5jdGlvbiBjb21wb25lbnRXaWxsTW91bnQoKSB7XG4gICAgdGhpcy5pbnN0YW5jZUFycmF5ID0gW107XG4gIH0sXG5cbiAgLy8gYWxsIGtleWJvYXJkIGV2ZW50cyBjYWxsYmFja3MgcnVuIGZyb20gaGVyZSBhdCBmaXJzdFxuICBvbktleURvd246IGZ1bmN0aW9uIG9uS2V5RG93bihlKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIHZhciBrZXlDb2RlID0gZS5rZXlDb2RlO1xuICAgIHZhciBoYW5kbGVkID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuZ2V0RmxhdEluc3RhbmNlQXJyYXkoKS5mb3JFYWNoKGZ1bmN0aW9uIChvYmopIHtcbiAgICAgIGlmIChvYmogJiYgb2JqLnByb3BzLmFjdGl2ZSkge1xuICAgICAgICBoYW5kbGVkID0gb2JqLm9uS2V5RG93bihlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAoaGFuZGxlZCkge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICAgIHZhciBhY3RpdmVJdGVtID0gbnVsbDtcbiAgICBpZiAoa2V5Q29kZSA9PT0gX3JjVXRpbC5LZXlDb2RlLlVQIHx8IGtleUNvZGUgPT09IF9yY1V0aWwuS2V5Q29kZS5ET1dOKSB7XG4gICAgICBhY3RpdmVJdGVtID0gdGhpcy5zdGVwKGtleUNvZGUgPT09IF9yY1V0aWwuS2V5Q29kZS5VUCA/IC0xIDogMSk7XG4gICAgfVxuICAgIGlmIChhY3RpdmVJdGVtKSB7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgYWN0aXZlS2V5OiBhY3RpdmVJdGVtLnByb3BzLmV2ZW50S2V5XG4gICAgICB9LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICgwLCBfZG9tU2Nyb2xsSW50b1ZpZXcyWydkZWZhdWx0J10pKF9yZWFjdERvbTJbJ2RlZmF1bHQnXS5maW5kRE9NTm9kZShhY3RpdmVJdGVtKSwgX3JlYWN0RG9tMlsnZGVmYXVsdCddLmZpbmRET01Ob2RlKF90aGlzKSwge1xuICAgICAgICAgIG9ubHlTY3JvbGxJZk5lZWRlZDogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIDE7XG4gICAgfSBlbHNlIGlmIChhY3RpdmVJdGVtID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICBhY3RpdmVLZXk6IG51bGxcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICB9LFxuXG4gIG9uQ29tbW9uSXRlbUhvdmVyOiBmdW5jdGlvbiBvbkNvbW1vbkl0ZW1Ib3ZlcihlKSB7XG4gICAgdmFyIG1vZGUgPSB0aGlzLnByb3BzLm1vZGU7XG4gICAgdmFyIGtleSA9IGUua2V5O1xuICAgIHZhciBob3ZlciA9IGUuaG92ZXI7XG4gICAgdmFyIHRyaWdnZXIgPSBlLnRyaWdnZXI7XG5cbiAgICB2YXIgYWN0aXZlS2V5ID0gdGhpcy5zdGF0ZS5hY3RpdmVLZXk7XG4gICAgaWYgKCF0cmlnZ2VyIHx8IGhvdmVyIHx8IHRoaXMucHJvcHMuY2xvc2VTdWJNZW51T25Nb3VzZUxlYXZlIHx8ICFlLml0ZW0uaXNTdWJNZW51IHx8IG1vZGUgPT09ICdpbmxpbmUnKSB7XG4gICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgYWN0aXZlS2V5OiBob3ZlciA/IGtleSA6IG51bGxcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7fVxuICAgIC8vIGtlZXAgYWN0aXZlIGZvciBzdWIgbWVudSBmb3IgY2xpY2sgYWN0aXZlXG4gICAgLy8gZW1wdHlcblxuICAgIC8vIGNsZWFyIGxhc3Qgb3BlbiBzdGF0dXNcbiAgICBpZiAoaG92ZXIgJiYgbW9kZSAhPT0gJ2lubGluZScpIHtcbiAgICAgIHZhciBhY3RpdmVJdGVtID0gdGhpcy5nZXRGbGF0SW5zdGFuY2VBcnJheSgpLmZpbHRlcihmdW5jdGlvbiAoYykge1xuICAgICAgICByZXR1cm4gYyAmJiBjLnByb3BzLmV2ZW50S2V5ID09PSBhY3RpdmVLZXk7XG4gICAgICB9KVswXTtcbiAgICAgIGlmIChhY3RpdmVJdGVtICYmIGFjdGl2ZUl0ZW0uaXNTdWJNZW51ICYmIGFjdGl2ZUl0ZW0ucHJvcHMuZXZlbnRLZXkgIT09IGtleSkge1xuICAgICAgICB0aGlzLm9uT3BlbkNoYW5nZSh7XG4gICAgICAgICAgaXRlbTogYWN0aXZlSXRlbSxcbiAgICAgICAgICBrZXk6IGFjdGl2ZUl0ZW0ucHJvcHMuZXZlbnRLZXksXG4gICAgICAgICAgb3BlbjogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIGdldEZsYXRJbnN0YW5jZUFycmF5OiBmdW5jdGlvbiBnZXRGbGF0SW5zdGFuY2VBcnJheSgpIHtcbiAgICB2YXIgaW5zdGFuY2VBcnJheSA9IHRoaXMuaW5zdGFuY2VBcnJheTtcbiAgICB2YXIgaGFzSW5uZXJBcnJheSA9IGluc3RhbmNlQXJyYXkuc29tZShmdW5jdGlvbiAoYSkge1xuICAgICAgcmV0dXJuIEFycmF5LmlzQXJyYXkoYSk7XG4gICAgfSk7XG4gICAgaWYgKGhhc0lubmVyQXJyYXkpIHtcbiAgICAgIGluc3RhbmNlQXJyYXkgPSBbXTtcbiAgICAgIHRoaXMuaW5zdGFuY2VBcnJheS5mb3JFYWNoKGZ1bmN0aW9uIChhKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGEpKSB7XG4gICAgICAgICAgaW5zdGFuY2VBcnJheS5wdXNoLmFwcGx5KGluc3RhbmNlQXJyYXksIGEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGluc3RhbmNlQXJyYXkucHVzaChhKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB0aGlzLmluc3RhbmNlQXJyYXkgPSBpbnN0YW5jZUFycmF5O1xuICAgIH1cbiAgICByZXR1cm4gaW5zdGFuY2VBcnJheTtcbiAgfSxcblxuICByZW5kZXJDb21tb25NZW51SXRlbTogZnVuY3Rpb24gcmVuZGVyQ29tbW9uTWVudUl0ZW0oY2hpbGQsIGksIHN1YkluZGV4LCBleHRyYVByb3BzKSB7XG4gICAgdmFyIHN0YXRlID0gdGhpcy5zdGF0ZTtcbiAgICB2YXIgcHJvcHMgPSB0aGlzLnByb3BzO1xuICAgIHZhciBrZXkgPSAoMCwgX3V0aWwuZ2V0S2V5RnJvbUNoaWxkcmVuSW5kZXgpKGNoaWxkLCBwcm9wcy5ldmVudEtleSwgaSk7XG4gICAgdmFyIGNoaWxkUHJvcHMgPSBjaGlsZC5wcm9wcztcbiAgICB2YXIgbmV3Q2hpbGRQcm9wcyA9ICgwLCBfb2JqZWN0QXNzaWduMlsnZGVmYXVsdCddKSh7XG4gICAgICBtb2RlOiBwcm9wcy5tb2RlLFxuICAgICAgbGV2ZWw6IHByb3BzLmxldmVsLFxuICAgICAgaW5saW5lSW5kZW50OiBwcm9wcy5pbmxpbmVJbmRlbnQsXG4gICAgICByZW5kZXJNZW51SXRlbTogdGhpcy5yZW5kZXJNZW51SXRlbSxcbiAgICAgIHJvb3RQcmVmaXhDbHM6IHByb3BzLnByZWZpeENscyxcbiAgICAgIGluZGV4OiBpLFxuICAgICAgcGFyZW50TWVudTogdGhpcyxcbiAgICAgIHJlZjogY2hpbGRQcm9wcy5kaXNhYmxlZCA/IHVuZGVmaW5lZCA6ICgwLCBfcmNVdGlsLmNyZWF0ZUNoYWluZWRGdW5jdGlvbikoY2hpbGQucmVmLCBzYXZlUmVmLmJpbmQodGhpcywgaSwgc3ViSW5kZXgpKSxcbiAgICAgIGV2ZW50S2V5OiBrZXksXG4gICAgICBjbG9zZVN1Yk1lbnVPbk1vdXNlTGVhdmU6IHByb3BzLmNsb3NlU3ViTWVudU9uTW91c2VMZWF2ZSxcbiAgICAgIG9uSXRlbUhvdmVyOiB0aGlzLm9uSXRlbUhvdmVyLFxuICAgICAgYWN0aXZlOiAhY2hpbGRQcm9wcy5kaXNhYmxlZCAmJiBrZXkgPT09IHN0YXRlLmFjdGl2ZUtleSxcbiAgICAgIG11bHRpcGxlOiBwcm9wcy5tdWx0aXBsZSxcbiAgICAgIG9uQ2xpY2s6IHRoaXMub25DbGljayxcbiAgICAgIG9wZW5UcmFuc2l0aW9uTmFtZTogdGhpcy5nZXRPcGVuVHJhbnNpdGlvbk5hbWUoKSxcbiAgICAgIG9wZW5BbmltYXRpb246IHByb3BzLm9wZW5BbmltYXRpb24sXG4gICAgICBvbk9wZW5DaGFuZ2U6IHRoaXMub25PcGVuQ2hhbmdlLFxuICAgICAgb25EZXNlbGVjdDogdGhpcy5vbkRlc2VsZWN0LFxuICAgICAgb25EZXN0cm95OiB0aGlzLm9uRGVzdHJveSxcbiAgICAgIG9uU2VsZWN0OiB0aGlzLm9uU2VsZWN0XG4gICAgfSwgZXh0cmFQcm9wcyk7XG4gICAgaWYgKHByb3BzLm1vZGUgPT09ICdpbmxpbmUnKSB7XG4gICAgICBuZXdDaGlsZFByb3BzLmNsb3NlU3ViTWVudU9uTW91c2VMZWF2ZSA9IG5ld0NoaWxkUHJvcHMub3BlblN1Yk1lbnVPbk1vdXNlRW50ZXIgPSBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIF9yZWFjdDJbJ2RlZmF1bHQnXS5jbG9uZUVsZW1lbnQoY2hpbGQsIG5ld0NoaWxkUHJvcHMpO1xuICB9LFxuXG4gIHJlbmRlclJvb3Q6IGZ1bmN0aW9uIHJlbmRlclJvb3QocHJvcHMpIHtcbiAgICB2YXIgX2NsYXNzZXM7XG5cbiAgICB0aGlzLmluc3RhbmNlQXJyYXkgPSBbXTtcbiAgICB2YXIgY2xhc3NlcyA9IChfY2xhc3NlcyA9IHt9LCBfZGVmaW5lUHJvcGVydHkoX2NsYXNzZXMsIHByb3BzLnByZWZpeENscywgMSksIF9kZWZpbmVQcm9wZXJ0eShfY2xhc3NlcywgcHJvcHMucHJlZml4Q2xzICsgJy0nICsgcHJvcHMubW9kZSwgMSksIF9kZWZpbmVQcm9wZXJ0eShfY2xhc3NlcywgcHJvcHMuY2xhc3NOYW1lLCAhIXByb3BzLmNsYXNzTmFtZSksIF9jbGFzc2VzKTtcbiAgICB2YXIgZG9tUHJvcHMgPSB7XG4gICAgICBjbGFzc05hbWU6ICgwLCBfY2xhc3NuYW1lczJbJ2RlZmF1bHQnXSkoY2xhc3NlcyksXG4gICAgICByb2xlOiAnbWVudScsXG4gICAgICAnYXJpYS1hY3RpdmVkZXNjZW5kYW50JzogJydcbiAgICB9O1xuICAgIGlmIChwcm9wcy5pZCkge1xuICAgICAgZG9tUHJvcHMuaWQgPSBwcm9wcy5pZDtcbiAgICB9XG4gICAgaWYgKHByb3BzLmZvY3VzYWJsZSkge1xuICAgICAgZG9tUHJvcHMudGFiSW5kZXggPSAnMCc7XG4gICAgICBkb21Qcm9wcy5vbktleURvd24gPSB0aGlzLm9uS2V5RG93bjtcbiAgICB9XG4gICAgcmV0dXJuKFxuICAgICAgLy8gRVNMaW50IGlzIG5vdCBzbWFydCBlbm91Z2ggdG8ga25vdyB0aGF0IHRoZSB0eXBlIG9mIGBjaGlsZHJlbmAgd2FzIGNoZWNrZWQuXG4gICAgICAvKiBlc2xpbnQtZGlzYWJsZSAqL1xuICAgICAgX3JlYWN0MlsnZGVmYXVsdCddLmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgIF9ET01XcmFwMlsnZGVmYXVsdCddLFxuICAgICAgICBfZXh0ZW5kcyh7IHN0eWxlOiBwcm9wcy5zdHlsZSxcbiAgICAgICAgICB0YWc6ICd1bCcsXG4gICAgICAgICAgaGlkZGVuQ2xhc3NOYW1lOiBwcm9wcy5wcmVmaXhDbHMgKyAnLWhpZGRlbicsXG4gICAgICAgICAgdmlzaWJsZTogcHJvcHMudmlzaWJsZVxuICAgICAgICB9LCBkb21Qcm9wcyksXG4gICAgICAgIF9yZWFjdDJbJ2RlZmF1bHQnXS5DaGlsZHJlbi5tYXAocHJvcHMuY2hpbGRyZW4sIHRoaXMucmVuZGVyTWVudUl0ZW0pXG4gICAgICApXG4gICAgICAvKmVzbGludC1lbmFibGUgKi9cblxuICAgICk7XG4gIH0sXG5cbiAgc3RlcDogZnVuY3Rpb24gc3RlcChkaXJlY3Rpb24pIHtcbiAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLmdldEZsYXRJbnN0YW5jZUFycmF5KCk7XG4gICAgdmFyIGFjdGl2ZUtleSA9IHRoaXMuc3RhdGUuYWN0aXZlS2V5O1xuICAgIHZhciBsZW4gPSBjaGlsZHJlbi5sZW5ndGg7XG4gICAgaWYgKGRpcmVjdGlvbiA8IDApIHtcbiAgICAgIGNoaWxkcmVuID0gY2hpbGRyZW4uY29uY2F0KCkucmV2ZXJzZSgpO1xuICAgIH1cbiAgICAvLyBmaW5kIGN1cnJlbnQgYWN0aXZlSW5kZXhcbiAgICB2YXIgYWN0aXZlSW5kZXggPSAtMTtcbiAgICBjaGlsZHJlbi5ldmVyeShmdW5jdGlvbiAoYywgY2kpIHtcbiAgICAgIGlmIChjICYmIGMucHJvcHMuZXZlbnRLZXkgPT09IGFjdGl2ZUtleSkge1xuICAgICAgICBhY3RpdmVJbmRleCA9IGNpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9KTtcbiAgICBpZiAoIXRoaXMucHJvcHMuZGVmYXVsdEFjdGl2ZUZpcnN0ICYmIGFjdGl2ZUluZGV4ICE9PSAtMSkge1xuICAgICAgaWYgKGFsbERpc2FibGVkKGNoaWxkcmVuLnNsaWNlKGFjdGl2ZUluZGV4LCBsZW4gLSAxKSkpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIHN0YXJ0ID0gKGFjdGl2ZUluZGV4ICsgMSkgJSBsZW47XG4gICAgdmFyIGkgPSBzdGFydDtcbiAgICBmb3IgKDs7KSB7XG4gICAgICB2YXIgY2hpbGQgPSBjaGlsZHJlbltpXTtcbiAgICAgIGlmICghY2hpbGQgfHwgY2hpbGQucHJvcHMuZGlzYWJsZWQpIHtcbiAgICAgICAgaSA9IChpICsgMSArIGxlbikgJSBsZW47XG4gICAgICAgIC8vIGNvbXBsZXRlIGEgbG9vcFxuICAgICAgICBpZiAoaSA9PT0gc3RhcnQpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGNoaWxkO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuZXhwb3J0c1snZGVmYXVsdCddID0gTWVudU1peGluO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vdXhjb3JlLXRhYmxlL34vdXhjb3JlLW1lbnUvfi9yYy1tZW51L2xpYi9NZW51TWl4aW4uanNcbiAqKiBtb2R1bGUgaWQgPSAxNFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgc2VlZCA9IDA7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGd1aWQoKSB7XG4gIHJldHVybiBEYXRlLm5vdygpICsgJ18nICsgc2VlZCsrO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi91eGNvcmUtdGFibGUvfi91eGNvcmUtbWVudS9+L3JjLW1lbnUvfi9yYy11dGlsL2xpYi9ndWlkLmpzXG4gKiogbW9kdWxlIGlkID0gMTZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGRlcHJlY2F0ZTtcblxuLyoqXG4gKiBNYXJrIHRoYXQgYSBtZXRob2Qgc2hvdWxkIG5vdCBiZSB1c2VkLlxuICogUmV0dXJucyBhIG1vZGlmaWVkIGZ1bmN0aW9uIHdoaWNoIHdhcm5zIG9uY2UgYnkgZGVmYXVsdC5cbiAqXG4gKiBJZiBgbG9jYWxTdG9yYWdlLm5vRGVwcmVjYXRpb24gPSB0cnVlYCBpcyBzZXQsIHRoZW4gaXQgaXMgYSBuby1vcC5cbiAqXG4gKiBJZiBgbG9jYWxTdG9yYWdlLnRocm93RGVwcmVjYXRpb24gPSB0cnVlYCBpcyBzZXQsIHRoZW4gZGVwcmVjYXRlZCBmdW5jdGlvbnNcbiAqIHdpbGwgdGhyb3cgYW4gRXJyb3Igd2hlbiBpbnZva2VkLlxuICpcbiAqIElmIGBsb2NhbFN0b3JhZ2UudHJhY2VEZXByZWNhdGlvbiA9IHRydWVgIGlzIHNldCwgdGhlbiBkZXByZWNhdGVkIGZ1bmN0aW9uc1xuICogd2lsbCBpbnZva2UgYGNvbnNvbGUudHJhY2UoKWAgaW5zdGVhZCBvZiBgY29uc29sZS5lcnJvcigpYC5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiAtIHRoZSBmdW5jdGlvbiB0byBkZXByZWNhdGVcbiAqIEBwYXJhbSB7U3RyaW5nfSBtc2cgLSB0aGUgc3RyaW5nIHRvIHByaW50IHRvIHRoZSBjb25zb2xlIHdoZW4gYGZuYCBpcyBpbnZva2VkXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IGEgbmV3IFwiZGVwcmVjYXRlZFwiIHZlcnNpb24gb2YgYGZuYFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBkZXByZWNhdGUgKGZuLCBtc2cpIHtcbiAgaWYgKGNvbmZpZygnbm9EZXByZWNhdGlvbicpKSB7XG4gICAgcmV0dXJuIGZuO1xuICB9XG5cbiAgdmFyIHdhcm5lZCA9IGZhbHNlO1xuICBmdW5jdGlvbiBkZXByZWNhdGVkKCkge1xuICAgIGlmICghd2FybmVkKSB7XG4gICAgICBpZiAoY29uZmlnKCd0aHJvd0RlcHJlY2F0aW9uJykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgICB9IGVsc2UgaWYgKGNvbmZpZygndHJhY2VEZXByZWNhdGlvbicpKSB7XG4gICAgICAgIGNvbnNvbGUudHJhY2UobXNnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUud2Fybihtc2cpO1xuICAgICAgfVxuICAgICAgd2FybmVkID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICByZXR1cm4gZGVwcmVjYXRlZDtcbn1cblxuLyoqXG4gKiBDaGVja3MgYGxvY2FsU3RvcmFnZWAgZm9yIGJvb2xlYW4gdmFsdWVzIGZvciB0aGUgZ2l2ZW4gYG5hbWVgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGNvbmZpZyAobmFtZSkge1xuICAvLyBhY2Nlc3NpbmcgZ2xvYmFsLmxvY2FsU3RvcmFnZSBjYW4gdHJpZ2dlciBhIERPTUV4Y2VwdGlvbiBpbiBzYW5kYm94ZWQgaWZyYW1lc1xuICB0cnkge1xuICAgIGlmICghZ2xvYmFsLmxvY2FsU3RvcmFnZSkgcmV0dXJuIGZhbHNlO1xuICB9IGNhdGNoIChfKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciB2YWwgPSBnbG9iYWwubG9jYWxTdG9yYWdlW25hbWVdO1xuICBpZiAobnVsbCA9PSB2YWwpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIFN0cmluZyh2YWwpLnRvTG93ZXJDYXNlKCkgPT09ICd0cnVlJztcbn1cblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3V4Y29yZS10YWJsZS9+L3V4Y29yZS1tZW51L34vcmMtbWVudS9+L3JjLXV0aWwvfi91dGlsLWRlcHJlY2F0ZS9icm93c2VyLmpzXG4gKiogbW9kdWxlIGlkID0gMThcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qIVxuICBDb3B5cmlnaHQgKGMpIDIwMTUgSmVkIFdhdHNvbi5cbiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlIChNSVQpLCBzZWVcbiAgaHR0cDovL2plZHdhdHNvbi5naXRodWIuaW8vY2xhc3NuYW1lc1xuKi9cbi8qIGdsb2JhbCBkZWZpbmUgKi9cblxuKGZ1bmN0aW9uICgpIHtcblx0J3VzZSBzdHJpY3QnO1xuXG5cdHZhciBoYXNPd24gPSB7fS5oYXNPd25Qcm9wZXJ0eTtcblxuXHRmdW5jdGlvbiBjbGFzc05hbWVzICgpIHtcblx0XHR2YXIgY2xhc3NlcyA9ICcnO1xuXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBhcmcgPSBhcmd1bWVudHNbaV07XG5cdFx0XHRpZiAoIWFyZykgY29udGludWU7XG5cblx0XHRcdHZhciBhcmdUeXBlID0gdHlwZW9mIGFyZztcblxuXHRcdFx0aWYgKGFyZ1R5cGUgPT09ICdzdHJpbmcnIHx8IGFyZ1R5cGUgPT09ICdudW1iZXInKSB7XG5cdFx0XHRcdGNsYXNzZXMgKz0gJyAnICsgYXJnO1xuXHRcdFx0fSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGFyZykpIHtcblx0XHRcdFx0Y2xhc3NlcyArPSAnICcgKyBjbGFzc05hbWVzLmFwcGx5KG51bGwsIGFyZyk7XG5cdFx0XHR9IGVsc2UgaWYgKGFyZ1R5cGUgPT09ICdvYmplY3QnKSB7XG5cdFx0XHRcdGZvciAodmFyIGtleSBpbiBhcmcpIHtcblx0XHRcdFx0XHRpZiAoaGFzT3duLmNhbGwoYXJnLCBrZXkpICYmIGFyZ1trZXldKSB7XG5cdFx0XHRcdFx0XHRjbGFzc2VzICs9ICcgJyArIGtleTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gY2xhc3Nlcy5zdWJzdHIoMSk7XG5cdH1cblxuXHRpZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlLmV4cG9ydHMpIHtcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGNsYXNzTmFtZXM7XG5cdH0gZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgZGVmaW5lLmFtZCA9PT0gJ29iamVjdCcgJiYgZGVmaW5lLmFtZCkge1xuXHRcdC8vIHJlZ2lzdGVyIGFzICdjbGFzc25hbWVzJywgY29uc2lzdGVudCB3aXRoIG5wbSBwYWNrYWdlIG5hbWVcblx0XHRkZWZpbmUoJ2NsYXNzbmFtZXMnLCBmdW5jdGlvbiAoKSB7XG5cdFx0XHRyZXR1cm4gY2xhc3NOYW1lcztcblx0XHR9KTtcblx0fSBlbHNlIHtcblx0XHR3aW5kb3cuY2xhc3NOYW1lcyA9IGNsYXNzTmFtZXM7XG5cdH1cbn0oKSk7XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jbGFzc25hbWVzL2luZGV4LmpzXG4gKiogbW9kdWxlIGlkID0gMTlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQGlnbm9yZVxuICogc29tZSBrZXktY29kZXMgZGVmaW5pdGlvbiBhbmQgdXRpbHMgZnJvbSBjbG9zdXJlLWxpYnJhcnlcbiAqIEBhdXRob3IgeWltaW5naGVAZ21haWwuY29tXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgS2V5Q29kZSA9IHtcbiAgLyoqXG4gICAqIE1BQ19FTlRFUlxuICAgKi9cbiAgTUFDX0VOVEVSOiAzLFxuICAvKipcbiAgICogQkFDS1NQQUNFXG4gICAqL1xuICBCQUNLU1BBQ0U6IDgsXG4gIC8qKlxuICAgKiBUQUJcbiAgICovXG4gIFRBQjogOSxcbiAgLyoqXG4gICAqIE5VTUxPQ0sgb24gRkYvU2FmYXJpIE1hY1xuICAgKi9cbiAgTlVNX0NFTlRFUjogMTIsIC8vIE5VTUxPQ0sgb24gRkYvU2FmYXJpIE1hY1xuICAvKipcbiAgICogRU5URVJcbiAgICovXG4gIEVOVEVSOiAxMyxcbiAgLyoqXG4gICAqIFNISUZUXG4gICAqL1xuICBTSElGVDogMTYsXG4gIC8qKlxuICAgKiBDVFJMXG4gICAqL1xuICBDVFJMOiAxNyxcbiAgLyoqXG4gICAqIEFMVFxuICAgKi9cbiAgQUxUOiAxOCxcbiAgLyoqXG4gICAqIFBBVVNFXG4gICAqL1xuICBQQVVTRTogMTksXG4gIC8qKlxuICAgKiBDQVBTX0xPQ0tcbiAgICovXG4gIENBUFNfTE9DSzogMjAsXG4gIC8qKlxuICAgKiBFU0NcbiAgICovXG4gIEVTQzogMjcsXG4gIC8qKlxuICAgKiBTUEFDRVxuICAgKi9cbiAgU1BBQ0U6IDMyLFxuICAvKipcbiAgICogUEFHRV9VUFxuICAgKi9cbiAgUEFHRV9VUDogMzMsIC8vIGFsc28gTlVNX05PUlRIX0VBU1RcbiAgLyoqXG4gICAqIFBBR0VfRE9XTlxuICAgKi9cbiAgUEFHRV9ET1dOOiAzNCwgLy8gYWxzbyBOVU1fU09VVEhfRUFTVFxuICAvKipcbiAgICogRU5EXG4gICAqL1xuICBFTkQ6IDM1LCAvLyBhbHNvIE5VTV9TT1VUSF9XRVNUXG4gIC8qKlxuICAgKiBIT01FXG4gICAqL1xuICBIT01FOiAzNiwgLy8gYWxzbyBOVU1fTk9SVEhfV0VTVFxuICAvKipcbiAgICogTEVGVFxuICAgKi9cbiAgTEVGVDogMzcsIC8vIGFsc28gTlVNX1dFU1RcbiAgLyoqXG4gICAqIFVQXG4gICAqL1xuICBVUDogMzgsIC8vIGFsc28gTlVNX05PUlRIXG4gIC8qKlxuICAgKiBSSUdIVFxuICAgKi9cbiAgUklHSFQ6IDM5LCAvLyBhbHNvIE5VTV9FQVNUXG4gIC8qKlxuICAgKiBET1dOXG4gICAqL1xuICBET1dOOiA0MCwgLy8gYWxzbyBOVU1fU09VVEhcbiAgLyoqXG4gICAqIFBSSU5UX1NDUkVFTlxuICAgKi9cbiAgUFJJTlRfU0NSRUVOOiA0NCxcbiAgLyoqXG4gICAqIElOU0VSVFxuICAgKi9cbiAgSU5TRVJUOiA0NSwgLy8gYWxzbyBOVU1fSU5TRVJUXG4gIC8qKlxuICAgKiBERUxFVEVcbiAgICovXG4gIERFTEVURTogNDYsIC8vIGFsc28gTlVNX0RFTEVURVxuICAvKipcbiAgICogWkVST1xuICAgKi9cbiAgWkVSTzogNDgsXG4gIC8qKlxuICAgKiBPTkVcbiAgICovXG4gIE9ORTogNDksXG4gIC8qKlxuICAgKiBUV09cbiAgICovXG4gIFRXTzogNTAsXG4gIC8qKlxuICAgKiBUSFJFRVxuICAgKi9cbiAgVEhSRUU6IDUxLFxuICAvKipcbiAgICogRk9VUlxuICAgKi9cbiAgRk9VUjogNTIsXG4gIC8qKlxuICAgKiBGSVZFXG4gICAqL1xuICBGSVZFOiA1MyxcbiAgLyoqXG4gICAqIFNJWFxuICAgKi9cbiAgU0lYOiA1NCxcbiAgLyoqXG4gICAqIFNFVkVOXG4gICAqL1xuICBTRVZFTjogNTUsXG4gIC8qKlxuICAgKiBFSUdIVFxuICAgKi9cbiAgRUlHSFQ6IDU2LFxuICAvKipcbiAgICogTklORVxuICAgKi9cbiAgTklORTogNTcsXG4gIC8qKlxuICAgKiBRVUVTVElPTl9NQVJLXG4gICAqL1xuICBRVUVTVElPTl9NQVJLOiA2MywgLy8gbmVlZHMgbG9jYWxpemF0aW9uXG4gIC8qKlxuICAgKiBBXG4gICAqL1xuICBBOiA2NSxcbiAgLyoqXG4gICAqIEJcbiAgICovXG4gIEI6IDY2LFxuICAvKipcbiAgICogQ1xuICAgKi9cbiAgQzogNjcsXG4gIC8qKlxuICAgKiBEXG4gICAqL1xuICBEOiA2OCxcbiAgLyoqXG4gICAqIEVcbiAgICovXG4gIEU6IDY5LFxuICAvKipcbiAgICogRlxuICAgKi9cbiAgRjogNzAsXG4gIC8qKlxuICAgKiBHXG4gICAqL1xuICBHOiA3MSxcbiAgLyoqXG4gICAqIEhcbiAgICovXG4gIEg6IDcyLFxuICAvKipcbiAgICogSVxuICAgKi9cbiAgSTogNzMsXG4gIC8qKlxuICAgKiBKXG4gICAqL1xuICBKOiA3NCxcbiAgLyoqXG4gICAqIEtcbiAgICovXG4gIEs6IDc1LFxuICAvKipcbiAgICogTFxuICAgKi9cbiAgTDogNzYsXG4gIC8qKlxuICAgKiBNXG4gICAqL1xuICBNOiA3NyxcbiAgLyoqXG4gICAqIE5cbiAgICovXG4gIE46IDc4LFxuICAvKipcbiAgICogT1xuICAgKi9cbiAgTzogNzksXG4gIC8qKlxuICAgKiBQXG4gICAqL1xuICBQOiA4MCxcbiAgLyoqXG4gICAqIFFcbiAgICovXG4gIFE6IDgxLFxuICAvKipcbiAgICogUlxuICAgKi9cbiAgUjogODIsXG4gIC8qKlxuICAgKiBTXG4gICAqL1xuICBTOiA4MyxcbiAgLyoqXG4gICAqIFRcbiAgICovXG4gIFQ6IDg0LFxuICAvKipcbiAgICogVVxuICAgKi9cbiAgVTogODUsXG4gIC8qKlxuICAgKiBWXG4gICAqL1xuICBWOiA4NixcbiAgLyoqXG4gICAqIFdcbiAgICovXG4gIFc6IDg3LFxuICAvKipcbiAgICogWFxuICAgKi9cbiAgWDogODgsXG4gIC8qKlxuICAgKiBZXG4gICAqL1xuICBZOiA4OSxcbiAgLyoqXG4gICAqIFpcbiAgICovXG4gIFo6IDkwLFxuICAvKipcbiAgICogTUVUQVxuICAgKi9cbiAgTUVUQTogOTEsIC8vIFdJTl9LRVlfTEVGVFxuICAvKipcbiAgICogV0lOX0tFWV9SSUdIVFxuICAgKi9cbiAgV0lOX0tFWV9SSUdIVDogOTIsXG4gIC8qKlxuICAgKiBDT05URVhUX01FTlVcbiAgICovXG4gIENPTlRFWFRfTUVOVTogOTMsXG4gIC8qKlxuICAgKiBOVU1fWkVST1xuICAgKi9cbiAgTlVNX1pFUk86IDk2LFxuICAvKipcbiAgICogTlVNX09ORVxuICAgKi9cbiAgTlVNX09ORTogOTcsXG4gIC8qKlxuICAgKiBOVU1fVFdPXG4gICAqL1xuICBOVU1fVFdPOiA5OCxcbiAgLyoqXG4gICAqIE5VTV9USFJFRVxuICAgKi9cbiAgTlVNX1RIUkVFOiA5OSxcbiAgLyoqXG4gICAqIE5VTV9GT1VSXG4gICAqL1xuICBOVU1fRk9VUjogMTAwLFxuICAvKipcbiAgICogTlVNX0ZJVkVcbiAgICovXG4gIE5VTV9GSVZFOiAxMDEsXG4gIC8qKlxuICAgKiBOVU1fU0lYXG4gICAqL1xuICBOVU1fU0lYOiAxMDIsXG4gIC8qKlxuICAgKiBOVU1fU0VWRU5cbiAgICovXG4gIE5VTV9TRVZFTjogMTAzLFxuICAvKipcbiAgICogTlVNX0VJR0hUXG4gICAqL1xuICBOVU1fRUlHSFQ6IDEwNCxcbiAgLyoqXG4gICAqIE5VTV9OSU5FXG4gICAqL1xuICBOVU1fTklORTogMTA1LFxuICAvKipcbiAgICogTlVNX01VTFRJUExZXG4gICAqL1xuICBOVU1fTVVMVElQTFk6IDEwNixcbiAgLyoqXG4gICAqIE5VTV9QTFVTXG4gICAqL1xuICBOVU1fUExVUzogMTA3LFxuICAvKipcbiAgICogTlVNX01JTlVTXG4gICAqL1xuICBOVU1fTUlOVVM6IDEwOSxcbiAgLyoqXG4gICAqIE5VTV9QRVJJT0RcbiAgICovXG4gIE5VTV9QRVJJT0Q6IDExMCxcbiAgLyoqXG4gICAqIE5VTV9ESVZJU0lPTlxuICAgKi9cbiAgTlVNX0RJVklTSU9OOiAxMTEsXG4gIC8qKlxuICAgKiBGMVxuICAgKi9cbiAgRjE6IDExMixcbiAgLyoqXG4gICAqIEYyXG4gICAqL1xuICBGMjogMTEzLFxuICAvKipcbiAgICogRjNcbiAgICovXG4gIEYzOiAxMTQsXG4gIC8qKlxuICAgKiBGNFxuICAgKi9cbiAgRjQ6IDExNSxcbiAgLyoqXG4gICAqIEY1XG4gICAqL1xuICBGNTogMTE2LFxuICAvKipcbiAgICogRjZcbiAgICovXG4gIEY2OiAxMTcsXG4gIC8qKlxuICAgKiBGN1xuICAgKi9cbiAgRjc6IDExOCxcbiAgLyoqXG4gICAqIEY4XG4gICAqL1xuICBGODogMTE5LFxuICAvKipcbiAgICogRjlcbiAgICovXG4gIEY5OiAxMjAsXG4gIC8qKlxuICAgKiBGMTBcbiAgICovXG4gIEYxMDogMTIxLFxuICAvKipcbiAgICogRjExXG4gICAqL1xuICBGMTE6IDEyMixcbiAgLyoqXG4gICAqIEYxMlxuICAgKi9cbiAgRjEyOiAxMjMsXG4gIC8qKlxuICAgKiBOVU1MT0NLXG4gICAqL1xuICBOVU1MT0NLOiAxNDQsXG4gIC8qKlxuICAgKiBTRU1JQ09MT05cbiAgICovXG4gIFNFTUlDT0xPTjogMTg2LCAvLyBuZWVkcyBsb2NhbGl6YXRpb25cbiAgLyoqXG4gICAqIERBU0hcbiAgICovXG4gIERBU0g6IDE4OSwgLy8gbmVlZHMgbG9jYWxpemF0aW9uXG4gIC8qKlxuICAgKiBFUVVBTFNcbiAgICovXG4gIEVRVUFMUzogMTg3LCAvLyBuZWVkcyBsb2NhbGl6YXRpb25cbiAgLyoqXG4gICAqIENPTU1BXG4gICAqL1xuICBDT01NQTogMTg4LCAvLyBuZWVkcyBsb2NhbGl6YXRpb25cbiAgLyoqXG4gICAqIFBFUklPRFxuICAgKi9cbiAgUEVSSU9EOiAxOTAsIC8vIG5lZWRzIGxvY2FsaXphdGlvblxuICAvKipcbiAgICogU0xBU0hcbiAgICovXG4gIFNMQVNIOiAxOTEsIC8vIG5lZWRzIGxvY2FsaXphdGlvblxuICAvKipcbiAgICogQVBPU1RST1BIRVxuICAgKi9cbiAgQVBPU1RST1BIRTogMTkyLCAvLyBuZWVkcyBsb2NhbGl6YXRpb25cbiAgLyoqXG4gICAqIFNJTkdMRV9RVU9URVxuICAgKi9cbiAgU0lOR0xFX1FVT1RFOiAyMjIsIC8vIG5lZWRzIGxvY2FsaXphdGlvblxuICAvKipcbiAgICogT1BFTl9TUVVBUkVfQlJBQ0tFVFxuICAgKi9cbiAgT1BFTl9TUVVBUkVfQlJBQ0tFVDogMjE5LCAvLyBuZWVkcyBsb2NhbGl6YXRpb25cbiAgLyoqXG4gICAqIEJBQ0tTTEFTSFxuICAgKi9cbiAgQkFDS1NMQVNIOiAyMjAsIC8vIG5lZWRzIGxvY2FsaXphdGlvblxuICAvKipcbiAgICogQ0xPU0VfU1FVQVJFX0JSQUNLRVRcbiAgICovXG4gIENMT1NFX1NRVUFSRV9CUkFDS0VUOiAyMjEsIC8vIG5lZWRzIGxvY2FsaXphdGlvblxuICAvKipcbiAgICogV0lOX0tFWVxuICAgKi9cbiAgV0lOX0tFWTogMjI0LFxuICAvKipcbiAgICogTUFDX0ZGX01FVEFcbiAgICovXG4gIE1BQ19GRl9NRVRBOiAyMjQsIC8vIEZpcmVmb3ggKEdlY2tvKSBmaXJlcyB0aGlzIGZvciB0aGUgbWV0YSBrZXkgaW5zdGVhZCBvZiA5MVxuICAvKipcbiAgICogV0lOX0lNRVxuICAgKi9cbiAgV0lOX0lNRTogMjI5XG59O1xuXG4vKlxuIHdoZXRoZXIgdGV4dCBhbmQgbW9kaWZpZWQga2V5IGlzIGVudGVyZWQgYXQgdGhlIHNhbWUgdGltZS5cbiAqL1xuS2V5Q29kZS5pc1RleHRNb2RpZnlpbmdLZXlFdmVudCA9IGZ1bmN0aW9uIGlzVGV4dE1vZGlmeWluZ0tleUV2ZW50KGUpIHtcbiAgdmFyIGtleUNvZGUgPSBlLmtleUNvZGU7XG4gIGlmIChlLmFsdEtleSAmJiAhZS5jdHJsS2V5IHx8IGUubWV0YUtleSB8fFxuICAvLyBGdW5jdGlvbiBrZXlzIGRvbid0IGdlbmVyYXRlIHRleHRcbiAga2V5Q29kZSA+PSBLZXlDb2RlLkYxICYmIGtleUNvZGUgPD0gS2V5Q29kZS5GMTIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBUaGUgZm9sbG93aW5nIGtleXMgYXJlIHF1aXRlIGhhcm1sZXNzLCBldmVuIGluIGNvbWJpbmF0aW9uIHdpdGhcbiAgLy8gQ1RSTCwgQUxUIG9yIFNISUZULlxuICBzd2l0Y2ggKGtleUNvZGUpIHtcbiAgICBjYXNlIEtleUNvZGUuQUxUOlxuICAgIGNhc2UgS2V5Q29kZS5DQVBTX0xPQ0s6XG4gICAgY2FzZSBLZXlDb2RlLkNPTlRFWFRfTUVOVTpcbiAgICBjYXNlIEtleUNvZGUuQ1RSTDpcbiAgICBjYXNlIEtleUNvZGUuRE9XTjpcbiAgICBjYXNlIEtleUNvZGUuRU5EOlxuICAgIGNhc2UgS2V5Q29kZS5FU0M6XG4gICAgY2FzZSBLZXlDb2RlLkhPTUU6XG4gICAgY2FzZSBLZXlDb2RlLklOU0VSVDpcbiAgICBjYXNlIEtleUNvZGUuTEVGVDpcbiAgICBjYXNlIEtleUNvZGUuTUFDX0ZGX01FVEE6XG4gICAgY2FzZSBLZXlDb2RlLk1FVEE6XG4gICAgY2FzZSBLZXlDb2RlLk5VTUxPQ0s6XG4gICAgY2FzZSBLZXlDb2RlLk5VTV9DRU5URVI6XG4gICAgY2FzZSBLZXlDb2RlLlBBR0VfRE9XTjpcbiAgICBjYXNlIEtleUNvZGUuUEFHRV9VUDpcbiAgICBjYXNlIEtleUNvZGUuUEFVU0U6XG4gICAgY2FzZSBLZXlDb2RlLlBSSU5UX1NDUkVFTjpcbiAgICBjYXNlIEtleUNvZGUuUklHSFQ6XG4gICAgY2FzZSBLZXlDb2RlLlNISUZUOlxuICAgIGNhc2UgS2V5Q29kZS5VUDpcbiAgICBjYXNlIEtleUNvZGUuV0lOX0tFWTpcbiAgICBjYXNlIEtleUNvZGUuV0lOX0tFWV9SSUdIVDpcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIHRydWU7XG4gIH1cbn07XG5cbi8qXG4gd2hldGhlciBjaGFyYWN0ZXIgaXMgZW50ZXJlZC5cbiAqL1xuS2V5Q29kZS5pc0NoYXJhY3RlcktleSA9IGZ1bmN0aW9uIGlzQ2hhcmFjdGVyS2V5KGtleUNvZGUpIHtcbiAgaWYgKGtleUNvZGUgPj0gS2V5Q29kZS5aRVJPICYmIGtleUNvZGUgPD0gS2V5Q29kZS5OSU5FKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAoa2V5Q29kZSA+PSBLZXlDb2RlLk5VTV9aRVJPICYmIGtleUNvZGUgPD0gS2V5Q29kZS5OVU1fTVVMVElQTFkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmIChrZXlDb2RlID49IEtleUNvZGUuQSAmJiBrZXlDb2RlIDw9IEtleUNvZGUuWikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLy8gU2FmYXJpIHNlbmRzIHplcm8ga2V5IGNvZGUgZm9yIG5vbi1sYXRpbiBjaGFyYWN0ZXJzLlxuICBpZiAod2luZG93Lm5hdmlnYXRpb24udXNlckFnZW50LmluZGV4T2YoJ1dlYktpdCcpICE9PSAtMSAmJiBrZXlDb2RlID09PSAwKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBzd2l0Y2ggKGtleUNvZGUpIHtcbiAgICBjYXNlIEtleUNvZGUuU1BBQ0U6XG4gICAgY2FzZSBLZXlDb2RlLlFVRVNUSU9OX01BUks6XG4gICAgY2FzZSBLZXlDb2RlLk5VTV9QTFVTOlxuICAgIGNhc2UgS2V5Q29kZS5OVU1fTUlOVVM6XG4gICAgY2FzZSBLZXlDb2RlLk5VTV9QRVJJT0Q6XG4gICAgY2FzZSBLZXlDb2RlLk5VTV9ESVZJU0lPTjpcbiAgICBjYXNlIEtleUNvZGUuU0VNSUNPTE9OOlxuICAgIGNhc2UgS2V5Q29kZS5EQVNIOlxuICAgIGNhc2UgS2V5Q29kZS5FUVVBTFM6XG4gICAgY2FzZSBLZXlDb2RlLkNPTU1BOlxuICAgIGNhc2UgS2V5Q29kZS5QRVJJT0Q6XG4gICAgY2FzZSBLZXlDb2RlLlNMQVNIOlxuICAgIGNhc2UgS2V5Q29kZS5BUE9TVFJPUEhFOlxuICAgIGNhc2UgS2V5Q29kZS5TSU5HTEVfUVVPVEU6XG4gICAgY2FzZSBLZXlDb2RlLk9QRU5fU1FVQVJFX0JSQUNLRVQ6XG4gICAgY2FzZSBLZXlDb2RlLkJBQ0tTTEFTSDpcbiAgICBjYXNlIEtleUNvZGUuQ0xPU0VfU1FVQVJFX0JSQUNLRVQ6XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEtleUNvZGU7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vdXhjb3JlLXRhYmxlL34vdXhjb3JlLW1lbnUvfi9yYy1tZW51L34vcmMtdXRpbC9saWIvS2V5Q29kZS5qc1xuICoqIG1vZHVsZSBpZCA9IDIxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIGxvZGFzaCAzLjkuMSAoQ3VzdG9tIEJ1aWxkKSA8aHR0cHM6Ly9sb2Rhc2guY29tLz5cbiAqIEJ1aWxkOiBgbG9kYXNoIG1vZGVybiBtb2R1bGFyaXplIGV4cG9ydHM9XCJucG1cIiAtbyAuL2BcbiAqIENvcHlyaWdodCAyMDEyLTIwMTUgVGhlIERvam8gRm91bmRhdGlvbiA8aHR0cDovL2Rvam9mb3VuZGF0aW9uLm9yZy8+XG4gKiBCYXNlZCBvbiBVbmRlcnNjb3JlLmpzIDEuOC4zIDxodHRwOi8vdW5kZXJzY29yZWpzLm9yZy9MSUNFTlNFPlxuICogQ29weXJpZ2h0IDIwMDktMjAxNSBKZXJlbXkgQXNoa2VuYXMsIERvY3VtZW50Q2xvdWQgYW5kIEludmVzdGlnYXRpdmUgUmVwb3J0ZXJzICYgRWRpdG9yc1xuICogQXZhaWxhYmxlIHVuZGVyIE1JVCBsaWNlbnNlIDxodHRwczovL2xvZGFzaC5jb20vbGljZW5zZT5cbiAqL1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgZnVuY1RhZyA9ICdbb2JqZWN0IEZ1bmN0aW9uXSc7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBob3N0IGNvbnN0cnVjdG9ycyAoU2FmYXJpID4gNSkuICovXG52YXIgcmVJc0hvc3RDdG9yID0gL15cXFtvYmplY3QgLis/Q29uc3RydWN0b3JcXF0kLztcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc09iamVjdExpa2UodmFsdWUpIHtcbiAgcmV0dXJuICEhdmFsdWUgJiYgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnO1xufVxuXG4vKiogVXNlZCBmb3IgbmF0aXZlIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gcmVzb2x2ZSB0aGUgZGVjb21waWxlZCBzb3VyY2Ugb2YgZnVuY3Rpb25zLiAqL1xudmFyIGZuVG9TdHJpbmcgPSBGdW5jdGlvbi5wcm90b3R5cGUudG9TdHJpbmc7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogVXNlZCB0byByZXNvbHZlIHRoZSBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAqIG9mIHZhbHVlcy5cbiAqL1xudmFyIG9ialRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBpZiBhIG1ldGhvZCBpcyBuYXRpdmUuICovXG52YXIgcmVJc05hdGl2ZSA9IFJlZ0V4cCgnXicgK1xuICBmblRvU3RyaW5nLmNhbGwoaGFzT3duUHJvcGVydHkpLnJlcGxhY2UoL1tcXFxcXiQuKis/KClbXFxde318XS9nLCAnXFxcXCQmJylcbiAgLnJlcGxhY2UoL2hhc093blByb3BlcnR5fChmdW5jdGlvbikuKj8oPz1cXFxcXFwoKXwgZm9yIC4rPyg/PVxcXFxcXF0pL2csICckMS4qPycpICsgJyQnXG4pO1xuXG4vKipcbiAqIEdldHMgdGhlIG5hdGl2ZSBmdW5jdGlvbiBhdCBga2V5YCBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBtZXRob2QgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGZ1bmN0aW9uIGlmIGl0J3MgbmF0aXZlLCBlbHNlIGB1bmRlZmluZWRgLlxuICovXG5mdW5jdGlvbiBnZXROYXRpdmUob2JqZWN0LCBrZXkpIHtcbiAgdmFyIHZhbHVlID0gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQgOiBvYmplY3Rba2V5XTtcbiAgcmV0dXJuIGlzTmF0aXZlKHZhbHVlKSA/IHZhbHVlIDogdW5kZWZpbmVkO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgRnVuY3Rpb25gIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgY29ycmVjdGx5IGNsYXNzaWZpZWQsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0Z1bmN0aW9uKF8pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNGdW5jdGlvbigvYWJjLyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbHVlKSB7XG4gIC8vIFRoZSB1c2Ugb2YgYE9iamVjdCN0b1N0cmluZ2AgYXZvaWRzIGlzc3VlcyB3aXRoIHRoZSBgdHlwZW9mYCBvcGVyYXRvclxuICAvLyBpbiBvbGRlciB2ZXJzaW9ucyBvZiBDaHJvbWUgYW5kIFNhZmFyaSB3aGljaCByZXR1cm4gJ2Z1bmN0aW9uJyBmb3IgcmVnZXhlc1xuICAvLyBhbmQgU2FmYXJpIDggZXF1aXZhbGVudHMgd2hpY2ggcmV0dXJuICdvYmplY3QnIGZvciB0eXBlZCBhcnJheSBjb25zdHJ1Y3RvcnMuXG4gIHJldHVybiBpc09iamVjdCh2YWx1ZSkgJiYgb2JqVG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT0gZnVuY1RhZztcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyB0aGUgW2xhbmd1YWdlIHR5cGVdKGh0dHBzOi8vZXM1LmdpdGh1Yi5pby8jeDgpIG9mIGBPYmplY3RgLlxuICogKGUuZy4gYXJyYXlzLCBmdW5jdGlvbnMsIG9iamVjdHMsIHJlZ2V4ZXMsIGBuZXcgTnVtYmVyKDApYCwgYW5kIGBuZXcgU3RyaW5nKCcnKWApXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzT2JqZWN0KHt9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdCgxKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG4gIC8vIEF2b2lkIGEgVjggSklUIGJ1ZyBpbiBDaHJvbWUgMTktMjAuXG4gIC8vIFNlZSBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MjI5MSBmb3IgbW9yZSBkZXRhaWxzLlxuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgcmV0dXJuICEhdmFsdWUgJiYgKHR5cGUgPT0gJ29iamVjdCcgfHwgdHlwZSA9PSAnZnVuY3Rpb24nKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIG5hdGl2ZSBmdW5jdGlvbi5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBuYXRpdmUgZnVuY3Rpb24sIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc05hdGl2ZShBcnJheS5wcm90b3R5cGUucHVzaCk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc05hdGl2ZShfKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzTmF0aXZlKHZhbHVlKSB7XG4gIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgIHJldHVybiByZUlzTmF0aXZlLnRlc3QoZm5Ub1N0cmluZy5jYWxsKHZhbHVlKSk7XG4gIH1cbiAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgcmVJc0hvc3RDdG9yLnRlc3QodmFsdWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldE5hdGl2ZTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3V4Y29yZS10YWJsZS9+L3V4Y29yZS1tZW51L34vcmMtbWVudS9+L3JjLXV0aWwvfi9zaGFsbG93ZXF1YWwvfi9sb2Rhc2gua2V5cy9+L2xvZGFzaC5fZ2V0bmF0aXZlL2luZGV4LmpzXG4gKiogbW9kdWxlIGlkID0gMjVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogbG9kYXNoIDMuMC44IChDdXN0b20gQnVpbGQpIDxodHRwczovL2xvZGFzaC5jb20vPlxuICogQnVpbGQ6IGBsb2Rhc2ggbW9kdWxhcml6ZSBleHBvcnRzPVwibnBtXCIgLW8gLi9gXG4gKiBDb3B5cmlnaHQgMjAxMi0yMDE2IFRoZSBEb2pvIEZvdW5kYXRpb24gPGh0dHA6Ly9kb2pvZm91bmRhdGlvbi5vcmcvPlxuICogQmFzZWQgb24gVW5kZXJzY29yZS5qcyAxLjguMyA8aHR0cDovL3VuZGVyc2NvcmVqcy5vcmcvTElDRU5TRT5cbiAqIENvcHlyaWdodCAyMDA5LTIwMTYgSmVyZW15IEFzaGtlbmFzLCBEb2N1bWVudENsb3VkIGFuZCBJbnZlc3RpZ2F0aXZlIFJlcG9ydGVycyAmIEVkaXRvcnNcbiAqIEF2YWlsYWJsZSB1bmRlciBNSVQgbGljZW5zZSA8aHR0cHM6Ly9sb2Rhc2guY29tL2xpY2Vuc2U+XG4gKi9cblxuLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG52YXIgTUFYX1NBRkVfSU5URUdFUiA9IDkwMDcxOTkyNTQ3NDA5OTE7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBhcmdzVGFnID0gJ1tvYmplY3QgQXJndW1lbnRzXScsXG4gICAgZnVuY1RhZyA9ICdbb2JqZWN0IEZ1bmN0aW9uXScsXG4gICAgZ2VuVGFnID0gJ1tvYmplY3QgR2VuZXJhdG9yRnVuY3Rpb25dJztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBVc2VkIHRvIHJlc29sdmUgdGhlIFtgdG9TdHJpbmdUYWdgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nKVxuICogb2YgdmFsdWVzLlxuICovXG52YXIgb2JqZWN0VG9TdHJpbmcgPSBvYmplY3RQcm90by50b1N0cmluZztcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgcHJvcGVydHlJc0VudW1lcmFibGUgPSBvYmplY3RQcm90by5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5wcm9wZXJ0eWAgd2l0aG91dCBzdXBwb3J0IGZvciBkZWVwIHBhdGhzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBiYXNlUHJvcGVydHkoa2V5KSB7XG4gIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQgOiBvYmplY3Rba2V5XTtcbiAgfTtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBcImxlbmd0aFwiIHByb3BlcnR5IHZhbHVlIG9mIGBvYmplY3RgLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgdG8gYXZvaWQgYSBbSklUIGJ1Z10oaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTE0Mjc5MilcbiAqIHRoYXQgYWZmZWN0cyBTYWZhcmkgb24gYXQgbGVhc3QgaU9TIDguMS04LjMgQVJNNjQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBcImxlbmd0aFwiIHZhbHVlLlxuICovXG52YXIgZ2V0TGVuZ3RoID0gYmFzZVByb3BlcnR5KCdsZW5ndGgnKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBsaWtlbHkgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBjb3JyZWN0bHkgY2xhc3NpZmllZCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJndW1lbnRzKGZ1bmN0aW9uKCkgeyByZXR1cm4gYXJndW1lbnRzOyB9KCkpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcmd1bWVudHMoWzEsIDIsIDNdKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzQXJndW1lbnRzKHZhbHVlKSB7XG4gIC8vIFNhZmFyaSA4LjEgaW5jb3JyZWN0bHkgbWFrZXMgYGFyZ3VtZW50cy5jYWxsZWVgIGVudW1lcmFibGUgaW4gc3RyaWN0IG1vZGUuXG4gIHJldHVybiBpc0FycmF5TGlrZU9iamVjdCh2YWx1ZSkgJiYgaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgJ2NhbGxlZScpICYmXG4gICAgKCFwcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHZhbHVlLCAnY2FsbGVlJykgfHwgb2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT0gYXJnc1RhZyk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYXJyYXktbGlrZS4gQSB2YWx1ZSBpcyBjb25zaWRlcmVkIGFycmF5LWxpa2UgaWYgaXQnc1xuICogbm90IGEgZnVuY3Rpb24gYW5kIGhhcyBhIGB2YWx1ZS5sZW5ndGhgIHRoYXQncyBhbiBpbnRlZ2VyIGdyZWF0ZXIgdGhhbiBvclxuICogZXF1YWwgdG8gYDBgIGFuZCBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gYE51bWJlci5NQVhfU0FGRV9JTlRFR0VSYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYXJyYXktbGlrZSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZShkb2N1bWVudC5ib2R5LmNoaWxkcmVuKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKCdhYmMnKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0FycmF5TGlrZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiBpc0xlbmd0aChnZXRMZW5ndGgodmFsdWUpKSAmJiAhaXNGdW5jdGlvbih2YWx1ZSk7XG59XG5cbi8qKlxuICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5pc0FycmF5TGlrZWAgZXhjZXB0IHRoYXQgaXQgYWxzbyBjaGVja3MgaWYgYHZhbHVlYFxuICogaXMgYW4gb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBhcnJheS1saWtlIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlT2JqZWN0KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZU9iamVjdChkb2N1bWVudC5ib2R5LmNoaWxkcmVuKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlT2JqZWN0KCdhYmMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0FycmF5TGlrZU9iamVjdChfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNBcnJheUxpa2VPYmplY3QodmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgaXNBcnJheUxpa2UodmFsdWUpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgRnVuY3Rpb25gIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgY29ycmVjdGx5IGNsYXNzaWZpZWQsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0Z1bmN0aW9uKF8pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNGdW5jdGlvbigvYWJjLyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbHVlKSB7XG4gIC8vIFRoZSB1c2Ugb2YgYE9iamVjdCN0b1N0cmluZ2AgYXZvaWRzIGlzc3VlcyB3aXRoIHRoZSBgdHlwZW9mYCBvcGVyYXRvclxuICAvLyBpbiBTYWZhcmkgOCB3aGljaCByZXR1cm5zICdvYmplY3QnIGZvciB0eXBlZCBhcnJheSBhbmQgd2VhayBtYXAgY29uc3RydWN0b3JzLFxuICAvLyBhbmQgUGhhbnRvbUpTIDEuOSB3aGljaCByZXR1cm5zICdmdW5jdGlvbicgZm9yIGBOb2RlTGlzdGAgaW5zdGFuY2VzLlxuICB2YXIgdGFnID0gaXNPYmplY3QodmFsdWUpID8gb2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSkgOiAnJztcbiAgcmV0dXJuIHRhZyA9PSBmdW5jVGFnIHx8IHRhZyA9PSBnZW5UYWc7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBhcnJheS1saWtlIGxlbmd0aC5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBmdW5jdGlvbiBpcyBsb29zZWx5IGJhc2VkIG9uIFtgVG9MZW5ndGhgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvI3NlYy10b2xlbmd0aCkuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgbGVuZ3RoLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNMZW5ndGgoMyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0xlbmd0aChOdW1iZXIuTUlOX1ZBTFVFKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0xlbmd0aChJbmZpbml0eSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNMZW5ndGgoJzMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzTGVuZ3RoKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicgJiZcbiAgICB2YWx1ZSA+IC0xICYmIHZhbHVlICUgMSA9PSAwICYmIHZhbHVlIDw9IE1BWF9TQUZFX0lOVEVHRVI7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgdGhlIFtsYW5ndWFnZSB0eXBlXShodHRwczovL2VzNS5naXRodWIuaW8vI3g4KSBvZiBgT2JqZWN0YC5cbiAqIChlLmcuIGFycmF5cywgZnVuY3Rpb25zLCBvYmplY3RzLCByZWdleGVzLCBgbmV3IE51bWJlcigwKWAsIGFuZCBgbmV3IFN0cmluZygnJylgKVxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdCh7fSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoXy5ub29wKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIHJldHVybiAhIXZhbHVlICYmICh0eXBlID09ICdvYmplY3QnIHx8IHR5cGUgPT0gJ2Z1bmN0aW9uJyk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UuIEEgdmFsdWUgaXMgb2JqZWN0LWxpa2UgaWYgaXQncyBub3QgYG51bGxgXG4gKiBhbmQgaGFzIGEgYHR5cGVvZmAgcmVzdWx0IG9mIFwib2JqZWN0XCIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKHt9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3RMaWtlKHZhbHVlKSB7XG4gIHJldHVybiAhIXZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0Jztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0FyZ3VtZW50cztcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3V4Y29yZS10YWJsZS9+L3V4Y29yZS1tZW51L34vcmMtbWVudS9+L3JjLXV0aWwvfi9zaGFsbG93ZXF1YWwvfi9sb2Rhc2gua2V5cy9+L2xvZGFzaC5pc2FyZ3VtZW50cy9pbmRleC5qc1xuICoqIG1vZHVsZSBpZCA9IDI2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIGxvZGFzaCAzLjAuNCAoQ3VzdG9tIEJ1aWxkKSA8aHR0cHM6Ly9sb2Rhc2guY29tLz5cbiAqIEJ1aWxkOiBgbG9kYXNoIG1vZGVybiBtb2R1bGFyaXplIGV4cG9ydHM9XCJucG1cIiAtbyAuL2BcbiAqIENvcHlyaWdodCAyMDEyLTIwMTUgVGhlIERvam8gRm91bmRhdGlvbiA8aHR0cDovL2Rvam9mb3VuZGF0aW9uLm9yZy8+XG4gKiBCYXNlZCBvbiBVbmRlcnNjb3JlLmpzIDEuOC4zIDxodHRwOi8vdW5kZXJzY29yZWpzLm9yZy9MSUNFTlNFPlxuICogQ29weXJpZ2h0IDIwMDktMjAxNSBKZXJlbXkgQXNoa2VuYXMsIERvY3VtZW50Q2xvdWQgYW5kIEludmVzdGlnYXRpdmUgUmVwb3J0ZXJzICYgRWRpdG9yc1xuICogQXZhaWxhYmxlIHVuZGVyIE1JVCBsaWNlbnNlIDxodHRwczovL2xvZGFzaC5jb20vbGljZW5zZT5cbiAqL1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYXJyYXlUYWcgPSAnW29iamVjdCBBcnJheV0nLFxuICAgIGZ1bmNUYWcgPSAnW29iamVjdCBGdW5jdGlvbl0nO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgaG9zdCBjb25zdHJ1Y3RvcnMgKFNhZmFyaSA+IDUpLiAqL1xudmFyIHJlSXNIb3N0Q3RvciA9IC9eXFxbb2JqZWN0IC4rP0NvbnN0cnVjdG9yXFxdJC87XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNPYmplY3RMaWtlKHZhbHVlKSB7XG4gIHJldHVybiAhIXZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0Jztcbn1cblxuLyoqIFVzZWQgZm9yIG5hdGl2ZSBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIHJlc29sdmUgdGhlIGRlY29tcGlsZWQgc291cmNlIG9mIGZ1bmN0aW9ucy4gKi9cbnZhciBmblRvU3RyaW5nID0gRnVuY3Rpb24ucHJvdG90eXBlLnRvU3RyaW5nO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIFVzZWQgdG8gcmVzb2x2ZSB0aGUgW2B0b1N0cmluZ1RhZ2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXG4gKiBvZiB2YWx1ZXMuXG4gKi9cbnZhciBvYmpUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgaWYgYSBtZXRob2QgaXMgbmF0aXZlLiAqL1xudmFyIHJlSXNOYXRpdmUgPSBSZWdFeHAoJ14nICtcbiAgZm5Ub1N0cmluZy5jYWxsKGhhc093blByb3BlcnR5KS5yZXBsYWNlKC9bXFxcXF4kLiorPygpW1xcXXt9fF0vZywgJ1xcXFwkJicpXG4gIC5yZXBsYWNlKC9oYXNPd25Qcm9wZXJ0eXwoZnVuY3Rpb24pLio/KD89XFxcXFxcKCl8IGZvciAuKz8oPz1cXFxcXFxdKS9nLCAnJDEuKj8nKSArICckJ1xuKTtcblxuLyogTmF0aXZlIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVJc0FycmF5ID0gZ2V0TmF0aXZlKEFycmF5LCAnaXNBcnJheScpO1xuXG4vKipcbiAqIFVzZWQgYXMgdGhlIFttYXhpbXVtIGxlbmd0aF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wLyNzZWMtbnVtYmVyLm1heF9zYWZlX2ludGVnZXIpXG4gKiBvZiBhbiBhcnJheS1saWtlIHZhbHVlLlxuICovXG52YXIgTUFYX1NBRkVfSU5URUdFUiA9IDkwMDcxOTkyNTQ3NDA5OTE7XG5cbi8qKlxuICogR2V0cyB0aGUgbmF0aXZlIGZ1bmN0aW9uIGF0IGBrZXlgIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIG1ldGhvZCB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZnVuY3Rpb24gaWYgaXQncyBuYXRpdmUsIGVsc2UgYHVuZGVmaW5lZGAuXG4gKi9cbmZ1bmN0aW9uIGdldE5hdGl2ZShvYmplY3QsIGtleSkge1xuICB2YXIgdmFsdWUgPSBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IG9iamVjdFtrZXldO1xuICByZXR1cm4gaXNOYXRpdmUodmFsdWUpID8gdmFsdWUgOiB1bmRlZmluZWQ7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBhcnJheS1saWtlIGxlbmd0aC5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBmdW5jdGlvbiBpcyBiYXNlZCBvbiBbYFRvTGVuZ3RoYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wLyNzZWMtdG9sZW5ndGgpLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgbGVuZ3RoLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzTGVuZ3RoKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicgJiYgdmFsdWUgPiAtMSAmJiB2YWx1ZSAlIDEgPT0gMCAmJiB2YWx1ZSA8PSBNQVhfU0FGRV9JTlRFR0VSO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYW4gYEFycmF5YCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGNvcnJlY3RseSBjbGFzc2lmaWVkLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcnJheShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheShmdW5jdGlvbigpIHsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc0FycmF5ID0gbmF0aXZlSXNBcnJheSB8fCBmdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBpc0xlbmd0aCh2YWx1ZS5sZW5ndGgpICYmIG9ialRvU3RyaW5nLmNhbGwodmFsdWUpID09IGFycmF5VGFnO1xufTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYEZ1bmN0aW9uYCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGNvcnJlY3RseSBjbGFzc2lmaWVkLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNGdW5jdGlvbihfKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzRnVuY3Rpb24oL2FiYy8pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNGdW5jdGlvbih2YWx1ZSkge1xuICAvLyBUaGUgdXNlIG9mIGBPYmplY3QjdG9TdHJpbmdgIGF2b2lkcyBpc3N1ZXMgd2l0aCB0aGUgYHR5cGVvZmAgb3BlcmF0b3JcbiAgLy8gaW4gb2xkZXIgdmVyc2lvbnMgb2YgQ2hyb21lIGFuZCBTYWZhcmkgd2hpY2ggcmV0dXJuICdmdW5jdGlvbicgZm9yIHJlZ2V4ZXNcbiAgLy8gYW5kIFNhZmFyaSA4IGVxdWl2YWxlbnRzIHdoaWNoIHJldHVybiAnb2JqZWN0JyBmb3IgdHlwZWQgYXJyYXkgY29uc3RydWN0b3JzLlxuICByZXR1cm4gaXNPYmplY3QodmFsdWUpICYmIG9ialRvU3RyaW5nLmNhbGwodmFsdWUpID09IGZ1bmNUYWc7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgdGhlIFtsYW5ndWFnZSB0eXBlXShodHRwczovL2VzNS5naXRodWIuaW8vI3g4KSBvZiBgT2JqZWN0YC5cbiAqIChlLmcuIGFycmF5cywgZnVuY3Rpb25zLCBvYmplY3RzLCByZWdleGVzLCBgbmV3IE51bWJlcigwKWAsIGFuZCBgbmV3IFN0cmluZygnJylgKVxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdCh7fSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoMSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xuICAvLyBBdm9pZCBhIFY4IEpJVCBidWcgaW4gQ2hyb21lIDE5LTIwLlxuICAvLyBTZWUgaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTIyOTEgZm9yIG1vcmUgZGV0YWlscy5cbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIHJldHVybiAhIXZhbHVlICYmICh0eXBlID09ICdvYmplY3QnIHx8IHR5cGUgPT0gJ2Z1bmN0aW9uJyk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBuYXRpdmUgZnVuY3Rpb24uXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgbmF0aXZlIGZ1bmN0aW9uLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNOYXRpdmUoQXJyYXkucHJvdG90eXBlLnB1c2gpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNOYXRpdmUoXyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc05hdGl2ZSh2YWx1ZSkge1xuICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoaXNGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICByZXR1cm4gcmVJc05hdGl2ZS50ZXN0KGZuVG9TdHJpbmcuY2FsbCh2YWx1ZSkpO1xuICB9XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIHJlSXNIb3N0Q3Rvci50ZXN0KHZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0FycmF5O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vdXhjb3JlLXRhYmxlL34vdXhjb3JlLW1lbnUvfi9yYy1tZW51L34vcmMtdXRpbC9+L3NoYWxsb3dlcXVhbC9+L2xvZGFzaC5rZXlzL34vbG9kYXNoLmlzYXJyYXkvaW5kZXguanNcbiAqKiBtb2R1bGUgaWQgPSAyN1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBTYWZlIGNoYWluZWQgZnVuY3Rpb25cbiAqXG4gKiBXaWxsIG9ubHkgY3JlYXRlIGEgbmV3IGZ1bmN0aW9uIGlmIG5lZWRlZCxcbiAqIG90aGVyd2lzZSB3aWxsIHBhc3MgYmFjayBleGlzdGluZyBmdW5jdGlvbnMgb3IgbnVsbC5cbiAqXG4gKiBAcmV0dXJucyB7ZnVuY3Rpb258bnVsbH1cbiAqL1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbmZ1bmN0aW9uIGNyZWF0ZUNoYWluZWRGdW5jdGlvbigpIHtcbiAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gIHJldHVybiBmdW5jdGlvbiBjaGFpbmVkRnVuY3Rpb24oKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoYXJnc1tpXSAmJiBhcmdzW2ldLmFwcGx5KSB7XG4gICAgICAgIGFyZ3NbaV0uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY3JlYXRlQ2hhaW5lZEZ1bmN0aW9uO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3V4Y29yZS10YWJsZS9+L3V4Y29yZS1tZW51L34vcmMtbWVudS9+L3JjLXV0aWwvbGliL2NyZWF0ZUNoYWluZWRGdW5jdGlvbi5qc1xuICoqIG1vZHVsZSBpZCA9IDI4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIEBpZ25vcmVcbiAqIGJhc2UgZXZlbnQgb2JqZWN0IGZvciBjdXN0b20gYW5kIGRvbSBldmVudC5cbiAqIEBhdXRob3IgeWltaW5naGVAZ21haWwuY29tXG4gKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5mdW5jdGlvbiByZXR1cm5GYWxzZSgpIHtcbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiByZXR1cm5UcnVlKCkge1xuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gRXZlbnRCYXNlT2JqZWN0KCkge1xuICB0aGlzLnRpbWVTdGFtcCA9IERhdGUubm93KCk7XG4gIHRoaXMudGFyZ2V0ID0gdW5kZWZpbmVkO1xuICB0aGlzLmN1cnJlbnRUYXJnZXQgPSB1bmRlZmluZWQ7XG59XG5cbkV2ZW50QmFzZU9iamVjdC5wcm90b3R5cGUgPSB7XG4gIGlzRXZlbnRPYmplY3Q6IDEsXG5cbiAgY29uc3RydWN0b3I6IEV2ZW50QmFzZU9iamVjdCxcblxuICBpc0RlZmF1bHRQcmV2ZW50ZWQ6IHJldHVybkZhbHNlLFxuXG4gIGlzUHJvcGFnYXRpb25TdG9wcGVkOiByZXR1cm5GYWxzZSxcblxuICBpc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZDogcmV0dXJuRmFsc2UsXG5cbiAgcHJldmVudERlZmF1bHQ6IGZ1bmN0aW9uIHByZXZlbnREZWZhdWx0KCkge1xuICAgIHRoaXMuaXNEZWZhdWx0UHJldmVudGVkID0gcmV0dXJuVHJ1ZTtcbiAgfSxcblxuICBzdG9wUHJvcGFnYXRpb246IGZ1bmN0aW9uIHN0b3BQcm9wYWdhdGlvbigpIHtcbiAgICB0aGlzLmlzUHJvcGFnYXRpb25TdG9wcGVkID0gcmV0dXJuVHJ1ZTtcbiAgfSxcblxuICBzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb246IGZ1bmN0aW9uIHN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpIHtcbiAgICB0aGlzLmlzSW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkID0gcmV0dXJuVHJ1ZTtcbiAgICAvLyBmaXhlZCAxLjJcbiAgICAvLyBjYWxsIHN0b3BQcm9wYWdhdGlvbiBpbXBsaWNpdGx5XG4gICAgdGhpcy5zdG9wUHJvcGFnYXRpb24oKTtcbiAgfSxcblxuICBoYWx0OiBmdW5jdGlvbiBoYWx0KGltbWVkaWF0ZSkge1xuICAgIGlmIChpbW1lZGlhdGUpIHtcbiAgICAgIHRoaXMuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgfVxuICAgIHRoaXMucHJldmVudERlZmF1bHQoKTtcbiAgfVxufTtcblxuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBFdmVudEJhc2VPYmplY3Q7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbXCJkZWZhdWx0XCJdO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3V4Y29yZS10YWJsZS9+L3V4Y29yZS1tZW51L34vcmMtbWVudS9+L3JjLXV0aWwvfi9hZGQtZG9tLWV2ZW50LWxpc3RlbmVyL2xpYi9FdmVudEJhc2VPYmplY3QuanNcbiAqKiBtb2R1bGUgaWQgPSAzMlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gY29udGFpbnMocm9vdCwgbikge1xuICB2YXIgbm9kZSA9IG47XG4gIHdoaWxlIChub2RlKSB7XG4gICAgaWYgKG5vZGUgPT09IHJvb3QpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBub2RlID0gbm9kZS5wYXJlbnROb2RlO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi91eGNvcmUtdGFibGUvfi91eGNvcmUtbWVudS9+L3JjLW1lbnUvfi9yYy11dGlsL2xpYi9Eb20vY29udGFpbnMuanNcbiAqKiBtb2R1bGUgaWQgPSAzM1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHRvQXJyYXkoY2hpbGRyZW4pIHtcbiAgdmFyIHJldCA9IFtdO1xuICBSZWFjdC5DaGlsZHJlbi5mb3JFYWNoKGNoaWxkcmVuLCBmdW5jdGlvbiBlYWNoKGMpIHtcbiAgICByZXQucHVzaChjKTtcbiAgfSk7XG4gIHJldHVybiByZXQ7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3V4Y29yZS10YWJsZS9+L3V4Y29yZS1tZW51L34vcmMtbWVudS9+L3JjLXV0aWwvbGliL0NoaWxkcmVuL3RvQXJyYXkuanNcbiAqKiBtb2R1bGUgaWQgPSAzNFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xuXG5mdW5jdGlvbiBtaXJyb3Iobykge1xuICByZXR1cm4gbztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBtYXBTZWxmKGNoaWxkcmVuKSB7XG4gIC8vIHJldHVybiBSZWFjdEZyYWdtZW50XG4gIHJldHVybiBSZWFjdC5DaGlsZHJlbi5tYXAoY2hpbGRyZW4sIG1pcnJvcik7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3V4Y29yZS10YWJsZS9+L3V4Y29yZS1tZW51L34vcmMtbWVudS9+L3JjLXV0aWwvbGliL0NoaWxkcmVuL21hcFNlbGYuanNcbiAqKiBtb2R1bGUgaWQgPSAzNVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG52YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblxudmFyIFJFX05VTSA9IC9bXFwtK10/KD86XFxkKlxcLnwpXFxkKyg/OltlRV1bXFwtK10/XFxkK3wpLy5zb3VyY2U7XG5cbmZ1bmN0aW9uIGdldENsaWVudFBvc2l0aW9uKGVsZW0pIHtcbiAgdmFyIGJveCA9IHVuZGVmaW5lZDtcbiAgdmFyIHggPSB1bmRlZmluZWQ7XG4gIHZhciB5ID0gdW5kZWZpbmVkO1xuICB2YXIgZG9jID0gZWxlbS5vd25lckRvY3VtZW50O1xuICB2YXIgYm9keSA9IGRvYy5ib2R5O1xuICB2YXIgZG9jRWxlbSA9IGRvYyAmJiBkb2MuZG9jdW1lbnRFbGVtZW50O1xuICAvLyDmoLnmja4gR0JTIOacgOaWsOaVsOaNru+8jEEtR3JhZGUgQnJvd3NlcnMg6YO95bey5pSv5oyBIGdldEJvdW5kaW5nQ2xpZW50UmVjdCDmlrnms5XvvIzkuI3nlKjlho3ogIPomZHkvKDnu5/nmoTlrp7njrDmlrnlvI9cbiAgYm94ID0gZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuICAvLyDms6jvvJpqUXVlcnkg6L+Y6ICD6JmR5YeP5Y67IGRvY0VsZW0uY2xpZW50TGVmdC9jbGllbnRUb3BcbiAgLy8g5L2G5rWL6K+V5Y+R546w77yM6L+Z5qC35Y+N6ICM5Lya5a+86Ie05b2TIGh0bWwg5ZKMIGJvZHkg5pyJ6L656LedL+i+ueahhuagt+W8j+aXtu+8jOiOt+WPlueahOWAvOS4jeato+ehrlxuICAvLyDmraTlpJbvvIxpZTYg5Lya5b+955WlIGh0bWwg55qEIG1hcmdpbiDlgLzvvIzlubjov5DlnLDmmK/msqHmnInosIHkvJrljrvorr7nva4gaHRtbCDnmoQgbWFyZ2luXG5cbiAgeCA9IGJveC5sZWZ0O1xuICB5ID0gYm94LnRvcDtcblxuICAvLyBJbiBJRSwgbW9zdCBvZiB0aGUgdGltZSwgMiBleHRyYSBwaXhlbHMgYXJlIGFkZGVkIHRvIHRoZSB0b3AgYW5kIGxlZnRcbiAgLy8gZHVlIHRvIHRoZSBpbXBsaWNpdCAyLXBpeGVsIGluc2V0IGJvcmRlci4gIEluIElFNi83IHF1aXJrcyBtb2RlIGFuZFxuICAvLyBJRTYgc3RhbmRhcmRzIG1vZGUsIHRoaXMgYm9yZGVyIGNhbiBiZSBvdmVycmlkZGVuIGJ5IHNldHRpbmcgdGhlXG4gIC8vIGRvY3VtZW50IGVsZW1lbnQncyBib3JkZXIgdG8gemVybyAtLSB0aHVzLCB3ZSBjYW5ub3QgcmVseSBvbiB0aGVcbiAgLy8gb2Zmc2V0IGFsd2F5cyBiZWluZyAyIHBpeGVscy5cblxuICAvLyBJbiBxdWlya3MgbW9kZSwgdGhlIG9mZnNldCBjYW4gYmUgZGV0ZXJtaW5lZCBieSBxdWVyeWluZyB0aGUgYm9keSdzXG4gIC8vIGNsaWVudExlZnQvY2xpZW50VG9wLCBidXQgaW4gc3RhbmRhcmRzIG1vZGUsIGl0IGlzIGZvdW5kIGJ5IHF1ZXJ5aW5nXG4gIC8vIHRoZSBkb2N1bWVudCBlbGVtZW50J3MgY2xpZW50TGVmdC9jbGllbnRUb3AuICBTaW5jZSB3ZSBhbHJlYWR5IGNhbGxlZFxuICAvLyBnZXRDbGllbnRCb3VuZGluZ1JlY3Qgd2UgaGF2ZSBhbHJlYWR5IGZvcmNlZCBhIHJlZmxvdywgc28gaXQgaXMgbm90XG4gIC8vIHRvbyBleHBlbnNpdmUganVzdCB0byBxdWVyeSB0aGVtIGFsbC5cblxuICAvLyBpZSDkuIvlupTor6Xlh4/ljrvnqpflj6PnmoTovrnmoYblkKfvvIzmr5Xnq5/pu5jorqQgYWJzb2x1dGUg6YO95piv55u45a+556qX5Y+j5a6a5L2N55qEXG4gIC8vIOeql+WPo+i+ueahhuagh+WHhuaYr+iuviBkb2N1bWVudEVsZW1lbnQgLHF1aXJrcyDml7borr7nva4gYm9keVxuICAvLyDmnIDlpb3npoHmraLlnKggYm9keSDlkowgaHRtbCDkuIrovrnmoYYg77yM5L2GIGllIDwgOSBodG1sIOm7mOiupOaciSAycHgg77yM5YeP5Y67XG4gIC8vIOS9huaYr+mdniBpZSDkuI3lj6/og73orr7nva7nqpflj6PovrnmoYbvvIxib2R5IGh0bWwg5Lmf5LiN5piv56qX5Y+jICxpZSDlj6/ku6XpgJrov4cgaHRtbCxib2R5IOiuvue9rlxuICAvLyDmoIflh4YgaWUg5LiLIGRvY0VsZW0uY2xpZW50VG9wIOWwseaYryBib3JkZXItdG9wXG4gIC8vIGllNyBodG1sIOWNs+eql+WPo+i+ueahhuaUueWPmOS4jeS6huOAguawuOi/nOS4uiAyXG4gIC8vIOS9huagh+WHhiBmaXJlZm94L2Nocm9tZS9pZTkg5LiLIGRvY0VsZW0uY2xpZW50VG9wIOaYr+eql+WPo+i+ueahhu+8jOWNs+S9v+iuvuS6hiBib3JkZXItdG9wIOS5n+S4uiAwXG5cbiAgeCAtPSBkb2NFbGVtLmNsaWVudExlZnQgfHwgYm9keS5jbGllbnRMZWZ0IHx8IDA7XG4gIHkgLT0gZG9jRWxlbS5jbGllbnRUb3AgfHwgYm9keS5jbGllbnRUb3AgfHwgMDtcblxuICByZXR1cm4ge1xuICAgIGxlZnQ6IHgsXG4gICAgdG9wOiB5XG4gIH07XG59XG5cbmZ1bmN0aW9uIGdldFNjcm9sbCh3LCB0b3ApIHtcbiAgdmFyIHJldCA9IHdbJ3BhZ2UnICsgKHRvcCA/ICdZJyA6ICdYJykgKyAnT2Zmc2V0J107XG4gIHZhciBtZXRob2QgPSAnc2Nyb2xsJyArICh0b3AgPyAnVG9wJyA6ICdMZWZ0Jyk7XG4gIGlmICh0eXBlb2YgcmV0ICE9PSAnbnVtYmVyJykge1xuICAgIHZhciBkID0gdy5kb2N1bWVudDtcbiAgICAvLyBpZTYsNyw4IHN0YW5kYXJkIG1vZGVcbiAgICByZXQgPSBkLmRvY3VtZW50RWxlbWVudFttZXRob2RdO1xuICAgIGlmICh0eXBlb2YgcmV0ICE9PSAnbnVtYmVyJykge1xuICAgICAgLy8gcXVpcmtzIG1vZGVcbiAgICAgIHJldCA9IGQuYm9keVttZXRob2RdO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBnZXRTY3JvbGxMZWZ0KHcpIHtcbiAgcmV0dXJuIGdldFNjcm9sbCh3KTtcbn1cblxuZnVuY3Rpb24gZ2V0U2Nyb2xsVG9wKHcpIHtcbiAgcmV0dXJuIGdldFNjcm9sbCh3LCB0cnVlKTtcbn1cblxuZnVuY3Rpb24gZ2V0T2Zmc2V0KGVsKSB7XG4gIHZhciBwb3MgPSBnZXRDbGllbnRQb3NpdGlvbihlbCk7XG4gIHZhciBkb2MgPSBlbC5vd25lckRvY3VtZW50O1xuICB2YXIgdyA9IGRvYy5kZWZhdWx0VmlldyB8fCBkb2MucGFyZW50V2luZG93O1xuICBwb3MubGVmdCArPSBnZXRTY3JvbGxMZWZ0KHcpO1xuICBwb3MudG9wICs9IGdldFNjcm9sbFRvcCh3KTtcbiAgcmV0dXJuIHBvcztcbn1cbmZ1bmN0aW9uIF9nZXRDb21wdXRlZFN0eWxlKGVsZW0sIG5hbWUsIGNvbXB1dGVkU3R5bGVfKSB7XG4gIHZhciB2YWwgPSAnJztcbiAgdmFyIGQgPSBlbGVtLm93bmVyRG9jdW1lbnQ7XG4gIHZhciBjb21wdXRlZFN0eWxlID0gY29tcHV0ZWRTdHlsZV8gfHwgZC5kZWZhdWx0Vmlldy5nZXRDb21wdXRlZFN0eWxlKGVsZW0sIG51bGwpO1xuXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9raXNzeXRlYW0va2lzc3kvaXNzdWVzLzYxXG4gIGlmIChjb21wdXRlZFN0eWxlKSB7XG4gICAgdmFsID0gY29tcHV0ZWRTdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKG5hbWUpIHx8IGNvbXB1dGVkU3R5bGVbbmFtZV07XG4gIH1cblxuICByZXR1cm4gdmFsO1xufVxuXG52YXIgX1JFX05VTV9OT19QWCA9IG5ldyBSZWdFeHAoJ14oJyArIFJFX05VTSArICcpKD8hcHgpW2EteiVdKyQnLCAnaScpO1xudmFyIFJFX1BPUyA9IC9eKHRvcHxyaWdodHxib3R0b218bGVmdCkkLztcbnZhciBDVVJSRU5UX1NUWUxFID0gJ2N1cnJlbnRTdHlsZSc7XG52YXIgUlVOVElNRV9TVFlMRSA9ICdydW50aW1lU3R5bGUnO1xudmFyIExFRlQgPSAnbGVmdCc7XG52YXIgUFggPSAncHgnO1xuXG5mdW5jdGlvbiBfZ2V0Q29tcHV0ZWRTdHlsZUlFKGVsZW0sIG5hbWUpIHtcbiAgLy8gY3VycmVudFN0eWxlIG1heWJlIG51bGxcbiAgLy8gaHR0cDovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L21zNTM1MjMxLmFzcHhcbiAgdmFyIHJldCA9IGVsZW1bQ1VSUkVOVF9TVFlMRV0gJiYgZWxlbVtDVVJSRU5UX1NUWUxFXVtuYW1lXTtcblxuICAvLyDlvZMgd2lkdGgvaGVpZ2h0IOiuvue9ruS4uueZvuWIhuavlOaXtu+8jOmAmui/hyBwaXhlbExlZnQg5pa55byP6L2s5o2i55qEIHdpZHRoL2hlaWdodCDlgLxcbiAgLy8g5LiA5byA5aeL5bCx5aSE55CG5LqGISBDVVNUT01fU1RZTEUuaGVpZ2h0LENVU1RPTV9TVFlMRS53aWR0aCAsY3NzSG9vayDop6PlhrNAMjAxMS0wOC0xOVxuICAvLyDlnKggaWUg5LiL5LiN5a+577yM6ZyA6KaB55u05o6l55SoIG9mZnNldCDmlrnlvI9cbiAgLy8gYm9yZGVyV2lkdGgg562J5YC85Lmf5pyJ6Zeu6aKY77yM5L2G6ICD6JmR5YiwIGJvcmRlcldpZHRoIOiuvuS4uueZvuWIhuavlOeahOamgueOh+W+iOWwj++8jOi/memHjOWwseS4jeiAg+iZkeS6hlxuXG4gIC8vIEZyb20gdGhlIGF3ZXNvbWUgaGFjayBieSBEZWFuIEVkd2FyZHNcbiAgLy8gaHR0cDovL2VyaWsuZWFlLm5ldC9hcmNoaXZlcy8yMDA3LzA3LzI3LzE4LjU0LjE1LyNjb21tZW50LTEwMjI5MVxuICAvLyBJZiB3ZSdyZSBub3QgZGVhbGluZyB3aXRoIGEgcmVndWxhciBwaXhlbCBudW1iZXJcbiAgLy8gYnV0IGEgbnVtYmVyIHRoYXQgaGFzIGEgd2VpcmQgZW5kaW5nLCB3ZSBuZWVkIHRvIGNvbnZlcnQgaXQgdG8gcGl4ZWxzXG4gIC8vIGV4Y2x1ZGUgbGVmdCByaWdodCBmb3IgcmVsYXRpdml0eVxuICBpZiAoX1JFX05VTV9OT19QWC50ZXN0KHJldCkgJiYgIVJFX1BPUy50ZXN0KG5hbWUpKSB7XG4gICAgLy8gUmVtZW1iZXIgdGhlIG9yaWdpbmFsIHZhbHVlc1xuICAgIHZhciBzdHlsZSA9IGVsZW0uc3R5bGU7XG4gICAgdmFyIGxlZnQgPSBzdHlsZVtMRUZUXTtcbiAgICB2YXIgcnNMZWZ0ID0gZWxlbVtSVU5USU1FX1NUWUxFXVtMRUZUXTtcblxuICAgIC8vIHByZXZlbnQgZmxhc2hpbmcgb2YgY29udGVudFxuICAgIGVsZW1bUlVOVElNRV9TVFlMRV1bTEVGVF0gPSBlbGVtW0NVUlJFTlRfU1RZTEVdW0xFRlRdO1xuXG4gICAgLy8gUHV0IGluIHRoZSBuZXcgdmFsdWVzIHRvIGdldCBhIGNvbXB1dGVkIHZhbHVlIG91dFxuICAgIHN0eWxlW0xFRlRdID0gbmFtZSA9PT0gJ2ZvbnRTaXplJyA/ICcxZW0nIDogcmV0IHx8IDA7XG4gICAgcmV0ID0gc3R5bGUucGl4ZWxMZWZ0ICsgUFg7XG5cbiAgICAvLyBSZXZlcnQgdGhlIGNoYW5nZWQgdmFsdWVzXG4gICAgc3R5bGVbTEVGVF0gPSBsZWZ0O1xuXG4gICAgZWxlbVtSVU5USU1FX1NUWUxFXVtMRUZUXSA9IHJzTGVmdDtcbiAgfVxuICByZXR1cm4gcmV0ID09PSAnJyA/ICdhdXRvJyA6IHJldDtcbn1cblxudmFyIGdldENvbXB1dGVkU3R5bGVYID0gdW5kZWZpbmVkO1xuaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gIGdldENvbXB1dGVkU3R5bGVYID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUgPyBfZ2V0Q29tcHV0ZWRTdHlsZSA6IF9nZXRDb21wdXRlZFN0eWxlSUU7XG59XG5cbmZ1bmN0aW9uIGVhY2goYXJyLCBmbikge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgIGZuKGFycltpXSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNCb3JkZXJCb3hGbihlbGVtKSB7XG4gIHJldHVybiBnZXRDb21wdXRlZFN0eWxlWChlbGVtLCAnYm94U2l6aW5nJykgPT09ICdib3JkZXItYm94Jztcbn1cblxudmFyIEJPWF9NT0RFTFMgPSBbJ21hcmdpbicsICdib3JkZXInLCAncGFkZGluZyddO1xudmFyIENPTlRFTlRfSU5ERVggPSAtMTtcbnZhciBQQURESU5HX0lOREVYID0gMjtcbnZhciBCT1JERVJfSU5ERVggPSAxO1xudmFyIE1BUkdJTl9JTkRFWCA9IDA7XG5cbmZ1bmN0aW9uIHN3YXAoZWxlbSwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgdmFyIG9sZCA9IHt9O1xuICB2YXIgc3R5bGUgPSBlbGVtLnN0eWxlO1xuICB2YXIgbmFtZSA9IHVuZGVmaW5lZDtcblxuICAvLyBSZW1lbWJlciB0aGUgb2xkIHZhbHVlcywgYW5kIGluc2VydCB0aGUgbmV3IG9uZXNcbiAgZm9yIChuYW1lIGluIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucy5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgb2xkW25hbWVdID0gc3R5bGVbbmFtZV07XG4gICAgICBzdHlsZVtuYW1lXSA9IG9wdGlvbnNbbmFtZV07XG4gICAgfVxuICB9XG5cbiAgY2FsbGJhY2suY2FsbChlbGVtKTtcblxuICAvLyBSZXZlcnQgdGhlIG9sZCB2YWx1ZXNcbiAgZm9yIChuYW1lIGluIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucy5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgc3R5bGVbbmFtZV0gPSBvbGRbbmFtZV07XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGdldFBCTVdpZHRoKGVsZW0sIHByb3BzLCB3aGljaCkge1xuICB2YXIgdmFsdWUgPSAwO1xuICB2YXIgcHJvcCA9IHVuZGVmaW5lZDtcbiAgdmFyIGogPSB1bmRlZmluZWQ7XG4gIHZhciBpID0gdW5kZWZpbmVkO1xuICBmb3IgKGogPSAwOyBqIDwgcHJvcHMubGVuZ3RoOyBqKyspIHtcbiAgICBwcm9wID0gcHJvcHNbal07XG4gICAgaWYgKHByb3ApIHtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCB3aGljaC5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY3NzUHJvcCA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKHByb3AgPT09ICdib3JkZXInKSB7XG4gICAgICAgICAgY3NzUHJvcCA9IHByb3AgKyB3aGljaFtpXSArICdXaWR0aCc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY3NzUHJvcCA9IHByb3AgKyB3aGljaFtpXTtcbiAgICAgICAgfVxuICAgICAgICB2YWx1ZSArPSBwYXJzZUZsb2F0KGdldENvbXB1dGVkU3R5bGVYKGVsZW0sIGNzc1Byb3ApKSB8fCAwO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gdmFsdWU7XG59XG5cbi8qKlxuICogQSBjcnVkZSB3YXkgb2YgZGV0ZXJtaW5pbmcgaWYgYW4gb2JqZWN0IGlzIGEgd2luZG93XG4gKiBAbWVtYmVyIHV0aWxcbiAqL1xuZnVuY3Rpb24gaXNXaW5kb3cob2JqKSB7XG4gIC8vIG11c3QgdXNlID09IGZvciBpZThcbiAgLyogZXNsaW50IGVxZXFlcTowICovXG4gIHJldHVybiBvYmogIT0gbnVsbCAmJiBvYmogPT0gb2JqLndpbmRvdztcbn1cblxudmFyIGRvbVV0aWxzID0ge307XG5cbmVhY2goWydXaWR0aCcsICdIZWlnaHQnXSwgZnVuY3Rpb24gKG5hbWUpIHtcbiAgZG9tVXRpbHNbJ2RvYycgKyBuYW1lXSA9IGZ1bmN0aW9uIChyZWZXaW4pIHtcbiAgICB2YXIgZCA9IHJlZldpbi5kb2N1bWVudDtcbiAgICByZXR1cm4gTWF0aC5tYXgoXG4gICAgLy8gZmlyZWZveCBjaHJvbWUgZG9jdW1lbnRFbGVtZW50LnNjcm9sbEhlaWdodDwgYm9keS5zY3JvbGxIZWlnaHRcbiAgICAvLyBpZSBzdGFuZGFyZCBtb2RlIDogZG9jdW1lbnRFbGVtZW50LnNjcm9sbEhlaWdodD4gYm9keS5zY3JvbGxIZWlnaHRcbiAgICBkLmRvY3VtZW50RWxlbWVudFsnc2Nyb2xsJyArIG5hbWVdLFxuICAgIC8vIHF1aXJrcyA6IGRvY3VtZW50RWxlbWVudC5zY3JvbGxIZWlnaHQg5pyA5aSn562J5LqO5Y+v6KeG56qX5Y+j5aSa5LiA54K577yfXG4gICAgZC5ib2R5WydzY3JvbGwnICsgbmFtZV0sIGRvbVV0aWxzWyd2aWV3cG9ydCcgKyBuYW1lXShkKSk7XG4gIH07XG5cbiAgZG9tVXRpbHNbJ3ZpZXdwb3J0JyArIG5hbWVdID0gZnVuY3Rpb24gKHdpbikge1xuICAgIC8vIHBjIGJyb3dzZXIgaW5jbHVkZXMgc2Nyb2xsYmFyIGluIHdpbmRvdy5pbm5lcldpZHRoXG4gICAgdmFyIHByb3AgPSAnY2xpZW50JyArIG5hbWU7XG4gICAgdmFyIGRvYyA9IHdpbi5kb2N1bWVudDtcbiAgICB2YXIgYm9keSA9IGRvYy5ib2R5O1xuICAgIHZhciBkb2N1bWVudEVsZW1lbnQgPSBkb2MuZG9jdW1lbnRFbGVtZW50O1xuICAgIHZhciBkb2N1bWVudEVsZW1lbnRQcm9wID0gZG9jdW1lbnRFbGVtZW50W3Byb3BdO1xuICAgIC8vIOagh+WHhuaooeW8j+WPliBkb2N1bWVudEVsZW1lbnRcbiAgICAvLyBiYWNrY29tcGF0IOWPliBib2R5XG4gICAgcmV0dXJuIGRvYy5jb21wYXRNb2RlID09PSAnQ1NTMUNvbXBhdCcgJiYgZG9jdW1lbnRFbGVtZW50UHJvcCB8fCBib2R5ICYmIGJvZHlbcHJvcF0gfHwgZG9jdW1lbnRFbGVtZW50UHJvcDtcbiAgfTtcbn0pO1xuXG4vKlxuIOW+l+WIsOWFg+e0oOeahOWkp+Wwj+S/oeaBr1xuIEBwYXJhbSBlbGVtXG4gQHBhcmFtIG5hbWVcbiBAcGFyYW0ge1N0cmluZ30gW2V4dHJhXSAgJ3BhZGRpbmcnIDogKGNzcyB3aWR0aCkgKyBwYWRkaW5nXG4gJ2JvcmRlcicgOiAoY3NzIHdpZHRoKSArIHBhZGRpbmcgKyBib3JkZXJcbiAnbWFyZ2luJyA6IChjc3Mgd2lkdGgpICsgcGFkZGluZyArIGJvcmRlciArIG1hcmdpblxuICovXG5mdW5jdGlvbiBnZXRXSChlbGVtLCBuYW1lLCBleHRyYSkge1xuICBpZiAoaXNXaW5kb3coZWxlbSkpIHtcbiAgICByZXR1cm4gbmFtZSA9PT0gJ3dpZHRoJyA/IGRvbVV0aWxzLnZpZXdwb3J0V2lkdGgoZWxlbSkgOiBkb21VdGlscy52aWV3cG9ydEhlaWdodChlbGVtKTtcbiAgfSBlbHNlIGlmIChlbGVtLm5vZGVUeXBlID09PSA5KSB7XG4gICAgcmV0dXJuIG5hbWUgPT09ICd3aWR0aCcgPyBkb21VdGlscy5kb2NXaWR0aChlbGVtKSA6IGRvbVV0aWxzLmRvY0hlaWdodChlbGVtKTtcbiAgfVxuICB2YXIgd2hpY2ggPSBuYW1lID09PSAnd2lkdGgnID8gWydMZWZ0JywgJ1JpZ2h0J10gOiBbJ1RvcCcsICdCb3R0b20nXTtcbiAgdmFyIGJvcmRlckJveFZhbHVlID0gbmFtZSA9PT0gJ3dpZHRoJyA/IGVsZW0ub2Zmc2V0V2lkdGggOiBlbGVtLm9mZnNldEhlaWdodDtcbiAgdmFyIGNvbXB1dGVkU3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlWChlbGVtKTtcbiAgdmFyIGlzQm9yZGVyQm94ID0gaXNCb3JkZXJCb3hGbihlbGVtLCBjb21wdXRlZFN0eWxlKTtcbiAgdmFyIGNzc0JveFZhbHVlID0gMDtcbiAgaWYgKGJvcmRlckJveFZhbHVlID09IG51bGwgfHwgYm9yZGVyQm94VmFsdWUgPD0gMCkge1xuICAgIGJvcmRlckJveFZhbHVlID0gdW5kZWZpbmVkO1xuICAgIC8vIEZhbGwgYmFjayB0byBjb21wdXRlZCB0aGVuIHVuIGNvbXB1dGVkIGNzcyBpZiBuZWNlc3NhcnlcbiAgICBjc3NCb3hWYWx1ZSA9IGdldENvbXB1dGVkU3R5bGVYKGVsZW0sIG5hbWUpO1xuICAgIGlmIChjc3NCb3hWYWx1ZSA9PSBudWxsIHx8IE51bWJlcihjc3NCb3hWYWx1ZSkgPCAwKSB7XG4gICAgICBjc3NCb3hWYWx1ZSA9IGVsZW0uc3R5bGVbbmFtZV0gfHwgMDtcbiAgICB9XG4gICAgLy8gTm9ybWFsaXplICcnLCBhdXRvLCBhbmQgcHJlcGFyZSBmb3IgZXh0cmFcbiAgICBjc3NCb3hWYWx1ZSA9IHBhcnNlRmxvYXQoY3NzQm94VmFsdWUpIHx8IDA7XG4gIH1cbiAgaWYgKGV4dHJhID09PSB1bmRlZmluZWQpIHtcbiAgICBleHRyYSA9IGlzQm9yZGVyQm94ID8gQk9SREVSX0lOREVYIDogQ09OVEVOVF9JTkRFWDtcbiAgfVxuICB2YXIgYm9yZGVyQm94VmFsdWVPcklzQm9yZGVyQm94ID0gYm9yZGVyQm94VmFsdWUgIT09IHVuZGVmaW5lZCB8fCBpc0JvcmRlckJveDtcbiAgdmFyIHZhbCA9IGJvcmRlckJveFZhbHVlIHx8IGNzc0JveFZhbHVlO1xuICBpZiAoZXh0cmEgPT09IENPTlRFTlRfSU5ERVgpIHtcbiAgICBpZiAoYm9yZGVyQm94VmFsdWVPcklzQm9yZGVyQm94KSB7XG4gICAgICByZXR1cm4gdmFsIC0gZ2V0UEJNV2lkdGgoZWxlbSwgWydib3JkZXInLCAncGFkZGluZyddLCB3aGljaCwgY29tcHV0ZWRTdHlsZSk7XG4gICAgfVxuICAgIHJldHVybiBjc3NCb3hWYWx1ZTtcbiAgfVxuICBpZiAoYm9yZGVyQm94VmFsdWVPcklzQm9yZGVyQm94KSB7XG4gICAgdmFyIHBhZGRpbmcgPSBleHRyYSA9PT0gUEFERElOR19JTkRFWCA/IC1nZXRQQk1XaWR0aChlbGVtLCBbJ2JvcmRlciddLCB3aGljaCwgY29tcHV0ZWRTdHlsZSkgOiBnZXRQQk1XaWR0aChlbGVtLCBbJ21hcmdpbiddLCB3aGljaCwgY29tcHV0ZWRTdHlsZSk7XG4gICAgcmV0dXJuIHZhbCArIChleHRyYSA9PT0gQk9SREVSX0lOREVYID8gMCA6IHBhZGRpbmcpO1xuICB9XG4gIHJldHVybiBjc3NCb3hWYWx1ZSArIGdldFBCTVdpZHRoKGVsZW0sIEJPWF9NT0RFTFMuc2xpY2UoZXh0cmEpLCB3aGljaCwgY29tcHV0ZWRTdHlsZSk7XG59XG5cbnZhciBjc3NTaG93ID0ge1xuICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgdmlzaWJpbGl0eTogJ2hpZGRlbicsXG4gIGRpc3BsYXk6ICdibG9jaydcbn07XG5cbi8vIGZpeCAjMTE5IDogaHR0cHM6Ly9naXRodWIuY29tL2tpc3N5dGVhbS9raXNzeS9pc3N1ZXMvMTE5XG5mdW5jdGlvbiBnZXRXSElnbm9yZURpc3BsYXkoZWxlbSkge1xuICB2YXIgdmFsID0gdW5kZWZpbmVkO1xuICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgLy8gaW4gY2FzZSBlbGVtIGlzIHdpbmRvd1xuICAvLyBlbGVtLm9mZnNldFdpZHRoID09PSB1bmRlZmluZWRcbiAgaWYgKGVsZW0ub2Zmc2V0V2lkdGggIT09IDApIHtcbiAgICB2YWwgPSBnZXRXSC5hcHBseSh1bmRlZmluZWQsIGFyZ3MpO1xuICB9IGVsc2Uge1xuICAgIHN3YXAoZWxlbSwgY3NzU2hvdywgZnVuY3Rpb24gKCkge1xuICAgICAgdmFsID0gZ2V0V0guYXBwbHkodW5kZWZpbmVkLCBhcmdzKTtcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gdmFsO1xufVxuXG5mdW5jdGlvbiBjc3MoZWwsIG5hbWUsIHYpIHtcbiAgdmFyIHZhbHVlID0gdjtcbiAgaWYgKCh0eXBlb2YgbmFtZSA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YobmFtZSkpID09PSAnb2JqZWN0Jykge1xuICAgIGZvciAodmFyIGkgaW4gbmFtZSkge1xuICAgICAgaWYgKG5hbWUuaGFzT3duUHJvcGVydHkoaSkpIHtcbiAgICAgICAgY3NzKGVsLCBpLCBuYW1lW2ldKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuICBpZiAodHlwZW9mIHZhbHVlICE9PSAndW5kZWZpbmVkJykge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgICB2YWx1ZSArPSAncHgnO1xuICAgIH1cbiAgICBlbC5zdHlsZVtuYW1lXSA9IHZhbHVlO1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbiAgcmV0dXJuIGdldENvbXB1dGVkU3R5bGVYKGVsLCBuYW1lKTtcbn1cblxuZWFjaChbJ3dpZHRoJywgJ2hlaWdodCddLCBmdW5jdGlvbiAobmFtZSkge1xuICB2YXIgZmlyc3QgPSBuYW1lLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgbmFtZS5zbGljZSgxKTtcbiAgZG9tVXRpbHNbJ291dGVyJyArIGZpcnN0XSA9IGZ1bmN0aW9uIChlbCwgaW5jbHVkZU1hcmdpbikge1xuICAgIHJldHVybiBlbCAmJiBnZXRXSElnbm9yZURpc3BsYXkoZWwsIG5hbWUsIGluY2x1ZGVNYXJnaW4gPyBNQVJHSU5fSU5ERVggOiBCT1JERVJfSU5ERVgpO1xuICB9O1xuICB2YXIgd2hpY2ggPSBuYW1lID09PSAnd2lkdGgnID8gWydMZWZ0JywgJ1JpZ2h0J10gOiBbJ1RvcCcsICdCb3R0b20nXTtcblxuICBkb21VdGlsc1tuYW1lXSA9IGZ1bmN0aW9uIChlbGVtLCB2YWwpIHtcbiAgICBpZiAodmFsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmIChlbGVtKSB7XG4gICAgICAgIHZhciBjb21wdXRlZFN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZVgoZWxlbSk7XG4gICAgICAgIHZhciBpc0JvcmRlckJveCA9IGlzQm9yZGVyQm94Rm4oZWxlbSk7XG4gICAgICAgIGlmIChpc0JvcmRlckJveCkge1xuICAgICAgICAgIHZhbCArPSBnZXRQQk1XaWR0aChlbGVtLCBbJ3BhZGRpbmcnLCAnYm9yZGVyJ10sIHdoaWNoLCBjb21wdXRlZFN0eWxlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY3NzKGVsZW0sIG5hbWUsIHZhbCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICByZXR1cm4gZWxlbSAmJiBnZXRXSElnbm9yZURpc3BsYXkoZWxlbSwgbmFtZSwgQ09OVEVOVF9JTkRFWCk7XG4gIH07XG59KTtcblxuLy8g6K6+572uIGVsZW0g55u45a+5IGVsZW0ub3duZXJEb2N1bWVudCDnmoTlnZDmoIdcbmZ1bmN0aW9uIHNldE9mZnNldChlbGVtLCBvZmZzZXQpIHtcbiAgLy8gc2V0IHBvc2l0aW9uIGZpcnN0LCBpbi1jYXNlIHRvcC9sZWZ0IGFyZSBzZXQgZXZlbiBvbiBzdGF0aWMgZWxlbVxuICBpZiAoY3NzKGVsZW0sICdwb3NpdGlvbicpID09PSAnc3RhdGljJykge1xuICAgIGVsZW0uc3R5bGUucG9zaXRpb24gPSAncmVsYXRpdmUnO1xuICB9XG5cbiAgdmFyIG9sZCA9IGdldE9mZnNldChlbGVtKTtcbiAgdmFyIHJldCA9IHt9O1xuICB2YXIgY3VycmVudCA9IHVuZGVmaW5lZDtcbiAgdmFyIGtleSA9IHVuZGVmaW5lZDtcblxuICBmb3IgKGtleSBpbiBvZmZzZXQpIHtcbiAgICBpZiAob2Zmc2V0Lmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgIGN1cnJlbnQgPSBwYXJzZUZsb2F0KGNzcyhlbGVtLCBrZXkpKSB8fCAwO1xuICAgICAgcmV0W2tleV0gPSBjdXJyZW50ICsgb2Zmc2V0W2tleV0gLSBvbGRba2V5XTtcbiAgICB9XG4gIH1cbiAgY3NzKGVsZW0sIHJldCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2V4dGVuZHMoe1xuICBnZXRXaW5kb3c6IGZ1bmN0aW9uIGdldFdpbmRvdyhub2RlKSB7XG4gICAgdmFyIGRvYyA9IG5vZGUub3duZXJEb2N1bWVudCB8fCBub2RlO1xuICAgIHJldHVybiBkb2MuZGVmYXVsdFZpZXcgfHwgZG9jLnBhcmVudFdpbmRvdztcbiAgfSxcbiAgb2Zmc2V0OiBmdW5jdGlvbiBvZmZzZXQoZWwsIHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHNldE9mZnNldChlbCwgdmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZ2V0T2Zmc2V0KGVsKTtcbiAgICB9XG4gIH0sXG5cbiAgaXNXaW5kb3c6IGlzV2luZG93LFxuICBlYWNoOiBlYWNoLFxuICBjc3M6IGNzcyxcbiAgY2xvbmU6IGZ1bmN0aW9uIGNsb25lKG9iaikge1xuICAgIHZhciByZXQgPSB7fTtcbiAgICBmb3IgKHZhciBpIGluIG9iaikge1xuICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShpKSkge1xuICAgICAgICByZXRbaV0gPSBvYmpbaV07XG4gICAgICB9XG4gICAgfVxuICAgIHZhciBvdmVyZmxvdyA9IG9iai5vdmVyZmxvdztcbiAgICBpZiAob3ZlcmZsb3cpIHtcbiAgICAgIGZvciAodmFyIGkgaW4gb2JqKSB7XG4gICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkoaSkpIHtcbiAgICAgICAgICByZXQub3ZlcmZsb3dbaV0gPSBvYmoub3ZlcmZsb3dbaV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfSxcbiAgc2Nyb2xsTGVmdDogZnVuY3Rpb24gc2Nyb2xsTGVmdCh3LCB2KSB7XG4gICAgaWYgKGlzV2luZG93KHcpKSB7XG4gICAgICBpZiAodiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBnZXRTY3JvbGxMZWZ0KHcpO1xuICAgICAgfVxuICAgICAgd2luZG93LnNjcm9sbFRvKHYsIGdldFNjcm9sbFRvcCh3KSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh2ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHcuc2Nyb2xsTGVmdDtcbiAgICAgIH1cbiAgICAgIHcuc2Nyb2xsTGVmdCA9IHY7XG4gICAgfVxuICB9LFxuICBzY3JvbGxUb3A6IGZ1bmN0aW9uIHNjcm9sbFRvcCh3LCB2KSB7XG4gICAgaWYgKGlzV2luZG93KHcpKSB7XG4gICAgICBpZiAodiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBnZXRTY3JvbGxUb3Aodyk7XG4gICAgICB9XG4gICAgICB3aW5kb3cuc2Nyb2xsVG8oZ2V0U2Nyb2xsTGVmdCh3KSwgdik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh2ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHcuc2Nyb2xsVG9wO1xuICAgICAgfVxuICAgICAgdy5zY3JvbGxUb3AgPSB2O1xuICAgIH1cbiAgfSxcblxuICB2aWV3cG9ydFdpZHRoOiAwLFxuICB2aWV3cG9ydEhlaWdodDogMFxufSwgZG9tVXRpbHMpO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3V4Y29yZS10YWJsZS9+L3V4Y29yZS1tZW51L34vcmMtbWVudS9+L2RvbS1zY3JvbGwtaW50by12aWV3L2xpYi91dGlsLmpzXG4gKiogbW9kdWxlIGlkID0gMzhcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLm5vb3AgPSBub29wO1xuZXhwb3J0cy5nZXRLZXlGcm9tQ2hpbGRyZW5JbmRleCA9IGdldEtleUZyb21DaGlsZHJlbkluZGV4O1xuZXhwb3J0cy5sb29wTWVudUl0ZW0gPSBsb29wTWVudUl0ZW07XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxudmFyIF9yZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5cbnZhciBfcmVhY3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmVhY3QpO1xuXG52YXIgbm93ID0gRGF0ZS5ub3coKTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbmZ1bmN0aW9uIGdldEtleUZyb21DaGlsZHJlbkluZGV4KGNoaWxkLCBtZW51RXZlbnRLZXksIGluZGV4KSB7XG4gIHZhciBwcmVmaXggPSBtZW51RXZlbnRLZXkgfHwgJyc7XG4gIHJldHVybiBjaGlsZC5rZXkgfHwgcHJlZml4ICsgJ2l0ZW1fJyArIG5vdyArICdfJyArIGluZGV4O1xufVxuXG5mdW5jdGlvbiBsb29wTWVudUl0ZW0oY2hpbGRyZW4sIGNiKSB7XG4gIHZhciBpbmRleCA9IC0xO1xuICBfcmVhY3QyWydkZWZhdWx0J10uQ2hpbGRyZW4uZm9yRWFjaChjaGlsZHJlbiwgZnVuY3Rpb24gKGMpIHtcbiAgICBpbmRleCsrO1xuICAgIGlmIChjICYmIGMudHlwZS5pc01lbnVJdGVtR3JvdXApIHtcbiAgICAgIF9yZWFjdDJbJ2RlZmF1bHQnXS5DaGlsZHJlbi5mb3JFYWNoKGMucHJvcHMuY2hpbGRyZW4sIGZ1bmN0aW9uIChjMikge1xuICAgICAgICBpbmRleCsrO1xuICAgICAgICBjYihjMiwgaW5kZXgpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNiKGMsIGluZGV4KTtcbiAgICB9XG4gIH0pO1xufVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3V4Y29yZS10YWJsZS9+L3V4Y29yZS1tZW51L34vcmMtbWVudS9saWIvdXRpbC5qc1xuICoqIG1vZHVsZSBpZCA9IDM5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbnZhciBfcmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xuXG52YXIgX3JlYWN0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JlYWN0KTtcblxudmFyIF9vYmplY3RBc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG5cbnZhciBfb2JqZWN0QXNzaWduMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX29iamVjdEFzc2lnbik7XG5cbnZhciBET01XcmFwID0gX3JlYWN0MlsnZGVmYXVsdCddLmNyZWF0ZUNsYXNzKHtcbiAgZGlzcGxheU5hbWU6ICdET01XcmFwJyxcblxuICBwcm9wVHlwZXM6IHtcbiAgICB0YWc6IF9yZWFjdDJbJ2RlZmF1bHQnXS5Qcm9wVHlwZXMuc3RyaW5nXG4gIH0sXG5cbiAgZ2V0RGVmYXVsdFByb3BzOiBmdW5jdGlvbiBnZXREZWZhdWx0UHJvcHMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRhZzogJ2RpdidcbiAgICB9O1xuICB9LFxuXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgIHZhciBwcm9wcyA9ICgwLCBfb2JqZWN0QXNzaWduMlsnZGVmYXVsdCddKSh7fSwgdGhpcy5wcm9wcyk7XG4gICAgaWYgKCFwcm9wcy52aXNpYmxlKSB7XG4gICAgICBwcm9wcy5jbGFzc05hbWUgPSBwcm9wcy5jbGFzc05hbWUgfHwgJyc7XG4gICAgICBwcm9wcy5jbGFzc05hbWUgKz0gJyAnICsgcHJvcHMuaGlkZGVuQ2xhc3NOYW1lO1xuICAgIH1cbiAgICB2YXIgVGFnID0gcHJvcHMudGFnO1xuICAgIHJldHVybiBfcmVhY3QyWydkZWZhdWx0J10uY3JlYXRlRWxlbWVudChUYWcsIHByb3BzKTtcbiAgfVxufSk7XG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IERPTVdyYXA7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi91eGNvcmUtdGFibGUvfi91eGNvcmUtbWVudS9+L3JjLW1lbnUvbGliL0RPTVdyYXAuanNcbiAqKiBtb2R1bGUgaWQgPSA0MFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxuXG52YXIgX1N1YlBvcHVwTWVudSA9IHJlcXVpcmUoJy4vU3ViUG9wdXBNZW51Jyk7XG5cbnZhciBfU3ViUG9wdXBNZW51MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1N1YlBvcHVwTWVudSk7XG5cbnZhciBfcmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xuXG52YXIgX3JlYWN0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JlYWN0KTtcblxudmFyIF9yY1V0aWwgPSByZXF1aXJlKCdyYy11dGlsJyk7XG5cbnZhciBfY2xhc3NuYW1lcyA9IHJlcXVpcmUoJ2NsYXNzbmFtZXMnKTtcblxudmFyIF9jbGFzc25hbWVzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NsYXNzbmFtZXMpO1xuXG52YXIgX29iamVjdEFzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcblxudmFyIF9vYmplY3RBc3NpZ24yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfb2JqZWN0QXNzaWduKTtcblxudmFyIFN1Yk1lbnUgPSBfcmVhY3QyWydkZWZhdWx0J10uY3JlYXRlQ2xhc3Moe1xuICBkaXNwbGF5TmFtZTogJ1N1Yk1lbnUnLFxuXG4gIHByb3BUeXBlczoge1xuICAgIHBhcmVudE1lbnU6IF9yZWFjdDJbJ2RlZmF1bHQnXS5Qcm9wVHlwZXMub2JqZWN0LFxuICAgIHRpdGxlOiBfcmVhY3QyWydkZWZhdWx0J10uUHJvcFR5cGVzLm5vZGUsXG4gICAgb25DbGljazogX3JlYWN0MlsnZGVmYXVsdCddLlByb3BUeXBlcy5mdW5jLFxuICAgIG9uT3BlbkNoYW5nZTogX3JlYWN0MlsnZGVmYXVsdCddLlByb3BUeXBlcy5mdW5jLFxuICAgIHJvb3RQcmVmaXhDbHM6IF9yZWFjdDJbJ2RlZmF1bHQnXS5Qcm9wVHlwZXMuc3RyaW5nLFxuICAgIGV2ZW50S2V5OiBfcmVhY3QyWydkZWZhdWx0J10uUHJvcFR5cGVzLnN0cmluZyxcbiAgICBtdWx0aXBsZTogX3JlYWN0MlsnZGVmYXVsdCddLlByb3BUeXBlcy5ib29sLFxuICAgIGFjdGl2ZTogX3JlYWN0MlsnZGVmYXVsdCddLlByb3BUeXBlcy5ib29sLFxuICAgIG9wZW46IF9yZWFjdDJbJ2RlZmF1bHQnXS5Qcm9wVHlwZXMuYm9vbCxcbiAgICBvblNlbGVjdDogX3JlYWN0MlsnZGVmYXVsdCddLlByb3BUeXBlcy5mdW5jLFxuICAgIGNsb3NlU3ViTWVudU9uTW91c2VMZWF2ZTogX3JlYWN0MlsnZGVmYXVsdCddLlByb3BUeXBlcy5ib29sLFxuICAgIG9wZW5TdWJNZW51T25Nb3VzZUVudGVyOiBfcmVhY3QyWydkZWZhdWx0J10uUHJvcFR5cGVzLmJvb2wsXG4gICAgb25EZXNlbGVjdDogX3JlYWN0MlsnZGVmYXVsdCddLlByb3BUeXBlcy5mdW5jLFxuICAgIG9uRGVzdHJveTogX3JlYWN0MlsnZGVmYXVsdCddLlByb3BUeXBlcy5mdW5jLFxuICAgIG9uSXRlbUhvdmVyOiBfcmVhY3QyWydkZWZhdWx0J10uUHJvcFR5cGVzLmZ1bmNcbiAgfSxcblxuICBtaXhpbnM6IFtyZXF1aXJlKCcuL1N1Yk1lbnVTdGF0ZU1peGluJyldLFxuXG4gIGdldERlZmF1bHRQcm9wczogZnVuY3Rpb24gZ2V0RGVmYXVsdFByb3BzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBvbk1vdXNlRW50ZXI6IGZ1bmN0aW9uIG9uTW91c2VFbnRlcigpIHt9LFxuICAgICAgdGl0bGU6ICcnXG4gICAgfTtcbiAgfSxcblxuICBnZXRJbml0aWFsU3RhdGU6IGZ1bmN0aW9uIGdldEluaXRpYWxTdGF0ZSgpIHtcbiAgICB0aGlzLmlzU3ViTWVudSA9IDE7XG4gICAgcmV0dXJuIHtcbiAgICAgIGRlZmF1bHRBY3RpdmVGaXJzdDogZmFsc2VcbiAgICB9O1xuICB9LFxuXG4gIGNvbXBvbmVudFdpbGxVbm1vdW50OiBmdW5jdGlvbiBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICB2YXIgcHJvcHMgPSB0aGlzLnByb3BzO1xuICAgIGlmIChwcm9wcy5vbkRlc3Ryb3kpIHtcbiAgICAgIHByb3BzLm9uRGVzdHJveShwcm9wcy5ldmVudEtleSk7XG4gICAgfVxuICB9LFxuXG4gIG9uRGVzdHJveTogZnVuY3Rpb24gb25EZXN0cm95KGtleSkge1xuICAgIHRoaXMucHJvcHMub25EZXN0cm95KGtleSk7XG4gIH0sXG5cbiAgb25LZXlEb3duOiBmdW5jdGlvbiBvbktleURvd24oZSkge1xuICAgIHZhciBrZXlDb2RlID0gZS5rZXlDb2RlO1xuICAgIHZhciBtZW51ID0gdGhpcy5tZW51SW5zdGFuY2U7XG5cbiAgICBpZiAoa2V5Q29kZSA9PT0gX3JjVXRpbC5LZXlDb2RlLkVOVEVSKSB7XG4gICAgICB0aGlzLm9uQ2xpY2soZSk7XG4gICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgZGVmYXVsdEFjdGl2ZUZpcnN0OiB0cnVlXG4gICAgICB9KTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmIChrZXlDb2RlID09PSBfcmNVdGlsLktleUNvZGUuUklHSFQpIHtcbiAgICAgIGlmICh0aGlzLnByb3BzLm9wZW4pIHtcbiAgICAgICAgbWVudS5vbktleURvd24oZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnRyaWdnZXJPcGVuQ2hhbmdlKHRydWUpO1xuICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICBkZWZhdWx0QWN0aXZlRmlyc3Q6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKGtleUNvZGUgPT09IF9yY1V0aWwuS2V5Q29kZS5MRUZUKSB7XG4gICAgICB2YXIgaGFuZGxlZCA9IHVuZGVmaW5lZDtcbiAgICAgIGlmICh0aGlzLnByb3BzLm9wZW4pIHtcbiAgICAgICAgaGFuZGxlZCA9IG1lbnUub25LZXlEb3duKGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIGlmICghaGFuZGxlZCkge1xuICAgICAgICB0aGlzLnRyaWdnZXJPcGVuQ2hhbmdlKGZhbHNlKTtcbiAgICAgICAgaGFuZGxlZCA9IHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gaGFuZGxlZDtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5wcm9wcy5vcGVuICYmIChrZXlDb2RlID09PSBfcmNVdGlsLktleUNvZGUuVVAgfHwga2V5Q29kZSA9PT0gX3JjVXRpbC5LZXlDb2RlLkRPV04pKSB7XG4gICAgICByZXR1cm4gbWVudS5vbktleURvd24oZSk7XG4gICAgfVxuICB9LFxuXG4gIG9uU3ViVHJlZU1vdXNlRW50ZXI6IGZ1bmN0aW9uIG9uU3ViVHJlZU1vdXNlRW50ZXIoKSB7XG4gICAgaWYgKHRoaXMubGVhdmVUaW1lcikge1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMubGVhdmVUaW1lcik7XG4gICAgICB0aGlzLmxlYXZlVGltZXIgPSBudWxsO1xuICAgIH1cbiAgfSxcblxuICBvbk9wZW5DaGFuZ2U6IGZ1bmN0aW9uIG9uT3BlbkNoYW5nZShlKSB7XG4gICAgdGhpcy5wcm9wcy5vbk9wZW5DaGFuZ2UodGhpcy5hZGRLZXlQYXRoKGUpKTtcbiAgfSxcblxuICBvbk1vdXNlRW50ZXI6IGZ1bmN0aW9uIG9uTW91c2VFbnRlcigpIHtcbiAgICBpZiAodGhpcy5sZWF2ZVRpbWVyKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy5sZWF2ZVRpbWVyKTtcbiAgICAgIHRoaXMubGVhdmVUaW1lciA9IG51bGw7XG4gICAgfVxuICAgIHZhciBwcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgdmFyIHBhcmVudE1lbnUgPSBwcm9wcy5wYXJlbnRNZW51O1xuICAgIGlmIChwYXJlbnRNZW51Lm1lbnVJdGVtTW91c2VMZWF2ZVRpbWVyKSB7XG4gICAgICBjbGVhclRpbWVvdXQocGFyZW50TWVudS5tZW51SXRlbU1vdXNlTGVhdmVUaW1lcik7XG4gICAgICBwYXJlbnRNZW51Lm1lbnVJdGVtTW91c2VMZWF2ZVRpbWVyID0gbnVsbDtcbiAgICB9XG4gICAgcHJvcHMub25JdGVtSG92ZXIoe1xuICAgICAga2V5OiB0aGlzLnByb3BzLmV2ZW50S2V5LFxuICAgICAgaXRlbTogdGhpcyxcbiAgICAgIGhvdmVyOiB0cnVlLFxuICAgICAgdHJpZ2dlcjogJ21vdXNlZW50ZXInXG4gICAgfSk7XG4gICAgaWYgKHByb3BzLm9wZW5TdWJNZW51T25Nb3VzZUVudGVyKSB7XG4gICAgICB0aGlzLnRyaWdnZXJPcGVuQ2hhbmdlKHRydWUpO1xuICAgIH1cbiAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgIGRlZmF1bHRBY3RpdmVGaXJzdDogZmFsc2VcbiAgICB9KTtcbiAgfSxcblxuICBvbk1vdXNlTGVhdmU6IGZ1bmN0aW9uIG9uTW91c2VMZWF2ZSgpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgLy8gcHJldmVudCBwb3B1cCBtZW51IGFuZCBzdWJtZW51IGdhcFxuICAgIHRoaXMubGVhdmVUaW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgLy8gbGVhdmUgd2hvbGUgc3ViIHRyZWVcbiAgICAgIC8vIHN0aWxsIGFjdGl2ZVxuICAgICAgaWYgKF90aGlzLmlzTW91bnRlZCgpICYmIF90aGlzLnByb3BzLmFjdGl2ZSkge1xuICAgICAgICBfdGhpcy5wcm9wcy5vbkl0ZW1Ib3Zlcih7XG4gICAgICAgICAga2V5OiBfdGhpcy5wcm9wcy5ldmVudEtleSxcbiAgICAgICAgICBpdGVtOiBfdGhpcyxcbiAgICAgICAgICBob3ZlcjogZmFsc2UsXG4gICAgICAgICAgdHJpZ2dlcjogJ21vdXNlbGVhdmUnXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKF90aGlzLmlzTW91bnRlZCgpICYmIF90aGlzLnByb3BzLm9wZW4pIHtcbiAgICAgICAgaWYgKF90aGlzLnByb3BzLmNsb3NlU3ViTWVudU9uTW91c2VMZWF2ZSkge1xuICAgICAgICAgIF90aGlzLnRyaWdnZXJPcGVuQ2hhbmdlKGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIDEwMCk7XG4gIH0sXG5cbiAgb25DbGljazogZnVuY3Rpb24gb25DbGljaygpIHtcbiAgICBpZiAodGhpcy5wcm9wcy5vcGVuU3ViTWVudU9uTW91c2VFbnRlcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnRyaWdnZXJPcGVuQ2hhbmdlKCF0aGlzLnByb3BzLm9wZW4sICdjbGljaycpO1xuICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgZGVmYXVsdEFjdGl2ZUZpcnN0OiBmYWxzZVxuICAgIH0pO1xuICB9LFxuXG4gIG9uU3ViTWVudUNsaWNrOiBmdW5jdGlvbiBvblN1Yk1lbnVDbGljayhpbmZvKSB7XG4gICAgdGhpcy5wcm9wcy5vbkNsaWNrKHRoaXMuYWRkS2V5UGF0aChpbmZvKSk7XG4gIH0sXG5cbiAgb25TZWxlY3Q6IGZ1bmN0aW9uIG9uU2VsZWN0KGluZm8pIHtcbiAgICB0aGlzLnByb3BzLm9uU2VsZWN0KGluZm8pO1xuICB9LFxuXG4gIG9uRGVzZWxlY3Q6IGZ1bmN0aW9uIG9uRGVzZWxlY3QoaW5mbykge1xuICAgIHRoaXMucHJvcHMub25EZXNlbGVjdChpbmZvKTtcbiAgfSxcblxuICBnZXRQcmVmaXhDbHM6IGZ1bmN0aW9uIGdldFByZWZpeENscygpIHtcbiAgICByZXR1cm4gdGhpcy5wcm9wcy5yb290UHJlZml4Q2xzICsgJy1zdWJtZW51JztcbiAgfSxcblxuICBnZXRBY3RpdmVDbGFzc05hbWU6IGZ1bmN0aW9uIGdldEFjdGl2ZUNsYXNzTmFtZSgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRQcmVmaXhDbHMoKSArICctYWN0aXZlJztcbiAgfSxcblxuICBnZXREaXNhYmxlZENsYXNzTmFtZTogZnVuY3Rpb24gZ2V0RGlzYWJsZWRDbGFzc05hbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0UHJlZml4Q2xzKCkgKyAnLWRpc2FibGVkJztcbiAgfSxcblxuICBnZXRPcGVuQ2xhc3NOYW1lOiBmdW5jdGlvbiBnZXRPcGVuQ2xhc3NOYW1lKCkge1xuICAgIHJldHVybiB0aGlzLnByb3BzLnJvb3RQcmVmaXhDbHMgKyAnLXN1Ym1lbnUtb3Blbic7XG4gIH0sXG5cbiAgc2F2ZU1lbnVJbnN0YW5jZTogZnVuY3Rpb24gc2F2ZU1lbnVJbnN0YW5jZShjKSB7XG4gICAgdGhpcy5tZW51SW5zdGFuY2UgPSBjO1xuICB9LFxuXG4gIGFkZEtleVBhdGg6IGZ1bmN0aW9uIGFkZEtleVBhdGgoaW5mbykge1xuICAgIHJldHVybiAoMCwgX29iamVjdEFzc2lnbjJbJ2RlZmF1bHQnXSkoe30sIGluZm8sIHtcbiAgICAgIGtleVBhdGg6IChpbmZvLmtleVBhdGggfHwgW10pLmNvbmNhdCh0aGlzLnByb3BzLmV2ZW50S2V5KVxuICAgIH0pO1xuICB9LFxuXG4gIHRyaWdnZXJPcGVuQ2hhbmdlOiBmdW5jdGlvbiB0cmlnZ2VyT3BlbkNoYW5nZShvcGVuLCB0eXBlKSB7XG4gICAgdmFyIGtleSA9IHRoaXMucHJvcHMuZXZlbnRLZXk7XG4gICAgdGhpcy5vbk9wZW5DaGFuZ2Uoe1xuICAgICAga2V5OiBrZXksXG4gICAgICBpdGVtOiB0aGlzLFxuICAgICAgdHJpZ2dlcjogdHlwZSxcbiAgICAgIG9wZW46IG9wZW5cbiAgICB9KTtcbiAgfSxcblxuICByZW5kZXJDaGlsZHJlbjogZnVuY3Rpb24gcmVuZGVyQ2hpbGRyZW4oY2hpbGRyZW4pIHtcbiAgICB2YXIgcHJvcHMgPSB0aGlzLnByb3BzO1xuICAgIHZhciBiYXNlUHJvcHMgPSB7XG4gICAgICBtb2RlOiBwcm9wcy5tb2RlID09PSAnaG9yaXpvbnRhbCcgPyAndmVydGljYWwnIDogcHJvcHMubW9kZSxcbiAgICAgIHZpc2libGU6IHByb3BzLm9wZW4sXG4gICAgICBsZXZlbDogcHJvcHMubGV2ZWwgKyAxLFxuICAgICAgaW5saW5lSW5kZW50OiBwcm9wcy5pbmxpbmVJbmRlbnQsXG4gICAgICBmb2N1c2FibGU6IGZhbHNlLFxuICAgICAgb25DbGljazogdGhpcy5vblN1Yk1lbnVDbGljayxcbiAgICAgIG9uU2VsZWN0OiB0aGlzLm9uU2VsZWN0LFxuICAgICAgb25EZXNlbGVjdDogdGhpcy5vbkRlc2VsZWN0LFxuICAgICAgb25EZXN0cm95OiB0aGlzLm9uRGVzdHJveSxcbiAgICAgIHNlbGVjdGVkS2V5czogcHJvcHMuc2VsZWN0ZWRLZXlzLFxuICAgICAgZXZlbnRLZXk6IHByb3BzLmV2ZW50S2V5ICsgJy1tZW51LScsXG4gICAgICBvcGVuS2V5czogcHJvcHMub3BlbktleXMsXG4gICAgICBvcGVuVHJhbnNpdGlvbk5hbWU6IHByb3BzLm9wZW5UcmFuc2l0aW9uTmFtZSxcbiAgICAgIG9wZW5BbmltYXRpb246IHByb3BzLm9wZW5BbmltYXRpb24sXG4gICAgICBvbk9wZW5DaGFuZ2U6IHRoaXMub25PcGVuQ2hhbmdlLFxuICAgICAgY2xvc2VTdWJNZW51T25Nb3VzZUxlYXZlOiBwcm9wcy5jbG9zZVN1Yk1lbnVPbk1vdXNlTGVhdmUsXG4gICAgICBkZWZhdWx0QWN0aXZlRmlyc3Q6IHRoaXMuc3RhdGUuZGVmYXVsdEFjdGl2ZUZpcnN0LFxuICAgICAgbXVsdGlwbGU6IHByb3BzLm11bHRpcGxlLFxuICAgICAgcHJlZml4Q2xzOiBwcm9wcy5yb290UHJlZml4Q2xzLFxuICAgICAgaWQ6IHRoaXMuX21lbnVJZCxcbiAgICAgIHJlZjogdGhpcy5zYXZlTWVudUluc3RhbmNlXG4gICAgfTtcbiAgICByZXR1cm4gX3JlYWN0MlsnZGVmYXVsdCddLmNyZWF0ZUVsZW1lbnQoXG4gICAgICBfU3ViUG9wdXBNZW51MlsnZGVmYXVsdCddLFxuICAgICAgYmFzZVByb3BzLFxuICAgICAgY2hpbGRyZW5cbiAgICApO1xuICB9LFxuXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgIHZhciBfY2xhc3NlcztcblxuICAgIHRoaXMuaGF2ZU9wZW4gPSB0aGlzLmhhdmVPcGVuIHx8IHRoaXMucHJvcHMub3BlbjtcbiAgICB2YXIgcHJvcHMgPSB0aGlzLnByb3BzO1xuICAgIHZhciBwcmVmaXhDbHMgPSB0aGlzLmdldFByZWZpeENscygpO1xuICAgIHZhciBjbGFzc2VzID0gKF9jbGFzc2VzID0ge30sIF9kZWZpbmVQcm9wZXJ0eShfY2xhc3NlcywgcHJvcHMuY2xhc3NOYW1lLCAhIXByb3BzLmNsYXNzTmFtZSksIF9kZWZpbmVQcm9wZXJ0eShfY2xhc3NlcywgcHJlZml4Q2xzICsgJy0nICsgcHJvcHMubW9kZSwgMSksIF9jbGFzc2VzKTtcblxuICAgIGNsYXNzZXNbdGhpcy5nZXRPcGVuQ2xhc3NOYW1lKCldID0gdGhpcy5wcm9wcy5vcGVuO1xuICAgIGNsYXNzZXNbdGhpcy5nZXRBY3RpdmVDbGFzc05hbWUoKV0gPSBwcm9wcy5hY3RpdmU7XG4gICAgY2xhc3Nlc1t0aGlzLmdldERpc2FibGVkQ2xhc3NOYW1lKCldID0gcHJvcHMuZGlzYWJsZWQ7XG4gICAgdGhpcy5fbWVudUlkID0gdGhpcy5fbWVudUlkIHx8ICgwLCBfcmNVdGlsLmd1aWQpKCk7XG4gICAgY2xhc3Nlc1twcmVmaXhDbHNdID0gdHJ1ZTtcbiAgICBjbGFzc2VzW3ByZWZpeENscyArICctJyArIHByb3BzLm1vZGVdID0gMTtcbiAgICB2YXIgY2xpY2tFdmVudHMgPSB7fTtcbiAgICB2YXIgbW91c2VFdmVudHMgPSB7fTtcbiAgICB2YXIgdGl0bGVNb3VzZUV2ZW50cyA9IHt9O1xuICAgIGlmICghcHJvcHMuZGlzYWJsZWQpIHtcbiAgICAgIGNsaWNrRXZlbnRzID0ge1xuICAgICAgICBvbkNsaWNrOiB0aGlzLm9uQ2xpY2tcbiAgICAgIH07XG4gICAgICBtb3VzZUV2ZW50cyA9IHtcbiAgICAgICAgb25Nb3VzZUxlYXZlOiB0aGlzLm9uTW91c2VMZWF2ZSxcbiAgICAgICAgb25Nb3VzZUVudGVyOiB0aGlzLm9uU3ViVHJlZU1vdXNlRW50ZXJcbiAgICAgIH07XG4gICAgICAvLyBvbmx5IHdvcmtzIGluIHRpdGxlLCBub3Qgb3V0ZXIgbGlcbiAgICAgIHRpdGxlTW91c2VFdmVudHMgPSB7XG4gICAgICAgIG9uTW91c2VFbnRlcjogdGhpcy5vbk1vdXNlRW50ZXJcbiAgICAgIH07XG4gICAgfVxuICAgIHZhciBzdHlsZSA9IHt9O1xuICAgIGlmIChwcm9wcy5tb2RlID09PSAnaW5saW5lJykge1xuICAgICAgc3R5bGUucGFkZGluZ0xlZnQgPSBwcm9wcy5pbmxpbmVJbmRlbnQgKiBwcm9wcy5sZXZlbDtcbiAgICB9XG4gICAgcmV0dXJuIF9yZWFjdDJbJ2RlZmF1bHQnXS5jcmVhdGVFbGVtZW50KFxuICAgICAgJ2xpJyxcbiAgICAgIF9leHRlbmRzKHsgY2xhc3NOYW1lOiAoMCwgX2NsYXNzbmFtZXMyWydkZWZhdWx0J10pKGNsYXNzZXMpIH0sIG1vdXNlRXZlbnRzKSxcbiAgICAgIF9yZWFjdDJbJ2RlZmF1bHQnXS5jcmVhdGVFbGVtZW50KFxuICAgICAgICAnZGl2JyxcbiAgICAgICAgX2V4dGVuZHMoe1xuICAgICAgICAgIHN0eWxlOiBzdHlsZSxcbiAgICAgICAgICBjbGFzc05hbWU6IHByZWZpeENscyArICctdGl0bGUnXG4gICAgICAgIH0sIHRpdGxlTW91c2VFdmVudHMsIGNsaWNrRXZlbnRzLCB7XG4gICAgICAgICAgJ2FyaWEtb3Blbic6IHByb3BzLm9wZW4sXG4gICAgICAgICAgJ2FyaWEtb3ducyc6IHRoaXMuX21lbnVJZCxcbiAgICAgICAgICAnYXJpYS1oYXNwb3B1cCc6ICd0cnVlJ1xuICAgICAgICB9KSxcbiAgICAgICAgcHJvcHMudGl0bGVcbiAgICAgICksXG4gICAgICB0aGlzLnJlbmRlckNoaWxkcmVuKHByb3BzLmNoaWxkcmVuKVxuICAgICk7XG4gIH1cbn0pO1xuXG5leHBvcnRzWydkZWZhdWx0J10gPSBTdWJNZW51O1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vdXhjb3JlLXRhYmxlL34vdXhjb3JlLW1lbnUvfi9yYy1tZW51L2xpYi9TdWJNZW51LmpzXG4gKiogbW9kdWxlIGlkID0gNDFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxudmFyIF9yZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5cbnZhciBfcmVhY3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmVhY3QpO1xuXG52YXIgX01lbnVNaXhpbiA9IHJlcXVpcmUoJy4vTWVudU1peGluJyk7XG5cbnZhciBfTWVudU1peGluMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX01lbnVNaXhpbik7XG5cbnZhciBfb2JqZWN0QXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xuXG52YXIgX29iamVjdEFzc2lnbjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9vYmplY3RBc3NpZ24pO1xuXG52YXIgX3V0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcblxudmFyIF9yY0FuaW1hdGUgPSByZXF1aXJlKCdyYy1hbmltYXRlJyk7XG5cbnZhciBfcmNBbmltYXRlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JjQW5pbWF0ZSk7XG5cbnZhciBTdWJQb3B1cE1lbnUgPSBfcmVhY3QyWydkZWZhdWx0J10uY3JlYXRlQ2xhc3Moe1xuICBkaXNwbGF5TmFtZTogJ1N1YlBvcHVwTWVudScsXG5cbiAgcHJvcFR5cGVzOiB7XG4gICAgb25TZWxlY3Q6IF9yZWFjdDJbJ2RlZmF1bHQnXS5Qcm9wVHlwZXMuZnVuYyxcbiAgICBvbkNsaWNrOiBfcmVhY3QyWydkZWZhdWx0J10uUHJvcFR5cGVzLmZ1bmMsXG4gICAgb25EZXNlbGVjdDogX3JlYWN0MlsnZGVmYXVsdCddLlByb3BUeXBlcy5mdW5jLFxuICAgIG9uT3BlbkNoYW5nZTogX3JlYWN0MlsnZGVmYXVsdCddLlByb3BUeXBlcy5mdW5jLFxuICAgIG9uRGVzdHJveTogX3JlYWN0MlsnZGVmYXVsdCddLlByb3BUeXBlcy5mdW5jLFxuICAgIG9wZW5UcmFuc2l0aW9uTmFtZTogX3JlYWN0MlsnZGVmYXVsdCddLlByb3BUeXBlcy5zdHJpbmcsXG4gICAgb3BlbkFuaW1hdGlvbjogX3JlYWN0MlsnZGVmYXVsdCddLlByb3BUeXBlcy5vbmVPZlR5cGUoW19yZWFjdDJbJ2RlZmF1bHQnXS5Qcm9wVHlwZXMuc3RyaW5nLCBfcmVhY3QyWydkZWZhdWx0J10uUHJvcFR5cGVzLm9iamVjdF0pLFxuICAgIG9wZW5LZXlzOiBfcmVhY3QyWydkZWZhdWx0J10uUHJvcFR5cGVzLmFycmF5T2YoX3JlYWN0MlsnZGVmYXVsdCddLlByb3BUeXBlcy5zdHJpbmcpLFxuICAgIGNsb3NlU3ViTWVudU9uTW91c2VMZWF2ZTogX3JlYWN0MlsnZGVmYXVsdCddLlByb3BUeXBlcy5ib29sLFxuICAgIHZpc2libGU6IF9yZWFjdDJbJ2RlZmF1bHQnXS5Qcm9wVHlwZXMuYm9vbCxcbiAgICBjaGlsZHJlbjogX3JlYWN0MlsnZGVmYXVsdCddLlByb3BUeXBlcy5hbnlcbiAgfSxcblxuICBtaXhpbnM6IFtfTWVudU1peGluMlsnZGVmYXVsdCddXSxcblxuICBvbkRlc2VsZWN0OiBmdW5jdGlvbiBvbkRlc2VsZWN0KHNlbGVjdEluZm8pIHtcbiAgICB0aGlzLnByb3BzLm9uRGVzZWxlY3Qoc2VsZWN0SW5mbyk7XG4gIH0sXG5cbiAgb25TZWxlY3Q6IGZ1bmN0aW9uIG9uU2VsZWN0KHNlbGVjdEluZm8pIHtcbiAgICB0aGlzLnByb3BzLm9uU2VsZWN0KHNlbGVjdEluZm8pO1xuICB9LFxuXG4gIG9uQ2xpY2s6IGZ1bmN0aW9uIG9uQ2xpY2soZSkge1xuICAgIHRoaXMucHJvcHMub25DbGljayhlKTtcbiAgfSxcblxuICBvbk9wZW5DaGFuZ2U6IGZ1bmN0aW9uIG9uT3BlbkNoYW5nZShlKSB7XG4gICAgdGhpcy5wcm9wcy5vbk9wZW5DaGFuZ2UoZSk7XG4gIH0sXG5cbiAgb25EZXN0cm95OiBmdW5jdGlvbiBvbkRlc3Ryb3koa2V5KSB7XG4gICAgdGhpcy5wcm9wcy5vbkRlc3Ryb3koa2V5KTtcbiAgfSxcblxuICBvbkl0ZW1Ib3ZlcjogZnVuY3Rpb24gb25JdGVtSG92ZXIoZSkge1xuICAgIHRoaXMub25Db21tb25JdGVtSG92ZXIoZSk7XG4gIH0sXG5cbiAgZ2V0T3BlblRyYW5zaXRpb25OYW1lOiBmdW5jdGlvbiBnZXRPcGVuVHJhbnNpdGlvbk5hbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMucHJvcHMub3BlblRyYW5zaXRpb25OYW1lO1xuICB9LFxuXG4gIHJlbmRlck1lbnVJdGVtOiBmdW5jdGlvbiByZW5kZXJNZW51SXRlbShjLCBpLCBzdWJJbmRleCkge1xuICAgIHZhciBwcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgdmFyIGtleSA9ICgwLCBfdXRpbC5nZXRLZXlGcm9tQ2hpbGRyZW5JbmRleCkoYywgcHJvcHMuZXZlbnRLZXksIGkpO1xuICAgIHZhciBleHRyYVByb3BzID0ge1xuICAgICAgb3BlbktleXM6IHByb3BzLm9wZW5LZXlzLFxuICAgICAgc2VsZWN0ZWRLZXlzOiBwcm9wcy5zZWxlY3RlZEtleXMsXG4gICAgICBvcGVuOiBwcm9wcy5vcGVuS2V5cy5pbmRleE9mKGtleSkgIT09IC0xLFxuICAgICAgc2VsZWN0ZWQ6IHByb3BzLnNlbGVjdGVkS2V5cy5pbmRleE9mKGtleSkgIT09IC0xLFxuICAgICAgb3BlblN1Yk1lbnVPbk1vdXNlRW50ZXI6IHRydWVcbiAgICB9O1xuICAgIHJldHVybiB0aGlzLnJlbmRlckNvbW1vbk1lbnVJdGVtKGMsIGksIHN1YkluZGV4LCBleHRyYVByb3BzKTtcbiAgfSxcblxuICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICB2YXIgcmVuZGVyRmlyc3QgPSB0aGlzLnJlbmRlckZpcnN0O1xuICAgIHRoaXMucmVuZGVyRmlyc3QgPSAxO1xuICAgIHRoaXMuaGF2ZU9wZW5lZCA9IHRoaXMuaGF2ZU9wZW5lZCB8fCB0aGlzLnByb3BzLnZpc2libGU7XG4gICAgaWYgKCF0aGlzLmhhdmVPcGVuZWQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB2YXIgdHJhbnNpdGlvbkFwcGVhciA9IHRydWU7XG4gICAgaWYgKCFyZW5kZXJGaXJzdCAmJiB0aGlzLnByb3BzLnZpc2libGUpIHtcbiAgICAgIHRyYW5zaXRpb25BcHBlYXIgPSBmYWxzZTtcbiAgICB9XG4gICAgdmFyIHByb3BzID0gKDAsIF9vYmplY3RBc3NpZ24yWydkZWZhdWx0J10pKHt9LCB0aGlzLnByb3BzKTtcbiAgICBwcm9wcy5jbGFzc05hbWUgKz0gJyAnICsgcHJvcHMucHJlZml4Q2xzICsgJy1zdWInO1xuICAgIHZhciBhbmltUHJvcHMgPSB7fTtcbiAgICBpZiAocHJvcHMub3BlblRyYW5zaXRpb25OYW1lKSB7XG4gICAgICBhbmltUHJvcHMudHJhbnNpdGlvbk5hbWUgPSBwcm9wcy5vcGVuVHJhbnNpdGlvbk5hbWU7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgcHJvcHMub3BlbkFuaW1hdGlvbiA9PT0gJ29iamVjdCcpIHtcbiAgICAgIGFuaW1Qcm9wcy5hbmltYXRpb24gPSAoMCwgX29iamVjdEFzc2lnbjJbJ2RlZmF1bHQnXSkoe30sIHByb3BzLm9wZW5BbmltYXRpb24pO1xuICAgICAgaWYgKCF0cmFuc2l0aW9uQXBwZWFyKSB7XG4gICAgICAgIGRlbGV0ZSBhbmltUHJvcHMuYW5pbWF0aW9uLmFwcGVhcjtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIF9yZWFjdDJbJ2RlZmF1bHQnXS5jcmVhdGVFbGVtZW50KFxuICAgICAgX3JjQW5pbWF0ZTJbJ2RlZmF1bHQnXSxcbiAgICAgIF9leHRlbmRzKHt9LCBhbmltUHJvcHMsIHtcbiAgICAgICAgc2hvd1Byb3A6ICd2aXNpYmxlJyxcbiAgICAgICAgY29tcG9uZW50OiAnJyxcbiAgICAgICAgdHJhbnNpdGlvbkFwcGVhcjogdHJhbnNpdGlvbkFwcGVhciB9KSxcbiAgICAgIHRoaXMucmVuZGVyUm9vdChwcm9wcylcbiAgICApO1xuICB9XG59KTtcblxuZXhwb3J0c1snZGVmYXVsdCddID0gU3ViUG9wdXBNZW51O1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vdXhjb3JlLXRhYmxlL34vdXhjb3JlLW1lbnUvfi9yYy1tZW51L2xpYi9TdWJQb3B1cE1lbnUuanNcbiAqKiBtb2R1bGUgaWQgPSA0MlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMudG9BcnJheUNoaWxkcmVuID0gdG9BcnJheUNoaWxkcmVuO1xuZXhwb3J0cy5maW5kQ2hpbGRJbkNoaWxkcmVuQnlLZXkgPSBmaW5kQ2hpbGRJbkNoaWxkcmVuQnlLZXk7XG5leHBvcnRzLmZpbmRTaG93bkNoaWxkSW5DaGlsZHJlbkJ5S2V5ID0gZmluZFNob3duQ2hpbGRJbkNoaWxkcmVuQnlLZXk7XG5leHBvcnRzLmZpbmRIaWRkZW5DaGlsZEluQ2hpbGRyZW5CeUtleSA9IGZpbmRIaWRkZW5DaGlsZEluQ2hpbGRyZW5CeUtleTtcbmV4cG9ydHMuaXNTYW1lQ2hpbGRyZW4gPSBpc1NhbWVDaGlsZHJlbjtcbmV4cG9ydHMubWVyZ2VDaGlsZHJlbiA9IG1lcmdlQ2hpbGRyZW47XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxudmFyIF9yZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5cbnZhciBfcmVhY3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmVhY3QpO1xuXG5mdW5jdGlvbiB0b0FycmF5Q2hpbGRyZW4oY2hpbGRyZW4pIHtcbiAgdmFyIHJldCA9IFtdO1xuICBfcmVhY3QyWydkZWZhdWx0J10uQ2hpbGRyZW4uZm9yRWFjaChjaGlsZHJlbiwgZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgcmV0LnB1c2goY2hpbGQpO1xuICB9KTtcbiAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gZmluZENoaWxkSW5DaGlsZHJlbkJ5S2V5KGNoaWxkcmVuLCBrZXkpIHtcbiAgdmFyIHJldCA9IG51bGw7XG4gIGlmIChjaGlsZHJlbikge1xuICAgIGNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICBpZiAocmV0KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChjaGlsZC5rZXkgPT09IGtleSkge1xuICAgICAgICByZXQgPSBjaGlsZDtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBmaW5kU2hvd25DaGlsZEluQ2hpbGRyZW5CeUtleShjaGlsZHJlbiwga2V5LCBzaG93UHJvcCkge1xuICB2YXIgcmV0ID0gbnVsbDtcbiAgaWYgKGNoaWxkcmVuKSB7XG4gICAgY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgIGlmIChjaGlsZC5rZXkgPT09IGtleSAmJiBjaGlsZC5wcm9wc1tzaG93UHJvcF0pIHtcbiAgICAgICAgaWYgKHJldCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcigndHdvIGNoaWxkIHdpdGggc2FtZSBrZXkgZm9yIDxyYy1hbmltYXRlPiBjaGlsZHJlbicpO1xuICAgICAgICB9XG4gICAgICAgIHJldCA9IGNoaWxkO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIGZpbmRIaWRkZW5DaGlsZEluQ2hpbGRyZW5CeUtleShjaGlsZHJlbiwga2V5LCBzaG93UHJvcCkge1xuICB2YXIgZm91bmQgPSAwO1xuICBpZiAoY2hpbGRyZW4pIHtcbiAgICBjaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgaWYgKGZvdW5kKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGZvdW5kID0gY2hpbGQua2V5ID09PSBrZXkgJiYgIWNoaWxkLnByb3BzW3Nob3dQcm9wXTtcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gZm91bmQ7XG59XG5cbmZ1bmN0aW9uIGlzU2FtZUNoaWxkcmVuKGMxLCBjMiwgc2hvd1Byb3ApIHtcbiAgdmFyIHNhbWUgPSBjMS5sZW5ndGggPT09IGMyLmxlbmd0aDtcbiAgaWYgKHNhbWUpIHtcbiAgICBjMS5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCwgaW5kZXgpIHtcbiAgICAgIHZhciBjaGlsZDIgPSBjMltpbmRleF07XG4gICAgICBpZiAoY2hpbGQua2V5ICE9PSBjaGlsZDIua2V5KSB7XG4gICAgICAgIHNhbWUgPSBmYWxzZTtcbiAgICAgIH0gZWxzZSBpZiAoc2hvd1Byb3AgJiYgY2hpbGQucHJvcHNbc2hvd1Byb3BdICE9PSBjaGlsZDIucHJvcHNbc2hvd1Byb3BdKSB7XG4gICAgICAgIHNhbWUgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICByZXR1cm4gc2FtZTtcbn1cblxuZnVuY3Rpb24gbWVyZ2VDaGlsZHJlbihwcmV2LCBuZXh0KSB7XG4gIHZhciByZXQgPSBbXTtcblxuICAvLyBGb3IgZWFjaCBrZXkgb2YgYG5leHRgLCB0aGUgbGlzdCBvZiBrZXlzIHRvIGluc2VydCBiZWZvcmUgdGhhdCBrZXkgaW5cbiAgLy8gdGhlIGNvbWJpbmVkIGxpc3RcbiAgdmFyIG5leHRDaGlsZHJlblBlbmRpbmcgPSB7fTtcbiAgdmFyIHBlbmRpbmdDaGlsZHJlbiA9IFtdO1xuICBwcmV2LmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgaWYgKGZpbmRDaGlsZEluQ2hpbGRyZW5CeUtleShuZXh0LCBjaGlsZC5rZXkpKSB7XG4gICAgICBpZiAocGVuZGluZ0NoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgICBuZXh0Q2hpbGRyZW5QZW5kaW5nW2NoaWxkLmtleV0gPSBwZW5kaW5nQ2hpbGRyZW47XG4gICAgICAgIHBlbmRpbmdDaGlsZHJlbiA9IFtdO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBwZW5kaW5nQ2hpbGRyZW4ucHVzaChjaGlsZCk7XG4gICAgfVxuICB9KTtcblxuICBuZXh0LmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgaWYgKG5leHRDaGlsZHJlblBlbmRpbmcuaGFzT3duUHJvcGVydHkoY2hpbGQua2V5KSkge1xuICAgICAgcmV0ID0gcmV0LmNvbmNhdChuZXh0Q2hpbGRyZW5QZW5kaW5nW2NoaWxkLmtleV0pO1xuICAgIH1cbiAgICByZXQucHVzaChjaGlsZCk7XG4gIH0pO1xuXG4gIHJldCA9IHJldC5jb25jYXQocGVuZGluZ0NoaWxkcmVuKTtcblxuICByZXR1cm4gcmV0O1xufVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3V4Y29yZS10YWJsZS9+L3V4Y29yZS1tZW51L34vcmMtbWVudS9+L3JjLWFuaW1hdGUvbGliL0NoaWxkcmVuVXRpbHMuanNcbiAqKiBtb2R1bGUgaWQgPSA0NVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xudmFyIEVWRU5UX05BTUVfTUFQID0ge1xuICB0cmFuc2l0aW9uZW5kOiB7XG4gICAgdHJhbnNpdGlvbjogJ3RyYW5zaXRpb25lbmQnLFxuICAgIFdlYmtpdFRyYW5zaXRpb246ICd3ZWJraXRUcmFuc2l0aW9uRW5kJyxcbiAgICBNb3pUcmFuc2l0aW9uOiAnbW96VHJhbnNpdGlvbkVuZCcsXG4gICAgT1RyYW5zaXRpb246ICdvVHJhbnNpdGlvbkVuZCcsXG4gICAgbXNUcmFuc2l0aW9uOiAnTVNUcmFuc2l0aW9uRW5kJ1xuICB9LFxuXG4gIGFuaW1hdGlvbmVuZDoge1xuICAgIGFuaW1hdGlvbjogJ2FuaW1hdGlvbmVuZCcsXG4gICAgV2Via2l0QW5pbWF0aW9uOiAnd2Via2l0QW5pbWF0aW9uRW5kJyxcbiAgICBNb3pBbmltYXRpb246ICdtb3pBbmltYXRpb25FbmQnLFxuICAgIE9BbmltYXRpb246ICdvQW5pbWF0aW9uRW5kJyxcbiAgICBtc0FuaW1hdGlvbjogJ01TQW5pbWF0aW9uRW5kJ1xuICB9XG59O1xuXG52YXIgZW5kRXZlbnRzID0gW107XG5cbmZ1bmN0aW9uIGRldGVjdEV2ZW50cygpIHtcbiAgdmFyIHRlc3RFbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICB2YXIgc3R5bGUgPSB0ZXN0RWwuc3R5bGU7XG5cbiAgaWYgKCEoJ0FuaW1hdGlvbkV2ZW50JyBpbiB3aW5kb3cpKSB7XG4gICAgZGVsZXRlIEVWRU5UX05BTUVfTUFQLmFuaW1hdGlvbmVuZC5hbmltYXRpb247XG4gIH1cblxuICBpZiAoISgnVHJhbnNpdGlvbkV2ZW50JyBpbiB3aW5kb3cpKSB7XG4gICAgZGVsZXRlIEVWRU5UX05BTUVfTUFQLnRyYW5zaXRpb25lbmQudHJhbnNpdGlvbjtcbiAgfVxuXG4gIGZvciAodmFyIGJhc2VFdmVudE5hbWUgaW4gRVZFTlRfTkFNRV9NQVApIHtcbiAgICBpZiAoRVZFTlRfTkFNRV9NQVAuaGFzT3duUHJvcGVydHkoYmFzZUV2ZW50TmFtZSkpIHtcbiAgICAgIHZhciBiYXNlRXZlbnRzID0gRVZFTlRfTkFNRV9NQVBbYmFzZUV2ZW50TmFtZV07XG4gICAgICBmb3IgKHZhciBzdHlsZU5hbWUgaW4gYmFzZUV2ZW50cykge1xuICAgICAgICBpZiAoc3R5bGVOYW1lIGluIHN0eWxlKSB7XG4gICAgICAgICAgZW5kRXZlbnRzLnB1c2goYmFzZUV2ZW50c1tzdHlsZU5hbWVdKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5pZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJykge1xuICBkZXRlY3RFdmVudHMoKTtcbn1cblxuZnVuY3Rpb24gYWRkRXZlbnRMaXN0ZW5lcihub2RlLCBldmVudE5hbWUsIGV2ZW50TGlzdGVuZXIpIHtcbiAgbm9kZS5hZGRFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgZXZlbnRMaXN0ZW5lciwgZmFsc2UpO1xufVxuXG5mdW5jdGlvbiByZW1vdmVFdmVudExpc3RlbmVyKG5vZGUsIGV2ZW50TmFtZSwgZXZlbnRMaXN0ZW5lcikge1xuICBub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBldmVudExpc3RlbmVyLCBmYWxzZSk7XG59XG5cbnZhciBUcmFuc2l0aW9uRXZlbnRzID0ge1xuICBhZGRFbmRFdmVudExpc3RlbmVyOiBmdW5jdGlvbiBhZGRFbmRFdmVudExpc3RlbmVyKG5vZGUsIGV2ZW50TGlzdGVuZXIpIHtcbiAgICBpZiAoZW5kRXZlbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgd2luZG93LnNldFRpbWVvdXQoZXZlbnRMaXN0ZW5lciwgMCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGVuZEV2ZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChlbmRFdmVudCkge1xuICAgICAgYWRkRXZlbnRMaXN0ZW5lcihub2RlLCBlbmRFdmVudCwgZXZlbnRMaXN0ZW5lcik7XG4gICAgfSk7XG4gIH0sXG5cblxuICBlbmRFdmVudHM6IGVuZEV2ZW50cyxcblxuICByZW1vdmVFbmRFdmVudExpc3RlbmVyOiBmdW5jdGlvbiByZW1vdmVFbmRFdmVudExpc3RlbmVyKG5vZGUsIGV2ZW50TGlzdGVuZXIpIHtcbiAgICBpZiAoZW5kRXZlbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBlbmRFdmVudHMuZm9yRWFjaChmdW5jdGlvbiAoZW5kRXZlbnQpIHtcbiAgICAgIHJlbW92ZUV2ZW50TGlzdGVuZXIobm9kZSwgZW5kRXZlbnQsIGV2ZW50TGlzdGVuZXIpO1xuICAgIH0pO1xuICB9XG59O1xuXG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IFRyYW5zaXRpb25FdmVudHM7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi91eGNvcmUtdGFibGUvfi91eGNvcmUtbWVudS9+L3JjLW1lbnUvfi9yYy1hbmltYXRlL34vY3NzLWFuaW1hdGlvbi9saWIvRXZlbnQuanNcbiAqKiBtb2R1bGUgaWQgPSA0OFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihhcnIsIG9iail7XG4gIGlmIChhcnIuaW5kZXhPZikgcmV0dXJuIGFyci5pbmRleE9mKG9iaik7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgKytpKSB7XG4gICAgaWYgKGFycltpXSA9PT0gb2JqKSByZXR1cm4gaTtcbiAgfVxuICByZXR1cm4gLTE7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3V4Y29yZS10YWJsZS9+L3V4Y29yZS1tZW51L34vcmMtbWVudS9+L3JjLWFuaW1hdGUvfi9jc3MtYW5pbWF0aW9uL34vY29tcG9uZW50LWNsYXNzZXMvfi9jb21wb25lbnQtaW5kZXhvZi9pbmRleC5qc1xuICoqIG1vZHVsZSBpZCA9IDUwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbnZhciB1dGlsID0ge1xuICBpc0FwcGVhclN1cHBvcnRlZDogZnVuY3Rpb24gaXNBcHBlYXJTdXBwb3J0ZWQocHJvcHMpIHtcbiAgICByZXR1cm4gcHJvcHMudHJhbnNpdGlvbk5hbWUgJiYgcHJvcHMudHJhbnNpdGlvbkFwcGVhciB8fCBwcm9wcy5hbmltYXRpb24uYXBwZWFyO1xuICB9LFxuICBpc0VudGVyU3VwcG9ydGVkOiBmdW5jdGlvbiBpc0VudGVyU3VwcG9ydGVkKHByb3BzKSB7XG4gICAgcmV0dXJuIHByb3BzLnRyYW5zaXRpb25OYW1lICYmIHByb3BzLnRyYW5zaXRpb25FbnRlciB8fCBwcm9wcy5hbmltYXRpb24uZW50ZXI7XG4gIH0sXG4gIGlzTGVhdmVTdXBwb3J0ZWQ6IGZ1bmN0aW9uIGlzTGVhdmVTdXBwb3J0ZWQocHJvcHMpIHtcbiAgICByZXR1cm4gcHJvcHMudHJhbnNpdGlvbk5hbWUgJiYgcHJvcHMudHJhbnNpdGlvbkxlYXZlIHx8IHByb3BzLmFuaW1hdGlvbi5sZWF2ZTtcbiAgfSxcblxuICBhbGxvd0FwcGVhckNhbGxiYWNrOiBmdW5jdGlvbiBhbGxvd0FwcGVhckNhbGxiYWNrKHByb3BzKSB7XG4gICAgcmV0dXJuIHByb3BzLnRyYW5zaXRpb25BcHBlYXIgfHwgcHJvcHMuYW5pbWF0aW9uLmFwcGVhcjtcbiAgfSxcbiAgYWxsb3dFbnRlckNhbGxiYWNrOiBmdW5jdGlvbiBhbGxvd0VudGVyQ2FsbGJhY2socHJvcHMpIHtcbiAgICByZXR1cm4gcHJvcHMudHJhbnNpdGlvbkVudGVyIHx8IHByb3BzLmFuaW1hdGlvbi5lbnRlcjtcbiAgfSxcbiAgYWxsb3dMZWF2ZUNhbGxiYWNrOiBmdW5jdGlvbiBhbGxvd0xlYXZlQ2FsbGJhY2socHJvcHMpIHtcbiAgICByZXR1cm4gcHJvcHMudHJhbnNpdGlvbkxlYXZlIHx8IHByb3BzLmFuaW1hdGlvbi5sZWF2ZTtcbiAgfVxufTtcbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gdXRpbDtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1tcImRlZmF1bHRcIl07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vdXhjb3JlLXRhYmxlL34vdXhjb3JlLW1lbnUvfi9yYy1tZW51L34vcmMtYW5pbWF0ZS9saWIvdXRpbC5qc1xuICoqIG1vZHVsZSBpZCA9IDUxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbnZhciBfcmNVdGlsID0gcmVxdWlyZSgncmMtdXRpbCcpO1xuXG52YXIgX3JjVXRpbDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yY1V0aWwpO1xuXG52YXIgX3JlYWN0RG9tID0gcmVxdWlyZSgncmVhY3QtZG9tJyk7XG5cbnZhciBfcmVhY3REb20yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmVhY3REb20pO1xuXG5leHBvcnRzWydkZWZhdWx0J10gPSB7XG4gIGNvbXBvbmVudERpZE1vdW50OiBmdW5jdGlvbiBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICB0aGlzLmNvbXBvbmVudERpZFVwZGF0ZSgpO1xuICB9LFxuXG4gIGNvbXBvbmVudERpZFVwZGF0ZTogZnVuY3Rpb24gY29tcG9uZW50RGlkVXBkYXRlKCkge1xuICAgIGlmICh0aGlzLnByb3BzLm1vZGUgIT09ICdpbmxpbmUnKSB7XG4gICAgICBpZiAodGhpcy5wcm9wcy5vcGVuKSB7XG4gICAgICAgIHRoaXMuYmluZFJvb3RDbG9zZUhhbmRsZXJzKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnVuYmluZFJvb3RDbG9zZUhhbmRsZXJzKCk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIGhhbmRsZURvY3VtZW50S2V5VXA6IGZ1bmN0aW9uIGhhbmRsZURvY3VtZW50S2V5VXAoZSkge1xuICAgIGlmIChlLmtleUNvZGUgPT09IF9yY1V0aWwuS2V5Q29kZS5FU0MpIHtcbiAgICAgIHRoaXMucHJvcHMub25JdGVtSG92ZXIoe1xuICAgICAgICBrZXk6IHRoaXMucHJvcHMuZXZlbnRLZXksXG4gICAgICAgIGl0ZW06IHRoaXMsXG4gICAgICAgIGhvdmVyOiBmYWxzZVxuICAgICAgfSk7XG4gICAgfVxuICB9LFxuXG4gIGhhbmRsZURvY3VtZW50Q2xpY2s6IGZ1bmN0aW9uIGhhbmRsZURvY3VtZW50Q2xpY2soZSkge1xuICAgIC8vIElmIHRoZSBjbGljayBvcmlnaW5hdGVkIGZyb20gd2l0aGluIHRoaXMgY29tcG9uZW50XG4gICAgLy8gZG9uJ3QgZG8gYW55dGhpbmcuXG4gICAgaWYgKF9yY1V0aWwyWydkZWZhdWx0J10uRG9tLmNvbnRhaW5zKF9yZWFjdERvbTJbJ2RlZmF1bHQnXS5maW5kRE9NTm9kZSh0aGlzKSwgZS50YXJnZXQpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBwcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgcHJvcHMub25JdGVtSG92ZXIoe1xuICAgICAgaG92ZXI6IGZhbHNlLFxuICAgICAgaXRlbTogdGhpcyxcbiAgICAgIGtleTogdGhpcy5wcm9wcy5ldmVudEtleVxuICAgIH0pO1xuICAgIHRoaXMudHJpZ2dlck9wZW5DaGFuZ2UoZmFsc2UpO1xuICB9LFxuXG4gIGJpbmRSb290Q2xvc2VIYW5kbGVyczogZnVuY3Rpb24gYmluZFJvb3RDbG9zZUhhbmRsZXJzKCkge1xuICAgIGlmICghdGhpcy5fb25Eb2N1bWVudENsaWNrTGlzdGVuZXIpIHtcbiAgICAgIHRoaXMuX29uRG9jdW1lbnRDbGlja0xpc3RlbmVyID0gX3JjVXRpbDJbJ2RlZmF1bHQnXS5Eb20uYWRkRXZlbnRMaXN0ZW5lcihkb2N1bWVudCwgJ2NsaWNrJywgdGhpcy5oYW5kbGVEb2N1bWVudENsaWNrKTtcbiAgICAgIHRoaXMuX29uRG9jdW1lbnRLZXl1cExpc3RlbmVyID0gX3JjVXRpbDJbJ2RlZmF1bHQnXS5Eb20uYWRkRXZlbnRMaXN0ZW5lcihkb2N1bWVudCwgJ2tleXVwJywgdGhpcy5oYW5kbGVEb2N1bWVudEtleVVwKTtcbiAgICB9XG4gIH0sXG5cbiAgdW5iaW5kUm9vdENsb3NlSGFuZGxlcnM6IGZ1bmN0aW9uIHVuYmluZFJvb3RDbG9zZUhhbmRsZXJzKCkge1xuICAgIGlmICh0aGlzLl9vbkRvY3VtZW50Q2xpY2tMaXN0ZW5lcikge1xuICAgICAgdGhpcy5fb25Eb2N1bWVudENsaWNrTGlzdGVuZXIucmVtb3ZlKCk7XG4gICAgICB0aGlzLl9vbkRvY3VtZW50Q2xpY2tMaXN0ZW5lciA9IG51bGw7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX29uRG9jdW1lbnRLZXl1cExpc3RlbmVyKSB7XG4gICAgICB0aGlzLl9vbkRvY3VtZW50S2V5dXBMaXN0ZW5lci5yZW1vdmUoKTtcbiAgICAgIHRoaXMuX29uRG9jdW1lbnRLZXl1cExpc3RlbmVyID0gbnVsbDtcbiAgICB9XG4gIH0sXG5cbiAgY29tcG9uZW50V2lsbFVubW91bnQ6IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgIHRoaXMudW5iaW5kUm9vdENsb3NlSGFuZGxlcnMoKTtcbiAgfVxufTtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3V4Y29yZS10YWJsZS9+L3V4Y29yZS1tZW51L34vcmMtbWVudS9saWIvU3ViTWVudVN0YXRlTWl4aW4uanNcbiAqKiBtb2R1bGUgaWQgPSA1MlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG52YXIgX3JlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxudmFyIF9yZWFjdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yZWFjdCk7XG5cbnZhciBfcmNVdGlsID0gcmVxdWlyZSgncmMtdXRpbCcpO1xuXG52YXIgX2NsYXNzbmFtZXMgPSByZXF1aXJlKCdjbGFzc25hbWVzJyk7XG5cbnZhciBfY2xhc3NuYW1lczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jbGFzc25hbWVzKTtcblxudmFyIE1lbnVJdGVtID0gX3JlYWN0MlsnZGVmYXVsdCddLmNyZWF0ZUNsYXNzKHtcbiAgZGlzcGxheU5hbWU6ICdNZW51SXRlbScsXG5cbiAgcHJvcFR5cGVzOiB7XG4gICAgcm9vdFByZWZpeENsczogX3JlYWN0MlsnZGVmYXVsdCddLlByb3BUeXBlcy5zdHJpbmcsXG4gICAgZXZlbnRLZXk6IF9yZWFjdDJbJ2RlZmF1bHQnXS5Qcm9wVHlwZXMuc3RyaW5nLFxuICAgIGFjdGl2ZTogX3JlYWN0MlsnZGVmYXVsdCddLlByb3BUeXBlcy5ib29sLFxuICAgIHNlbGVjdGVkOiBfcmVhY3QyWydkZWZhdWx0J10uUHJvcFR5cGVzLmJvb2wsXG4gICAgZGlzYWJsZWQ6IF9yZWFjdDJbJ2RlZmF1bHQnXS5Qcm9wVHlwZXMuYm9vbCxcbiAgICB0aXRsZTogX3JlYWN0MlsnZGVmYXVsdCddLlByb3BUeXBlcy5zdHJpbmcsXG4gICAgb25TZWxlY3Q6IF9yZWFjdDJbJ2RlZmF1bHQnXS5Qcm9wVHlwZXMuZnVuYyxcbiAgICBvbkNsaWNrOiBfcmVhY3QyWydkZWZhdWx0J10uUHJvcFR5cGVzLmZ1bmMsXG4gICAgb25EZXNlbGVjdDogX3JlYWN0MlsnZGVmYXVsdCddLlByb3BUeXBlcy5mdW5jLFxuICAgIHBhcmVudE1lbnU6IF9yZWFjdDJbJ2RlZmF1bHQnXS5Qcm9wVHlwZXMub2JqZWN0LFxuICAgIG9uSXRlbUhvdmVyOiBfcmVhY3QyWydkZWZhdWx0J10uUHJvcFR5cGVzLmZ1bmMsXG4gICAgb25EZXN0cm95OiBfcmVhY3QyWydkZWZhdWx0J10uUHJvcFR5cGVzLmZ1bmNcbiAgfSxcblxuICBnZXREZWZhdWx0UHJvcHM6IGZ1bmN0aW9uIGdldERlZmF1bHRQcm9wcygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgb25TZWxlY3Q6IGZ1bmN0aW9uIG9uU2VsZWN0KCkge30sXG4gICAgICBvbk1vdXNlRW50ZXI6IGZ1bmN0aW9uIG9uTW91c2VFbnRlcigpIHt9XG4gICAgfTtcbiAgfSxcblxuICBjb21wb25lbnRXaWxsVW5tb3VudDogZnVuY3Rpb24gY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgdmFyIHByb3BzID0gdGhpcy5wcm9wcztcbiAgICBpZiAocHJvcHMub25EZXN0cm95KSB7XG4gICAgICBwcm9wcy5vbkRlc3Ryb3kocHJvcHMuZXZlbnRLZXkpO1xuICAgIH1cbiAgfSxcblxuICBvbktleURvd246IGZ1bmN0aW9uIG9uS2V5RG93bihlKSB7XG4gICAgdmFyIGtleUNvZGUgPSBlLmtleUNvZGU7XG4gICAgaWYgKGtleUNvZGUgPT09IF9yY1V0aWwuS2V5Q29kZS5FTlRFUikge1xuICAgICAgdGhpcy5vbkNsaWNrKGUpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9LFxuXG4gIG9uTW91c2VMZWF2ZTogZnVuY3Rpb24gb25Nb3VzZUxlYXZlKCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICB2YXIgZXZlbnRLZXkgPSB0aGlzLnByb3BzLmV2ZW50S2V5O1xuICAgIHZhciBwYXJlbnRNZW51ID0gdGhpcy5wcm9wcy5wYXJlbnRNZW51O1xuICAgIHBhcmVudE1lbnUubWVudUl0ZW1Nb3VzZUxlYXZlVGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChfdGhpcy5pc01vdW50ZWQoKSAmJiBfdGhpcy5wcm9wcy5hY3RpdmUpIHtcbiAgICAgICAgX3RoaXMucHJvcHMub25JdGVtSG92ZXIoe1xuICAgICAgICAgIGtleTogZXZlbnRLZXksXG4gICAgICAgICAgaXRlbTogX3RoaXMsXG4gICAgICAgICAgaG92ZXI6IGZhbHNlLFxuICAgICAgICAgIHRyaWdnZXI6ICdtb3VzZWxlYXZlJ1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LCAzMCk7XG4gIH0sXG5cbiAgb25Nb3VzZUVudGVyOiBmdW5jdGlvbiBvbk1vdXNlRW50ZXIoKSB7XG4gICAgdmFyIHByb3BzID0gdGhpcy5wcm9wcztcbiAgICB2YXIgcGFyZW50TWVudSA9IHRoaXMucHJvcHMucGFyZW50TWVudTtcbiAgICBpZiAocGFyZW50TWVudS5tZW51SXRlbU1vdXNlTGVhdmVUaW1lcikge1xuICAgICAgY2xlYXJUaW1lb3V0KHBhcmVudE1lbnUubWVudUl0ZW1Nb3VzZUxlYXZlVGltZXIpO1xuICAgICAgcGFyZW50TWVudS5tZW51SXRlbU1vdXNlTGVhdmVUaW1lciA9IG51bGw7XG4gICAgfVxuICAgIHZhciBldmVudEtleSA9IHByb3BzLmV2ZW50S2V5O1xuICAgIHByb3BzLm9uSXRlbUhvdmVyKHtcbiAgICAgIGtleTogZXZlbnRLZXksXG4gICAgICBpdGVtOiB0aGlzLFxuICAgICAgaG92ZXI6IHRydWUsXG4gICAgICB0cmlnZ2VyOiAnbW91c2VlbnRlcidcbiAgICB9KTtcbiAgfSxcblxuICBvbkNsaWNrOiBmdW5jdGlvbiBvbkNsaWNrKGUpIHtcbiAgICB2YXIgcHJvcHMgPSB0aGlzLnByb3BzO1xuICAgIHZhciBldmVudEtleSA9IHByb3BzLmV2ZW50S2V5O1xuICAgIHZhciBpbmZvID0ge1xuICAgICAga2V5OiBldmVudEtleSxcbiAgICAgIGtleVBhdGg6IFtldmVudEtleV0sXG4gICAgICBpdGVtOiB0aGlzLFxuICAgICAgZG9tRXZlbnQ6IGVcbiAgICB9O1xuICAgIHByb3BzLm9uQ2xpY2soaW5mbyk7XG4gICAgaWYgKHByb3BzLm11bHRpcGxlKSB7XG4gICAgICBpZiAocHJvcHMuc2VsZWN0ZWQpIHtcbiAgICAgICAgcHJvcHMub25EZXNlbGVjdChpbmZvKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByb3BzLm9uU2VsZWN0KGluZm8pO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIXByb3BzLnNlbGVjdGVkKSB7XG4gICAgICBwcm9wcy5vblNlbGVjdChpbmZvKTtcbiAgICB9XG4gIH0sXG5cbiAgZ2V0UHJlZml4Q2xzOiBmdW5jdGlvbiBnZXRQcmVmaXhDbHMoKSB7XG4gICAgcmV0dXJuIHRoaXMucHJvcHMucm9vdFByZWZpeENscyArICctaXRlbSc7XG4gIH0sXG5cbiAgZ2V0QWN0aXZlQ2xhc3NOYW1lOiBmdW5jdGlvbiBnZXRBY3RpdmVDbGFzc05hbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0UHJlZml4Q2xzKCkgKyAnLWFjdGl2ZSc7XG4gIH0sXG5cbiAgZ2V0U2VsZWN0ZWRDbGFzc05hbWU6IGZ1bmN0aW9uIGdldFNlbGVjdGVkQ2xhc3NOYW1lKCkge1xuICAgIHJldHVybiB0aGlzLmdldFByZWZpeENscygpICsgJy1zZWxlY3RlZCc7XG4gIH0sXG5cbiAgZ2V0RGlzYWJsZWRDbGFzc05hbWU6IGZ1bmN0aW9uIGdldERpc2FibGVkQ2xhc3NOYW1lKCkge1xuICAgIHJldHVybiB0aGlzLmdldFByZWZpeENscygpICsgJy1kaXNhYmxlZCc7XG4gIH0sXG5cbiAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgdmFyIHByb3BzID0gdGhpcy5wcm9wcztcbiAgICB2YXIgY2xhc3NlcyA9IHt9O1xuICAgIGNsYXNzZXNbdGhpcy5nZXRBY3RpdmVDbGFzc05hbWUoKV0gPSAhcHJvcHMuZGlzYWJsZWQgJiYgcHJvcHMuYWN0aXZlO1xuICAgIGNsYXNzZXNbdGhpcy5nZXRTZWxlY3RlZENsYXNzTmFtZSgpXSA9IHByb3BzLnNlbGVjdGVkO1xuICAgIGNsYXNzZXNbdGhpcy5nZXREaXNhYmxlZENsYXNzTmFtZSgpXSA9IHByb3BzLmRpc2FibGVkO1xuICAgIGNsYXNzZXNbdGhpcy5nZXRQcmVmaXhDbHMoKV0gPSB0cnVlO1xuICAgIGNsYXNzZXNbcHJvcHMuY2xhc3NOYW1lXSA9ICEhcHJvcHMuY2xhc3NOYW1lO1xuICAgIHZhciBhdHRycyA9IF9leHRlbmRzKHt9LCBwcm9wcy5hdHRyaWJ1dGUsIHtcbiAgICAgIHRpdGxlOiBwcm9wcy50aXRsZSxcbiAgICAgIGNsYXNzTmFtZTogKDAsIF9jbGFzc25hbWVzMlsnZGVmYXVsdCddKShjbGFzc2VzKSxcbiAgICAgIHJvbGU6ICdtZW51aXRlbScsXG4gICAgICAnYXJpYS1zZWxlY3RlZCc6IHByb3BzLnNlbGVjdGVkLFxuICAgICAgJ2FyaWEtZGlzYWJsZWQnOiBwcm9wcy5kaXNhYmxlZFxuICAgIH0pO1xuICAgIHZhciBtb3VzZUV2ZW50ID0ge307XG4gICAgaWYgKCFwcm9wcy5kaXNhYmxlZCkge1xuICAgICAgbW91c2VFdmVudCA9IHtcbiAgICAgICAgb25DbGljazogdGhpcy5vbkNsaWNrLFxuICAgICAgICBvbk1vdXNlTGVhdmU6IHRoaXMub25Nb3VzZUxlYXZlLFxuICAgICAgICBvbk1vdXNlRW50ZXI6IHRoaXMub25Nb3VzZUVudGVyXG4gICAgICB9O1xuICAgIH1cbiAgICB2YXIgc3R5bGUgPSBfZXh0ZW5kcyh7fSwgcHJvcHMuc3R5bGUpO1xuICAgIGlmIChwcm9wcy5tb2RlID09PSAnaW5saW5lJykge1xuICAgICAgc3R5bGUucGFkZGluZ0xlZnQgPSBwcm9wcy5pbmxpbmVJbmRlbnQgKiBwcm9wcy5sZXZlbDtcbiAgICB9XG4gICAgcmV0dXJuIF9yZWFjdDJbJ2RlZmF1bHQnXS5jcmVhdGVFbGVtZW50KFxuICAgICAgJ2xpJyxcbiAgICAgIF9leHRlbmRzKHsgc3R5bGU6IHN0eWxlXG4gICAgICB9LCBhdHRycywgbW91c2VFdmVudCksXG4gICAgICBwcm9wcy5jaGlsZHJlblxuICAgICk7XG4gIH1cbn0pO1xuXG5leHBvcnRzWydkZWZhdWx0J10gPSBNZW51SXRlbTtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3V4Y29yZS10YWJsZS9+L3V4Y29yZS1tZW51L34vcmMtbWVudS9saWIvTWVudUl0ZW0uanNcbiAqKiBtb2R1bGUgaWQgPSA1M1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG52YXIgX3JlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxudmFyIF9yZWFjdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yZWFjdCk7XG5cbnZhciBNZW51SXRlbUdyb3VwID0gX3JlYWN0MlsnZGVmYXVsdCddLmNyZWF0ZUNsYXNzKHtcbiAgZGlzcGxheU5hbWU6ICdNZW51SXRlbUdyb3VwJyxcblxuICBwcm9wVHlwZXM6IHtcbiAgICByZW5kZXJNZW51SXRlbTogX3JlYWN0LlByb3BUeXBlcy5mdW5jLFxuICAgIGluZGV4OiBfcmVhY3QuUHJvcFR5cGVzLm51bWJlclxuICB9LFxuXG4gIGdldERlZmF1bHRQcm9wczogZnVuY3Rpb24gZ2V0RGVmYXVsdFByb3BzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBkaXNhYmxlZDogdHJ1ZVxuICAgIH07XG4gIH0sXG5cbiAgcmVuZGVySW5uZXJNZW51SXRlbTogZnVuY3Rpb24gcmVuZGVySW5uZXJNZW51SXRlbShpdGVtLCBzdWJJbmRleCkge1xuICAgIHZhciByZW5kZXJNZW51SXRlbSA9IHRoaXMucHJvcHMucmVuZGVyTWVudUl0ZW07XG4gICAgcmV0dXJuIHJlbmRlck1lbnVJdGVtKGl0ZW0sIHRoaXMucHJvcHMuaW5kZXgsIHN1YkluZGV4KTtcbiAgfSxcblxuICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICB2YXIgcHJvcHMgPSB0aGlzLnByb3BzO1xuICAgIHZhciBjbGFzc05hbWUgPSBwcm9wcy5jbGFzc05hbWUgfHwgJyc7XG4gICAgdmFyIHJvb3RQcmVmaXhDbHMgPSBwcm9wcy5yb290UHJlZml4Q2xzO1xuXG4gICAgY2xhc3NOYW1lICs9ICcgJyArIHJvb3RQcmVmaXhDbHMgKyAnLWl0ZW0tZ3JvdXAnO1xuICAgIHZhciB0aXRsZUNsYXNzTmFtZSA9IHJvb3RQcmVmaXhDbHMgKyAnLWl0ZW0tZ3JvdXAtdGl0bGUnO1xuICAgIHZhciBsaXN0Q2xhc3NOYW1lID0gcm9vdFByZWZpeENscyArICctaXRlbS1ncm91cC1saXN0JztcbiAgICByZXR1cm4gX3JlYWN0MlsnZGVmYXVsdCddLmNyZWF0ZUVsZW1lbnQoXG4gICAgICAnbGknLFxuICAgICAgeyBjbGFzc05hbWU6IGNsYXNzTmFtZSB9LFxuICAgICAgX3JlYWN0MlsnZGVmYXVsdCddLmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICdkaXYnLFxuICAgICAgICB7IGNsYXNzTmFtZTogdGl0bGVDbGFzc05hbWUgfSxcbiAgICAgICAgcHJvcHMudGl0bGVcbiAgICAgICksXG4gICAgICBfcmVhY3QyWydkZWZhdWx0J10uY3JlYXRlRWxlbWVudChcbiAgICAgICAgJ3VsJyxcbiAgICAgICAgeyBjbGFzc05hbWU6IGxpc3RDbGFzc05hbWUgfSxcbiAgICAgICAgX3JlYWN0MlsnZGVmYXVsdCddLkNoaWxkcmVuLm1hcChwcm9wcy5jaGlsZHJlbiwgdGhpcy5yZW5kZXJJbm5lck1lbnVJdGVtKVxuICAgICAgKVxuICAgICk7XG4gIH1cbn0pO1xuXG5NZW51SXRlbUdyb3VwLmlzTWVudUl0ZW1Hcm91cCA9IHRydWU7XG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IE1lbnVJdGVtR3JvdXA7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi91eGNvcmUtdGFibGUvfi91eGNvcmUtbWVudS9+L3JjLW1lbnUvbGliL01lbnVJdGVtR3JvdXAuanNcbiAqKiBtb2R1bGUgaWQgPSA1NFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG52YXIgX3JlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxudmFyIF9yZWFjdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yZWFjdCk7XG5cbnZhciBEaXZpZGVyID0gX3JlYWN0MlsnZGVmYXVsdCddLmNyZWF0ZUNsYXNzKHtcbiAgZGlzcGxheU5hbWU6ICdEaXZpZGVyJyxcblxuICBnZXREZWZhdWx0UHJvcHM6IGZ1bmN0aW9uIGdldERlZmF1bHRQcm9wcygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZGlzYWJsZWQ6IHRydWVcbiAgICB9O1xuICB9LFxuXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgIHZhciBwcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgdmFyIGNsYXNzTmFtZSA9IHByb3BzLmNsYXNzTmFtZSB8fCAnJztcbiAgICB2YXIgcm9vdFByZWZpeENscyA9IHByb3BzLnJvb3RQcmVmaXhDbHM7XG4gICAgY2xhc3NOYW1lICs9ICcgJyArIChyb290UHJlZml4Q2xzICsgJy1pdGVtLWRpdmlkZXInKTtcbiAgICByZXR1cm4gX3JlYWN0MlsnZGVmYXVsdCddLmNyZWF0ZUVsZW1lbnQoJ2xpJywgX2V4dGVuZHMoe30sIHByb3BzLCB7IGNsYXNzTmFtZTogY2xhc3NOYW1lIH0pKTtcbiAgfVxufSk7XG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IERpdmlkZXI7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi91eGNvcmUtdGFibGUvfi91eGNvcmUtbWVudS9+L3JjLW1lbnUvbGliL0RpdmlkZXIuanNcbiAqKiBtb2R1bGUgaWQgPSA1NVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIERyb3Bkb3duIENvbXBvbmVudCBmb3IgdXhjb3JlXG4gKiBAYXV0aG9yIFxuICpcbiAqIENvcHlyaWdodCAyMDE0LTIwMTUsIFV4Y29yZSBUZWFtLCBBbGludy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL0Ryb3Bkb3duJyk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vdXhjb3JlLXRhYmxlL34vdXhjb3JlLWRyb3Bkb3duL2J1aWxkL2luZGV4LmpzXG4gKiogbW9kdWxlIGlkID0gNTZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9yY0Ryb3Bkb3duID0gcmVxdWlyZSgncmMtZHJvcGRvd24nKTtcblxudmFyIF9yY0Ryb3Bkb3duMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JjRHJvcGRvd24pO1xuXG52YXIgX29iamVjdEFzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcblxudmFyIF9vYmplY3RBc3NpZ24yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfb2JqZWN0QXNzaWduKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgXCJkZWZhdWx0XCI6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIERyb3Bkb3duID0gZnVuY3Rpb24gKF9SY0Ryb3Bkb3duKSB7XG5cdF9pbmhlcml0cyhEcm9wZG93biwgX1JjRHJvcGRvd24pO1xuXG5cdGZ1bmN0aW9uIERyb3Bkb3duKHByb3BzKSB7XG5cdFx0X2NsYXNzQ2FsbENoZWNrKHRoaXMsIERyb3Bkb3duKTtcblxuXHRcdHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfUmNEcm9wZG93bi5jYWxsKHRoaXMsIHByb3BzKSk7XG5cdH1cblxuXHRyZXR1cm4gRHJvcGRvd247XG59KF9yY0Ryb3Bkb3duMltcImRlZmF1bHRcIl0pO1xuXG5Ecm9wZG93bi5kaXNwbGF5TmFtZSA9ICd1eGNvcmUtZHJvcGRvd24nO1xuRHJvcGRvd24ucHJvcFR5cGVzID0gX3JjRHJvcGRvd24yW1wiZGVmYXVsdFwiXS5wcm9wVHlwZXM7XG5Ecm9wZG93bi5kZWZhdWx0UHJvcHMgPSAoMCwgX29iamVjdEFzc2lnbjJbXCJkZWZhdWx0XCJdKShfcmNEcm9wZG93bjJbXCJkZWZhdWx0XCJdLmRlZmF1bHRQcm9wcywge1xuXHRwcmVmaXhDbHM6ICdrdW1hLWRyb3Bkb3duJyxcblx0b3ZlcmxheUNsYXNzTmFtZTogJ3V4Y29yZSdcbn0pO1xuXG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IERyb3Bkb3duO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vdXhjb3JlLXRhYmxlL34vdXhjb3JlLWRyb3Bkb3duL2J1aWxkL0Ryb3Bkb3duLmpzXG4gKiogbW9kdWxlIGlkID0gNTdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9Ecm9wZG93biA9IHJlcXVpcmUoJy4vRHJvcGRvd24nKTtcblxudmFyIF9Ecm9wZG93bjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9Ecm9wZG93bik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IFwiZGVmYXVsdFwiOiBvYmogfTsgfVxuXG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IF9Ecm9wZG93bjJbXCJkZWZhdWx0XCJdO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vdXhjb3JlLXRhYmxlL34vdXhjb3JlLWRyb3Bkb3duL34vcmMtZHJvcGRvd24vbGliL2luZGV4LmpzXG4gKiogbW9kdWxlIGlkID0gNThcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcblxudmFyIF9yZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5cbnZhciBfcmVhY3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmVhY3QpO1xuXG52YXIgX3JlYWN0RG9tID0gcmVxdWlyZSgncmVhY3QtZG9tJyk7XG5cbnZhciBfcmVhY3REb20yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmVhY3REb20pO1xuXG52YXIgX3JjVHJpZ2dlciA9IHJlcXVpcmUoJ3JjLXRyaWdnZXInKTtcblxudmFyIF9yY1RyaWdnZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmNUcmlnZ2VyKTtcblxudmFyIF9wbGFjZW1lbnRzID0gcmVxdWlyZSgnLi9wbGFjZW1lbnRzJyk7XG5cbnZhciBfcGxhY2VtZW50czIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9wbGFjZW1lbnRzKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgXCJkZWZhdWx0XCI6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XG5cbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhvYmosIGtleXMpIHsgdmFyIHRhcmdldCA9IHt9OyBmb3IgKHZhciBpIGluIG9iaikgeyBpZiAoa2V5cy5pbmRleE9mKGkpID49IDApIGNvbnRpbnVlOyBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGkpKSBjb250aW51ZTsgdGFyZ2V0W2ldID0gb2JqW2ldOyB9IHJldHVybiB0YXJnZXQ7IH1cblxuLypcblxuIHZhciBNZW51SXRlbSA9IE1lbnUuSXRlbTtcblxuIHZhciBtZW51ID0gPE1lbnU+PE1lbnVJdGVtPjE8L01lbnVJdGVtPjwvTWVudT47XG5cbiA8RHJvcERvd24gdHJpZ2dlcj1cImNsaWNrXCIgYW5pbWF0aW9uTmFtZT1cIlwiIG92ZXJsYXk9ezw+fSBvblNlbGVjdD17fT5cbiA8YnV0dG9uPm9wZW48L2J1dHRvbj5cbiA8L0Ryb3BEb3duPlxuICovXG5cbnZhciBEcm9wZG93biA9IF9yZWFjdDJbXCJkZWZhdWx0XCJdLmNyZWF0ZUNsYXNzKHtcbiAgZGlzcGxheU5hbWU6ICdEcm9wZG93bicsXG5cbiAgcHJvcFR5cGVzOiB7XG4gICAgbWluT3ZlcmxheVdpZHRoTWF0Y2hUcmlnZ2VyOiBfcmVhY3QuUHJvcFR5cGVzLmJvb2wsXG4gICAgb25WaXNpYmxlQ2hhbmdlOiBfcmVhY3QuUHJvcFR5cGVzLmZ1bmMsXG4gICAgcHJlZml4Q2xzOiBfcmVhY3QuUHJvcFR5cGVzLnN0cmluZyxcbiAgICBjaGlsZHJlbjogX3JlYWN0LlByb3BUeXBlcy5hbnksXG4gICAgdHJhbnNpdGlvbk5hbWU6IF9yZWFjdC5Qcm9wVHlwZXMuc3RyaW5nLFxuICAgIG92ZXJsYXlDbGFzc05hbWU6IF9yZWFjdC5Qcm9wVHlwZXMuc3RyaW5nLFxuICAgIGFuaW1hdGlvbjogX3JlYWN0LlByb3BUeXBlcy5hbnksXG4gICAgYWxpZ246IF9yZWFjdC5Qcm9wVHlwZXMub2JqZWN0LFxuICAgIG92ZXJsYXlTdHlsZTogX3JlYWN0LlByb3BUeXBlcy5vYmplY3QsXG4gICAgcGxhY2VtZW50OiBfcmVhY3QuUHJvcFR5cGVzLnN0cmluZyxcbiAgICB0cmlnZ2VyOiBfcmVhY3QuUHJvcFR5cGVzLmFycmF5LFxuICAgIHNob3dBY3Rpb246IF9yZWFjdC5Qcm9wVHlwZXMuYXJyYXksXG4gICAgaGlkZUFjdGlvbjogX3JlYWN0LlByb3BUeXBlcy5hcnJheSxcbiAgICBnZXRQb3B1cENvbnRhaW5lcjogX3JlYWN0LlByb3BUeXBlcy5mdW5jXG4gIH0sXG5cbiAgZ2V0RGVmYXVsdFByb3BzOiBmdW5jdGlvbiBnZXREZWZhdWx0UHJvcHMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG1pbk92ZXJsYXlXaWR0aE1hdGNoVHJpZ2dlcjogdHJ1ZSxcbiAgICAgIHByZWZpeENsczogJ3JjLWRyb3Bkb3duJyxcbiAgICAgIHRyaWdnZXI6IFsnaG92ZXInXSxcbiAgICAgIHNob3dBY3Rpb246IFtdLFxuICAgICAgaGlkZUFjdGlvbjogW10sXG4gICAgICBvdmVybGF5Q2xhc3NOYW1lOiAnJyxcbiAgICAgIG92ZXJsYXlTdHlsZToge30sXG4gICAgICBkZWZhdWx0VmlzaWJsZTogZmFsc2UsXG4gICAgICBvblZpc2libGVDaGFuZ2U6IGZ1bmN0aW9uIG9uVmlzaWJsZUNoYW5nZSgpIHt9LFxuXG4gICAgICBwbGFjZW1lbnQ6ICdib3R0b21MZWZ0J1xuICAgIH07XG4gIH0sXG4gIGdldEluaXRpYWxTdGF0ZTogZnVuY3Rpb24gZ2V0SW5pdGlhbFN0YXRlKCkge1xuICAgIHZhciBwcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgaWYgKCd2aXNpYmxlJyBpbiBwcm9wcykge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdmlzaWJsZTogcHJvcHMudmlzaWJsZVxuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHZpc2libGU6IHByb3BzLmRlZmF1bHRWaXNpYmxlXG4gICAgfTtcbiAgfSxcbiAgY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wczogZnVuY3Rpb24gY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhwcm9wcykge1xuICAgIGlmICgndmlzaWJsZScgaW4gcHJvcHMpIHtcbiAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICB2aXNpYmxlOiBwcm9wcy52aXNpYmxlXG4gICAgICB9KTtcbiAgICB9XG4gIH0sXG4gIG9uQ2xpY2s6IGZ1bmN0aW9uIG9uQ2xpY2soZSkge1xuICAgIHZhciBwcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgdmFyIG92ZXJsYXlQcm9wcyA9IHByb3BzLm92ZXJsYXkucHJvcHM7XG4gICAgaWYgKCEoJ3Zpc2libGUnIGluIHByb3BzKSkge1xuICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgIHZpc2libGU6IGZhbHNlXG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKG92ZXJsYXlQcm9wcy5vbkNsaWNrKSB7XG4gICAgICBvdmVybGF5UHJvcHMub25DbGljayhlKTtcbiAgICB9XG4gIH0sXG4gIG9uVmlzaWJsZUNoYW5nZTogZnVuY3Rpb24gb25WaXNpYmxlQ2hhbmdlKHYpIHtcbiAgICB2YXIgcHJvcHMgPSB0aGlzLnByb3BzO1xuICAgIGlmICghKCd2aXNpYmxlJyBpbiBwcm9wcykpIHtcbiAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICB2aXNpYmxlOiB2XG4gICAgICB9KTtcbiAgICB9XG4gICAgcHJvcHMub25WaXNpYmxlQ2hhbmdlKHYpO1xuICB9LFxuICBnZXRNZW51RWxlbWVudDogZnVuY3Rpb24gZ2V0TWVudUVsZW1lbnQoKSB7XG4gICAgdmFyIHByb3BzID0gdGhpcy5wcm9wcztcbiAgICByZXR1cm4gX3JlYWN0MltcImRlZmF1bHRcIl0uY2xvbmVFbGVtZW50KHByb3BzLm92ZXJsYXksIHtcbiAgICAgIHByZWZpeENsczogcHJvcHMucHJlZml4Q2xzICsgJy1tZW51JyxcbiAgICAgIG9uQ2xpY2s6IHRoaXMub25DbGlja1xuICAgIH0pO1xuICB9LFxuICBnZXRQb3B1cERvbU5vZGU6IGZ1bmN0aW9uIGdldFBvcHVwRG9tTm9kZSgpIHtcbiAgICByZXR1cm4gdGhpcy5yZWZzLnRyaWdnZXIuZ2V0UG9wdXBEb21Ob2RlKCk7XG4gIH0sXG4gIGFmdGVyVmlzaWJsZUNoYW5nZTogZnVuY3Rpb24gYWZ0ZXJWaXNpYmxlQ2hhbmdlKHZpc2libGUpIHtcbiAgICBpZiAodmlzaWJsZSAmJiB0aGlzLnByb3BzLm1pbk92ZXJsYXlXaWR0aE1hdGNoVHJpZ2dlcikge1xuICAgICAgdmFyIG92ZXJsYXlOb2RlID0gdGhpcy5nZXRQb3B1cERvbU5vZGUoKTtcbiAgICAgIHZhciByb290Tm9kZSA9IF9yZWFjdERvbTJbXCJkZWZhdWx0XCJdLmZpbmRET01Ob2RlKHRoaXMpO1xuICAgICAgaWYgKHJvb3ROb2RlLm9mZnNldFdpZHRoID4gb3ZlcmxheU5vZGUub2Zmc2V0V2lkdGgpIHtcbiAgICAgICAgb3ZlcmxheU5vZGUuc3R5bGUud2lkdGggPSByb290Tm9kZS5vZmZzZXRXaWR0aCArICdweCc7XG4gICAgICB9XG4gICAgfVxuICB9LFxuICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICB2YXIgX2V4dGVuZHMyO1xuXG4gICAgdmFyIF9wcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgdmFyIHByZWZpeENscyA9IF9wcm9wcy5wcmVmaXhDbHM7XG4gICAgdmFyIGNoaWxkcmVuID0gX3Byb3BzLmNoaWxkcmVuO1xuICAgIHZhciB0cmFuc2l0aW9uTmFtZSA9IF9wcm9wcy50cmFuc2l0aW9uTmFtZTtcbiAgICB2YXIgYW5pbWF0aW9uID0gX3Byb3BzLmFuaW1hdGlvbjtcbiAgICB2YXIgYWxpZ24gPSBfcHJvcHMuYWxpZ247XG4gICAgdmFyIHBsYWNlbWVudCA9IF9wcm9wcy5wbGFjZW1lbnQ7XG4gICAgdmFyIGdldFBvcHVwQ29udGFpbmVyID0gX3Byb3BzLmdldFBvcHVwQ29udGFpbmVyO1xuICAgIHZhciBzaG93QWN0aW9uID0gX3Byb3BzLnNob3dBY3Rpb247XG4gICAgdmFyIGhpZGVBY3Rpb24gPSBfcHJvcHMuaGlkZUFjdGlvbjtcbiAgICB2YXIgb3ZlcmxheUNsYXNzTmFtZSA9IF9wcm9wcy5vdmVybGF5Q2xhc3NOYW1lO1xuICAgIHZhciBvdmVybGF5U3R5bGUgPSBfcHJvcHMub3ZlcmxheVN0eWxlO1xuICAgIHZhciB0cmlnZ2VyID0gX3Byb3BzLnRyaWdnZXI7XG5cbiAgICB2YXIgb3RoZXJQcm9wcyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhfcHJvcHMsIFsncHJlZml4Q2xzJywgJ2NoaWxkcmVuJywgJ3RyYW5zaXRpb25OYW1lJywgJ2FuaW1hdGlvbicsICdhbGlnbicsICdwbGFjZW1lbnQnLCAnZ2V0UG9wdXBDb250YWluZXInLCAnc2hvd0FjdGlvbicsICdoaWRlQWN0aW9uJywgJ292ZXJsYXlDbGFzc05hbWUnLCAnb3ZlcmxheVN0eWxlJywgJ3RyaWdnZXInXSk7XG5cbiAgICByZXR1cm4gX3JlYWN0MltcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChcbiAgICAgIF9yY1RyaWdnZXIyW1wiZGVmYXVsdFwiXSxcbiAgICAgIF9leHRlbmRzKHt9LCBvdGhlclByb3BzLCAoX2V4dGVuZHMyID0ge1xuICAgICAgICBwcmVmaXhDbHM6IHByZWZpeENscyxcbiAgICAgICAgcmVmOiAndHJpZ2dlcicsXG4gICAgICAgIHBvcHVwQ2xhc3NOYW1lOiBvdmVybGF5Q2xhc3NOYW1lLFxuICAgICAgICBwb3B1cFN0eWxlOiBvdmVybGF5U3R5bGUsXG4gICAgICAgIGJ1aWx0aW5QbGFjZW1lbnRzOiBfcGxhY2VtZW50czJbXCJkZWZhdWx0XCJdLFxuICAgICAgICBhY3Rpb246IHRyaWdnZXIsXG4gICAgICAgIHNob3dBY3Rpb246IHNob3dBY3Rpb25cbiAgICAgIH0sIF9kZWZpbmVQcm9wZXJ0eShfZXh0ZW5kczIsICdzaG93QWN0aW9uJywgc2hvd0FjdGlvbiksIF9kZWZpbmVQcm9wZXJ0eShfZXh0ZW5kczIsICdoaWRlQWN0aW9uJywgaGlkZUFjdGlvbiksIF9kZWZpbmVQcm9wZXJ0eShfZXh0ZW5kczIsICdwb3B1cFBsYWNlbWVudCcsIHBsYWNlbWVudCksIF9kZWZpbmVQcm9wZXJ0eShfZXh0ZW5kczIsICdwb3B1cEFsaWduJywgYWxpZ24pLCBfZGVmaW5lUHJvcGVydHkoX2V4dGVuZHMyLCAncG9wdXBUcmFuc2l0aW9uTmFtZScsIHRyYW5zaXRpb25OYW1lKSwgX2RlZmluZVByb3BlcnR5KF9leHRlbmRzMiwgJ3BvcHVwQW5pbWF0aW9uJywgYW5pbWF0aW9uKSwgX2RlZmluZVByb3BlcnR5KF9leHRlbmRzMiwgJ3BvcHVwVmlzaWJsZScsIHRoaXMuc3RhdGUudmlzaWJsZSksIF9kZWZpbmVQcm9wZXJ0eShfZXh0ZW5kczIsICdhZnRlclBvcHVwVmlzaWJsZUNoYW5nZScsIHRoaXMuYWZ0ZXJWaXNpYmxlQ2hhbmdlKSwgX2RlZmluZVByb3BlcnR5KF9leHRlbmRzMiwgJ3BvcHVwJywgdGhpcy5nZXRNZW51RWxlbWVudCgpKSwgX2RlZmluZVByb3BlcnR5KF9leHRlbmRzMiwgJ29uUG9wdXBWaXNpYmxlQ2hhbmdlJywgdGhpcy5vblZpc2libGVDaGFuZ2UpLCBfZGVmaW5lUHJvcGVydHkoX2V4dGVuZHMyLCAnZ2V0UG9wdXBDb250YWluZXInLCBnZXRQb3B1cENvbnRhaW5lciksIF9leHRlbmRzMikpLFxuICAgICAgY2hpbGRyZW5cbiAgICApO1xuICB9XG59KTtcblxuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBEcm9wZG93bjtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3V4Y29yZS10YWJsZS9+L3V4Y29yZS1kcm9wZG93bi9+L3JjLWRyb3Bkb3duL2xpYi9Ecm9wZG93bi5qc1xuICoqIG1vZHVsZSBpZCA9IDU5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xudmFyIFJFX05VTSA9IC9bXFwtK10/KD86XFxkKlxcLnwpXFxkKyg/OltlRV1bXFwtK10/XFxkK3wpLy5zb3VyY2U7XG5cbnZhciBnZXRDb21wdXRlZFN0eWxlWCA9IHVuZGVmaW5lZDtcblxuZnVuY3Rpb24gY3NzKGVsLCBuYW1lLCB2KSB7XG4gIHZhciB2YWx1ZSA9IHY7XG4gIGlmICh0eXBlb2YgbmFtZSA9PT0gJ29iamVjdCcpIHtcbiAgICBmb3IgKHZhciBpIGluIG5hbWUpIHtcbiAgICAgIGlmIChuYW1lLmhhc093blByb3BlcnR5KGkpKSB7XG4gICAgICAgIGNzcyhlbCwgaSwgbmFtZVtpXSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgICAgdmFsdWUgPSB2YWx1ZSArICdweCc7XG4gICAgfVxuICAgIGVsLnN0eWxlW25hbWVdID0gdmFsdWU7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuICByZXR1cm4gZ2V0Q29tcHV0ZWRTdHlsZVgoZWwsIG5hbWUpO1xufVxuXG5mdW5jdGlvbiBnZXRDbGllbnRQb3NpdGlvbihlbGVtKSB7XG4gIHZhciBib3ggPSB1bmRlZmluZWQ7XG4gIHZhciB4ID0gdW5kZWZpbmVkO1xuICB2YXIgeSA9IHVuZGVmaW5lZDtcbiAgdmFyIGRvYyA9IGVsZW0ub3duZXJEb2N1bWVudDtcbiAgdmFyIGJvZHkgPSBkb2MuYm9keTtcbiAgdmFyIGRvY0VsZW0gPSBkb2MgJiYgZG9jLmRvY3VtZW50RWxlbWVudDtcbiAgLy8g5qC55o2uIEdCUyDmnIDmlrDmlbDmja7vvIxBLUdyYWRlIEJyb3dzZXJzIOmDveW3suaUr+aMgSBnZXRCb3VuZGluZ0NsaWVudFJlY3Qg5pa55rOV77yM5LiN55So5YaN6ICD6JmR5Lyg57uf55qE5a6e546w5pa55byPXG4gIGJveCA9IGVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cbiAgLy8g5rOo77yaalF1ZXJ5IOi/mOiAg+iZkeWHj+WOuyBkb2NFbGVtLmNsaWVudExlZnQvY2xpZW50VG9wXG4gIC8vIOS9hua1i+ivleWPkeeOsO+8jOi/meagt+WPjeiAjOS8muWvvOiHtOW9kyBodG1sIOWSjCBib2R5IOaciei+uei3nS/ovrnmoYbmoLflvI/ml7bvvIzojrflj5bnmoTlgLzkuI3mraPnoa5cbiAgLy8g5q2k5aSW77yMaWU2IOS8muW/veeVpSBodG1sIOeahCBtYXJnaW4g5YC877yM5bm46L+Q5Zyw5piv5rKh5pyJ6LCB5Lya5Y676K6+572uIGh0bWwg55qEIG1hcmdpblxuXG4gIHggPSBib3gubGVmdDtcbiAgeSA9IGJveC50b3A7XG5cbiAgLy8gSW4gSUUsIG1vc3Qgb2YgdGhlIHRpbWUsIDIgZXh0cmEgcGl4ZWxzIGFyZSBhZGRlZCB0byB0aGUgdG9wIGFuZCBsZWZ0XG4gIC8vIGR1ZSB0byB0aGUgaW1wbGljaXQgMi1waXhlbCBpbnNldCBib3JkZXIuICBJbiBJRTYvNyBxdWlya3MgbW9kZSBhbmRcbiAgLy8gSUU2IHN0YW5kYXJkcyBtb2RlLCB0aGlzIGJvcmRlciBjYW4gYmUgb3ZlcnJpZGRlbiBieSBzZXR0aW5nIHRoZVxuICAvLyBkb2N1bWVudCBlbGVtZW50J3MgYm9yZGVyIHRvIHplcm8gLS0gdGh1cywgd2UgY2Fubm90IHJlbHkgb24gdGhlXG4gIC8vIG9mZnNldCBhbHdheXMgYmVpbmcgMiBwaXhlbHMuXG5cbiAgLy8gSW4gcXVpcmtzIG1vZGUsIHRoZSBvZmZzZXQgY2FuIGJlIGRldGVybWluZWQgYnkgcXVlcnlpbmcgdGhlIGJvZHknc1xuICAvLyBjbGllbnRMZWZ0L2NsaWVudFRvcCwgYnV0IGluIHN0YW5kYXJkcyBtb2RlLCBpdCBpcyBmb3VuZCBieSBxdWVyeWluZ1xuICAvLyB0aGUgZG9jdW1lbnQgZWxlbWVudCdzIGNsaWVudExlZnQvY2xpZW50VG9wLiAgU2luY2Ugd2UgYWxyZWFkeSBjYWxsZWRcbiAgLy8gZ2V0Q2xpZW50Qm91bmRpbmdSZWN0IHdlIGhhdmUgYWxyZWFkeSBmb3JjZWQgYSByZWZsb3csIHNvIGl0IGlzIG5vdFxuICAvLyB0b28gZXhwZW5zaXZlIGp1c3QgdG8gcXVlcnkgdGhlbSBhbGwuXG5cbiAgLy8gaWUg5LiL5bqU6K+l5YeP5Y6756qX5Y+j55qE6L655qGG5ZCn77yM5q+V56uf6buY6K6kIGFic29sdXRlIOmDveaYr+ebuOWvueeql+WPo+WumuS9jeeahFxuICAvLyDnqpflj6PovrnmoYbmoIflh4bmmK/orr4gZG9jdW1lbnRFbGVtZW50ICxxdWlya3Mg5pe26K6+572uIGJvZHlcbiAgLy8g5pyA5aW956aB5q2i5ZyoIGJvZHkg5ZKMIGh0bWwg5LiK6L655qGGIO+8jOS9hiBpZSA8IDkgaHRtbCDpu5jorqTmnIkgMnB4IO+8jOWHj+WOu1xuICAvLyDkvYbmmK/pnZ4gaWUg5LiN5Y+v6IO96K6+572u56qX5Y+j6L655qGG77yMYm9keSBodG1sIOS5n+S4jeaYr+eql+WPoyAsaWUg5Y+v5Lul6YCa6L+HIGh0bWwsYm9keSDorr7nva5cbiAgLy8g5qCH5YeGIGllIOS4iyBkb2NFbGVtLmNsaWVudFRvcCDlsLHmmK8gYm9yZGVyLXRvcFxuICAvLyBpZTcgaHRtbCDljbPnqpflj6PovrnmoYbmlLnlj5jkuI3kuobjgILmsLjov5zkuLogMlxuICAvLyDkvYbmoIflh4YgZmlyZWZveC9jaHJvbWUvaWU5IOS4iyBkb2NFbGVtLmNsaWVudFRvcCDmmK/nqpflj6PovrnmoYbvvIzljbPkvb/orr7kuoYgYm9yZGVyLXRvcCDkuZ/kuLogMFxuXG4gIHggLT0gZG9jRWxlbS5jbGllbnRMZWZ0IHx8IGJvZHkuY2xpZW50TGVmdCB8fCAwO1xuICB5IC09IGRvY0VsZW0uY2xpZW50VG9wIHx8IGJvZHkuY2xpZW50VG9wIHx8IDA7XG5cbiAgcmV0dXJuIHsgbGVmdDogeCwgdG9wOiB5IH07XG59XG5cbmZ1bmN0aW9uIGdldFNjcm9sbCh3LCB0b3ApIHtcbiAgdmFyIHJldCA9IHdbJ3BhZ2UnICsgKHRvcCA/ICdZJyA6ICdYJykgKyAnT2Zmc2V0J107XG4gIHZhciBtZXRob2QgPSAnc2Nyb2xsJyArICh0b3AgPyAnVG9wJyA6ICdMZWZ0Jyk7XG4gIGlmICh0eXBlb2YgcmV0ICE9PSAnbnVtYmVyJykge1xuICAgIHZhciBkID0gdy5kb2N1bWVudDtcbiAgICAvLyBpZTYsNyw4IHN0YW5kYXJkIG1vZGVcbiAgICByZXQgPSBkLmRvY3VtZW50RWxlbWVudFttZXRob2RdO1xuICAgIGlmICh0eXBlb2YgcmV0ICE9PSAnbnVtYmVyJykge1xuICAgICAgLy8gcXVpcmtzIG1vZGVcbiAgICAgIHJldCA9IGQuYm9keVttZXRob2RdO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBnZXRTY3JvbGxMZWZ0KHcpIHtcbiAgcmV0dXJuIGdldFNjcm9sbCh3KTtcbn1cblxuZnVuY3Rpb24gZ2V0U2Nyb2xsVG9wKHcpIHtcbiAgcmV0dXJuIGdldFNjcm9sbCh3LCB0cnVlKTtcbn1cblxuZnVuY3Rpb24gZ2V0T2Zmc2V0KGVsKSB7XG4gIHZhciBwb3MgPSBnZXRDbGllbnRQb3NpdGlvbihlbCk7XG4gIHZhciBkb2MgPSBlbC5vd25lckRvY3VtZW50O1xuICB2YXIgdyA9IGRvYy5kZWZhdWx0VmlldyB8fCBkb2MucGFyZW50V2luZG93O1xuICBwb3MubGVmdCArPSBnZXRTY3JvbGxMZWZ0KHcpO1xuICBwb3MudG9wICs9IGdldFNjcm9sbFRvcCh3KTtcbiAgcmV0dXJuIHBvcztcbn1cbmZ1bmN0aW9uIF9nZXRDb21wdXRlZFN0eWxlKGVsZW0sIG5hbWUsIGNzKSB7XG4gIHZhciBjb21wdXRlZFN0eWxlID0gY3M7XG4gIHZhciB2YWwgPSAnJztcbiAgdmFyIGQgPSBlbGVtLm93bmVyRG9jdW1lbnQ7XG4gIGNvbXB1dGVkU3R5bGUgPSBjb21wdXRlZFN0eWxlIHx8IGQuZGVmYXVsdFZpZXcuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtLCBudWxsKTtcblxuICAvLyBodHRwczovL2dpdGh1Yi5jb20va2lzc3l0ZWFtL2tpc3N5L2lzc3Vlcy82MVxuICBpZiAoY29tcHV0ZWRTdHlsZSkge1xuICAgIHZhbCA9IGNvbXB1dGVkU3R5bGUuZ2V0UHJvcGVydHlWYWx1ZShuYW1lKSB8fCBjb21wdXRlZFN0eWxlW25hbWVdO1xuICB9XG5cbiAgcmV0dXJuIHZhbDtcbn1cblxudmFyIF9SRV9OVU1fTk9fUFggPSBuZXcgUmVnRXhwKCdeKCcgKyBSRV9OVU0gKyAnKSg/IXB4KVthLXolXSskJywgJ2knKTtcbnZhciBSRV9QT1MgPSAvXih0b3B8cmlnaHR8Ym90dG9tfGxlZnQpJC87XG52YXIgQ1VSUkVOVF9TVFlMRSA9ICdjdXJyZW50U3R5bGUnO1xudmFyIFJVTlRJTUVfU1RZTEUgPSAncnVudGltZVN0eWxlJztcbnZhciBMRUZUID0gJ2xlZnQnO1xudmFyIFBYID0gJ3B4JztcblxuZnVuY3Rpb24gX2dldENvbXB1dGVkU3R5bGVJRShlbGVtLCBuYW1lKSB7XG4gIC8vIGN1cnJlbnRTdHlsZSBtYXliZSBudWxsXG4gIC8vIGh0dHA6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9tczUzNTIzMS5hc3B4XG4gIHZhciByZXQgPSBlbGVtW0NVUlJFTlRfU1RZTEVdICYmIGVsZW1bQ1VSUkVOVF9TVFlMRV1bbmFtZV07XG5cbiAgLy8g5b2TIHdpZHRoL2hlaWdodCDorr7nva7kuLrnmb7liIbmr5Tml7bvvIzpgJrov4cgcGl4ZWxMZWZ0IOaWueW8j+i9rOaNoueahCB3aWR0aC9oZWlnaHQg5YC8XG4gIC8vIOS4gOW8gOWni+WwseWkhOeQhuS6hiEgQ1VTVE9NX1NUWUxFLmhlaWdodCxDVVNUT01fU1RZTEUud2lkdGggLGNzc0hvb2sg6Kej5YazQDIwMTEtMDgtMTlcbiAgLy8g5ZyoIGllIOS4i+S4jeWvue+8jOmcgOimgeebtOaOpeeUqCBvZmZzZXQg5pa55byPXG4gIC8vIGJvcmRlcldpZHRoIOetieWAvOS5n+aciemXrumimO+8jOS9huiAg+iZkeWIsCBib3JkZXJXaWR0aCDorr7kuLrnmb7liIbmr5TnmoTmpoLnjoflvojlsI/vvIzov5nph4zlsLHkuI3ogIPomZHkuoZcblxuICAvLyBGcm9tIHRoZSBhd2Vzb21lIGhhY2sgYnkgRGVhbiBFZHdhcmRzXG4gIC8vIGh0dHA6Ly9lcmlrLmVhZS5uZXQvYXJjaGl2ZXMvMjAwNy8wNy8yNy8xOC41NC4xNS8jY29tbWVudC0xMDIyOTFcbiAgLy8gSWYgd2UncmUgbm90IGRlYWxpbmcgd2l0aCBhIHJlZ3VsYXIgcGl4ZWwgbnVtYmVyXG4gIC8vIGJ1dCBhIG51bWJlciB0aGF0IGhhcyBhIHdlaXJkIGVuZGluZywgd2UgbmVlZCB0byBjb252ZXJ0IGl0IHRvIHBpeGVsc1xuICAvLyBleGNsdWRlIGxlZnQgcmlnaHQgZm9yIHJlbGF0aXZpdHlcbiAgaWYgKF9SRV9OVU1fTk9fUFgudGVzdChyZXQpICYmICFSRV9QT1MudGVzdChuYW1lKSkge1xuICAgIC8vIFJlbWVtYmVyIHRoZSBvcmlnaW5hbCB2YWx1ZXNcbiAgICB2YXIgc3R5bGUgPSBlbGVtLnN0eWxlO1xuICAgIHZhciBsZWZ0ID0gc3R5bGVbTEVGVF07XG4gICAgdmFyIHJzTGVmdCA9IGVsZW1bUlVOVElNRV9TVFlMRV1bTEVGVF07XG5cbiAgICAvLyBwcmV2ZW50IGZsYXNoaW5nIG9mIGNvbnRlbnRcbiAgICBlbGVtW1JVTlRJTUVfU1RZTEVdW0xFRlRdID0gZWxlbVtDVVJSRU5UX1NUWUxFXVtMRUZUXTtcblxuICAgIC8vIFB1dCBpbiB0aGUgbmV3IHZhbHVlcyB0byBnZXQgYSBjb21wdXRlZCB2YWx1ZSBvdXRcbiAgICBzdHlsZVtMRUZUXSA9IG5hbWUgPT09ICdmb250U2l6ZScgPyAnMWVtJyA6IHJldCB8fCAwO1xuICAgIHJldCA9IHN0eWxlLnBpeGVsTGVmdCArIFBYO1xuXG4gICAgLy8gUmV2ZXJ0IHRoZSBjaGFuZ2VkIHZhbHVlc1xuICAgIHN0eWxlW0xFRlRdID0gbGVmdDtcblxuICAgIGVsZW1bUlVOVElNRV9TVFlMRV1bTEVGVF0gPSByc0xlZnQ7XG4gIH1cbiAgcmV0dXJuIHJldCA9PT0gJycgPyAnYXV0bycgOiByZXQ7XG59XG5cbmlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICBnZXRDb21wdXRlZFN0eWxlWCA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlID8gX2dldENvbXB1dGVkU3R5bGUgOiBfZ2V0Q29tcHV0ZWRTdHlsZUlFO1xufVxuXG5mdW5jdGlvbiBnZXRPZmZzZXREaXJlY3Rpb24oZGlyLCBvcHRpb24pIHtcbiAgaWYgKGRpciA9PT0gJ2xlZnQnKSB7XG4gICAgcmV0dXJuIG9wdGlvbi51c2VDc3NSaWdodCA/ICdyaWdodCcgOiBkaXI7XG4gIH1cbiAgcmV0dXJuIG9wdGlvbi51c2VDc3NCb3R0b20gPyAnYm90dG9tJyA6IGRpcjtcbn1cblxuZnVuY3Rpb24gb3Bwb3NpdGVPZmZzZXREaXJlY3Rpb24oZGlyKSB7XG4gIGlmIChkaXIgPT09ICdsZWZ0Jykge1xuICAgIHJldHVybiAncmlnaHQnO1xuICB9IGVsc2UgaWYgKGRpciA9PT0gJ3JpZ2h0Jykge1xuICAgIHJldHVybiAnbGVmdCc7XG4gIH0gZWxzZSBpZiAoZGlyID09PSAndG9wJykge1xuICAgIHJldHVybiAnYm90dG9tJztcbiAgfSBlbHNlIGlmIChkaXIgPT09ICdib3R0b20nKSB7XG4gICAgcmV0dXJuICd0b3AnO1xuICB9XG59XG5cbi8vIOiuvue9riBlbGVtIOebuOWvuSBlbGVtLm93bmVyRG9jdW1lbnQg55qE5Z2Q5qCHXG5mdW5jdGlvbiBzZXRPZmZzZXQoZWxlbSwgb2Zmc2V0LCBvcHRpb24pIHtcbiAgLy8gc2V0IHBvc2l0aW9uIGZpcnN0LCBpbi1jYXNlIHRvcC9sZWZ0IGFyZSBzZXQgZXZlbiBvbiBzdGF0aWMgZWxlbVxuICBpZiAoY3NzKGVsZW0sICdwb3NpdGlvbicpID09PSAnc3RhdGljJykge1xuICAgIGVsZW0uc3R5bGUucG9zaXRpb24gPSAncmVsYXRpdmUnO1xuICB9XG4gIHZhciBwcmVzZXRIID0gLTk5OTtcbiAgdmFyIHByZXNldFYgPSAtOTk5O1xuICB2YXIgaG9yaXpvbnRhbFByb3BlcnR5ID0gZ2V0T2Zmc2V0RGlyZWN0aW9uKCdsZWZ0Jywgb3B0aW9uKTtcbiAgdmFyIHZlcnRpY2FsUHJvcGVydHkgPSBnZXRPZmZzZXREaXJlY3Rpb24oJ3RvcCcsIG9wdGlvbik7XG4gIHZhciBvcHBvc2l0ZUhvcml6b250YWxQcm9wZXJ0eSA9IG9wcG9zaXRlT2Zmc2V0RGlyZWN0aW9uKGhvcml6b250YWxQcm9wZXJ0eSk7XG4gIHZhciBvcHBvc2l0ZVZlcnRpY2FsUHJvcGVydHkgPSBvcHBvc2l0ZU9mZnNldERpcmVjdGlvbih2ZXJ0aWNhbFByb3BlcnR5KTtcblxuICBpZiAoaG9yaXpvbnRhbFByb3BlcnR5ICE9PSAnbGVmdCcpIHtcbiAgICBwcmVzZXRIID0gOTk5O1xuICB9XG5cbiAgaWYgKHZlcnRpY2FsUHJvcGVydHkgIT09ICd0b3AnKSB7XG4gICAgcHJlc2V0ViA9IDk5OTtcbiAgfVxuXG4gIGlmICgnbGVmdCcgaW4gb2Zmc2V0KSB7XG4gICAgZWxlbS5zdHlsZVtvcHBvc2l0ZUhvcml6b250YWxQcm9wZXJ0eV0gPSAnJztcbiAgICBlbGVtLnN0eWxlW2hvcml6b250YWxQcm9wZXJ0eV0gPSBwcmVzZXRIICsgJ3B4JztcbiAgfVxuICBpZiAoJ3RvcCcgaW4gb2Zmc2V0KSB7XG4gICAgZWxlbS5zdHlsZVtvcHBvc2l0ZVZlcnRpY2FsUHJvcGVydHldID0gJyc7XG4gICAgZWxlbS5zdHlsZVt2ZXJ0aWNhbFByb3BlcnR5XSA9IHByZXNldFYgKyAncHgnO1xuICB9XG4gIHZhciBvbGQgPSBnZXRPZmZzZXQoZWxlbSk7XG4gIHZhciByZXQgPSB7fTtcbiAgdmFyIGtleSA9IHVuZGVmaW5lZDtcbiAgZm9yIChrZXkgaW4gb2Zmc2V0KSB7XG4gICAgaWYgKG9mZnNldC5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICB2YXIgZGlyID0gZ2V0T2Zmc2V0RGlyZWN0aW9uKGtleSwgb3B0aW9uKTtcbiAgICAgIHZhciBwcmVzZXQgPSBrZXkgPT09ICdsZWZ0JyA/IHByZXNldEggOiBwcmVzZXRWO1xuICAgICAgaWYgKGRpciA9PT0ga2V5KSB7XG4gICAgICAgIHJldFtkaXJdID0gcHJlc2V0ICsgb2Zmc2V0W2tleV0gLSBvbGRba2V5XTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldFtkaXJdID0gcHJlc2V0ICsgb2xkW2tleV0gLSBvZmZzZXRba2V5XTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgY3NzKGVsZW0sIHJldCk7XG59XG5cbmZ1bmN0aW9uIGVhY2goYXJyLCBmbikge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgIGZuKGFycltpXSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNCb3JkZXJCb3hGbihlbGVtKSB7XG4gIHJldHVybiBnZXRDb21wdXRlZFN0eWxlWChlbGVtLCAnYm94U2l6aW5nJykgPT09ICdib3JkZXItYm94Jztcbn1cblxudmFyIEJPWF9NT0RFTFMgPSBbJ21hcmdpbicsICdib3JkZXInLCAncGFkZGluZyddO1xudmFyIENPTlRFTlRfSU5ERVggPSAtMTtcbnZhciBQQURESU5HX0lOREVYID0gMjtcbnZhciBCT1JERVJfSU5ERVggPSAxO1xudmFyIE1BUkdJTl9JTkRFWCA9IDA7XG5cbmZ1bmN0aW9uIHN3YXAoZWxlbSwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgdmFyIG9sZCA9IHt9O1xuICB2YXIgc3R5bGUgPSBlbGVtLnN0eWxlO1xuICB2YXIgbmFtZSA9IHVuZGVmaW5lZDtcblxuICAvLyBSZW1lbWJlciB0aGUgb2xkIHZhbHVlcywgYW5kIGluc2VydCB0aGUgbmV3IG9uZXNcbiAgZm9yIChuYW1lIGluIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucy5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgb2xkW25hbWVdID0gc3R5bGVbbmFtZV07XG4gICAgICBzdHlsZVtuYW1lXSA9IG9wdGlvbnNbbmFtZV07XG4gICAgfVxuICB9XG5cbiAgY2FsbGJhY2suY2FsbChlbGVtKTtcblxuICAvLyBSZXZlcnQgdGhlIG9sZCB2YWx1ZXNcbiAgZm9yIChuYW1lIGluIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucy5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgc3R5bGVbbmFtZV0gPSBvbGRbbmFtZV07XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGdldFBCTVdpZHRoKGVsZW0sIHByb3BzLCB3aGljaCkge1xuICB2YXIgdmFsdWUgPSAwO1xuICB2YXIgcHJvcCA9IHVuZGVmaW5lZDtcbiAgdmFyIGogPSB1bmRlZmluZWQ7XG4gIHZhciBpID0gdW5kZWZpbmVkO1xuICBmb3IgKGogPSAwOyBqIDwgcHJvcHMubGVuZ3RoOyBqKyspIHtcbiAgICBwcm9wID0gcHJvcHNbal07XG4gICAgaWYgKHByb3ApIHtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCB3aGljaC5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY3NzUHJvcCA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKHByb3AgPT09ICdib3JkZXInKSB7XG4gICAgICAgICAgY3NzUHJvcCA9IHByb3AgKyB3aGljaFtpXSArICdXaWR0aCc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY3NzUHJvcCA9IHByb3AgKyB3aGljaFtpXTtcbiAgICAgICAgfVxuICAgICAgICB2YWx1ZSArPSBwYXJzZUZsb2F0KGdldENvbXB1dGVkU3R5bGVYKGVsZW0sIGNzc1Byb3ApKSB8fCAwO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gdmFsdWU7XG59XG5cbi8qKlxuICogQSBjcnVkZSB3YXkgb2YgZGV0ZXJtaW5pbmcgaWYgYW4gb2JqZWN0IGlzIGEgd2luZG93XG4gKiBAbWVtYmVyIHV0aWxcbiAqL1xuZnVuY3Rpb24gaXNXaW5kb3cob2JqKSB7XG4gIC8vIG11c3QgdXNlID09IGZvciBpZThcbiAgLyogZXNsaW50IGVxZXFlcTowICovXG4gIHJldHVybiBvYmogIT09IG51bGwgJiYgb2JqICE9PSB1bmRlZmluZWQgJiYgb2JqID09IG9iai53aW5kb3c7XG59XG5cbnZhciBkb21VdGlscyA9IHt9O1xuXG5lYWNoKFsnV2lkdGgnLCAnSGVpZ2h0J10sIGZ1bmN0aW9uIChuYW1lKSB7XG4gIGRvbVV0aWxzWydkb2MnICsgbmFtZV0gPSBmdW5jdGlvbiAocmVmV2luKSB7XG4gICAgdmFyIGQgPSByZWZXaW4uZG9jdW1lbnQ7XG4gICAgcmV0dXJuIE1hdGgubWF4KFxuICAgIC8vIGZpcmVmb3ggY2hyb21lIGRvY3VtZW50RWxlbWVudC5zY3JvbGxIZWlnaHQ8IGJvZHkuc2Nyb2xsSGVpZ2h0XG4gICAgLy8gaWUgc3RhbmRhcmQgbW9kZSA6IGRvY3VtZW50RWxlbWVudC5zY3JvbGxIZWlnaHQ+IGJvZHkuc2Nyb2xsSGVpZ2h0XG4gICAgZC5kb2N1bWVudEVsZW1lbnRbJ3Njcm9sbCcgKyBuYW1lXSxcbiAgICAvLyBxdWlya3MgOiBkb2N1bWVudEVsZW1lbnQuc2Nyb2xsSGVpZ2h0IOacgOWkp+etieS6juWPr+inhueql+WPo+WkmuS4gOeCue+8n1xuICAgIGQuYm9keVsnc2Nyb2xsJyArIG5hbWVdLCBkb21VdGlsc1sndmlld3BvcnQnICsgbmFtZV0oZCkpO1xuICB9O1xuXG4gIGRvbVV0aWxzWyd2aWV3cG9ydCcgKyBuYW1lXSA9IGZ1bmN0aW9uICh3aW4pIHtcbiAgICAvLyBwYyBicm93c2VyIGluY2x1ZGVzIHNjcm9sbGJhciBpbiB3aW5kb3cuaW5uZXJXaWR0aFxuICAgIHZhciBwcm9wID0gJ2NsaWVudCcgKyBuYW1lO1xuICAgIHZhciBkb2MgPSB3aW4uZG9jdW1lbnQ7XG4gICAgdmFyIGJvZHkgPSBkb2MuYm9keTtcbiAgICB2YXIgZG9jdW1lbnRFbGVtZW50ID0gZG9jLmRvY3VtZW50RWxlbWVudDtcbiAgICB2YXIgZG9jdW1lbnRFbGVtZW50UHJvcCA9IGRvY3VtZW50RWxlbWVudFtwcm9wXTtcbiAgICAvLyDmoIflh4bmqKHlvI/lj5YgZG9jdW1lbnRFbGVtZW50XG4gICAgLy8gYmFja2NvbXBhdCDlj5YgYm9keVxuICAgIHJldHVybiBkb2MuY29tcGF0TW9kZSA9PT0gJ0NTUzFDb21wYXQnICYmIGRvY3VtZW50RWxlbWVudFByb3AgfHwgYm9keSAmJiBib2R5W3Byb3BdIHx8IGRvY3VtZW50RWxlbWVudFByb3A7XG4gIH07XG59KTtcblxuLypcbiDlvpfliLDlhYPntKDnmoTlpKflsI/kv6Hmga9cbiBAcGFyYW0gZWxlbVxuIEBwYXJhbSBuYW1lXG4gQHBhcmFtIHtTdHJpbmd9IFtleHRyYV0gICdwYWRkaW5nJyA6IChjc3Mgd2lkdGgpICsgcGFkZGluZ1xuICdib3JkZXInIDogKGNzcyB3aWR0aCkgKyBwYWRkaW5nICsgYm9yZGVyXG4gJ21hcmdpbicgOiAoY3NzIHdpZHRoKSArIHBhZGRpbmcgKyBib3JkZXIgKyBtYXJnaW5cbiAqL1xuZnVuY3Rpb24gZ2V0V0goZWxlbSwgbmFtZSwgZXgpIHtcbiAgdmFyIGV4dHJhID0gZXg7XG4gIGlmIChpc1dpbmRvdyhlbGVtKSkge1xuICAgIHJldHVybiBuYW1lID09PSAnd2lkdGgnID8gZG9tVXRpbHMudmlld3BvcnRXaWR0aChlbGVtKSA6IGRvbVV0aWxzLnZpZXdwb3J0SGVpZ2h0KGVsZW0pO1xuICB9IGVsc2UgaWYgKGVsZW0ubm9kZVR5cGUgPT09IDkpIHtcbiAgICByZXR1cm4gbmFtZSA9PT0gJ3dpZHRoJyA/IGRvbVV0aWxzLmRvY1dpZHRoKGVsZW0pIDogZG9tVXRpbHMuZG9jSGVpZ2h0KGVsZW0pO1xuICB9XG4gIHZhciB3aGljaCA9IG5hbWUgPT09ICd3aWR0aCcgPyBbJ0xlZnQnLCAnUmlnaHQnXSA6IFsnVG9wJywgJ0JvdHRvbSddO1xuICB2YXIgYm9yZGVyQm94VmFsdWUgPSBuYW1lID09PSAnd2lkdGgnID8gZWxlbS5vZmZzZXRXaWR0aCA6IGVsZW0ub2Zmc2V0SGVpZ2h0O1xuICB2YXIgY29tcHV0ZWRTdHlsZSA9IGdldENvbXB1dGVkU3R5bGVYKGVsZW0pO1xuICB2YXIgaXNCb3JkZXJCb3ggPSBpc0JvcmRlckJveEZuKGVsZW0sIGNvbXB1dGVkU3R5bGUpO1xuICB2YXIgY3NzQm94VmFsdWUgPSAwO1xuICBpZiAoYm9yZGVyQm94VmFsdWUgPT09IG51bGwgfHwgYm9yZGVyQm94VmFsdWUgPT09IHVuZGVmaW5lZCB8fCBib3JkZXJCb3hWYWx1ZSA8PSAwKSB7XG4gICAgYm9yZGVyQm94VmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgLy8gRmFsbCBiYWNrIHRvIGNvbXB1dGVkIHRoZW4gdW4gY29tcHV0ZWQgY3NzIGlmIG5lY2Vzc2FyeVxuICAgIGNzc0JveFZhbHVlID0gZ2V0Q29tcHV0ZWRTdHlsZVgoZWxlbSwgbmFtZSk7XG4gICAgaWYgKGNzc0JveFZhbHVlID09PSBudWxsIHx8IGNzc0JveFZhbHVlID09PSB1bmRlZmluZWQgfHwgTnVtYmVyKGNzc0JveFZhbHVlKSA8IDApIHtcbiAgICAgIGNzc0JveFZhbHVlID0gZWxlbS5zdHlsZVtuYW1lXSB8fCAwO1xuICAgIH1cbiAgICAvLyBOb3JtYWxpemUgJycsIGF1dG8sIGFuZCBwcmVwYXJlIGZvciBleHRyYVxuICAgIGNzc0JveFZhbHVlID0gcGFyc2VGbG9hdChjc3NCb3hWYWx1ZSkgfHwgMDtcbiAgfVxuICBpZiAoZXh0cmEgPT09IHVuZGVmaW5lZCkge1xuICAgIGV4dHJhID0gaXNCb3JkZXJCb3ggPyBCT1JERVJfSU5ERVggOiBDT05URU5UX0lOREVYO1xuICB9XG4gIHZhciBib3JkZXJCb3hWYWx1ZU9ySXNCb3JkZXJCb3ggPSBib3JkZXJCb3hWYWx1ZSAhPT0gdW5kZWZpbmVkIHx8IGlzQm9yZGVyQm94O1xuICB2YXIgdmFsID0gYm9yZGVyQm94VmFsdWUgfHwgY3NzQm94VmFsdWU7XG4gIGlmIChleHRyYSA9PT0gQ09OVEVOVF9JTkRFWCkge1xuICAgIGlmIChib3JkZXJCb3hWYWx1ZU9ySXNCb3JkZXJCb3gpIHtcbiAgICAgIHJldHVybiB2YWwgLSBnZXRQQk1XaWR0aChlbGVtLCBbJ2JvcmRlcicsICdwYWRkaW5nJ10sIHdoaWNoLCBjb21wdXRlZFN0eWxlKTtcbiAgICB9XG4gICAgcmV0dXJuIGNzc0JveFZhbHVlO1xuICB9IGVsc2UgaWYgKGJvcmRlckJveFZhbHVlT3JJc0JvcmRlckJveCkge1xuICAgIGlmIChleHRyYSA9PT0gQk9SREVSX0lOREVYKSB7XG4gICAgICByZXR1cm4gdmFsO1xuICAgIH1cbiAgICByZXR1cm4gdmFsICsgKGV4dHJhID09PSBQQURESU5HX0lOREVYID8gLWdldFBCTVdpZHRoKGVsZW0sIFsnYm9yZGVyJ10sIHdoaWNoLCBjb21wdXRlZFN0eWxlKSA6IGdldFBCTVdpZHRoKGVsZW0sIFsnbWFyZ2luJ10sIHdoaWNoLCBjb21wdXRlZFN0eWxlKSk7XG4gIH1cbiAgcmV0dXJuIGNzc0JveFZhbHVlICsgZ2V0UEJNV2lkdGgoZWxlbSwgQk9YX01PREVMUy5zbGljZShleHRyYSksIHdoaWNoLCBjb21wdXRlZFN0eWxlKTtcbn1cblxudmFyIGNzc1Nob3cgPSB7IHBvc2l0aW9uOiAnYWJzb2x1dGUnLCB2aXNpYmlsaXR5OiAnaGlkZGVuJywgZGlzcGxheTogJ2Jsb2NrJyB9O1xuXG4vLyBmaXggIzExOSA6IGh0dHBzOi8vZ2l0aHViLmNvbS9raXNzeXRlYW0va2lzc3kvaXNzdWVzLzExOVxuZnVuY3Rpb24gZ2V0V0hJZ25vcmVEaXNwbGF5KCkge1xuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cblxuICB2YXIgdmFsID0gdW5kZWZpbmVkO1xuICB2YXIgZWxlbSA9IGFyZ3NbMF07XG4gIC8vIGluIGNhc2UgZWxlbSBpcyB3aW5kb3dcbiAgLy8gZWxlbS5vZmZzZXRXaWR0aCA9PT0gdW5kZWZpbmVkXG4gIGlmIChlbGVtLm9mZnNldFdpZHRoICE9PSAwKSB7XG4gICAgdmFsID0gZ2V0V0guYXBwbHkodW5kZWZpbmVkLCBhcmdzKTtcbiAgfSBlbHNlIHtcbiAgICBzd2FwKGVsZW0sIGNzc1Nob3csIGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhbCA9IGdldFdILmFwcGx5KHVuZGVmaW5lZCwgYXJncyk7XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHZhbDtcbn1cblxuZWFjaChbJ3dpZHRoJywgJ2hlaWdodCddLCBmdW5jdGlvbiAobmFtZSkge1xuICB2YXIgZmlyc3QgPSBuYW1lLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgbmFtZS5zbGljZSgxKTtcbiAgZG9tVXRpbHNbJ291dGVyJyArIGZpcnN0XSA9IGZ1bmN0aW9uIChlbCwgaW5jbHVkZU1hcmdpbikge1xuICAgIHJldHVybiBlbCAmJiBnZXRXSElnbm9yZURpc3BsYXkoZWwsIG5hbWUsIGluY2x1ZGVNYXJnaW4gPyBNQVJHSU5fSU5ERVggOiBCT1JERVJfSU5ERVgpO1xuICB9O1xuICB2YXIgd2hpY2ggPSBuYW1lID09PSAnd2lkdGgnID8gWydMZWZ0JywgJ1JpZ2h0J10gOiBbJ1RvcCcsICdCb3R0b20nXTtcblxuICBkb21VdGlsc1tuYW1lXSA9IGZ1bmN0aW9uIChlbGVtLCB2KSB7XG4gICAgdmFyIHZhbCA9IHY7XG4gICAgaWYgKHZhbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAoZWxlbSkge1xuICAgICAgICB2YXIgY29tcHV0ZWRTdHlsZSA9IGdldENvbXB1dGVkU3R5bGVYKGVsZW0pO1xuICAgICAgICB2YXIgaXNCb3JkZXJCb3ggPSBpc0JvcmRlckJveEZuKGVsZW0pO1xuICAgICAgICBpZiAoaXNCb3JkZXJCb3gpIHtcbiAgICAgICAgICB2YWwgKz0gZ2V0UEJNV2lkdGgoZWxlbSwgWydwYWRkaW5nJywgJ2JvcmRlciddLCB3aGljaCwgY29tcHV0ZWRTdHlsZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNzcyhlbGVtLCBuYW1lLCB2YWwpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgcmV0dXJuIGVsZW0gJiYgZ2V0V0hJZ25vcmVEaXNwbGF5KGVsZW0sIG5hbWUsIENPTlRFTlRfSU5ERVgpO1xuICB9O1xufSk7XG5cbmZ1bmN0aW9uIG1peCh0bywgZnJvbSkge1xuICBmb3IgKHZhciBpIGluIGZyb20pIHtcbiAgICBpZiAoZnJvbS5oYXNPd25Qcm9wZXJ0eShpKSkge1xuICAgICAgdG9baV0gPSBmcm9tW2ldO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdG87XG59XG5cbnZhciB1dGlscyA9IHtcbiAgZ2V0V2luZG93OiBmdW5jdGlvbiBnZXRXaW5kb3cobm9kZSkge1xuICAgIGlmIChub2RlICYmIG5vZGUuZG9jdW1lbnQgJiYgbm9kZS5zZXRUaW1lb3V0KSB7XG4gICAgICByZXR1cm4gbm9kZTtcbiAgICB9XG4gICAgdmFyIGRvYyA9IG5vZGUub3duZXJEb2N1bWVudCB8fCBub2RlO1xuICAgIHJldHVybiBkb2MuZGVmYXVsdFZpZXcgfHwgZG9jLnBhcmVudFdpbmRvdztcbiAgfSxcbiAgb2Zmc2V0OiBmdW5jdGlvbiBvZmZzZXQoZWwsIHZhbHVlLCBvcHRpb24pIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgc2V0T2Zmc2V0KGVsLCB2YWx1ZSwgb3B0aW9uIHx8IHt9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGdldE9mZnNldChlbCk7XG4gICAgfVxuICB9LFxuICBpc1dpbmRvdzogaXNXaW5kb3csXG4gIGVhY2g6IGVhY2gsXG4gIGNzczogY3NzLFxuICBjbG9uZTogZnVuY3Rpb24gY2xvbmUob2JqKSB7XG4gICAgdmFyIGkgPSB1bmRlZmluZWQ7XG4gICAgdmFyIHJldCA9IHt9O1xuICAgIGZvciAoaSBpbiBvYmopIHtcbiAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkoaSkpIHtcbiAgICAgICAgcmV0W2ldID0gb2JqW2ldO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgb3ZlcmZsb3cgPSBvYmoub3ZlcmZsb3c7XG4gICAgaWYgKG92ZXJmbG93KSB7XG4gICAgICBmb3IgKGkgaW4gb2JqKSB7XG4gICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkoaSkpIHtcbiAgICAgICAgICByZXQub3ZlcmZsb3dbaV0gPSBvYmoub3ZlcmZsb3dbaV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfSxcbiAgbWl4OiBtaXgsXG4gIGdldFdpbmRvd1Njcm9sbExlZnQ6IGZ1bmN0aW9uIGdldFdpbmRvd1Njcm9sbExlZnQodykge1xuICAgIHJldHVybiBnZXRTY3JvbGxMZWZ0KHcpO1xuICB9LFxuICBnZXRXaW5kb3dTY3JvbGxUb3A6IGZ1bmN0aW9uIGdldFdpbmRvd1Njcm9sbFRvcCh3KSB7XG4gICAgcmV0dXJuIGdldFNjcm9sbFRvcCh3KTtcbiAgfSxcbiAgbWVyZ2U6IGZ1bmN0aW9uIG1lcmdlKCkge1xuICAgIHZhciByZXQgPSB7fTtcblxuICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4yKSwgX2tleTIgPSAwOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICBhcmdzW19rZXkyXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB1dGlscy5taXgocmV0LCBhcmdzW2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfSxcbiAgdmlld3BvcnRXaWR0aDogMCxcbiAgdmlld3BvcnRIZWlnaHQ6IDBcbn07XG5cbm1peCh1dGlscywgZG9tVXRpbHMpO1xuXG5leHBvcnRzWydkZWZhdWx0J10gPSB1dGlscztcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3V4Y29yZS10YWJsZS9+L3V4Y29yZS1kcm9wZG93bi9+L3JjLWRyb3Bkb3duL34vcmMtdHJpZ2dlci9+L3JjLWFsaWduL34vZG9tLWFsaWduL2xpYi91dGlscy5qc1xuICoqIG1vZHVsZSBpZCA9IDg2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIOiOt+WPliBub2RlIOS4iueahCBhbGlnbiDlr7npvZDngrkg55u45a+55LqO6aG16Z2i55qE5Z2Q5qCHXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmZ1bmN0aW9uIGdldEFsaWduT2Zmc2V0KHJlZ2lvbiwgYWxpZ24pIHtcbiAgdmFyIFYgPSBhbGlnbi5jaGFyQXQoMCk7XG4gIHZhciBIID0gYWxpZ24uY2hhckF0KDEpO1xuICB2YXIgdyA9IHJlZ2lvbi53aWR0aDtcbiAgdmFyIGggPSByZWdpb24uaGVpZ2h0O1xuICB2YXIgeCA9IHVuZGVmaW5lZDtcbiAgdmFyIHkgPSB1bmRlZmluZWQ7XG5cbiAgeCA9IHJlZ2lvbi5sZWZ0O1xuICB5ID0gcmVnaW9uLnRvcDtcblxuICBpZiAoViA9PT0gJ2MnKSB7XG4gICAgeSArPSBoIC8gMjtcbiAgfSBlbHNlIGlmIChWID09PSAnYicpIHtcbiAgICB5ICs9IGg7XG4gIH1cblxuICBpZiAoSCA9PT0gJ2MnKSB7XG4gICAgeCArPSB3IC8gMjtcbiAgfSBlbHNlIGlmIChIID09PSAncicpIHtcbiAgICB4ICs9IHc7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGxlZnQ6IHgsXG4gICAgdG9wOiB5XG4gIH07XG59XG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IGdldEFsaWduT2Zmc2V0O1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vdXhjb3JlLXRhYmxlL34vdXhjb3JlLWRyb3Bkb3duL34vcmMtZHJvcGRvd24vfi9yYy10cmlnZ2VyL34vcmMtYWxpZ24vfi9kb20tYWxpZ24vbGliL2dldEFsaWduT2Zmc2V0LmpzXG4gKiogbW9kdWxlIGlkID0gOTJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBpc1dpbmRvdztcbmZ1bmN0aW9uIGlzV2luZG93KG9iaikge1xuICAvKiBlc2xpbnQgbm8tZXEtbnVsbDogMCAqL1xuICAvKiBlc2xpbnQgZXFlcWVxOiAwICovXG4gIHJldHVybiBvYmogIT0gbnVsbCAmJiBvYmogPT0gb2JqLndpbmRvdztcbn1cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3V4Y29yZS10YWJsZS9+L3V4Y29yZS1kcm9wZG93bi9+L3JjLWRyb3Bkb3duL34vcmMtdHJpZ2dlci9+L3JjLWFsaWduL2xpYi9pc1dpbmRvdy5qc1xuICoqIG1vZHVsZSBpZCA9IDkzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbnZhciBfcmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xuXG52YXIgX3JlYWN0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JlYWN0KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgXCJkZWZhdWx0XCI6IG9iaiB9OyB9XG5cbnZhciBMYXp5UmVuZGVyQm94ID0gX3JlYWN0MltcImRlZmF1bHRcIl0uY3JlYXRlQ2xhc3Moe1xuICBkaXNwbGF5TmFtZTogJ0xhenlSZW5kZXJCb3gnLFxuXG4gIHByb3BUeXBlczoge1xuICAgIGNoaWxkcmVuOiBfcmVhY3QuUHJvcFR5cGVzLmFueSxcbiAgICBjbGFzc05hbWU6IF9yZWFjdC5Qcm9wVHlwZXMuc3RyaW5nLFxuICAgIHZpc2libGU6IF9yZWFjdC5Qcm9wVHlwZXMuYm9vbCxcbiAgICBoaWRkZW5DbGFzc05hbWU6IF9yZWFjdC5Qcm9wVHlwZXMuc3RyaW5nXG4gIH0sXG4gIHNob3VsZENvbXBvbmVudFVwZGF0ZTogZnVuY3Rpb24gc2hvdWxkQ29tcG9uZW50VXBkYXRlKG5leHRQcm9wcykge1xuICAgIHJldHVybiBuZXh0UHJvcHMuaGlkZGVuQ2xhc3NOYW1lIHx8IG5leHRQcm9wcy52aXNpYmxlO1xuICB9LFxuICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICBpZiAodGhpcy5wcm9wcy5oaWRkZW5DbGFzc05hbWUpIHtcbiAgICAgIHZhciBjbGFzc05hbWUgPSB0aGlzLnByb3BzLmNsYXNzTmFtZTtcbiAgICAgIGlmICghdGhpcy5wcm9wcy52aXNpYmxlKSB7XG4gICAgICAgIGNsYXNzTmFtZSArPSAnICcgKyB0aGlzLnByb3BzLmhpZGRlbkNsYXNzTmFtZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBfcmVhY3QyW1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KCdkaXYnLCBfZXh0ZW5kcyh7fSwgdGhpcy5wcm9wcywgeyBjbGFzc05hbWU6IGNsYXNzTmFtZSB9KSk7XG4gICAgfVxuICAgIGlmIChfcmVhY3QyW1wiZGVmYXVsdFwiXS5DaGlsZHJlbi5jb3VudCh0aGlzLnByb3BzLmNoaWxkcmVuKSA+IDEpIHtcbiAgICAgIHJldHVybiBfcmVhY3QyW1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KCdkaXYnLCB0aGlzLnByb3BzKTtcbiAgICB9XG4gICAgcmV0dXJuIF9yZWFjdDJbXCJkZWZhdWx0XCJdLkNoaWxkcmVuLm9ubHkodGhpcy5wcm9wcy5jaGlsZHJlbik7XG4gIH1cbn0pO1xuXG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IExhenlSZW5kZXJCb3g7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi91eGNvcmUtdGFibGUvfi91eGNvcmUtZHJvcGRvd24vfi9yYy1kcm9wZG93bi9+L3JjLXRyaWdnZXIvbGliL0xhenlSZW5kZXJCb3guanNcbiAqKiBtb2R1bGUgaWQgPSAxMDRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcblxuZXhwb3J0cy5nZXRBbGlnbkZyb21QbGFjZW1lbnQgPSBnZXRBbGlnbkZyb21QbGFjZW1lbnQ7XG5leHBvcnRzLmdldFBvcHVwQ2xhc3NOYW1lRnJvbUFsaWduID0gZ2V0UG9wdXBDbGFzc05hbWVGcm9tQWxpZ247XG5mdW5jdGlvbiBpc1BvaW50c0VxKGExLCBhMikge1xuICByZXR1cm4gYTFbMF0gPT09IGEyWzBdICYmIGExWzFdID09PSBhMlsxXTtcbn1cblxuZnVuY3Rpb24gZ2V0QWxpZ25Gcm9tUGxhY2VtZW50KGJ1aWx0aW5QbGFjZW1lbnRzLCBwbGFjZW1lbnRTdHIsIGFsaWduKSB7XG4gIHZhciBiYXNlQWxpZ24gPSBidWlsdGluUGxhY2VtZW50c1twbGFjZW1lbnRTdHJdIHx8IHt9O1xuICByZXR1cm4gX2V4dGVuZHMoe30sIGJhc2VBbGlnbiwgYWxpZ24pO1xufVxuXG5mdW5jdGlvbiBnZXRQb3B1cENsYXNzTmFtZUZyb21BbGlnbihidWlsdGluUGxhY2VtZW50cywgcHJlZml4Q2xzLCBhbGlnbikge1xuICB2YXIgcG9pbnRzID0gYWxpZ24ucG9pbnRzO1xuICBmb3IgKHZhciBwbGFjZW1lbnQgaW4gYnVpbHRpblBsYWNlbWVudHMpIHtcbiAgICBpZiAoYnVpbHRpblBsYWNlbWVudHMuaGFzT3duUHJvcGVydHkocGxhY2VtZW50KSkge1xuICAgICAgaWYgKGlzUG9pbnRzRXEoYnVpbHRpblBsYWNlbWVudHNbcGxhY2VtZW50XS5wb2ludHMsIHBvaW50cykpIHtcbiAgICAgICAgcmV0dXJuIHByZWZpeENscyArICctcGxhY2VtZW50LScgKyBwbGFjZW1lbnQ7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiAnJztcbn1cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi91eGNvcmUtdGFibGUvfi91eGNvcmUtZHJvcGRvd24vfi9yYy1kcm9wZG93bi9+L3JjLXRyaWdnZXIvbGliL3V0aWxzLmpzXG4gKiogbW9kdWxlIGlkID0gMTA1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG52YXIgYXV0b0FkanVzdE92ZXJmbG93ID0ge1xuICBhZGp1c3RYOiAxLFxuICBhZGp1c3RZOiAxXG59O1xuXG52YXIgdGFyZ2V0T2Zmc2V0ID0gWzAsIDBdO1xuXG52YXIgcGxhY2VtZW50cyA9IGV4cG9ydHMucGxhY2VtZW50cyA9IHtcbiAgdG9wTGVmdDoge1xuICAgIHBvaW50czogWydibCcsICd0bCddLFxuICAgIG92ZXJmbG93OiBhdXRvQWRqdXN0T3ZlcmZsb3csXG4gICAgb2Zmc2V0OiBbMCwgLTRdLFxuICAgIHRhcmdldE9mZnNldDogdGFyZ2V0T2Zmc2V0XG4gIH0sXG4gIGJvdHRvbUxlZnQ6IHtcbiAgICBwb2ludHM6IFsndGwnLCAnYmwnXSxcbiAgICBvdmVyZmxvdzogYXV0b0FkanVzdE92ZXJmbG93LFxuICAgIG9mZnNldDogWzAsIDRdLFxuICAgIHRhcmdldE9mZnNldDogdGFyZ2V0T2Zmc2V0XG4gIH1cbn07XG5cbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gcGxhY2VtZW50cztcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi91eGNvcmUtdGFibGUvfi91eGNvcmUtZHJvcGRvd24vfi9yYy1kcm9wZG93bi9saWIvcGxhY2VtZW50cy5qc1xuICoqIG1vZHVsZSBpZCA9IDEwNlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xudmFyIGF1dG9BZGp1c3RPdmVyZmxvdyA9IHtcbiAgYWRqdXN0WDogMSxcbiAgYWRqdXN0WTogMVxufTtcblxudmFyIHRhcmdldE9mZnNldCA9IFswLCAwXTtcblxudmFyIHBsYWNlbWVudHMgPSBleHBvcnRzLnBsYWNlbWVudHMgPSB7XG4gIGxlZnQ6IHtcbiAgICBwb2ludHM6IFsnY3InLCAnY2wnXSxcbiAgICBvdmVyZmxvdzogYXV0b0FkanVzdE92ZXJmbG93LFxuICAgIG9mZnNldDogWy00LCAwXSxcbiAgICB0YXJnZXRPZmZzZXQ6IHRhcmdldE9mZnNldFxuICB9LFxuICByaWdodDoge1xuICAgIHBvaW50czogWydjbCcsICdjciddLFxuICAgIG92ZXJmbG93OiBhdXRvQWRqdXN0T3ZlcmZsb3csXG4gICAgb2Zmc2V0OiBbNCwgMF0sXG4gICAgdGFyZ2V0T2Zmc2V0OiB0YXJnZXRPZmZzZXRcbiAgfSxcbiAgdG9wOiB7XG4gICAgcG9pbnRzOiBbJ2JjJywgJ3RjJ10sXG4gICAgb3ZlcmZsb3c6IGF1dG9BZGp1c3RPdmVyZmxvdyxcbiAgICBvZmZzZXQ6IFswLCAtNF0sXG4gICAgdGFyZ2V0T2Zmc2V0OiB0YXJnZXRPZmZzZXRcbiAgfSxcbiAgYm90dG9tOiB7XG4gICAgcG9pbnRzOiBbJ3RjJywgJ2JjJ10sXG4gICAgb3ZlcmZsb3c6IGF1dG9BZGp1c3RPdmVyZmxvdyxcbiAgICBvZmZzZXQ6IFswLCA0XSxcbiAgICB0YXJnZXRPZmZzZXQ6IHRhcmdldE9mZnNldFxuICB9LFxuICB0b3BMZWZ0OiB7XG4gICAgcG9pbnRzOiBbJ2JsJywgJ3RsJ10sXG4gICAgb3ZlcmZsb3c6IGF1dG9BZGp1c3RPdmVyZmxvdyxcbiAgICBvZmZzZXQ6IFswLCAtNF0sXG4gICAgdGFyZ2V0T2Zmc2V0OiB0YXJnZXRPZmZzZXRcbiAgfSxcbiAgbGVmdFRvcDoge1xuICAgIHBvaW50czogWyd0cicsICd0bCddLFxuICAgIG92ZXJmbG93OiBhdXRvQWRqdXN0T3ZlcmZsb3csXG4gICAgb2Zmc2V0OiBbLTQsIDBdLFxuICAgIHRhcmdldE9mZnNldDogdGFyZ2V0T2Zmc2V0XG4gIH0sXG4gIHRvcFJpZ2h0OiB7XG4gICAgcG9pbnRzOiBbJ2JyJywgJ3RyJ10sXG4gICAgb3ZlcmZsb3c6IGF1dG9BZGp1c3RPdmVyZmxvdyxcbiAgICBvZmZzZXQ6IFswLCAtNF0sXG4gICAgdGFyZ2V0T2Zmc2V0OiB0YXJnZXRPZmZzZXRcbiAgfSxcbiAgcmlnaHRUb3A6IHtcbiAgICBwb2ludHM6IFsndGwnLCAndHInXSxcbiAgICBvdmVyZmxvdzogYXV0b0FkanVzdE92ZXJmbG93LFxuICAgIG9mZnNldDogWzQsIDBdLFxuICAgIHRhcmdldE9mZnNldDogdGFyZ2V0T2Zmc2V0XG4gIH0sXG4gIGJvdHRvbVJpZ2h0OiB7XG4gICAgcG9pbnRzOiBbJ3RyJywgJ2JyJ10sXG4gICAgb3ZlcmZsb3c6IGF1dG9BZGp1c3RPdmVyZmxvdyxcbiAgICBvZmZzZXQ6IFswLCA0XSxcbiAgICB0YXJnZXRPZmZzZXQ6IHRhcmdldE9mZnNldFxuICB9LFxuICByaWdodEJvdHRvbToge1xuICAgIHBvaW50czogWydibCcsICdiciddLFxuICAgIG92ZXJmbG93OiBhdXRvQWRqdXN0T3ZlcmZsb3csXG4gICAgb2Zmc2V0OiBbNCwgMF0sXG4gICAgdGFyZ2V0T2Zmc2V0OiB0YXJnZXRPZmZzZXRcbiAgfSxcbiAgYm90dG9tTGVmdDoge1xuICAgIHBvaW50czogWyd0bCcsICdibCddLFxuICAgIG92ZXJmbG93OiBhdXRvQWRqdXN0T3ZlcmZsb3csXG4gICAgb2Zmc2V0OiBbMCwgNF0sXG4gICAgdGFyZ2V0T2Zmc2V0OiB0YXJnZXRPZmZzZXRcbiAgfSxcbiAgbGVmdEJvdHRvbToge1xuICAgIHBvaW50czogWydicicsICdibCddLFxuICAgIG92ZXJmbG93OiBhdXRvQWRqdXN0T3ZlcmZsb3csXG4gICAgb2Zmc2V0OiBbLTQsIDBdLFxuICAgIHRhcmdldE9mZnNldDogdGFyZ2V0T2Zmc2V0XG4gIH1cbn07XG5cbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gcGxhY2VtZW50cztcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi91eGNvcmUtdGFibGUvfi91eGNvcmUtdG9vbHRpcC9+L3JjLXRvb2x0aXAvbGliL3BsYWNlbWVudHMuanNcbiAqKiBtb2R1bGUgaWQgPSAxMTFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbi8qKlxuICogQ3JlYXRlZCBieSB4eSBvbiAxNS80LzEzLlxuICovXG5cbnZhciBSb3cgPSByZXF1aXJlKFwiLi9Sb3dcIik7XG52YXIgTWFzayA9IHJlcXVpcmUoXCIuL01hc2tcIik7XG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuL3V0aWxcIik7XG52YXIgZGVlcGNvcHkgPSByZXF1aXJlKCdkZWVwY29weScpO1xuXG52YXIgUmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xudmFyIFJlYWN0RE9NID0gcmVxdWlyZSgncmVhY3QtZG9tJyk7XG5cbnZhciBUYm9keSA9IGZ1bmN0aW9uIChfUmVhY3QkQ29tcG9uZW50KSB7XG4gICAgX2luaGVyaXRzKFRib2R5LCBfUmVhY3QkQ29tcG9uZW50KTtcblxuICAgIGZ1bmN0aW9uIFRib2R5KHByb3BzKSB7XG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBUYm9keSk7XG5cbiAgICAgICAgdmFyIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX1JlYWN0JENvbXBvbmVudC5jYWxsKHRoaXMsIHByb3BzKSk7XG5cbiAgICAgICAgX3RoaXMuc3RhdGUgPSB7fTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cblxuICAgIFRib2R5LnByb3RvdHlwZS5jb21wb25lbnREaWRNb3VudCA9IGZ1bmN0aW9uIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgICAgICB2YXIgbWUgPSB0aGlzO1xuICAgICAgICBtZS5yb290RWwgPSBSZWFjdERPTS5maW5kRE9NTm9kZShtZS5yZWZzLnJvb3QpO1xuICAgICAgICBtZS5zY3JvbGxIYW5kbGVyID0gbWUub25TY3JvbGwuYmluZChtZSk7XG4gICAgICAgICQobWUucm9vdEVsKS5vbihcInNjcm9sbFwiLCBtZS5zY3JvbGxIYW5kbGVyKTtcbiAgICB9O1xuXG4gICAgVGJvZHkucHJvdG90eXBlLmNvbXBvbmVudFdpbGxVbm1vdW50ID0gZnVuY3Rpb24gY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgICAgIHZhciBtZSA9IHRoaXM7XG4gICAgICAgIG1lLnJlc2l6ZVRpbWVyID0gbnVsbDtcbiAgICAgICAgJChtZS5yb290RWwpLm9mZihcInNjcm9sbFwiLCBtZS5zY3JvbGxIYW5kbGVyKTtcbiAgICB9O1xuXG4gICAgVGJvZHkucHJvdG90eXBlLnJlbmRlckVtcHR5RGF0YSA9IGZ1bmN0aW9uIHJlbmRlckVtcHR5RGF0YSgpIHtcblxuICAgICAgICBpZiAodGhpcy5wcm9wcy5kYXRhLmxlbmd0aCA9PSAwICYmICF0aGlzLnByb3BzLm1hc2spIHtcbiAgICAgICAgICAgIHZhciBfc3R5bGUgPSB7XG4gICAgICAgICAgICAgICAgbGluZUhlaWdodDogdGhpcy5wcm9wcy5oZWlnaHQgLSAxMCArIFwicHhcIlxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICAgICAgIFwiZGl2XCIsXG4gICAgICAgICAgICAgICAgeyBjbGFzc05hbWU6IFwia3VtYS11eHRhYmxlLWJvZHktZW1wdHl3b3JkXCIsIHN0eWxlOiBfc3R5bGUgfSxcbiAgICAgICAgICAgICAgICB0aGlzLnByb3BzLnJvb3QucHJvcHMuZW1wdHlUZXh0XG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIFRib2R5LnByb3RvdHlwZS5vblNjcm9sbCA9IGZ1bmN0aW9uIG9uU2Nyb2xsKGUpIHtcbiAgICAgICAgLy8gVE9ETzogcmVtb3ZlIGpxdWVyeSBhbmltYXRpb25cbiAgICAgICAgLy8gICAgICAgbWVyZ2UgY2xhc3NuYW1lIHNjcm9sbC9uby9maXhlZFxuXG4gICAgICAgIHRoaXMuZWwgPSBSZWFjdERPTS5maW5kRE9NTm9kZSh0aGlzKTtcbiAgICAgICAgdmFyICR0YWJsZUVsID0gJCh0aGlzLmVsKS5wYXJlbnRzKFwiLmt1bWEtdXh0YWJsZVwiKTtcbiAgICAgICAgaWYgKHRoaXMucHJvcHMuZml4ZWRDb2x1bW4gPT0gJ25vJykge1xuICAgICAgICAgICAgJHRhYmxlRWwuZmluZCgnLmt1bWEtdXh0YWJsZS1oZWFkZXItbm8nKS5hbmltYXRlKHtcbiAgICAgICAgICAgICAgICBzY3JvbGxMZWZ0OiAkdGFibGVFbC5maW5kKCcua3VtYS11eHRhYmxlLWJvZHktbm8nKS5zY3JvbGxMZWZ0KClcbiAgICAgICAgICAgIH0sIDApO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHRhcmdldCA9ICQoZS50YXJnZXQpO1xuICAgICAgICBpZiAodGFyZ2V0Lmhhc0NsYXNzKCdrdW1hLXV4dGFibGUtYm9keS1zY3JvbGwnKSkge1xuXG4gICAgICAgICAgICAkdGFibGVFbC5maW5kKCcua3VtYS11eHRhYmxlLWJvZHktZml4ZWQnKS5hbmltYXRlKHtcbiAgICAgICAgICAgICAgICBzY3JvbGxUb3A6ICR0YWJsZUVsLmZpbmQoJy5rdW1hLXV4dGFibGUtYm9keS1zY3JvbGwnKS5zY3JvbGxUb3AoKVxuICAgICAgICAgICAgfSwgMCk7XG4gICAgICAgICAgICAkdGFibGVFbC5maW5kKCcua3VtYS11eHRhYmxlLWhlYWRlci1zY3JvbGwnKS5hbmltYXRlKHtcbiAgICAgICAgICAgICAgICBzY3JvbGxMZWZ0OiAkdGFibGVFbC5maW5kKCcua3VtYS11eHRhYmxlLWJvZHktc2Nyb2xsJykuc2Nyb2xsTGVmdCgpXG4gICAgICAgICAgICB9LCAwKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICR0YWJsZUVsLmZpbmQoJy5rdW1hLXV4dGFibGUtYm9keS1zY3JvbGwnKS5hbmltYXRlKHtcbiAgICAgICAgICAgICAgICBzY3JvbGxUb3A6ICR0YWJsZUVsLmZpbmQoJy5rdW1hLXV4dGFibGUtYm9keS1maXhlZCcpLnNjcm9sbFRvcCgpXG4gICAgICAgICAgICB9LCAwKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBUYm9keS5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKCkge1xuXG4gICAgICAgIHZhciBtZSA9IHRoaXMsXG4gICAgICAgICAgICBfcHJvcHMgPSBtZS5wcm9wcyxcbiAgICAgICAgICAgIF9jb2x1bW5zID0gX3Byb3BzLmNvbHVtbnMsXG4gICAgICAgICAgICBfZGF0YSA9IF9wcm9wcy5kYXRhLmxlbmd0aCA+IDAgPyBfcHJvcHMuZGF0YSA6IFtdLFxuICAgICAgICAgICAgX3N0eWxlID0ge30sXG4gICAgICAgICAgICBfd2lkdGggPSAwLFxuICAgICAgICAgICAgYm9keVdyYXBDbGFzc05hbWUgPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgaWYgKF9wcm9wcy5maXhlZENvbHVtbiA9PSAnZml4ZWQnKSB7XG4gICAgICAgICAgICBfY29sdW1ucyA9IF9wcm9wcy5jb2x1bW5zLmZpbHRlcihmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgICAgICAgIGlmIChpdGVtLmZpeGVkICYmICFpdGVtLmhpZGRlbikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWl0ZW0ud2lkdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0ud2lkdGggPSAxMDA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgX3dpZHRoID0gaXRlbS53aWR0aCAqIDEgKyBfd2lkdGg7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgX3N0eWxlID0ge1xuICAgICAgICAgICAgICAgIHdpZHRoOiBfd2lkdGgsXG4gICAgICAgICAgICAgICAgbWluV2lkdGg6IF93aWR0aFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGJvZHlXcmFwQ2xhc3NOYW1lID0gXCJrdW1hLXV4dGFibGUtYm9keS1maXhlZFwiO1xuICAgICAgICB9IGVsc2UgaWYgKF9wcm9wcy5maXhlZENvbHVtbiA9PSAnc2Nyb2xsJykge1xuICAgICAgICAgICAgdmFyIGZpeGVkV2lkdGggPSAwO1xuICAgICAgICAgICAgX2NvbHVtbnMgPSBfcHJvcHMuY29sdW1ucy5maWx0ZXIoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICBpZiAoIWl0ZW0uZml4ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICghaXRlbS5oaWRkZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpdGVtLndpZHRoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtLndpZHRoID0gMTAwO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIF93aWR0aCA9IGl0ZW0ud2lkdGggKiAxICsgX3dpZHRoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyBjb250ZW50LWJveDogYm9yZGVyLWJveFxuICAgICAgICAgICAgdmFyIGRlbHRhID0gMjtcbiAgICAgICAgICAgIGlmICh1dGlsLmlzSUUoOCkpIHtcbiAgICAgICAgICAgICAgICBkZWx0YSA9IDM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfc3R5bGUgPSB7XG4gICAgICAgICAgICAgICAgd2lkdGg6IF9wcm9wcy53aWR0aCAtIF93aWR0aCAtIGRlbHRhLCAvL2NoYW5nZSAyIHRvIDMsIGZpeCBpZTggaXNzdWVcbiAgICAgICAgICAgICAgICBtaW5XaWR0aDogX3Byb3BzLndpZHRoIC0gX3dpZHRoIC0gZGVsdGFcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBib2R5V3JhcENsYXNzTmFtZSA9IFwia3VtYS11eHRhYmxlLWJvZHktc2Nyb2xsXCI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBib2R5V3JhcENsYXNzTmFtZSA9IFwia3VtYS11eHRhYmxlLWJvZHktbm9cIjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAgIFwiZGl2XCIsXG4gICAgICAgICAgICB7IGNsYXNzTmFtZTogYm9keVdyYXBDbGFzc05hbWUsIHJlZjogXCJyb290XCIsIHN0eWxlOiBfc3R5bGUgfSxcbiAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgICAgICAgXCJ1bFwiLFxuICAgICAgICAgICAgICAgIHsgY2xhc3NOYW1lOiB0aGlzLnByb3BzLmpzeHByZWZpeENscyB9LFxuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyRW1wdHlEYXRhKCksXG4gICAgICAgICAgICAgICAgX2RhdGEubWFwKGZ1bmN0aW9uIChpdGVtLCBpbmRleCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVuZGVyUHJvcHMgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2x1bW5zOiBfY29sdW1ucyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvd0luZGV4OiBpdGVtLmpzeGlkLCAvL3RyZWUgbW9kZSwgcm93SW5kZXggbmVlZCB0aGluayBtb3JlLCBzbyB1c2UganN4aWRcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvd0RhdGE6IGRlZXBjb3B5KF9kYXRhW2luZGV4XSksXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRleDogaW5kZXgsXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBfZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvb3Q6IF9wcm9wcy5yb290LFxuICAgICAgICAgICAgICAgICAgICAgICAgYWRkUm93Q2xhc3NOYW1lOiBfcHJvcHMuYWRkUm93Q2xhc3NOYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgcm93U2VsZWN0aW9uOiBfcHJvcHMucm93U2VsZWN0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgY2hhbmdlU2VsZWN0ZWQ6IG1lLnByb3BzLmNoYW5nZVNlbGVjdGVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3ViQ29tcDogX3Byb3BzLnN1YkNvbXAsXG4gICAgICAgICAgICAgICAgICAgICAgICByZW5kZXJTdWJDb21wOiBfcHJvcHMucmVuZGVyU3ViQ29tcCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbnM6IF9wcm9wcy5hY3Rpb25zLFxuICAgICAgICAgICAgICAgICAgICAgICAga2V5OiAncm93JyArIGluZGV4LFxuICAgICAgICAgICAgICAgICAgICAgICAgbW9kZTogX3Byb3BzLm1vZGUsXG4gICAgICAgICAgICAgICAgICAgICAgICByZW5kZXJNb2RlbDogX3Byb3BzLnJlbmRlck1vZGVsLFxuICAgICAgICAgICAgICAgICAgICAgICAgZml4ZWRDb2x1bW46IF9wcm9wcy5maXhlZENvbHVtbixcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldmVsOiAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgbGV2ZWxzOiBfcHJvcHMubGV2ZWxzLFxuICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlRGF0YUNoYW5nZTogX3Byb3BzLmhhbmRsZURhdGFDaGFuZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBhdHRhY2hDZWxsRmllbGQ6IF9wcm9wcy5hdHRhY2hDZWxsRmllbGQsXG4gICAgICAgICAgICAgICAgICAgICAgICBkZXRhY2hDZWxsRmllbGQ6IF9wcm9wcy5kZXRhY2hDZWxsRmllbGQsXG4gICAgICAgICAgICAgICAgICAgICAgICB2aXNpYmxlOiB0cnVlXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFJvdywgcmVuZGVyUHJvcHMpO1xuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoTWFzaywgeyB2aXNpYmxlOiBfcHJvcHMubWFzaywgdGV4dDogX3Byb3BzLmxvYWRpbmdUZXh0IH0pXG4gICAgICAgICAgICApXG4gICAgICAgICk7XG4gICAgfTtcblxuICAgIHJldHVybiBUYm9keTtcbn0oUmVhY3QuQ29tcG9uZW50KTtcblxuO1xuXG5UYm9keS5wcm9wVHlwZXMgPSB7fTtcblxuVGJvZHkuZGVmYXVsdFByb3BzID0ge1xuICAgIGpzeHByZWZpeENsczogXCJrdW1hLXV4dGFibGUtYm9keVwiXG59O1xuXG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IFRib2R5O1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vdXhjb3JlLXRhYmxlL2J1aWxkL1Rib2R5LmpzXG4gKiogbW9kdWxlIGlkID0gMTU4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxuLyoqXG4gKiBDcmVhdGVkIGJ5IHh5IG9uIDE1LzQvMTMuXG4gKi9cbnZhciBDZWxsID0gcmVxdWlyZSgnLi9DZWxsJyk7XG52YXIgY2xhc3NuYW1lcyA9IHJlcXVpcmUoJ2NsYXNzbmFtZXMnKTtcbnZhciBhc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG52YXIgQ29uc3QgPSByZXF1aXJlKCd1eGNvcmUtY29uc3QnKTtcbnZhciBkZWVwRXF1YWwgPSByZXF1aXJlKCdkZWVwLWVxdWFsJyk7XG52YXIgZGVlcGNvcHkgPSByZXF1aXJlKCdkZWVwY29weScpO1xuXG52YXIgUmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xudmFyIFJlYWN0RE9NID0gcmVxdWlyZSgncmVhY3QtZG9tJyk7XG5cbnZhciBSb3cgPSBmdW5jdGlvbiAoX1JlYWN0JENvbXBvbmVudCkge1xuICAgIF9pbmhlcml0cyhSb3csIF9SZWFjdCRDb21wb25lbnQpO1xuXG4gICAgZnVuY3Rpb24gUm93KHByb3BzKSB7XG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBSb3cpO1xuXG4gICAgICAgIHZhciBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9SZWFjdCRDb21wb25lbnQuY2FsbCh0aGlzLCBwcm9wcykpO1xuXG4gICAgICAgIF90aGlzLnN0YXRlID0ge1xuICAgICAgICAgICAgZXhwYW5kZWQ6IF90aGlzLnByb3BzLmxldmVsIDwgX3RoaXMucHJvcHMubGV2ZWxzID8gdHJ1ZSA6IGZhbHNlXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG5cbiAgICBSb3cucHJvdG90eXBlLnNob3VsZENvbXBvbmVudFVwZGF0ZSA9IGZ1bmN0aW9uIHNob3VsZENvbXBvbmVudFVwZGF0ZShuZXh0UHJvcHMsIG5leHRTdGF0ZSkge1xuICAgICAgICAvLyDpnIDopoHogIPomZHnmoQgcHJvcCDljIXmi6xcbiAgICAgICAgLy8gY29sdW1ucywgcm93SW5kZXgocyksIHJvd0RhdGEsIGluZGV4KHMpLCBhZGRSb3dDbGFzc05hbWUoZiksIHJvd1NlbGVjdGlvbiwgc3ViQ29tcChmKSwgYWN0aW9uc1xuICAgICAgICAvLyBtb2RlKHMpLCByZW5kZXJNb2RlbChzKSwgZml4ZWRDb2x1bW4ocyksIGxldmVscyhzKSwgdmlzaWJsZShzKVxuICAgICAgICB2YXIgbWUgPSB0aGlzO1xuICAgICAgICB2YXIgc2hvdWxkVXBkYXRlID0gZmFsc2U7XG4gICAgICAgIFsncm93SW5kZXgnLCAnaW5kZXgnLCAnbW9kZScsICdyZW5kZXJNb2RlbCcsICdmaXhlZENvbHVtbicsICdsZXZlbHMnLCAnYWRkUm93Q2xhc3NOYW1lJywgJ3N1YkNvbXAnLCAndmlzaWJsZSddLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICAgIGlmIChtZS5wcm9wc1tpdGVtXSAhPT0gbmV4dFByb3BzW2l0ZW1dKSB7XG4gICAgICAgICAgICAgICAgc2hvdWxkVXBkYXRlID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGlmICghc2hvdWxkVXBkYXRlKSB7XG4gICAgICAgICAgICBbJ2NvbHVtbnMnLCAncm93RGF0YScsICdyb3dTZWxlY3Rpb24nLCAnYWN0aW9ucyddLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0sIGluZGV4KSB7XG4gICAgICAgICAgICAgICAgaWYgKCFkZWVwRXF1YWwobWUucHJvcHNbaXRlbV0sIG5leHRQcm9wc1tpdGVtXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgc2hvdWxkVXBkYXRlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKCFzaG91bGRVcGRhdGUpIHtcbiAgICAgICAgICAgIHNob3VsZFVwZGF0ZSA9IG1lLnN0YXRlLmV4cGFuZGVkICE9PSBuZXh0U3RhdGUuZXhwYW5kZWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNob3VsZFVwZGF0ZTtcbiAgICB9O1xuXG4gICAgUm93LnByb3RvdHlwZS5oYW5kbGVDbGljayA9IGZ1bmN0aW9uIGhhbmRsZUNsaWNrKHJvd0RhdGEpIHtcbiAgICAgICAgdmFyIG1lID0gdGhpcztcbiAgICB9O1xuXG4gICAgUm93LnByb3RvdHlwZS5oYW5kbGVEb3VibGVDbGljayA9IGZ1bmN0aW9uIGhhbmRsZURvdWJsZUNsaWNrKHJvd0RhdGEpIHtcbiAgICAgICAgdmFyIHRhYmxlID0gdGhpcy5wcm9wcy5yb290O1xuICAgICAgICBpZiAodGFibGUucHJvcHMuZG91YmxlQ2xpY2tUb0VkaXQpIHtcbiAgICAgICAgICAgIHRhYmxlLmVkaXRSb3coZGVlcGNvcHkocm93RGF0YSkpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIFJvdy5wcm90b3R5cGUuc2hvd1N1YkNvbXBGdW5jID0gZnVuY3Rpb24gc2hvd1N1YkNvbXBGdW5jKCkge1xuICAgICAgICB2YXIgbWUgPSB0aGlzO1xuICAgICAgICBtZS5wcm9wcy5yb290LnRvZ2dsZVN1YkNvbXAobWUucHJvcHMucm93RGF0YSk7XG4gICAgfTtcblxuICAgIFJvdy5wcm90b3R5cGUucmVuZGVyU3ViQ29tcCA9IGZ1bmN0aW9uIHJlbmRlclN1YkNvbXAoKSB7XG4gICAgICAgIHZhciBwcm9wcyA9IHRoaXMucHJvcHM7XG5cbiAgICAgICAgaWYgKHByb3BzLnJlbmRlck1vZGVsID09ICd0cmVlJykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHByb3BzLnN1YkNvbXApIHtcbiAgICAgICAgICAgICAgICBpZiAocHJvcHMucm93RGF0YS5zaG93U3ViQ29tcCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc3ViQ29tcCA9IFJlYWN0LmNsb25lRWxlbWVudChwcm9wcy5zdWJDb21wLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXNzZWREYXRhOiB0aGlzLnByb3BzLnJvd0RhdGEsXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnRIYXNDaGVja2JveDogISF0aGlzLnByb3BzLnJvd1NlbGVjdGlvbixcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudEhhc0NoZWNrOiAhIXRoaXMucHJvcHMucm93U2VsZWN0aW9uIC8vLy8vXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAgICAgICAgICAgICAgICdkaXYnLFxuICAgICAgICAgICAgICAgICAgICAgICAgeyBjbGFzc05hbWU6ICdrdW1hLXV4dGFibGUtc3Vicm93JywgcmVmOiAnc3ViUm93JyB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgc3ViQ29tcFxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHByb3BzLnJlbmRlclN1YkNvbXApIHtcbiAgICAgICAgICAgICAgICB2YXIgc3ViQ29tcCA9IHByb3BzLnJlbmRlclN1YkNvbXAoZGVlcGNvcHkocHJvcHMucm93RGF0YSkpO1xuICAgICAgICAgICAgICAgIGlmIChzdWJDb21wICYmIHByb3BzLnJvd0RhdGEuc2hvd1N1YkNvbXApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgICAgICAgICAgICAgICAnZGl2JyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgY2xhc3NOYW1lOiAna3VtYS11eHRhYmxlLXN1YnJvdycsIHJlZjogJ3N1YlJvdycgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1YkNvbXBcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgUm93LnByb3RvdHlwZS5yZW5kZXJDaGlsZCA9IGZ1bmN0aW9uIHJlbmRlckNoaWxkKCkge1xuXG4gICAgICAgIHZhciBwcm9wcyA9IHRoaXMucHJvcHMsXG4gICAgICAgICAgICBtZSA9IHRoaXMsXG4gICAgICAgICAgICBjaGlsZHJlbiA9IFtdO1xuXG4gICAgICAgIGlmIChwcm9wcy5yZW5kZXJNb2RlbCAhPT0gJ3RyZWUnKSB7XG4gICAgICAgICAgICByZXR1cm4gY2hpbGRyZW47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByb3BzLnJvd0RhdGEuZGF0YXMpIHtcbiAgICAgICAgICAgIHByb3BzLnJvd0RhdGEuZGF0YXMuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgICAgIHZhciByZW5kZXJQcm9wcyA9IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICAgICAgICAgICAgbGV2ZWw6IG1lLnByb3BzLmxldmVsICsgMSxcbiAgICAgICAgICAgICAgICAgICAgcm93RGF0YTogbm9kZSxcbiAgICAgICAgICAgICAgICAgICAgcm93SW5kZXg6IG5vZGUuanN4aWQsXG4gICAgICAgICAgICAgICAgICAgIGtleTogbm9kZS5qc3hpZCxcbiAgICAgICAgICAgICAgICAgICAgc2hvd1N1YkNvbXA6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICB2aXNpYmxlOiBtZS5zdGF0ZS5leHBhbmRlZCAmJiBtZS5wcm9wcy52aXNpYmxlXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgY2hpbGRyZW4ucHVzaChSZWFjdC5jcmVhdGVFbGVtZW50KFJvdywgcmVuZGVyUHJvcHMpKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB2YXIgcmVuZGVyUHJvcHMgPSB7XG4gICAgICAgICAgICAgICAga2V5OiBcInRyZWVSb3dcIiArIHRoaXMucHJvcHMucm93RGF0YS5qc3hpZCxcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU6IFwia3VtYS11eHRhYmxlLXRyZWUtcm93XCJcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGNoaWxkcmVuID0gUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAgICAgICAndWwnLFxuICAgICAgICAgICAgICAgIHJlbmRlclByb3BzLFxuICAgICAgICAgICAgICAgIGNoaWxkcmVuXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNoaWxkcmVuO1xuICAgIH07XG5cbiAgICBSb3cucHJvdG90eXBlLnJlbmRlckV4cGVuZEljb24gPSBmdW5jdGlvbiByZW5kZXJFeHBlbmRJY29uKHJvd0luZGV4KSB7XG5cbiAgICAgICAgdmFyIGV4cGFuZENvbGxhcHNlSWNvbiA9IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIHByb3BzID0gdGhpcy5wcm9wcyxcbiAgICAgICAgICAgIF9leHBhbmRJY29uQ2xhc3MgPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgaWYgKHByb3BzLnJlbmRlck1vZGVsICE9PSAndHJlZScpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwcm9wcy5yb3dEYXRhLmRhdGFzKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuc3RhdGUuZXhwYW5kZWQpIHtcblxuICAgICAgICAgICAgICAgIF9leHBhbmRJY29uQ2xhc3MgPSB7XG4gICAgICAgICAgICAgICAgICAgIFwia3VtYS1pY29uXCI6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIFwia3VtYS1pY29uLXRyZWUtb3Blbi0yXCI6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBcImt1bWEtaWNvbi10cmVlLWNsb3NlLTJcIjogdHJ1ZVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgX2V4cGFuZEljb25DbGFzc1tcImt1bWEtdXh0YWJsZS1leHBhbmRJY29uLVwiICsgcHJvcHMuZml4ZWRDb2x1bW4gKyBcIi1cIiArIHJvd0luZGV4XSA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICBleHBhbmRDb2xsYXBzZUljb24gPSBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICAgICAgICAgICAnc3BhbicsXG4gICAgICAgICAgICAgICAgICAgIHsgY2xhc3NOYW1lOiAna3VtYS11eHRhYmxlLXRyZWUtaWNvbicsICdkYXRhLXR5cGUnOiBwcm9wcy5maXhlZENvbHVtbiwgJ2RhdGEtaW5kZXgnOiByb3dJbmRleCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2xpY2s6IHRoaXMudG9nZ2xlRXhwYW5kZWQuYmluZCh0aGlzKSB9LFxuICAgICAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KCdpJywgeyBjbGFzc05hbWU6IGNsYXNzbmFtZXMoX2V4cGFuZEljb25DbGFzcykgfSlcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgICAgIF9leHBhbmRJY29uQ2xhc3MgPSB7XG4gICAgICAgICAgICAgICAgICAgIFwia3VtYS1pY29uXCI6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIFwia3VtYS1pY29uLXRyZWUtb3Blbi0yXCI6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIFwia3VtYS1pY29uLXRyZWUtY2xvc2UtMlwiOiBmYWxzZVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgX2V4cGFuZEljb25DbGFzc1tcImt1bWEtdXh0YWJsZS1leHBhbmRJY29uLVwiICsgcHJvcHMuZml4ZWRDb2x1bW4gKyBcIi1cIiArIHJvd0luZGV4XSA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICBleHBhbmRDb2xsYXBzZUljb24gPSBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICAgICAgICAgICAnc3BhbicsXG4gICAgICAgICAgICAgICAgICAgIHsgY2xhc3NOYW1lOiAna3VtYS11eHRhYmxlLXRyZWUtaWNvbicsICdkYXRhLXR5cGUnOiBwcm9wcy5maXhlZENvbHVtbiwgJ2RhdGEtaW5kZXgnOiByb3dJbmRleCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2xpY2s6IHRoaXMudG9nZ2xlRXhwYW5kZWQuYmluZCh0aGlzKSB9LFxuICAgICAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KCdpJywgeyBjbGFzc05hbWU6IGNsYXNzbmFtZXMoX2V4cGFuZEljb25DbGFzcykgfSlcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZXhwYW5kQ29sbGFwc2VJY29uID0gUmVhY3QuY3JlYXRlRWxlbWVudCgnc3BhbicsIHsgY2xhc3NOYW1lOiAna3VtYS11eHRhYmxlLWVtcHR5aWNvbicgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGV4cGFuZENvbGxhcHNlSWNvbjtcbiAgICB9O1xuXG4gICAgUm93LnByb3RvdHlwZS5yZW5kZXJJbmRlbnQgPSBmdW5jdGlvbiByZW5kZXJJbmRlbnQoKSB7XG4gICAgICAgIHZhciBpbmRlbnRzID0gW107XG4gICAgICAgIGlmICh0aGlzLnByb3BzLnJlbmRlck1vZGVsID09ICd0cmVlJykge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnByb3BzLmxldmVsIC0gMTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlbmRlclByb3BzID0ge1xuICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU6IFwiaW5kZW50XCIsXG4gICAgICAgICAgICAgICAgICAgIGtleTogJ2luZGVudCcgKyBpXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBpbmRlbnRzLnB1c2goUmVhY3QuY3JlYXRlRWxlbWVudCgnc3BhbicsIHJlbmRlclByb3BzKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaW5kZW50cztcbiAgICB9O1xuXG4gICAgUm93LnByb3RvdHlwZS50b2dnbGVFeHBhbmRlZCA9IGZ1bmN0aW9uIHRvZ2dsZUV4cGFuZGVkKGUpIHtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICBleHBhbmRlZDogIXRoaXMuc3RhdGUuZXhwYW5kZWRcbiAgICAgICAgfSk7XG4gICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIHZhciB0ID0gJChlLnRhcmdldCk7XG4gICAgICAgIGlmICghdC5oYXNDbGFzcygna3VtYS11eHRhYmxlLXRyZWUtaWNvbicpKSB7XG4gICAgICAgICAgICB0ID0gdC5wYXJlbnRzKCcua3VtYS11eHRhYmxlLXRyZWUtaWNvbicpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0LmRhdGEoJ3R5cGUnKSA9PSAnZml4ZWQnKSB7XG4gICAgICAgICAgICAkKFwiLmt1bWEtdXh0YWJsZS1leHBhbmRJY29uLXNjcm9sbFwiICsgXCItXCIgKyB0LmRhdGEoJ2luZGV4JykpLnRyaWdnZXIoJ2NsaWNrJyk7XG4gICAgICAgIH0gZWxzZSBpZiAodC5kYXRhKCd0eXBlJykgPT0gJ3Njcm9sbCcpIHtcbiAgICAgICAgICAgICQoXCIua3VtYS11eHRhYmxlLWV4cGFuZEljb24tZml4ZWRcIiArIFwiLVwiICsgdC5kYXRhKCdpbmRleCcpKS50cmlnZ2VyKCdjbGljaycpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIFJvdy5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgICAgICB2YXIgX2NsYXNzbmFtZXM7XG5cbiAgICAgICAgdmFyIHByb3BzID0gdGhpcy5wcm9wcyxcbiAgICAgICAgICAgIF9jb2x1bW5zID0gW10sXG4gICAgICAgICAgICBfc3R5bGUgPSB7fSxcbiAgICAgICAgICAgIF9kYXRhID0gcHJvcHMuZGF0YSxcbiAgICAgICAgICAgIG1lID0gdGhpcyxcbiAgICAgICAgICAgIG90aGVyQ2xzID0gcHJvcHMuYWRkUm93Q2xhc3NOYW1lKF9kYXRhW3Byb3BzLnJvd0luZGV4XSk7XG5cbiAgICAgICAgaWYgKCF0aGlzLnByb3BzLnZpc2libGUpIHtcbiAgICAgICAgICAgIF9zdHlsZSA9IHtcbiAgICAgICAgICAgICAgICBkaXNwbGF5OiAnbm9uZSdcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICBwcm9wcy5jb2x1bW5zLmZvckVhY2goZnVuY3Rpb24gKGNvbHVtbiwgaW5kZXgpIHtcbiAgICAgICAgICAgIGlmIChcImdyb3VwXCIgaW4gY29sdW1uKSB7XG4gICAgICAgICAgICAgICAgX2NvbHVtbnMgPSBfY29sdW1ucy5jb25jYXQoY29sdW1uLmNvbHVtbnMpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBfY29sdW1ucy5wdXNoKGNvbHVtbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHZhciBmaXJzdFZpc2FibGVDb2x1bW4gPSAwO1xuXG4gICAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICAgJ2xpJyxcbiAgICAgICAgICAgIHsgY2xhc3NOYW1lOiBjbGFzc25hbWVzKChfY2xhc3NuYW1lcyA9IHt9LCBfY2xhc3NuYW1lc1t0aGlzLnByb3BzLnByZWZpeENsc10gPSB0cnVlLCBfY2xhc3NuYW1lc1tvdGhlckNsc10gPSAhIW90aGVyQ2xzLCBfY2xhc3NuYW1lc1snZXZlbiddID0gcHJvcHMucm93SW5kZXggJSAyID09IDEgPyB0cnVlIDogZmFsc2UsIF9jbGFzc25hbWVzKSksIHN0eWxlOiBfc3R5bGUsXG4gICAgICAgICAgICAgICAgb25DbGljazogdGhpcy5oYW5kbGVDbGljay5iaW5kKHRoaXMsIHByb3BzLnJvd0RhdGEpLFxuICAgICAgICAgICAgICAgIG9uRG91YmxlQ2xpY2s6IHRoaXMuaGFuZGxlRG91YmxlQ2xpY2suYmluZCh0aGlzLCBwcm9wcy5yb3dEYXRhKSB9LFxuICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAgICAgICAnZGl2JyxcbiAgICAgICAgICAgICAgICB7IGNsYXNzTmFtZTogdGhpcy5wcm9wcy5wcmVmaXhDbHMgKyAnLWNlbGxzJyB9LFxuICAgICAgICAgICAgICAgIF9jb2x1bW5zLm1hcChmdW5jdGlvbiAoaXRlbSwgaW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGl0ZW0uaGlkZGVuKSByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIGZpcnN0VmlzYWJsZUNvbHVtbisrO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVuZGVyUHJvcHMgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2x1bW46IGl0ZW0sXG4gICAgICAgICAgICAgICAgICAgICAgICByb290OiBwcm9wcy5yb290LFxuICAgICAgICAgICAgICAgICAgICAgICAgYWxpZ246IGl0ZW0uYWxpZ24sXG4gICAgICAgICAgICAgICAgICAgICAgICByb3dEYXRhOiBwcm9wcy5yb3dEYXRhLFxuICAgICAgICAgICAgICAgICAgICAgICAgcm93SW5kZXg6IHByb3BzLnJvd0luZGV4LFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXg6IHByb3BzLmluZGV4LFxuICAgICAgICAgICAgICAgICAgICAgICAgY2VsbEluZGV4OiBpbmRleCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhc1N1YkNvbXA6IHByb3BzLnN1YkNvbXAgPyB0cnVlIDogcHJvcHMucmVuZGVyU3ViQ29tcCA/IHByb3BzLnJlbmRlclN1YkNvbXAoZGVlcGNvcHkocHJvcHMucm93RGF0YSkpIDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBfZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5nZVNlbGVjdGVkOiBtZS5wcm9wcy5jaGFuZ2VTZWxlY3RlZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNob3dTdWJDb21wQ2FsbGJhY2s6IG1lLnNob3dTdWJDb21wRnVuYy5iaW5kKG1lKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvd1NlbGVjdGlvbjogcHJvcHMucm93U2VsZWN0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgYWN0aW9uczogcHJvcHMuYWN0aW9ucyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vZGU6IHByb3BzLm1vZGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGVEYXRhQ2hhbmdlOiBwcm9wcy5oYW5kbGVEYXRhQ2hhbmdlLFxuICAgICAgICAgICAgICAgICAgICAgICAgYXR0YWNoQ2VsbEZpZWxkOiBwcm9wcy5hdHRhY2hDZWxsRmllbGQsXG4gICAgICAgICAgICAgICAgICAgICAgICBkZXRhY2hDZWxsRmllbGQ6IHByb3BzLmRldGFjaENlbGxGaWVsZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleTogXCJjZWxsXCIgKyBpbmRleFxuICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChmaXJzdFZpc2FibGVDb2x1bW4gPT0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgQ2VsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW5kZXJQcm9wcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZS5yZW5kZXJJbmRlbnQoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZS5yZW5kZXJFeHBlbmRJY29uKHByb3BzLnJvd0luZGV4KVxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvL2lmIGhhdmUgdmVydGljYWwgZGF0YSBzdHJ1Y3R1cmUsIGhvdyB0byBwcm9jZXNzIGl0XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KENlbGwsIHJlbmRlclByb3BzKTtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIG1lLnJlbmRlckNoaWxkKCksXG4gICAgICAgICAgICB0aGlzLnJlbmRlclN1YkNvbXAoKVxuICAgICAgICApO1xuICAgIH07XG5cbiAgICByZXR1cm4gUm93O1xufShSZWFjdC5Db21wb25lbnQpO1xuXG47XG5cblJvdy5wcm9wVHlwZXMgPSB7XG4gICAgcHJlZml4Q2xzOiBSZWFjdC5Qcm9wVHlwZXMuc3RyaW5nLFxuICAgIHNob3dTdWJDb21wOiBSZWFjdC5Qcm9wVHlwZXMuYm9vbFxufTtcblxuUm93LmRlZmF1bHRQcm9wcyA9IHtcbiAgICBwcmVmaXhDbHM6IFwia3VtYS11eHRhYmxlLXJvd1wiLFxuICAgIHNob3dTdWJDb21wOiBmYWxzZVxufTtcblxuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBSb3c7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi91eGNvcmUtdGFibGUvYnVpbGQvUm93LmpzXG4gKiogbW9kdWxlIGlkID0gMTU5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9O1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbi8qKlxuICogQ3JlYXRlZCBieSB4eSBvbiAxNS80LzEzLlxuICovXG5cbnZhciBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG52YXIgUmVhY3RET00gPSByZXF1aXJlKCdyZWFjdC1kb20nKTtcbnZhciBDb25zdCA9IHJlcXVpcmUoJ3V4Y29yZS1jb25zdCcpO1xudmFyIERyb3Bkb3duID0gcmVxdWlyZSgndXhjb3JlLWRyb3Bkb3duJyk7XG52YXIgTWVudSA9IHJlcXVpcmUoJ3V4Y29yZS1tZW51Jyk7XG5cbnZhciBDaGVja0JveCA9IHJlcXVpcmUoJy4vQ2hlY2tCb3gnKTtcbnZhciBSYWRpbyA9IHJlcXVpcmUoJy4vUmFkaW8nKTtcbnZhciBUZXh0RmllbGQgPSByZXF1aXJlKCcuL1RleHRGaWVsZCcpO1xudmFyIFNlbGVjdEZpZWxkID0gcmVxdWlyZShcIi4vU2VsZWN0RmllbGRcIik7XG52YXIgUmFkaW9GaWVsZCA9IHJlcXVpcmUoXCIuL1JhZGlvRmllbGRcIik7XG52YXIgdXRpbCA9IHJlcXVpcmUoJy4vVXRpbCcpO1xudmFyIGNsYXNzbmFtZXMgPSByZXF1aXJlKCdjbGFzc25hbWVzJyk7XG52YXIgYXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xudmFyIGRlZXBjb3B5ID0gcmVxdWlyZSgnZGVlcGNvcHknKTtcbnZhciBmaWVsZHNNYXAgPSB7XG4gICAgXCJzZWxlY3RcIjogU2VsZWN0RmllbGQsXG4gICAgXCJ0ZXh0XCI6IFRleHRGaWVsZCxcbiAgICBcInJhZGlvXCI6IFJhZGlvRmllbGRcbn07XG5cbnZhciBDZWxsID0gZnVuY3Rpb24gKF9SZWFjdCRDb21wb25lbnQpIHtcbiAgICBfaW5oZXJpdHMoQ2VsbCwgX1JlYWN0JENvbXBvbmVudCk7XG5cbiAgICBmdW5jdGlvbiBDZWxsKHByb3BzKSB7XG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDZWxsKTtcblxuICAgICAgICB2YXIgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfUmVhY3QkQ29tcG9uZW50LmNhbGwodGhpcywgcHJvcHMpKTtcblxuICAgICAgICBfdGhpcy5zdGF0ZSA9IHtcbiAgICAgICAgICAgICdmb2xkJzogMSwgLy8gMS0gZm9sZCAgMC11bmZvbGRcbiAgICAgICAgICAgICdjaGVja2VkJzogISFfdGhpcy5nZXRDZWxsRGF0YSgpXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG5cbiAgICBDZWxsLnByb3RvdHlwZS5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzID0gZnVuY3Rpb24gY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhuZXh0UHJvcHMpIHtcbiAgICAgICAgdmFyIG1lID0gdGhpcztcbiAgICAgICAgaWYgKG1lLnByb3BzLmNvbHVtbi50eXBlID09IFwiY2hlY2tib3hcIiB8fCBtZS5wcm9wcy5jb2x1bW4udHlwZSA9PSBcImNoZWNrYm94U2VsZWN0b3JcIiB8fCBtZS5wcm9wcy5jb2x1bW4udHlwZSA9PSBcInJhZGlvU2VsZWN0b3JcIikge1xuICAgICAgICAgICAgbWUuc2V0U3RhdGUoe1xuICAgICAgICAgICAgICAgIGNoZWNrZWQ6ICEhbWUuZ2V0Q2VsbERhdGEobmV4dFByb3BzKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgQ2VsbC5wcm90b3R5cGUuY29tcG9uZW50RGlkTW91bnQgPSBmdW5jdGlvbiBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICAgICAgdmFyIG1lID0gdGhpcztcbiAgICAgICAgaWYgKG1lLnByb3BzLmNvbHVtbi50eXBlID09IFwiY2hlY2tib3hcIiB8fCBtZS5wcm9wcy5jb2x1bW4udHlwZSA9PSBcImNoZWNrYm94U2VsZWN0b3JcIiB8fCBtZS5wcm9wcy5jb2x1bW4udHlwZSA9PSBcInJhZGlvU2VsZWN0b3JcIikge1xuICAgICAgICAgICAgbWUucHJvcHMuY2hhbmdlU2VsZWN0ZWQobWUuc3RhdGUuY2hlY2tlZCwgbWUucHJvcHMucm93SW5kZXgsIHRydWUpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIENlbGwucHJvdG90eXBlLmhhbmRsZUNoZWNrQ2hhbmdlID0gZnVuY3Rpb24gaGFuZGxlQ2hlY2tDaGFuZ2UoZSkge1xuICAgICAgICB2YXIgbWUgPSB0aGlzLFxuICAgICAgICAgICAgX3Byb3BzID0gdGhpcy5wcm9wcyxcbiAgICAgICAgICAgIHYgPSBfcHJvcHMucm93RGF0YTtcbiAgICAgICAgbWUucHJvcHMuY2hhbmdlU2VsZWN0ZWQoZS50YXJnZXQuY2hlY2tlZCwgX3Byb3BzLnJvd0luZGV4LCBmYWxzZSk7XG4gICAgfTtcblxuICAgIENlbGwucHJvdG90eXBlLmhhbmRsZURyb3Bkb3duVmlzaWJsZUNoYW5nZSA9IGZ1bmN0aW9uIGhhbmRsZURyb3Bkb3duVmlzaWJsZUNoYW5nZSh2aXNpYmxlKSB7XG4gICAgICAgIHZhciBtZSA9IHRoaXM7XG4gICAgICAgIG1lLnNldFN0YXRlKHtcbiAgICAgICAgICAgIGRyb3Bkb3duVmlzaWJsZTogdmlzaWJsZVxuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgQ2VsbC5wcm90b3R5cGUuc2hvd1N1YkNvbXAgPSBmdW5jdGlvbiBzaG93U3ViQ29tcCgpIHtcbiAgICAgICAgdGhpcy5wcm9wcy5zaG93U3ViQ29tcENhbGxiYWNrLmFwcGx5KCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBhY3Rpb25zIHtBcnJheSBvciBPYmplY3R9XG4gICAgICovXG5cblxuICAgIENlbGwucHJvdG90eXBlLmdldEFjdGlvbkl0ZW1zID0gZnVuY3Rpb24gZ2V0QWN0aW9uSXRlbXMoYWN0aW9ucykge1xuICAgICAgICBpZiAoKHR5cGVvZiBhY3Rpb25zID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihhY3Rpb25zKSkgIT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJUYWJsZTogQWN0aW9ucyBzaG91bGQgYmUgYW4gb2JqZWN0IG9yIGFycmF5XCIpO1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIG1lID0gdGhpcztcbiAgICAgICAgICAgIG1lLml0ZW1zID0gW107XG4gICAgICAgICAgICBpZiAoYWN0aW9ucyBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgICAgICAgbWUuaXRlbXMgPSBhY3Rpb25zO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpIGluIGFjdGlvbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFjdGlvbnMuaGFzT3duUHJvcGVydHkoaSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lLml0ZW1zLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlOiBpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrOiBhY3Rpb25zW2ldXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIG1lLml0ZW1zO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIENlbGwucHJvdG90eXBlLmdldEVkaXREYXRhID0gZnVuY3Rpb24gZ2V0RWRpdERhdGEoKSB7XG4gICAgICAgIHZhciBtZSA9IHRoaXM7XG4gICAgICAgIHZhciBjb2x1bW4gPSBtZS5wcm9wcy5jb2x1bW47XG4gICAgICAgIHZhciBlZGl0S2V5ID0gY29sdW1uLmVkaXRLZXkgfHwgY29sdW1uLmRhdGFLZXk7XG4gICAgICAgIHJldHVybiBtZS5wcm9wcy5yb3dEYXRhW2VkaXRLZXldO1xuICAgIH07XG5cbiAgICBDZWxsLnByb3RvdHlwZS5nZXRDZWxsRGF0YSA9IGZ1bmN0aW9uIGdldENlbGxEYXRhKG5leHRQcm9wcykge1xuXG4gICAgICAgIHZhciBwcm9wcyA9IG5leHRQcm9wcyB8fCB0aGlzLnByb3BzLFxuICAgICAgICAgICAgX2NvbHVtbiA9IHByb3BzLmNvbHVtbixcbiAgICAgICAgICAgIGNlbGxEYXRhID0gcHJvcHMucm93RGF0YVtfY29sdW1uLmRhdGFLZXldO1xuXG4gICAgICAgIHJldHVybiBjZWxsRGF0YTtcbiAgICB9O1xuXG4gICAgQ2VsbC5wcm90b3R5cGUuaGFuZGxlQWN0aW9uQ2xpY2sgPSBmdW5jdGlvbiBoYW5kbGVBY3Rpb25DbGljayhjYiwgZSkge1xuICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICB2YXIgbWUgPSB0aGlzO1xuICAgICAgICBtZS5zZXRTdGF0ZSh7XG4gICAgICAgICAgICBkcm9wZG93blZpc2libGU6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgICAgICBjYiAmJiBjYigpO1xuICAgIH07XG5cbiAgICBDZWxsLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIoKSB7XG5cbiAgICAgICAgdmFyIG1lID0gdGhpcyxcbiAgICAgICAgICAgIHByb3BzID0gbWUucHJvcHMsXG4gICAgICAgICAgICBfY29sdW1uID0gcHJvcHMuY29sdW1uLFxuICAgICAgICAgICAgX3dpZHRoID0gX2NvbHVtbi53aWR0aCxcbiAgICAgICAgICAgIF9tb2RlID0gcHJvcHMucm93RGF0YVsnX19tb2RlX18nXSxcbiAgICAgICAgICAgIF9zdHlsZSA9IHtcbiAgICAgICAgICAgIHdpZHRoOiBfd2lkdGggPyBfd2lkdGggOiAxMDAsXG4gICAgICAgICAgICB0ZXh0QWxpZ246IHByb3BzLmFsaWduID8gcHJvcHMuYWxpZ24gOiBcImxlZnRcIlxuICAgICAgICB9LFxuICAgICAgICAgICAgX3YgPSBkZWVwY29weShwcm9wcy5yb3dEYXRhKSxcbiAgICAgICAgICAgIHJlbmRlclByb3BzID0gdW5kZWZpbmVkO1xuXG4gICAgICAgIGlmIChfY29sdW1uLnR5cGUgPT0gJ2FjdGlvbicpIHtcbiAgICAgICAgICAgIF92ID0gUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAgICAgICAnZGl2JyxcbiAgICAgICAgICAgICAgICB7IGNsYXNzTmFtZTogJ2FjdGlvbi1jb250YWluZXInIH0sXG4gICAgICAgICAgICAgICAgbWUucmVuZGVyQWN0aW9uSXRlbXMoX2NvbHVtbiwgX3YsIF9tb2RlKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIGlmIChfY29sdW1uLnR5cGUgPT0gJ2NoZWNrYm94JyB8fCBfY29sdW1uLnR5cGUgPT0gJ2NoZWNrYm94U2VsZWN0b3InKSB7XG5cbiAgICAgICAgICAgIF9zdHlsZS5wYWRkaW5nUmlnaHQgPSA0O1xuICAgICAgICAgICAgX3N0eWxlLnBhZGRpbmdMZWZ0ID0gMTI7XG5cbiAgICAgICAgICAgIHZhciBjaGVja2VkID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgaWYgKG1lLnN0YXRlLmNoZWNrZWQpIHtcbiAgICAgICAgICAgICAgICBjaGVja2VkID0gJ2NoZWNrZWQnO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjaGVja2VkID0gXCJcIjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGRpc2FibGUgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmICgnZGlzYWJsZScgaW4gX2NvbHVtbikge1xuICAgICAgICAgICAgICAgIGRpc2FibGUgPSBfY29sdW1uLmRpc2FibGU7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCdpc0Rpc2FibGUnIGluIF9jb2x1bW4pIHtcbiAgICAgICAgICAgICAgICBkaXNhYmxlID0gISFfY29sdW1uLmlzRGlzYWJsZShwcm9wcy5yb3dEYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF92ID0gUmVhY3QuY3JlYXRlRWxlbWVudChDaGVja0JveCwgeyBkaXNhYmxlOiBkaXNhYmxlLCBtb2RlOiBwcm9wcy5tb2RlLCBhbGlnbjogcHJvcHMuYWxpZ24sIGpzeGNoZWNrZWQ6IGNoZWNrZWQsIHJlZjogJ2NoZWNrYm94Jywgb25jaGFuZ2U6IG1lLmhhbmRsZUNoZWNrQ2hhbmdlLmJpbmQobWUpIH0pO1xuICAgICAgICB9IGVsc2UgaWYgKF9jb2x1bW4udHlwZSA9PSAncmFkaW9TZWxlY3RvcicpIHtcbiAgICAgICAgICAgIF9zdHlsZS5wYWRkaW5nUmlnaHQgPSA0O1xuICAgICAgICAgICAgX3N0eWxlLnBhZGRpbmdMZWZ0ID0gMTI7XG5cbiAgICAgICAgICAgIHZhciBjaGVja2VkID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgaWYgKG1lLnN0YXRlLmNoZWNrZWQpIHtcbiAgICAgICAgICAgICAgICBjaGVja2VkID0gJ2NoZWNrZWQnO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjaGVja2VkID0gXCJcIjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGRpc2FibGUgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmICgnZGlzYWJsZScgaW4gX2NvbHVtbikge1xuICAgICAgICAgICAgICAgIGRpc2FibGUgPSBfY29sdW1uLmRpc2FibGU7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCdpc0Rpc2FibGUnIGluIF9jb2x1bW4pIHtcbiAgICAgICAgICAgICAgICBkaXNhYmxlID0gISFfY29sdW1uLmlzRGlzYWJsZShwcm9wcy5yb3dEYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF92ID0gUmVhY3QuY3JlYXRlRWxlbWVudChSYWRpbywgeyBkaXNhYmxlOiBkaXNhYmxlLCBtb2RlOiBwcm9wcy5tb2RlLCBhbGlnbjogcHJvcHMuYWxpZ24sIGpzeGNoZWNrZWQ6IGNoZWNrZWQsIG9uY2hhbmdlOiBtZS5oYW5kbGVDaGVja0NoYW5nZS5iaW5kKG1lKSB9KTtcbiAgICAgICAgfSBlbHNlIGlmIChfY29sdW1uLnR5cGUgPT0gJ3RyZWVJY29uJykge1xuICAgICAgICAgICAgX3YgPSBtZS5yZW5kZXJUcmVlSWNvbigpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaW5saW5lIGVkaXQgbW9kZVxuICAgICAgICBlbHNlIGlmICgoX2NvbHVtbi50eXBlID09ICdjdXN0b20nIHx8IF9jb2x1bW4udHlwZSBpbiBmaWVsZHNNYXApICYmIF9tb2RlID09IENvbnN0Lk1PREUuRURJVCAmJiAoISgnY2FuRWRpdCcgaW4gX2NvbHVtbikgfHwgX2NvbHVtbi5jYW5FZGl0KHByb3BzLnJvd0RhdGEpKSkge1xuICAgICAgICAgICAgICAgIHJlbmRlclByb3BzID0ge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogbWUuZ2V0RWRpdERhdGEoKSxcbiAgICAgICAgICAgICAgICAgICAgcm93RGF0YTogcHJvcHMucm93RGF0YSxcbiAgICAgICAgICAgICAgICAgICAgaW5kZXg6IHByb3BzLmluZGV4LFxuICAgICAgICAgICAgICAgICAgICBjb2x1bW46IF9jb2x1bW4sXG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZURhdGFDaGFuZ2U6IHByb3BzLmhhbmRsZURhdGFDaGFuZ2UsXG4gICAgICAgICAgICAgICAgICAgIGF0dGFjaENlbGxGaWVsZDogcHJvcHMuYXR0YWNoQ2VsbEZpZWxkLFxuICAgICAgICAgICAgICAgICAgICBkZXRhY2hDZWxsRmllbGQ6IHByb3BzLmRldGFjaENlbGxGaWVsZFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgdmFyIEZpZWxkID0gdW5kZWZpbmVkO1xuXG4gICAgICAgICAgICAgICAgaWYgKF9jb2x1bW4udHlwZSA9PSAnY3VzdG9tJykge1xuICAgICAgICAgICAgICAgICAgICBGaWVsZCA9IHByb3BzLmNvbHVtbi5jdXN0b21GaWVsZDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBGaWVsZCA9IGZpZWxkc01hcFtfY29sdW1uLnR5cGVdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBfdiA9IFJlYWN0LmNyZWF0ZUVsZW1lbnQoRmllbGQsIHJlbmRlclByb3BzKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoX2NvbHVtbi50eXBlID09ICdtb25leScgfHwgX2NvbHVtbi50eXBlID09IFwiY2FyZFwiIHx8IF9jb2x1bW4udHlwZSA9PSBcImNubW9iaWxlXCIpIHtcbiAgICAgICAgICAgICAgICBfdiA9IFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgICAgICAgICAgICdkaXYnLFxuICAgICAgICAgICAgICAgICAgICB7IGNsYXNzTmFtZTogJ2RlZmF1bHQtY2VsbCcsIHRpdGxlOiBtZS5nZXRDZWxsRGF0YSgpIH0sXG4gICAgICAgICAgICAgICAgICAgIHV0aWwuZm9ybWF0VmFsdWUobWUuZ2V0Q2VsbERhdGEoKSwgX2NvbHVtbi50eXBlLCBfY29sdW1uLmRlbGltaXRlcilcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChfY29sdW1uLnJlbmRlcikge1xuICAgICAgICAgICAgICAgIF92ID0gX2NvbHVtbi5yZW5kZXIuYXBwbHkobnVsbCwgW21lLmdldENlbGxEYXRhKCksIF92XSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIF92ID0gUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAgICAgICAgICAgJ2RpdicsXG4gICAgICAgICAgICAgICAgICAgIHsgY2xhc3NOYW1lOiAnZGVmYXVsdC1jZWxsJywgdGl0bGU6IG1lLmdldENlbGxEYXRhKCkgfSxcbiAgICAgICAgICAgICAgICAgICAgbWUuZ2V0Q2VsbERhdGEoKVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgdmFyIGNoaWxkID0gbWUucHJvcHMuY2hpbGRyZW47XG4gICAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICAgJ2RpdicsXG4gICAgICAgICAgICB7IGNsYXNzTmFtZTogcHJvcHMuanN4cHJlZml4Q2xzLCBzdHlsZTogX3N0eWxlIH0sXG4gICAgICAgICAgICBjaGlsZCxcbiAgICAgICAgICAgIF92XG4gICAgICAgICk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb2x1bW4gY3VycmVudCBjb2x1bW4gY29uZmlnXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHJvd0RhdGEgY3VycmVudCByb3cgZGF0YVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBtb2RlIGN1cnJlbnQgcm93IG1vZGU6IGVkaXQgb3Igdmlldywgc2FtZSBhcyByb3dEYXRhWydfX21vZGVfXyddIFxuICAgICAqL1xuXG4gICAgQ2VsbC5wcm90b3R5cGUucmVuZGVyQWN0aW9uSXRlbXMgPSBmdW5jdGlvbiByZW5kZXJBY3Rpb25JdGVtcyhjb2x1bW4sIHJvd0RhdGEsIG1vZGUpIHtcbiAgICAgICAgdmFyIG1lID0gdGhpcztcbiAgICAgICAgdmFyIGFjdGlvbnMgPSBtZS5nZXRBY3Rpb25JdGVtcyhjb2x1bW4uYWN0aW9ucykuZmlsdGVyKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgICByZXR1cm4gISgnbW9kZScgaW4gaXRlbSkgfHwgaXRlbS5tb2RlID09IG1vZGU7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoYWN0aW9ucy5sZW5ndGggPD0gMikge1xuICAgICAgICAgICAgcmV0dXJuIGFjdGlvbnMubWFwKGZ1bmN0aW9uIChpdGVtLCBpbmRleCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICAgICAgICAgICAnYScsXG4gICAgICAgICAgICAgICAgICAgIHsgaHJlZjogJ2phdmFzY3JpcHQ6dm9pZCgwKTsnLCBrZXk6IGluZGV4LCBjbGFzc05hbWU6ICdhY3Rpb24nLCBvbkNsaWNrOiBtZS5oYW5kbGVBY3Rpb25DbGljay5iaW5kKG1lLCBpdGVtLmNhbGxiYWNrLmJpbmQobWUsIHJvd0RhdGEsIG1lLnByb3BzLnJvb3QpKSB9LFxuICAgICAgICAgICAgICAgICAgICAhIWl0ZW0ucmVuZGVyID8gaXRlbS5yZW5kZXIoaXRlbS50aXRsZSwgbWUucHJvcHMucm93RGF0YSkgOiBpdGVtLnRpdGxlXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIGFyciA9IFtdO1xuICAgICAgICAgICAgYXJyLnB1c2goUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAgICAgICAnYScsXG4gICAgICAgICAgICAgICAgeyBocmVmOiAnamF2YXNjcmlwdDp2b2lkKDApOycsIGNsYXNzTmFtZTogJ2FjdGlvbicsIGtleTogJ2FjdGlvbicsIG9uQ2xpY2s6IG1lLmhhbmRsZUFjdGlvbkNsaWNrLmJpbmQobWUsIGFjdGlvbnNbMF0uY2FsbGJhY2suYmluZChtZSwgcm93RGF0YSwgbWUucHJvcHMucm9vdCkpIH0sXG4gICAgICAgICAgICAgICAgISFhY3Rpb25zWzBdLnJlbmRlciA/IGFjdGlvbnNbMF0ucmVuZGVyKGFjdGlvbnNbMF0udGl0bGUsIG1lLnByb3BzLnJvd0RhdGEpIDogYWN0aW9uc1swXS50aXRsZVxuICAgICAgICAgICAgKSk7XG4gICAgICAgICAgICB2YXIgbWVudSA9IFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgICAgICAgTWVudSxcbiAgICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICAgIGFjdGlvbnMuc2xpY2UoMSkubWFwKGZ1bmN0aW9uIChhY3Rpb24sIGluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICAgICAgICAgICAgICAgTWVudS5JdGVtLFxuICAgICAgICAgICAgICAgICAgICAgICAgeyBrZXk6IGluZGV4IH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdhJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IGhyZWY6ICdqYXZhc2NyaXB0OnZvaWQoMCk7JywgY2xhc3NOYW1lOiAnYWN0aW9uJywga2V5OiAnYWN0aW9uJywgb25DbGljazogbWUuaGFuZGxlQWN0aW9uQ2xpY2suYmluZChtZSwgYWN0aW9uLmNhbGxiYWNrLmJpbmQobWUsIHJvd0RhdGEsIG1lLnByb3BzLnJvb3QpKSB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICEhYWN0aW9uLnJlbmRlciA/IGFjdGlvbi5yZW5kZXIoYWN0aW9uLnRpdGxlLCBtZS5wcm9wcy5yb3dEYXRhKSA6IGFjdGlvbi50aXRsZVxuICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgYXJyLnB1c2goUmVhY3QuY3JlYXRlRWxlbWVudCgnaScsIHsgY2xhc3NOYW1lOiAna3VtYS1pY29uIGt1bWEtaWNvbi10cmlhbmdsZS1kb3duJywga2V5OiAnaWNvbicgfSkpO1xuICAgICAgICAgICAgdmFyIGRyb3Bkb3duT3B0aW9ucyA9IHtcbiAgICAgICAgICAgICAgICBrZXk6ICdpY29uJyxcbiAgICAgICAgICAgICAgICBvdmVybGF5OiBtZW51LFxuICAgICAgICAgICAgICAgIHRyaWdnZXI6IFsnY2xpY2snXSxcbiAgICAgICAgICAgICAgICB2aXNpYmxlOiBtZS5zdGF0ZS5kcm9wZG93blZpc2libGUsXG4gICAgICAgICAgICAgICAgb25WaXNpYmxlQ2hhbmdlOiBtZS5oYW5kbGVEcm9wZG93blZpc2libGVDaGFuZ2UuYmluZChtZSlcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAgICAgICBEcm9wZG93bixcbiAgICAgICAgICAgICAgICBkcm9wZG93bk9wdGlvbnMsXG4gICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAgICAgICAgICAgJ3NwYW4nLFxuICAgICAgICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICAgICAgICBhcnJcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIENlbGwucHJvdG90eXBlLnJlbmRlclRyZWVJY29uID0gZnVuY3Rpb24gcmVuZGVyVHJlZUljb24oKSB7XG4gICAgICAgIGlmICh0aGlzLnByb3BzLmNlbGxJbmRleCA9PSAwICYmIHRoaXMucHJvcHMuaGFzU3ViQ29tcCkge1xuICAgICAgICAgICAgdmFyIG9wZW4gPSB0aGlzLnByb3BzLnJvd0RhdGEuc2hvd1N1YkNvbXA7XG4gICAgICAgICAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAgICAgICAnc3BhbicsXG4gICAgICAgICAgICAgICAgeyBjbGFzc05hbWU6ICdrdW1hLXV4dGFibGUtdHJlZS1pY29uJywgb25DbGljazogdGhpcy5zaG93U3ViQ29tcC5iaW5kKHRoaXMpIH0sXG4gICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudCgnaScsIHsgY2xhc3NOYW1lOiBjbGFzc25hbWVzKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwia3VtYS1pY29uXCI6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBcImt1bWEtaWNvbi10cmVlLW9wZW5cIjogb3BlbixcbiAgICAgICAgICAgICAgICAgICAgICAgIFwia3VtYS1pY29uLXRyZWUtY2xvc2VcIjogIW9wZW5cbiAgICAgICAgICAgICAgICAgICAgfSkgfSlcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgcmV0dXJuIENlbGw7XG59KFJlYWN0LkNvbXBvbmVudCk7XG5cbjtcblxuQ2VsbC5wcm9wVHlwZXMgPSB7fTtcblxuQ2VsbC5kZWZhdWx0UHJvcHMgPSB7XG4gICAganN4cHJlZml4Q2xzOiBcImt1bWEtdXh0YWJsZS1jZWxsXCJcbn07XG5cbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gQ2VsbDtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3V4Y29yZS10YWJsZS9idWlsZC9DZWxsL2luZGV4LmpzXG4gKiogbW9kdWxlIGlkID0gMTYwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxuLyoqXG4gKiBBIHJhZGlvIGZpZWxkXG4gKi9cblxudmFyIENvbnN0ID0gcmVxdWlyZSgndXhjb3JlLWNvbnN0Jyk7XG52YXIgUmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xudmFyIFJlYWN0RE9NID0gcmVxdWlyZSgncmVhY3QtZG9tJyk7XG5cbnZhciBSYWRpbyA9IGZ1bmN0aW9uIChfUmVhY3QkQ29tcG9uZW50KSB7XG4gICAgX2luaGVyaXRzKFJhZGlvLCBfUmVhY3QkQ29tcG9uZW50KTtcblxuICAgIGZ1bmN0aW9uIFJhZGlvKHByb3BzKSB7XG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBSYWRpbyk7XG5cbiAgICAgICAgdmFyIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX1JlYWN0JENvbXBvbmVudC5jYWxsKHRoaXMsIHByb3BzKSk7XG5cbiAgICAgICAgX3RoaXMuc3RhdGUgPSB7XG4gICAgICAgICAgICBjaGVja2VkOiAhIV90aGlzLnByb3BzLmNoZWNrZWRcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cblxuICAgIFJhZGlvLnByb3RvdHlwZS5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzID0gZnVuY3Rpb24gY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhuZXh0UHJvcHMpIHtcbiAgICAgICAgdGhpcy5zdGF0ZS5jaGVja2VkID0gISFuZXh0UHJvcHMuanN4Y2hlY2tlZDtcbiAgICB9O1xuXG4gICAgUmFkaW8ucHJvdG90eXBlLmhhbmRsZUNoYW5nZSA9IGZ1bmN0aW9uIGhhbmRsZUNoYW5nZShlKSB7XG4gICAgICAgIGlmIChlLnRhcmdldC5jaGVja2VkICE9IHRoaXMuc3RhdGUuY2hlY2tlZCkge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZS5jaGVja2VkID0gIXRoaXMuc3RhdGUuY2hlY2tlZDtcbiAgICAgICAgICAgIHRoaXMucHJvcHMub25jaGFuZ2UuYXBwbHkobnVsbCwgW2VdKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBSYWRpby5wcm90b3R5cGUuZ2V0VmFsdWUgPSBmdW5jdGlvbiBnZXRWYWx1ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVmcy5yYWRpby5jaGVja2VkO1xuICAgIH07XG5cbiAgICBSYWRpby5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKCkge1xuXG4gICAgICAgIHZhciBwcm9wcyA9IHRoaXMucHJvcHM7XG5cbiAgICAgICAgaWYgKHByb3BzLm1vZGUgIT09IENvbnN0Lk1PREUuVklFVykge1xuICAgICAgICAgICAgdmFyIHJlbmRlclByb3BzID0ge1xuICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogXCJrdW1hLWNoZWNrYm94XCIsXG4gICAgICAgICAgICAgICAgY2hlY2tlZDogdGhpcy5wcm9wcy5qc3hjaGVja2VkLFxuICAgICAgICAgICAgICAgIG9uQ2hhbmdlOiB0aGlzLmhhbmRsZUNoYW5nZS5iaW5kKHRoaXMpXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKCEhcHJvcHMuZGlzYWJsZSkge1xuICAgICAgICAgICAgICAgIHJlbmRlclByb3BzLmRpc2FibGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICAgICAgICdsYWJlbCcsXG4gICAgICAgICAgICAgICAgeyBjbGFzc05hbWU6ICdrdW1hLXV4dGFibGUtcm93LXNlbGVjdG9yJyB9LFxuICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoJ2lucHV0JywgX2V4dGVuZHMoeyB0eXBlOiAncmFkaW8nLCByZWY6ICdyYWRpbycgfSwgcmVuZGVyUHJvcHMpKSxcbiAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KCdzJywgbnVsbClcbiAgICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgIHZhciByZW5kZXJQcm9wcyA9IHtcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU6IFwia3VtYS1jaGVja2JveFwiLFxuICAgICAgICAgICAgICAgIGNoZWNrZWQ6IHRoaXMucHJvcHMuanN4Y2hlY2tlZCxcbiAgICAgICAgICAgICAgICBkaXNhYmxlZDogdHJ1ZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICAgICAgICdsYWJlbCcsXG4gICAgICAgICAgICAgICAgeyBjbGFzc05hbWU6ICdrdW1hLXV4dGFibGUtcm93LXNlbGVjdG9yJyB9LFxuICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoJ2lucHV0JywgX2V4dGVuZHMoeyB0eXBlOiAncmFkaW8nLCByZWY6ICdyYWRpbycgfSwgcmVuZGVyUHJvcHMpKSxcbiAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KCdzJywgbnVsbClcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgcmV0dXJuIFJhZGlvO1xufShSZWFjdC5Db21wb25lbnQpO1xuXG47XG5cblJhZGlvLnByb3BUeXBlcyA9IHt9O1xuXG5SYWRpby5kZWZhdWx0UHJvcHMgPSB7fTtcblxuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBSYWRpbztcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3V4Y29yZS10YWJsZS9idWlsZC9DZWxsL1JhZGlvLmpzXG4gKiogbW9kdWxlIGlkID0gMTYxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhvYmosIGtleXMpIHsgdmFyIHRhcmdldCA9IHt9OyBmb3IgKHZhciBpIGluIG9iaikgeyBpZiAoa2V5cy5pbmRleE9mKGkpID49IDApIGNvbnRpbnVlOyBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGkpKSBjb250aW51ZTsgdGFyZ2V0W2ldID0gb2JqW2ldOyB9IHJldHVybiB0YXJnZXQ7IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG4vKipcbiAqIEEgZWRpdGFibGUgcGxhaW4gdGV4dCBmaWVsZFxuICovXG5cbnZhciBDZWxsRmllbGQgPSByZXF1aXJlKCcuL0NlbGxGaWVsZCcpO1xudmFyIGNsYXNzbmFtZXMgPSByZXF1aXJlKCdjbGFzc25hbWVzJyk7XG52YXIgYXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xudmFyIFJlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcbnZhciBSZWFjdERPTSA9IHJlcXVpcmUoJ3JlYWN0LWRvbScpO1xuXG52YXIgVGV4dEZpZWxkID0gZnVuY3Rpb24gKF9DZWxsRmllbGQpIHtcbiAgICBfaW5oZXJpdHMoVGV4dEZpZWxkLCBfQ2VsbEZpZWxkKTtcblxuICAgIGZ1bmN0aW9uIFRleHRGaWVsZChwcm9wcykge1xuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgVGV4dEZpZWxkKTtcblxuICAgICAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX0NlbGxGaWVsZC5jYWxsKHRoaXMsIHByb3BzKSk7XG4gICAgfVxuXG4gICAgVGV4dEZpZWxkLnByb3RvdHlwZS5yZW5kZXJDb250ZW50ID0gZnVuY3Rpb24gcmVuZGVyQ29udGVudCgpIHtcbiAgICAgICAgdmFyIG1lID0gdGhpcztcbiAgICAgICAgdmFyIGRhdGFLZXkgPSBtZS5wcm9wcy5jb2x1bW4uZGF0YUtleTtcbiAgICAgICAgdmFyIGZpZWxkUHJvcHMgPSB7XG4gICAgICAgICAgICBjbGFzc05hbWU6IGNsYXNzbmFtZXMoe1xuICAgICAgICAgICAgICAgIFwia3VtYS1pbnB1dFwiOiB0cnVlXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIG9uQ2hhbmdlOiBmdW5jdGlvbiBvbkNoYW5nZShlKSB7XG4gICAgICAgICAgICAgICAgbWUuaGFuZGxlRGF0YUNoYW5nZSh7XG4gICAgICAgICAgICAgICAgICAgIGpzeGlkOiBtZS5wcm9wcy5yb3dEYXRhWydqc3hpZCddLFxuICAgICAgICAgICAgICAgICAgICBjb2x1bW46IG1lLnByb3BzLmNvbHVtbixcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGUudGFyZ2V0LnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICB0ZXh0OiBlLnRhcmdldC52YWx1ZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHZhbHVlOiBtZS5wcm9wcy52YWx1ZVxuICAgICAgICB9O1xuICAgICAgICBpZiAobWUucHJvcHMuY29sdW1uLmNvbmZpZykge1xuICAgICAgICAgICAgdmFyIF9tZSRwcm9wcyRjb2x1bW4kY29uZiA9IG1lLnByb3BzLmNvbHVtbi5jb25maWc7XG4gICAgICAgICAgICB2YXIgY2xhc3NOYW1lID0gX21lJHByb3BzJGNvbHVtbiRjb25mLmNsYXNzTmFtZTtcbiAgICAgICAgICAgIHZhciBvbkNoYW5nZSA9IF9tZSRwcm9wcyRjb2x1bW4kY29uZi5vbkNoYW5nZTtcblxuICAgICAgICAgICAgdmFyIGN1c3RvbVByb3BzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9tZSRwcm9wcyRjb2x1bW4kY29uZiwgWydjbGFzc05hbWUnLCAnb25DaGFuZ2UnXSk7XG5cbiAgICAgICAgICAgIGFzc2lnbihmaWVsZFByb3BzLCBjdXN0b21Qcm9wcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoJ2lucHV0JywgZmllbGRQcm9wcyk7XG4gICAgfTtcblxuICAgIHJldHVybiBUZXh0RmllbGQ7XG59KENlbGxGaWVsZCk7XG5cbjtcblxuVGV4dEZpZWxkLnByb3BUeXBlcyA9IGFzc2lnbih7fSwgQ2VsbEZpZWxkLnByb3BUeXBlcyk7XG5cblRleHRGaWVsZC5kZWZhdWx0UHJvcHMgPSBhc3NpZ24oe30sIENlbGxGaWVsZC5kZWZhdWx0UHJvcHMpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFRleHRGaWVsZDtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi91eGNvcmUtdGFibGUvYnVpbGQvQ2VsbC9UZXh0RmllbGQuanNcbiAqKiBtb2R1bGUgaWQgPSAxNjJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxudmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIGNsYXNzbmFtZXMgPSByZXF1aXJlKCdjbGFzc25hbWVzJyk7XG52YXIgYXNzZ2luID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xuXG52YXIgUmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xudmFyIFJlYWN0RE9NID0gcmVxdWlyZSgncmVhY3QtZG9tJyk7XG5cbnZhciBDZWxsRmllbGQgPSBmdW5jdGlvbiAoX1JlYWN0JENvbXBvbmVudCkge1xuICAgIF9pbmhlcml0cyhDZWxsRmllbGQsIF9SZWFjdCRDb21wb25lbnQpO1xuXG4gICAgZnVuY3Rpb24gQ2VsbEZpZWxkKHByb3BzKSB7XG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDZWxsRmllbGQpO1xuXG4gICAgICAgIHZhciBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9SZWFjdCRDb21wb25lbnQuY2FsbCh0aGlzLCBwcm9wcykpO1xuXG4gICAgICAgIF90aGlzLnN0YXRlID0ge1xuICAgICAgICAgICAgcGFzczogdHJ1ZVxuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG5cbiAgICBDZWxsRmllbGQucHJvdG90eXBlLmNvbXBvbmVudERpZE1vdW50ID0gZnVuY3Rpb24gY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgICAgIHZhciBtZSA9IHRoaXM7XG4gICAgICAgIG1lLnByb3BzLmF0dGFjaENlbGxGaWVsZChtZS52YWxpZGF0ZS5iaW5kKHRoaXMpLCBtZS5nZXROYW1lKCkpO1xuICAgIH07XG5cbiAgICBDZWxsRmllbGQucHJvdG90eXBlLmNvbXBvbmVudFdpbGxVbm1vdW50ID0gZnVuY3Rpb24gY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgICAgIHZhciBtZSA9IHRoaXM7XG4gICAgICAgIG1lLnByb3BzLmRldGFjaENlbGxGaWVsZChtZS5nZXROYW1lKCkpO1xuICAgIH07XG5cbiAgICBDZWxsRmllbGQucHJvdG90eXBlLmhhbmRsZURhdGFDaGFuZ2UgPSBmdW5jdGlvbiBoYW5kbGVEYXRhQ2hhbmdlKG9iaikge1xuICAgICAgICB2YXIgbWUgPSB0aGlzO1xuICAgICAgICB2YXIganN4aWQgPSBvYmouanN4aWQ7XG4gICAgICAgIHZhciBjb2x1bW4gPSBvYmouY29sdW1uO1xuICAgICAgICB2YXIgdmFsdWUgPSBvYmoudmFsdWU7XG4gICAgICAgIHZhciB0ZXh0ID0gb2JqLnRleHQ7XG5cbiAgICAgICAgbWUudmFsaWRhdGUodmFsdWUsIGZ1bmN0aW9uIChwYXNzKSB7XG4gICAgICAgICAgICBtZS5wcm9wcy5oYW5kbGVEYXRhQ2hhbmdlKGFzc2dpbih7fSwgb2JqLCB7XG4gICAgICAgICAgICAgICAgcGFzczogcGFzc1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgQ2VsbEZpZWxkLnByb3RvdHlwZS5nZXROYW1lID0gZnVuY3Rpb24gZ2V0TmFtZSgpIHtcbiAgICAgICAgdmFyIG1lID0gdGhpcztcbiAgICAgICAgcmV0dXJuIG1lLnByb3BzLmNvbHVtbi5kYXRhS2V5ICsgXCIuXCIgKyBtZS5wcm9wcy5pbmRleDtcbiAgICB9O1xuXG4gICAgQ2VsbEZpZWxkLnByb3RvdHlwZS52YWxpZGF0ZSA9IGZ1bmN0aW9uIHZhbGlkYXRlKHZhbHVlLCBjYikge1xuICAgICAgICB2YXIgbWUgPSB0aGlzO1xuICAgICAgICB2YWx1ZSA9IHZhbHVlIHx8IG1lLnByb3BzLnZhbHVlO1xuICAgICAgICB2YXIgcm93RGF0YSA9IG1lLnByb3BzLnJvd0RhdGE7XG4gICAgICAgIHZhciBydWxlcyA9IG1lLnByb3BzLmNvbHVtbi5ydWxlcztcblxuICAgICAgICB2YXIgcGFzcyA9IHRydWU7XG4gICAgICAgIHZhciBlcnJNc2cgPSBcIlwiO1xuICAgICAgICBpZiAoKHR5cGVvZiBydWxlcyA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YocnVsZXMpKSA9PSBcIm9iamVjdFwiICYmICFBcnJheS5pc0FycmF5KHJ1bGVzKSkge1xuICAgICAgICAgICAgcGFzcyA9ICEhcnVsZXMudmFsaWRhdG9yKHZhbHVlLCByb3dEYXRhKTtcbiAgICAgICAgICAgIGVyck1zZyA9IHJ1bGVzLmVyck1zZztcbiAgICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHJ1bGVzKSkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBydWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHBhc3MgPSBydWxlc1tpXS52YWxpZGF0b3IodmFsdWUsIHJvd0RhdGEpO1xuICAgICAgICAgICAgICAgIGlmICghcGFzcykge1xuICAgICAgICAgICAgICAgICAgICBlcnJNc2cgPSBydWxlc1tpXS5lcnJNc2c7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAhIWNiICYmIGNiKHBhc3MpO1xuICAgICAgICBtZS5zZXRTdGF0ZSh7XG4gICAgICAgICAgICBwYXNzOiBwYXNzLFxuICAgICAgICAgICAgZXJyTXNnOiBlcnJNc2dcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBwYXNzO1xuICAgIH07XG5cbiAgICBDZWxsRmllbGQucHJvdG90eXBlLnJlbmRlckNvbnRlbnQgPSBmdW5jdGlvbiByZW5kZXJDb250ZW50KCkge307XG5cbiAgICBDZWxsRmllbGQucHJvdG90eXBlLmFkZFNwZWNpZmljQ2xhc3MgPSBmdW5jdGlvbiBhZGRTcGVjaWZpY0NsYXNzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wcm9wcy5wcmVmaXhDbHM7XG4gICAgfTtcblxuICAgIENlbGxGaWVsZC5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgICAgICB2YXIgX2NsYXNzbmFtZXM7XG5cbiAgICAgICAgdmFyIG1lID0gdGhpcztcbiAgICAgICAgdmFyIHNwZWNpZmljQ2xzID0gbWUuYWRkU3BlY2lmaWNDbGFzcygpO1xuICAgICAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAgICdkaXYnLFxuICAgICAgICAgICAgeyBjbGFzc05hbWU6IGNsYXNzbmFtZXMoKF9jbGFzc25hbWVzID0ge1xuICAgICAgICAgICAgICAgICAgICBcImhhc0Vycm9yXCI6ICFtZS5zdGF0ZS5wYXNzXG4gICAgICAgICAgICAgICAgfSwgX2NsYXNzbmFtZXNbc3BlY2lmaWNDbHNdID0gdHJ1ZSwgX2NsYXNzbmFtZXNbbWUucHJvcHMuY2xhc3NOYW1lXSA9ICEhbWUucHJvcHMuY2xhc3NOYW1lLCBfY2xhc3NuYW1lcykpIH0sXG4gICAgICAgICAgICBtZS5yZW5kZXJDb250ZW50KClcbiAgICAgICAgKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIENlbGxGaWVsZDtcbn0oUmVhY3QuQ29tcG9uZW50KTtcblxuQ2VsbEZpZWxkLmRpc3BsYXlOYW1lID0gXCJDZWxsRmllbGRcIjtcbkNlbGxGaWVsZC5wcm9wVHlwZXMgPSB7XG4gICAgcHJlZml4Q2xzOiBSZWFjdC5Qcm9wVHlwZXMuc3RyaW5nXG59O1xuXG5DZWxsRmllbGQuZGVmYXVsdFByb3BzID0ge1xuICAgIHByZWZpeENsczogJ2t1bWEtdXh0YWJsZS1jZWxsLWZpZWxkJ1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBDZWxsRmllbGQ7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vdXhjb3JlLXRhYmxlL2J1aWxkL0NlbGwvQ2VsbEZpZWxkLmpzXG4gKiogbW9kdWxlIGlkID0gMTYzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhvYmosIGtleXMpIHsgdmFyIHRhcmdldCA9IHt9OyBmb3IgKHZhciBpIGluIG9iaikgeyBpZiAoa2V5cy5pbmRleE9mKGkpID49IDApIGNvbnRpbnVlOyBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGkpKSBjb250aW51ZTsgdGFyZ2V0W2ldID0gb2JqW2ldOyB9IHJldHVybiB0YXJnZXQ7IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgQ2VsbEZpZWxkID0gcmVxdWlyZSgnLi9DZWxsRmllbGQnKTtcbnZhciBjbGFzc25hbWVzID0gcmVxdWlyZSgnY2xhc3NuYW1lcycpO1xudmFyIGFzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcbnZhciBTZWxlY3QgPSByZXF1aXJlKCd1eGNvcmUtc2VsZWN0MicpO1xudmFyIE9wdGlvbiA9IFNlbGVjdC5PcHRpb247XG5cbnZhciBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG52YXIgUmVhY3RET00gPSByZXF1aXJlKCdyZWFjdC1kb20nKTtcblxudmFyIFNlbGVjdEZpZWxkID0gZnVuY3Rpb24gKF9DZWxsRmllbGQpIHtcbiAgICBfaW5oZXJpdHMoU2VsZWN0RmllbGQsIF9DZWxsRmllbGQpO1xuXG4gICAgZnVuY3Rpb24gU2VsZWN0RmllbGQocHJvcHMpIHtcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFNlbGVjdEZpZWxkKTtcblxuICAgICAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX0NlbGxGaWVsZC5jYWxsKHRoaXMsIHByb3BzKSk7XG4gICAgfVxuXG4gICAgU2VsZWN0RmllbGQucHJvdG90eXBlLnJlbmRlckNvbnRlbnQgPSBmdW5jdGlvbiByZW5kZXJDb250ZW50KCkge1xuICAgICAgICB2YXIgbWUgPSB0aGlzO1xuICAgICAgICB2YXIgZmllbGRQcm9wcyA9IHtcbiAgICAgICAgICAgIG9uU2VsZWN0OiBmdW5jdGlvbiBvblNlbGVjdCh2YWx1ZSwgT3B0aW9uKSB7XG4gICAgICAgICAgICAgICAgbWUuaGFuZGxlRGF0YUNoYW5nZSh7XG4gICAgICAgICAgICAgICAgICAgIGpzeGlkOiBtZS5wcm9wcy5yb3dEYXRhWydqc3hpZCddLFxuICAgICAgICAgICAgICAgICAgICBjb2x1bW46IG1lLnByb3BzLmNvbHVtbixcbiAgICAgICAgICAgICAgICAgICAgdGV4dDogT3B0aW9uLnByb3BzLmNoaWxkcmVuLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB2YWx1ZTogbWUucHJvcHMudmFsdWVcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKG1lLnByb3BzLmNvbHVtbi5jb25maWcpIHtcbiAgICAgICAgICAgIHZhciBfbWUkcHJvcHMkY29sdW1uJGNvbmYgPSBtZS5wcm9wcy5jb2x1bW4uY29uZmlnO1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gX21lJHByb3BzJGNvbHVtbiRjb25mLnZhbHVlO1xuICAgICAgICAgICAgdmFyIG9uU2VsZWN0ID0gX21lJHByb3BzJGNvbHVtbiRjb25mLm9uU2VsZWN0O1xuXG4gICAgICAgICAgICB2YXIgY3VzdG9tUHJvcHMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX21lJHByb3BzJGNvbHVtbiRjb25mLCBbJ3ZhbHVlJywgJ29uU2VsZWN0J10pO1xuXG4gICAgICAgICAgICBhc3NpZ24oZmllbGRQcm9wcywgY3VzdG9tUHJvcHMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICAgU2VsZWN0LFxuICAgICAgICAgICAgZmllbGRQcm9wcyxcbiAgICAgICAgICAgIG1lLnByb3BzLmNvbHVtbi5yZW5kZXJDaGlsZHJlbiAmJiBtZS5wcm9wcy5jb2x1bW4ucmVuZGVyQ2hpbGRyZW4oKVxuICAgICAgICApO1xuICAgIH07XG5cbiAgICByZXR1cm4gU2VsZWN0RmllbGQ7XG59KENlbGxGaWVsZCk7XG5cbjtcblxuU2VsZWN0RmllbGQucHJvcFR5cGVzID0gYXNzaWduKHt9LCBDZWxsRmllbGQucHJvcFR5cGVzKTtcblxuU2VsZWN0RmllbGQuZGVmYXVsdFByb3BzID0gYXNzaWduKHt9LCBDZWxsRmllbGQuZGVmYXVsdFByb3BzKTtcblxubW9kdWxlLmV4cG9ydHMgPSBTZWxlY3RGaWVsZDtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi91eGNvcmUtdGFibGUvYnVpbGQvQ2VsbC9TZWxlY3RGaWVsZC5qc1xuICoqIG1vZHVsZSBpZCA9IDE2NFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX3JlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxudmFyIF9yZWFjdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yZWFjdCk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IFwiZGVmYXVsdFwiOiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBPcHRHcm91cCA9IGZ1bmN0aW9uIChfUmVhY3QkQ29tcG9uZW50KSB7XG4gIF9pbmhlcml0cyhPcHRHcm91cCwgX1JlYWN0JENvbXBvbmVudCk7XG5cbiAgZnVuY3Rpb24gT3B0R3JvdXAoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIE9wdEdyb3VwKTtcblxuICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoT3B0R3JvdXApLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICB9XG5cbiAgcmV0dXJuIE9wdEdyb3VwO1xufShfcmVhY3QyW1wiZGVmYXVsdFwiXS5Db21wb25lbnQpO1xuXG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IE9wdEdyb3VwO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vdXhjb3JlLXRhYmxlL34vdXhjb3JlLXNlbGVjdDIvfi9yYy1zZWxlY3QvbGliL09wdEdyb3VwLmpzXG4gKiogbW9kdWxlIGlkID0gMTg5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLm5vb3AgPSBub29wO1xuZXhwb3J0cy5nZXRLZXlGcm9tQ2hpbGRyZW5JbmRleCA9IGdldEtleUZyb21DaGlsZHJlbkluZGV4O1xuZXhwb3J0cy5sb29wTWVudUl0ZW0gPSBsb29wTWVudUl0ZW07XG5cbnZhciBfcmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xuXG52YXIgX3JlYWN0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JlYWN0KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgXCJkZWZhdWx0XCI6IG9iaiB9OyB9XG5cbnZhciBub3cgPSBEYXRlLm5vdygpO1xuXG5mdW5jdGlvbiBub29wKCkge31cblxuZnVuY3Rpb24gZ2V0S2V5RnJvbUNoaWxkcmVuSW5kZXgoY2hpbGQsIG1lbnVFdmVudEtleSwgaW5kZXgpIHtcbiAgdmFyIHByZWZpeCA9IG1lbnVFdmVudEtleSB8fCAnJztcbiAgcmV0dXJuIGNoaWxkLmtleSB8fCBwcmVmaXggKyAnaXRlbV8nICsgbm93ICsgJ18nICsgaW5kZXg7XG59XG5cbmZ1bmN0aW9uIGxvb3BNZW51SXRlbShjaGlsZHJlbiwgY2IpIHtcbiAgdmFyIGluZGV4ID0gLTE7XG4gIF9yZWFjdDJbXCJkZWZhdWx0XCJdLkNoaWxkcmVuLmZvckVhY2goY2hpbGRyZW4sIGZ1bmN0aW9uIChjKSB7XG4gICAgaW5kZXgrKztcbiAgICBpZiAoYyAmJiBjLnR5cGUuaXNNZW51SXRlbUdyb3VwKSB7XG4gICAgICBfcmVhY3QyW1wiZGVmYXVsdFwiXS5DaGlsZHJlbi5mb3JFYWNoKGMucHJvcHMuY2hpbGRyZW4sIGZ1bmN0aW9uIChjMikge1xuICAgICAgICBpbmRleCsrO1xuICAgICAgICBjYihjMiwgaW5kZXgpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNiKGMsIGluZGV4KTtcbiAgICB9XG4gIH0pO1xufVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3V4Y29yZS10YWJsZS9+L3V4Y29yZS1zZWxlY3QyL34vcmMtc2VsZWN0L34vcmMtbWVudS9saWIvdXRpbC5qc1xuICoqIG1vZHVsZSBpZCA9IDIwNlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX3JlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxudmFyIF9yZWFjdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yZWFjdCk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IFwiZGVmYXVsdFwiOiBvYmogfTsgfVxuXG52YXIgTWVudUl0ZW1Hcm91cCA9IF9yZWFjdDJbXCJkZWZhdWx0XCJdLmNyZWF0ZUNsYXNzKHtcbiAgZGlzcGxheU5hbWU6ICdNZW51SXRlbUdyb3VwJyxcblxuICBwcm9wVHlwZXM6IHtcbiAgICByZW5kZXJNZW51SXRlbTogX3JlYWN0LlByb3BUeXBlcy5mdW5jLFxuICAgIGluZGV4OiBfcmVhY3QuUHJvcFR5cGVzLm51bWJlclxuICB9LFxuXG4gIGdldERlZmF1bHRQcm9wczogZnVuY3Rpb24gZ2V0RGVmYXVsdFByb3BzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBkaXNhYmxlZDogdHJ1ZVxuICAgIH07XG4gIH0sXG4gIHJlbmRlcklubmVyTWVudUl0ZW06IGZ1bmN0aW9uIHJlbmRlcklubmVyTWVudUl0ZW0oaXRlbSwgc3ViSW5kZXgpIHtcbiAgICB2YXIgcmVuZGVyTWVudUl0ZW0gPSB0aGlzLnByb3BzLnJlbmRlck1lbnVJdGVtO1xuICAgIHJldHVybiByZW5kZXJNZW51SXRlbShpdGVtLCB0aGlzLnByb3BzLmluZGV4LCBzdWJJbmRleCk7XG4gIH0sXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgIHZhciBwcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgdmFyIGNsYXNzTmFtZSA9IHByb3BzLmNsYXNzTmFtZSB8fCAnJztcbiAgICB2YXIgcm9vdFByZWZpeENscyA9IHByb3BzLnJvb3RQcmVmaXhDbHM7XG5cbiAgICBjbGFzc05hbWUgKz0gJyAnICsgcm9vdFByZWZpeENscyArICctaXRlbS1ncm91cCc7XG4gICAgdmFyIHRpdGxlQ2xhc3NOYW1lID0gcm9vdFByZWZpeENscyArICctaXRlbS1ncm91cC10aXRsZSc7XG4gICAgdmFyIGxpc3RDbGFzc05hbWUgPSByb290UHJlZml4Q2xzICsgJy1pdGVtLWdyb3VwLWxpc3QnO1xuICAgIHJldHVybiBfcmVhY3QyW1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFxuICAgICAgJ2xpJyxcbiAgICAgIHsgY2xhc3NOYW1lOiBjbGFzc05hbWUgfSxcbiAgICAgIF9yZWFjdDJbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICdkaXYnLFxuICAgICAgICB7IGNsYXNzTmFtZTogdGl0bGVDbGFzc05hbWUgfSxcbiAgICAgICAgcHJvcHMudGl0bGVcbiAgICAgICksXG4gICAgICBfcmVhY3QyW1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFxuICAgICAgICAndWwnLFxuICAgICAgICB7IGNsYXNzTmFtZTogbGlzdENsYXNzTmFtZSB9LFxuICAgICAgICBfcmVhY3QyW1wiZGVmYXVsdFwiXS5DaGlsZHJlbi5tYXAocHJvcHMuY2hpbGRyZW4sIHRoaXMucmVuZGVySW5uZXJNZW51SXRlbSlcbiAgICAgIClcbiAgICApO1xuICB9XG59KTtcblxuTWVudUl0ZW1Hcm91cC5pc01lbnVJdGVtR3JvdXAgPSB0cnVlO1xuXG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IE1lbnVJdGVtR3JvdXA7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi91eGNvcmUtdGFibGUvfi91eGNvcmUtc2VsZWN0Mi9+L3JjLXNlbGVjdC9+L3JjLW1lbnUvbGliL01lbnVJdGVtR3JvdXAuanNcbiAqKiBtb2R1bGUgaWQgPSAyMTJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcblxudmFyIF9yZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5cbnZhciBfcmVhY3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmVhY3QpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBcImRlZmF1bHRcIjogb2JqIH07IH1cblxudmFyIERpdmlkZXIgPSBfcmVhY3QyW1wiZGVmYXVsdFwiXS5jcmVhdGVDbGFzcyh7XG4gIGRpc3BsYXlOYW1lOiAnRGl2aWRlcicsXG4gIGdldERlZmF1bHRQcm9wczogZnVuY3Rpb24gZ2V0RGVmYXVsdFByb3BzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBkaXNhYmxlZDogdHJ1ZVxuICAgIH07XG4gIH0sXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgIHZhciBwcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgdmFyIGNsYXNzTmFtZSA9IHByb3BzLmNsYXNzTmFtZSB8fCAnJztcbiAgICB2YXIgcm9vdFByZWZpeENscyA9IHByb3BzLnJvb3RQcmVmaXhDbHM7XG4gICAgY2xhc3NOYW1lICs9ICcgJyArIChyb290UHJlZml4Q2xzICsgJy1pdGVtLWRpdmlkZXInKTtcbiAgICByZXR1cm4gX3JlYWN0MltcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudCgnbGknLCBfZXh0ZW5kcyh7fSwgcHJvcHMsIHsgY2xhc3NOYW1lOiBjbGFzc05hbWUgfSkpO1xuICB9XG59KTtcblxuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBEaXZpZGVyO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vdXhjb3JlLXRhYmxlL34vdXhjb3JlLXNlbGVjdDIvfi9yYy1zZWxlY3Qvfi9yYy1tZW51L2xpYi9EaXZpZGVyLmpzXG4gKiogbW9kdWxlIGlkID0gMjEzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfcmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xuXG52YXIgX3JlYWN0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JlYWN0KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgXCJkZWZhdWx0XCI6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIE9wdGlvbiA9IGZ1bmN0aW9uIChfUmVhY3QkQ29tcG9uZW50KSB7XG4gIF9pbmhlcml0cyhPcHRpb24sIF9SZWFjdCRDb21wb25lbnQpO1xuXG4gIGZ1bmN0aW9uIE9wdGlvbigpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgT3B0aW9uKTtcblxuICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoT3B0aW9uKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgfVxuXG4gIHJldHVybiBPcHRpb247XG59KF9yZWFjdDJbXCJkZWZhdWx0XCJdLkNvbXBvbmVudCk7XG5cbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gT3B0aW9uO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vdXhjb3JlLXRhYmxlL34vdXhjb3JlLXNlbGVjdDIvfi9yYy1zZWxlY3QvbGliL09wdGlvbi5qc1xuICoqIG1vZHVsZSBpZCA9IDIzNFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMob2JqLCBrZXlzKSB7IHZhciB0YXJnZXQgPSB7fTsgZm9yICh2YXIgaSBpbiBvYmopIHsgaWYgKGtleXMuaW5kZXhPZihpKSA+PSAwKSBjb250aW51ZTsgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBpKSkgY29udGludWU7IHRhcmdldFtpXSA9IG9ialtpXTsgfSByZXR1cm4gdGFyZ2V0OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIENlbGxGaWVsZCA9IHJlcXVpcmUoJy4vQ2VsbEZpZWxkJyk7XG52YXIgY2xhc3NuYW1lcyA9IHJlcXVpcmUoJ2NsYXNzbmFtZXMnKTtcbnZhciBhc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG52YXIgUmFkaW9Hcm91cCA9IHJlcXVpcmUoJ3V4Y29yZS1yYWRpb2dyb3VwJyk7XG52YXIgUmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xudmFyIFJlYWN0RE9NID0gcmVxdWlyZSgncmVhY3QtZG9tJyk7XG5cbnZhciBSYWRpb0ZpZWxkID0gZnVuY3Rpb24gKF9DZWxsRmllbGQpIHtcbiAgICBfaW5oZXJpdHMoUmFkaW9GaWVsZCwgX0NlbGxGaWVsZCk7XG5cbiAgICBmdW5jdGlvbiBSYWRpb0ZpZWxkKHByb3BzKSB7XG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBSYWRpb0ZpZWxkKTtcblxuICAgICAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX0NlbGxGaWVsZC5jYWxsKHRoaXMsIHByb3BzKSk7XG4gICAgfVxuXG4gICAgUmFkaW9GaWVsZC5wcm90b3R5cGUucHJvY2Vzc0NoaWxkcmVuID0gZnVuY3Rpb24gcHJvY2Vzc0NoaWxkcmVuKCkge1xuICAgICAgICB2YXIgbWUgPSB0aGlzO1xuICAgICAgICB2YXIgb2JqID0ge307XG4gICAgICAgIGlmIChtZS5wcm9wcy5jb2x1bW4ucmVuZGVyQ2hpbGRyZW4pIHtcbiAgICAgICAgICAgIG1lLnByb3BzLmNvbHVtbi5yZW5kZXJDaGlsZHJlbigpLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICBvYmpbaXRlbS5wcm9wcy52YWx1ZV0gPSBpdGVtLnByb3BzLnRleHQ7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJSYWRpb0NlbGxGaWVsZDogcmVuZGVyQ2hpbGRyZW4gbXVzdCBiZSBwYXNzZWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9O1xuXG4gICAgUmFkaW9GaWVsZC5wcm90b3R5cGUucmVuZGVyQ29udGVudCA9IGZ1bmN0aW9uIHJlbmRlckNvbnRlbnQoKSB7XG4gICAgICAgIHZhciBtZSA9IHRoaXM7XG4gICAgICAgIHZhciBkYXRhS2V5ID0gbWUucHJvcHMuY29sdW1uLmRhdGFLZXk7XG4gICAgICAgIHZhciB0ZXh0TWFwID0gbWUucHJvY2Vzc0NoaWxkcmVuKCk7XG4gICAgICAgIHZhciBmaWVsZFByb3BzID0ge1xuICAgICAgICAgICAgb25DaGFuZ2U6IGZ1bmN0aW9uIG9uQ2hhbmdlKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgbWUuaGFuZGxlRGF0YUNoYW5nZSh7XG4gICAgICAgICAgICAgICAgICAgIGpzeGlkOiBtZS5wcm9wcy5yb3dEYXRhWydqc3hpZCddLFxuICAgICAgICAgICAgICAgICAgICBjb2x1bW46IG1lLnByb3BzLmNvbHVtbixcbiAgICAgICAgICAgICAgICAgICAgdGV4dDogdGV4dE1hcFt2YWx1ZV0sXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHZhbHVlOiBtZS5wcm9wcy52YWx1ZVxuICAgICAgICB9O1xuICAgICAgICBpZiAobWUucHJvcHMuY29sdW1uLmNvbmZpZykge1xuICAgICAgICAgICAgdmFyIF9tZSRwcm9wcyRjb2x1bW4kY29uZiA9IG1lLnByb3BzLmNvbHVtbi5jb25maWc7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBfbWUkcHJvcHMkY29sdW1uJGNvbmYudmFsdWU7XG4gICAgICAgICAgICB2YXIgb25DaGFuZ2UgPSBfbWUkcHJvcHMkY29sdW1uJGNvbmYub25DaGFuZ2U7XG5cbiAgICAgICAgICAgIHZhciBjdXN0b21Qcm9wcyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhfbWUkcHJvcHMkY29sdW1uJGNvbmYsIFsndmFsdWUnLCAnb25DaGFuZ2UnXSk7XG5cbiAgICAgICAgICAgIGFzc2lnbihmaWVsZFByb3BzLCBjdXN0b21Qcm9wcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgICBSYWRpb0dyb3VwLFxuICAgICAgICAgICAgZmllbGRQcm9wcyxcbiAgICAgICAgICAgIG1lLnByb3BzLmNvbHVtbi5yZW5kZXJDaGlsZHJlbigpXG4gICAgICAgICk7XG4gICAgfTtcblxuICAgIHJldHVybiBSYWRpb0ZpZWxkO1xufShDZWxsRmllbGQpO1xuXG47XG5cblJhZGlvRmllbGQucHJvcFR5cGVzID0gYXNzaWduKHt9LCBDZWxsRmllbGQucHJvcFR5cGVzKTtcblxuUmFkaW9GaWVsZC5kZWZhdWx0UHJvcHMgPSBhc3NpZ24oe30sIENlbGxGaWVsZC5kZWZhdWx0UHJvcHMpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJhZGlvRmllbGQ7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vdXhjb3JlLXRhYmxlL2J1aWxkL0NlbGwvUmFkaW9GaWVsZC5qc1xuICoqIG1vZHVsZSBpZCA9IDIzNVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG52YXIgUmVhY3RET00gPSByZXF1aXJlKCdyZWFjdC1kb20nKTtcblxudmFyIFJhZGlvZ3JvdXBJdGVtID0gZnVuY3Rpb24gKF9SZWFjdCRDb21wb25lbnQpIHtcbiAgICBfaW5oZXJpdHMoUmFkaW9ncm91cEl0ZW0sIF9SZWFjdCRDb21wb25lbnQpO1xuXG4gICAgZnVuY3Rpb24gUmFkaW9ncm91cEl0ZW0ocHJvcHMpIHtcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFJhZGlvZ3JvdXBJdGVtKTtcblxuICAgICAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX1JlYWN0JENvbXBvbmVudC5jYWxsKHRoaXMsIHByb3BzKSk7XG4gICAgfVxuXG4gICAgUmFkaW9ncm91cEl0ZW0ucHJvdG90eXBlLl9oYW5kbGVDaGFuZ2UgPSBmdW5jdGlvbiBfaGFuZGxlQ2hhbmdlKGUpIHtcbiAgICAgICAgdmFyIG1lID0gdGhpcztcbiAgICAgICAgbWUucHJvcHMub25DaGFuZ2UobWUucHJvcHMudmFsdWUpO1xuICAgIH07XG5cbiAgICBSYWRpb2dyb3VwSXRlbS5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgICAgICB2YXIgbWUgPSB0aGlzO1xuICAgICAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAgICdsYWJlbCcsXG4gICAgICAgICAgICB7IGNsYXNzTmFtZTogJycgKyBtZS5wcm9wcy5wcmVmaXhDbHMgfSxcbiAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoJ2lucHV0JywgeyB0eXBlOiAncmFkaW8nLCBkaXNhYmxlZDogbWUucHJvcHMuZGlzYWJsZWQsIHJlZjogJ3JhZGlvJywgY2xhc3NOYW1lOiAna3VtYS1jaGVja2JveCcsIGNoZWNrZWQ6IG1lLnByb3BzLmNoZWNrZWQsIG9uQ2hhbmdlOiBtZS5faGFuZGxlQ2hhbmdlLmJpbmQobWUpIH0pLFxuICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudCgncycsIG51bGwpLFxuICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAgICAgICAnc3BhbicsXG4gICAgICAgICAgICAgICAgeyBjbGFzc05hbWU6IG1lLnByb3BzLnByZWZpeENscyArICctY29udGVudCcgfSxcbiAgICAgICAgICAgICAgICBtZS5wcm9wcy50ZXh0XG4gICAgICAgICAgICApXG4gICAgICAgICk7XG4gICAgfTtcblxuICAgIHJldHVybiBSYWRpb2dyb3VwSXRlbTtcbn0oUmVhY3QuQ29tcG9uZW50KTtcblxuUmFkaW9ncm91cEl0ZW0uZGlzcGxheU5hbWUgPSBcIlJhZGlvZ3JvdXBJdGVtXCI7XG5SYWRpb2dyb3VwSXRlbS5wcm9wVHlwZXMgPSB7XG4gICAgcHJlZml4Q2xzOiBSZWFjdC5Qcm9wVHlwZXMuc3RyaW5nLFxuICAgIHRleHQ6IFJlYWN0LlByb3BUeXBlcy5zdHJpbmcsXG4gICAgdmFsdWU6IFJlYWN0LlByb3BUeXBlcy5zdHJpbmcsXG4gICAgY2xhc3NOYW1lOiBSZWFjdC5Qcm9wVHlwZXMuc3RyaW5nLFxuICAgIGRpc2FibGVkOiBSZWFjdC5Qcm9wVHlwZXMuYm9vbCxcbiAgICBvbkNoYW5nZTogUmVhY3QuUHJvcFR5cGVzLmZ1bmNcbn07XG5SYWRpb2dyb3VwSXRlbS5kZWZhdWx0UHJvcHMgPSB7XG4gICAgcHJlZml4Q2xzOiBcImt1bWEtcmFkaW8tZ3JvdXAtaXRlbVwiLFxuICAgIHRleHQ6IFwiXCIsXG4gICAgdmFsdWU6IFwiXCIsXG4gICAgY2xhc3NOYW1lOiBcImt1bWEtY2hlY2tib3hcIixcbiAgICBkaXNhYmxlZDogZmFsc2UsXG4gICAgb25DaGFuZ2U6IGZ1bmN0aW9uIG9uQ2hhbmdlKCkge31cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmFkaW9ncm91cEl0ZW07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vdXhjb3JlLXRhYmxlL34vdXhjb3JlLXJhZGlvZ3JvdXAvYnVpbGQvUmFkaW9ncm91cEl0ZW0uanNcbiAqKiBtb2R1bGUgaWQgPSAyMzhcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgRm9ybWF0dGVyID0gcmVxdWlyZSgndXhjb3JlLWZvcm1hdHRlcicpO1xudmFyIHV0aWwgPSB7XG4gICAgZm9ybWF0VmFsdWU6IGZ1bmN0aW9uIGZvcm1hdFZhbHVlKHZhbHVlLCB0eXBlLCBkZWxpbWl0ZXIpIHtcbiAgICAgICAgZGVsaW1pdGVyID0gZGVsaW1pdGVyIHx8IFwiIFwiO1xuICAgICAgICBpZiAodmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHZhbHVlID0gdmFsdWUgKyBcIlwiO1xuICAgICAgICBpZiAodHlwZSA9PSBcIm1vbmV5XCIpIHtcbiAgICAgICAgICAgIHJldHVybiBGb3JtYXR0ZXIubW9uZXkodmFsdWUsIGRlbGltaXRlcik7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PSBcImNhcmRcIikge1xuICAgICAgICAgICAgcmV0dXJuIEZvcm1hdHRlci5jYXJkKHZhbHVlLCBkZWxpbWl0ZXIpO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT0gXCJjbm1vYmlsZVwiKSB7XG4gICAgICAgICAgICByZXR1cm4gRm9ybWF0dGVyLmNubW9iaWxlKHZhbHVlLCBkZWxpbWl0ZXIpO1xuICAgICAgICB9XG4gICAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSB1dGlsO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3V4Y29yZS10YWJsZS9idWlsZC9DZWxsL1V0aWwuanNcbiAqKiBtb2R1bGUgaWQgPSAyMzlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogRm9ybWF0dGVyIENvbXBvbmVudCBmb3IgdXhjb3JlXG4gKiBAYXV0aG9yIGV0ZXJuYWxza3lcbiAqXG4gKiBDb3B5cmlnaHQgMjAxNC0yMDE1LCBVeGNvcmUgVGVhbSwgQWxpbncuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICovXG5cbnZhciBGb3JtYXR0ZXIgPSB7fTtcblxuRm9ybWF0dGVyLmRhdGUgPSBmdW5jdGlvbihzdHIsIHBhdHRlcm4pIHtcbiAgICB2YXIgZGF0ZSA9IG5ldyBEYXRlKHN0cik7XG4gICAgcGF0dGVybiA9IHBhdHRlcm4gfHwgJ1lZWVktTU0tREQnO1xuICAgIHZhciBvID0ge1xuICAgICAgICBcIk0rXCI6IGRhdGUuZ2V0TW9udGgoKSArIDEsIC8v5pyI5Lu9IFxuICAgICAgICBcIkQrXCI6IGRhdGUuZ2V0RGF0ZSgpLCAvL+aXpSBcbiAgICAgICAgXCJkK1wiOiBkYXRlLmdldERhdGUoKSwgLy/ml6UgXG4gICAgICAgIFwiSCtcIjogZGF0ZS5nZXRIb3VycygpLCAvL+Wwj+aXtiBcbiAgICAgICAgXCJoK1wiOiBkYXRlLmdldEhvdXJzKCksIC8v5bCP5pe2IFxuICAgICAgICBcIm0rXCI6IGRhdGUuZ2V0TWludXRlcygpLCAvL+WIhiBcbiAgICAgICAgXCJzK1wiOiBkYXRlLmdldFNlY29uZHMoKSwgLy/np5IgXG4gICAgICAgIFwiUStcIjogTWF0aC5mbG9vcigoZGF0ZS5nZXRNb250aCgpICsgMykgLyAzKSwgLy/lraPluqYgXG4gICAgICAgIFwicStcIjogTWF0aC5mbG9vcigoZGF0ZS5nZXRNb250aCgpICsgMykgLyAzKSwgLy/lraPluqYgXG4gICAgICAgIFwiU1wiOiBkYXRlLmdldE1pbGxpc2Vjb25kcygpIC8v5q+r56eSIFxuICAgIH07XG4gICAgaWYgKC8oeSspL2kudGVzdChwYXR0ZXJuKSkge1xuICAgICAgICBwYXR0ZXJuID0gcGF0dGVybi5yZXBsYWNlKFJlZ0V4cC4kMSwgKGRhdGUuZ2V0RnVsbFllYXIoKSArIFwiXCIpLnN1YnN0cig0IC0gUmVnRXhwLiQxLmxlbmd0aCkpO1xuICAgIH1cbiAgICBmb3IgKHZhciBrIGluIG8pIHtcbiAgICAgICAgaWYgKG5ldyBSZWdFeHAoXCIoXCIgKyBrICsgXCIpXCIpLnRlc3QocGF0dGVybikpIHBhdHRlcm4gPSBwYXR0ZXJuLnJlcGxhY2UoUmVnRXhwLiQxLCAoUmVnRXhwLiQxLmxlbmd0aCA9PSAxKSA/IChvW2tdKSA6ICgoXCIwMFwiICsgb1trXSkuc3Vic3RyKChcIlwiICsgb1trXSkubGVuZ3RoKSkpO1xuICAgIH1cbiAgICByZXR1cm4gcGF0dGVybjtcbn1cblxuRm9ybWF0dGVyLm1vbmV5ID0gZnVuY3Rpb24oc3RyLCBkZWxpbWl0ZXIsIGZpeGVkTnVtKSB7XG4gICAgZGVsaW1pdGVyID0gZGVsaW1pdGVyIHx8IFwiIFwiO1xuICAgIGlmIChmaXhlZE51bSkge1xuICAgICAgICBzdHIgPSBwYXJzZUZsb2F0KHN0cikudG9GaXhlZChmaXhlZE51bSkudG9TdHJpbmcoKVxuICAgIH1cbiAgICBpZiAoc3RyLmluZGV4T2YoXCIuXCIpICE9PSAtMSkge1xuICAgICAgICByZXR1cm4gc3RyLnJlcGxhY2UoLyhcXGQpKD89KD86XFxkezN9KSsoXFwuKSkvZywgZnVuY3Rpb24obWF0Y2gsICQxKSB7XG4gICAgICAgICAgICByZXR1cm4gJDEgKyBkZWxpbWl0ZXI7XG4gICAgICAgIH0pLnJlcGxhY2UoLyhcXGR7M30pKD8hWyR8XFwufFxcKHxcXHNdKS9nLCBmdW5jdGlvbihtYXRjaCwgJDEpIHtcbiAgICAgICAgICAgIHJldHVybiAkMTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gc3RyLnJlcGxhY2UoLyhcXGQpKD89KD86XFxkezN9KSskKS9nLCBmdW5jdGlvbihtYXRjaCwgJDEpIHtcbiAgICAgICAgICAgIHJldHVybiAkMSArIGRlbGltaXRlcjtcbiAgICAgICAgfSlcbiAgICB9XG59XG5cbkZvcm1hdHRlci5jbm1vYmlsZSA9IGZ1bmN0aW9uKHN0ciwgZGVsaW1pdGVyKSB7XG4gICAgZGVsaW1pdGVyID0gZGVsaW1pdGVyIHx8IFwiIFwiO1xuICAgIHJldHVybiBzdHIucmVwbGFjZSgvXihcXCs/MD84NikoPyEkKS8sIFwiJDFcIiArIGRlbGltaXRlcikucmVwbGFjZSgvKFxcZHs0fSkoPyEkKS9nLCBcIiQxXCIgKyBkZWxpbWl0ZXIpO1xufVxuXG5Gb3JtYXR0ZXIuY2FyZCA9IGZ1bmN0aW9uKHN0ciwgZGVsaW1pdGVyKSB7XG4gICAgZGVsaW1pdGVyID0gZGVsaW1pdGVyIHx8IFwiIFwiO1xuICAgIHJldHVybiBzdHIucmVwbGFjZSgvKFxcZHs0fSkoPyEkKS9nLCBcIiQxXCIgKyBkZWxpbWl0ZXIpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEZvcm1hdHRlcjtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi91eGNvcmUtdGFibGUvfi91eGNvcmUtZm9ybWF0dGVyL3NyYy9Gb3JtYXR0ZXIuanNcbiAqKiBtb2R1bGUgaWQgPSAyNDFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qIVxuICogQGxpY2Vuc2UgZGVlcGNvcHkuanMgQ29weXJpZ2h0KGMpIDIwMTMgc2FzYSsxXG4gKiBodHRwczovL2dpdGh1Yi5jb20vc2FzYXBsdXMxL2RlZXBjb3B5LmpzXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXG4gKi9cblxuXG4vKipcbiAqIGV4cG9ydCB0byBBTUQvQ29tbW9uSlMvZ2xvYmFsLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBnbG9iYWwgZ2xvYmFsIG9iamVjdC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZhY3RvcnkgZmFjdG9yeSBtZXRob2QuXG4gKi9cbihmdW5jdGlvbihnbG9iYWwsIGZhY3RvcnkpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmICEhZGVmaW5lLmFtZCkge1xuICAgIGRlZmluZShmYWN0b3J5KTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcbiAgfSBlbHNlIHtcbiAgICBnbG9iYWwuZGVlcGNvcHkgPSBmYWN0b3J5KCk7XG4gIH1cbn0odGhpcywgZnVuY3Rpb24oKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgaXNOb2RlLCB1dGlsLCBpc0J1ZmZlciwgZ2V0S2V5cywgZ2V0U3ltYm9scywgaW5kZXhPZkFycmF5O1xuXG4gIC8vIGlzIG5vZGUuanMvaW8uanM/XG4gIGlzTm9kZSA9ICh0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHJlcXVpcmUgIT09ICd1bmRlZmluZWQnKTtcblxuICAvLyBmYWxsYmFjayB1dGlsIG1vZHVsZSBmb3IgYnJvd3Nlci5cbiAgdXRpbCA9IChpc05vZGUpID8gcmVxdWlyZSgndXRpbCcpIDogKGZ1bmN0aW9uKCkge1xuICAgIGZ1bmN0aW9uIGlzQXJyYXkodmFsdWUpIHtcbiAgICAgIHJldHVybiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT09ICdbb2JqZWN0IEFycmF5XScpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzRGF0ZSh2YWx1ZSkge1xuICAgICAgcmV0dXJuICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmXG4gICAgICAgICAgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSA9PT0gJ1tvYmplY3QgRGF0ZV0nKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc1JlZ0V4cCh2YWx1ZSkge1xuICAgICAgcmV0dXJuICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmXG4gICAgICAgICAgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSA9PT0gJ1tvYmplY3QgUmVnRXhwXScpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzU3ltYm9sKHZhbHVlKSB7XG4gICAgICByZXR1cm4gKHR5cGVvZiB2YWx1ZSA9PT0gJ3N5bWJvbCcpO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBpc0FycmF5OiAodHlwZW9mIEFycmF5LmlzQXJyYXkgPT09ICdmdW5jdGlvbicpID9cbiAgICAgICAgICBmdW5jdGlvbihvYmopIHtcbiAgICAgICAgICAgIHJldHVybiBBcnJheS5pc0FycmF5KG9iaik7XG4gICAgICAgICAgfSA6IGlzQXJyYXksXG4gICAgICBpc0RhdGU6IGlzRGF0ZSxcbiAgICAgIGlzUmVnRXhwOiBpc1JlZ0V4cCxcbiAgICAgIGlzU3ltYm9sOiAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJykgP1xuICAgICAgICAgIGlzU3ltYm9sIDpcbiAgICAgICAgICBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIC8vIGFsd2F5cyByZXR1cm4gZmFsc2Ugd2hlbiBTeW1ib2wgaXMgbm90IHN1cHBvcnRlZC5cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgfTtcbiAgfSgpKTtcblxuICAvLyBmYWxsYmFjayBCdWZmZXIuaXNCdWZmZXJcbiAgaXNCdWZmZXIgPSAoaXNOb2RlKSA/XG4gICAgICBmdW5jdGlvbihvYmopIHtcbiAgICAgICAgcmV0dXJuIEJ1ZmZlci5pc0J1ZmZlcihvYmopO1xuICAgICAgfSA6XG4gICAgICBmdW5jdGlvbigpIHtcbiAgICAgICAgLy8gaWYgYnJvd3NlciwgYWx3YXlzIHJldHVybiBmYWxzZVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9O1xuXG4gIC8vIGZhbGxiYWNrIE9iamVjdC5rZXlzIGZvciBvbGQgYnJvd3NlcnMuXG4gIGdldEtleXMgPSAodHlwZW9mIE9iamVjdC5rZXlzID09PSAnZnVuY3Rpb24nKSA/XG4gICAgICBmdW5jdGlvbihvYmopIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKG9iaik7XG4gICAgICB9IDpcbiAgICAgIGZ1bmN0aW9uKG9iaikge1xuICAgICAgICB2YXIga2V5cyA9IFtdLFxuICAgICAgICAgICAga2V5O1xuXG4gICAgICAgIGlmIChvYmogPT09IG51bGwgfHwgdHlwZW9mIG9iaiAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdvYmogaXMgbm90IGFuIE9iamVjdCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChrZXkgaW4gb2JqKSB7XG4gICAgICAgICAgb2JqLmhhc093blByb3BlcnR5KGtleSkgJiYga2V5cy5wdXNoKGtleSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ga2V5cztcbiAgICAgIH07XG5cbiAgLy8gZ2V0IHN5bWJvbHMgaW4gb2JqZWN0LlxuICBnZXRTeW1ib2xzID0gKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicpID9cbiAgICAgIGZ1bmN0aW9uKG9iaikge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmopO1xuICAgICAgfSA6XG4gICAgICBmdW5jdGlvbigpIHtcbiAgICAgICAgLy8gYWx3YXlzIHJldHVybiBlbXB0eSBhcnJheSB3aGVuIFN5bWJvbCBpcyBub3Qgc3VwcG9ydGVkLlxuICAgICAgICByZXR1cm4gW107XG4gICAgICB9O1xuXG4gIC8vIGZhbGxiYWNrIEFycmF5I2luZGV4T2YgZm9yIG9sZCBicm93c2Vycy5cbiAgaW5kZXhPZkFycmF5ID0gKHR5cGVvZiBBcnJheS5wcm90b3R5cGUuaW5kZXhPZiA9PT0gJ2Z1bmN0aW9uJykgP1xuICAgICAgZnVuY3Rpb24oYXJyYXksIHNlYXJjaEVsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIGFycmF5LmluZGV4T2Yoc2VhcmNoRWxlbWVudCk7XG4gICAgICB9IDpcbiAgICAgIGZ1bmN0aW9uKGFycmF5LCBzZWFyY2hFbGVtZW50KSB7XG4gICAgICAgIHZhciBpLCBsZW47XG5cbiAgICAgICAgaWYgKCF1dGlsLmlzQXJyYXkoYXJyYXkpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignYXJyYXkgaXMgbm90IGFuIEFycmF5Jyk7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSBhcnJheS5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgICAgIGlmIChhcnJheVtpXSA9PT0gc2VhcmNoRWxlbWVudCkge1xuICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgfTtcblxuICAvKipcbiAgICogcmVjdXJzaXZlIGRlZXAgY29weSBmb3IgdmFsdWUuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgY29weSB0YXJnZXQuXG4gICAqIEBwYXJhbSB7Kn0gY2xvbmVcbiAgICogQHBhcmFtIHtBcnJheX0gdmlzaXRlZFxuICAgKiBAcGFyYW0ge0FycmF5fSByZWZlcmVuY2VcbiAgICogQHJldHVybiB7Kn0gY29waWVkIHZhbHVlLlxuICAgKi9cbiAgZnVuY3Rpb24gY29weVZhbHVlXyh2YWx1ZSwgY2xvbmUsIHZpc2l0ZWQsIHJlZmVyZW5jZSkge1xuICAgIHZhciBzdHIsIHBvcywgYnVmLCBrZXlzLCBpLCBsZW4sIGtleSwgdmFsLCBpZHgsIG9iaiwgcmVmO1xuXG4gICAgLy8gbnVtYmVyLCBzdHJpbmcsIGJvb2xlYW4sIG51bGwsIHVuZGVmaW5lZCwgZnVuY3Rpb24gYW5kIHN5bWJvbC5cbiAgICBpZiAodmFsdWUgPT09IG51bGwgfHwgdHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0Jykge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIC8vIERhdGUuXG4gICAgaWYgKHV0aWwuaXNEYXRlKHZhbHVlKSkge1xuICAgICAgLy8gRmlyZWZveCBuZWVkIHRvIGNvbnZlcnQgdG8gTnVtYmVyXG4gICAgICAvL1xuICAgICAgLy8gRmlyZWZveDpcbiAgICAgIC8vICAgdmFyIGRhdGUgPSBuZXcgRGF0ZTtcbiAgICAgIC8vICAgK2RhdGU7ICAgICAgICAgICAgLy8gMTQyMDkwOTM2NTk2N1xuICAgICAgLy8gICArbmV3IERhdGUoZGF0ZSk7ICAvLyAxNDIwOTA5MzY1MDAwXG4gICAgICAvLyAgICtuZXcgRGF0ZSgrZGF0ZSk7IC8vIDE0MjA5MDkzNjU5NjdcbiAgICAgIC8vIENocm9tZTpcbiAgICAgIC8vICAgdmFyIGRhdGUgPSBuZXcgRGF0ZTtcbiAgICAgIC8vICAgK2RhdGU7ICAgICAgICAgICAgLy8gMTQyMDkwOTc1NzkxM1xuICAgICAgLy8gICArbmV3IERhdGUoZGF0ZSk7ICAvLyAxNDIwOTA5NzU3OTEzXG4gICAgICAvLyAgICtuZXcgRGF0ZSgrZGF0ZSk7IC8vIDE0MjA5MDk3NTc5MTNcbiAgICAgIHJldHVybiBuZXcgRGF0ZSgrdmFsdWUpO1xuICAgIH1cblxuICAgIC8vIFJlZ0V4cC5cbiAgICBpZiAodXRpbC5pc1JlZ0V4cCh2YWx1ZSkpIHtcbiAgICAgIC8vIENocm9tZSwgU2FmYXJpOlxuICAgICAgLy8gICAobmV3IFJlZ0V4cCkuc291cmNlID0+IFwiKD86KVwiXG4gICAgICAvLyBGaXJlZm94OlxuICAgICAgLy8gICAobmV3IFJlZ0V4cCkuc291cmNlID0+IFwiXCJcbiAgICAgIC8vIENocm9tZSwgU2FmYXJpLCBGaXJlZm94XG4gICAgICAvLyAgIFN0cmluZyhuZXcgUmVnRXhwKSA9PiBcIi8oPzopL1wiXG4gICAgICBzdHIgPSBTdHJpbmcodmFsdWUpO1xuICAgICAgcG9zID0gc3RyLmxhc3RJbmRleE9mKCcvJyk7XG5cbiAgICAgIHJldHVybiBuZXcgUmVnRXhwKHN0ci5zbGljZSgxLCBwb3MpLCBzdHIuc2xpY2UocG9zICsgMSkpO1xuICAgIH1cblxuICAgIC8vIEJ1ZmZlciwgbm9kZS5qcyBvbmx5LlxuICAgIGlmIChpc0J1ZmZlcih2YWx1ZSkpIHtcbiAgICAgIGJ1ZiA9IG5ldyBCdWZmZXIodmFsdWUubGVuZ3RoKTtcbiAgICAgIHZhbHVlLmNvcHkoYnVmKTtcblxuICAgICAgcmV0dXJuIGJ1ZjtcbiAgICB9XG5cbiAgICAvLyBPYmplY3Qgb3IgQXJyYXkuXG4gICAga2V5cyA9IGdldEtleXModmFsdWUpLmNvbmNhdChnZXRTeW1ib2xzKHZhbHVlKSk7XG5cbiAgICBmb3IgKGkgPSAwLCBsZW4gPSBrZXlzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICBrZXkgPSBrZXlzW2ldO1xuICAgICAgdmFsID0gdmFsdWVba2V5XTtcblxuICAgICAgaWYgKHZhbCAhPT0gbnVsbCAmJiB0eXBlb2YgdmFsID09PSAnb2JqZWN0Jykge1xuICAgICAgICBpZHggPSBpbmRleE9mQXJyYXkodmlzaXRlZCwgdmFsKTtcblxuICAgICAgICBpZiAoaWR4ID09PSAtMSkge1xuICAgICAgICAgIC8vIG5vdCBjaXJjdWxhciByZWZlcmVuY2VcbiAgICAgICAgICBvYmogPSAodXRpbC5pc0FycmF5KHZhbCkpID8gW10gOiB7fTtcblxuICAgICAgICAgIHZpc2l0ZWQucHVzaCh2YWwpO1xuICAgICAgICAgIHJlZmVyZW5jZS5wdXNoKG9iaik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gY2lyY3VsYXIgcmVmZXJlbmNlXG4gICAgICAgICAgcmVmID0gcmVmZXJlbmNlW2lkeF07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY2xvbmVba2V5XSA9IHJlZiB8fCBjb3B5VmFsdWVfKHZhbCwgb2JqLCB2aXNpdGVkLCByZWZlcmVuY2UpO1xuICAgIH1cblxuICAgIHJldHVybiBjbG9uZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBkZWVwIGNvcHkgZm9yIHZhbHVlLlxuICAgKlxuICAgKiBAcGFyYW0geyp9IHZhbHVlIGNvcHkgdGFyZ2V0LlxuICAgKi9cbiAgZnVuY3Rpb24gZGVlcGNvcHkodmFsdWUpIHtcbiAgICB2YXIgY2xvbmUgPSAodXRpbC5pc0FycmF5KHZhbHVlKSkgPyBbXSA6IHt9LFxuICAgICAgICB2aXNpdGVkID0gW3ZhbHVlXSxcbiAgICAgICAgcmVmZXJlbmNlID0gW2Nsb25lXTtcblxuICAgIHJldHVybiBjb3B5VmFsdWVfKHZhbHVlLCBjbG9uZSwgdmlzaXRlZCwgcmVmZXJlbmNlKTtcbiAgfVxuXG4gIHJldHVybiBkZWVwY29weTtcbn0pKTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3V4Y29yZS10YWJsZS9+L2RlZXBjb3B5L2RlZXBjb3B5LmpzXG4gKiogbW9kdWxlIGlkID0gMjQyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcblxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xudmFyIHF1ZXVlID0gW107XG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcbnZhciBjdXJyZW50UXVldWU7XG52YXIgcXVldWVJbmRleCA9IC0xO1xuXG5mdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKSB7XG4gICAgaWYgKCFkcmFpbmluZyB8fCAhY3VycmVudFF1ZXVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBxdWV1ZSA9IGN1cnJlbnRRdWV1ZS5jb25jYXQocXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICB9XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBkcmFpblF1ZXVlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuICAgIGlmIChkcmFpbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0aW1lb3V0ID0gc2V0VGltZW91dChjbGVhblVwTmV4dFRpY2spO1xuICAgIGRyYWluaW5nID0gdHJ1ZTtcblxuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUobGVuKSB7XG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIH1cbiAgICBjdXJyZW50UXVldWUgPSBudWxsO1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xufVxuXG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcbiAgICAgICAgc2V0VGltZW91dChkcmFpblF1ZXVlLCAwKTtcbiAgICB9XG59O1xuXG4vLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXG5mdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcbiAgICB0aGlzLmZ1biA9IGZ1bjtcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG59XG5JdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XG59O1xucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogL3Vzci9sb2NhbC9saWIvfi8ubnBtaW5zdGFsbC9wcm9jZXNzLzAuMTEuMy9wcm9jZXNzL2Jyb3dzZXIuanNcbiAqKiBtb2R1bGUgaWQgPSAyNDNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qIVxuICogVGhlIGJ1ZmZlciBtb2R1bGUgZnJvbSBub2RlLmpzLCBmb3IgdGhlIGJyb3dzZXIuXG4gKlxuICogQGF1dGhvciAgIEZlcm9zcyBBYm91a2hhZGlqZWggPGZlcm9zc0BmZXJvc3Mub3JnPiA8aHR0cDovL2Zlcm9zcy5vcmc+XG4gKiBAbGljZW5zZSAgTUlUXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG5vLXByb3RvICovXG5cbid1c2Ugc3RyaWN0J1xuXG52YXIgYmFzZTY0ID0gcmVxdWlyZSgnYmFzZTY0LWpzJylcbnZhciBpZWVlNzU0ID0gcmVxdWlyZSgnaWVlZTc1NCcpXG52YXIgaXNBcnJheSA9IHJlcXVpcmUoJ2lzYXJyYXknKVxuXG5leHBvcnRzLkJ1ZmZlciA9IEJ1ZmZlclxuZXhwb3J0cy5TbG93QnVmZmVyID0gU2xvd0J1ZmZlclxuZXhwb3J0cy5JTlNQRUNUX01BWF9CWVRFUyA9IDUwXG5CdWZmZXIucG9vbFNpemUgPSA4MTkyIC8vIG5vdCB1c2VkIGJ5IHRoaXMgaW1wbGVtZW50YXRpb25cblxudmFyIHJvb3RQYXJlbnQgPSB7fVxuXG4vKipcbiAqIElmIGBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVGA6XG4gKiAgID09PSB0cnVlICAgIFVzZSBVaW50OEFycmF5IGltcGxlbWVudGF0aW9uIChmYXN0ZXN0KVxuICogICA9PT0gZmFsc2UgICBVc2UgT2JqZWN0IGltcGxlbWVudGF0aW9uIChtb3N0IGNvbXBhdGlibGUsIGV2ZW4gSUU2KVxuICpcbiAqIEJyb3dzZXJzIHRoYXQgc3VwcG9ydCB0eXBlZCBhcnJheXMgYXJlIElFIDEwKywgRmlyZWZveCA0KywgQ2hyb21lIDcrLCBTYWZhcmkgNS4xKyxcbiAqIE9wZXJhIDExLjYrLCBpT1MgNC4yKy5cbiAqXG4gKiBEdWUgdG8gdmFyaW91cyBicm93c2VyIGJ1Z3MsIHNvbWV0aW1lcyB0aGUgT2JqZWN0IGltcGxlbWVudGF0aW9uIHdpbGwgYmUgdXNlZCBldmVuXG4gKiB3aGVuIHRoZSBicm93c2VyIHN1cHBvcnRzIHR5cGVkIGFycmF5cy5cbiAqXG4gKiBOb3RlOlxuICpcbiAqICAgLSBGaXJlZm94IDQtMjkgbGFja3Mgc3VwcG9ydCBmb3IgYWRkaW5nIG5ldyBwcm9wZXJ0aWVzIHRvIGBVaW50OEFycmF5YCBpbnN0YW5jZXMsXG4gKiAgICAgU2VlOiBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD02OTU0MzguXG4gKlxuICogICAtIFNhZmFyaSA1LTcgbGFja3Mgc3VwcG9ydCBmb3IgY2hhbmdpbmcgdGhlIGBPYmplY3QucHJvdG90eXBlLmNvbnN0cnVjdG9yYCBwcm9wZXJ0eVxuICogICAgIG9uIG9iamVjdHMuXG4gKlxuICogICAtIENocm9tZSA5LTEwIGlzIG1pc3NpbmcgdGhlIGBUeXBlZEFycmF5LnByb3RvdHlwZS5zdWJhcnJheWAgZnVuY3Rpb24uXG4gKlxuICogICAtIElFMTAgaGFzIGEgYnJva2VuIGBUeXBlZEFycmF5LnByb3RvdHlwZS5zdWJhcnJheWAgZnVuY3Rpb24gd2hpY2ggcmV0dXJucyBhcnJheXMgb2ZcbiAqICAgICBpbmNvcnJlY3QgbGVuZ3RoIGluIHNvbWUgc2l0dWF0aW9ucy5cblxuICogV2UgZGV0ZWN0IHRoZXNlIGJ1Z2d5IGJyb3dzZXJzIGFuZCBzZXQgYEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUYCB0byBgZmFsc2VgIHNvIHRoZXlcbiAqIGdldCB0aGUgT2JqZWN0IGltcGxlbWVudGF0aW9uLCB3aGljaCBpcyBzbG93ZXIgYnV0IGJlaGF2ZXMgY29ycmVjdGx5LlxuICovXG5CdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCA9IGdsb2JhbC5UWVBFRF9BUlJBWV9TVVBQT1JUICE9PSB1bmRlZmluZWRcbiAgPyBnbG9iYWwuVFlQRURfQVJSQVlfU1VQUE9SVFxuICA6IHR5cGVkQXJyYXlTdXBwb3J0KClcblxuZnVuY3Rpb24gdHlwZWRBcnJheVN1cHBvcnQgKCkge1xuICBmdW5jdGlvbiBCYXIgKCkge31cbiAgdHJ5IHtcbiAgICB2YXIgYXJyID0gbmV3IFVpbnQ4QXJyYXkoMSlcbiAgICBhcnIuZm9vID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gNDIgfVxuICAgIGFyci5jb25zdHJ1Y3RvciA9IEJhclxuICAgIHJldHVybiBhcnIuZm9vKCkgPT09IDQyICYmIC8vIHR5cGVkIGFycmF5IGluc3RhbmNlcyBjYW4gYmUgYXVnbWVudGVkXG4gICAgICAgIGFyci5jb25zdHJ1Y3RvciA9PT0gQmFyICYmIC8vIGNvbnN0cnVjdG9yIGNhbiBiZSBzZXRcbiAgICAgICAgdHlwZW9mIGFyci5zdWJhcnJheSA9PT0gJ2Z1bmN0aW9uJyAmJiAvLyBjaHJvbWUgOS0xMCBsYWNrIGBzdWJhcnJheWBcbiAgICAgICAgYXJyLnN1YmFycmF5KDEsIDEpLmJ5dGVMZW5ndGggPT09IDAgLy8gaWUxMCBoYXMgYnJva2VuIGBzdWJhcnJheWBcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbmZ1bmN0aW9uIGtNYXhMZW5ndGggKCkge1xuICByZXR1cm4gQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlRcbiAgICA/IDB4N2ZmZmZmZmZcbiAgICA6IDB4M2ZmZmZmZmZcbn1cblxuLyoqXG4gKiBDbGFzczogQnVmZmVyXG4gKiA9PT09PT09PT09PT09XG4gKlxuICogVGhlIEJ1ZmZlciBjb25zdHJ1Y3RvciByZXR1cm5zIGluc3RhbmNlcyBvZiBgVWludDhBcnJheWAgdGhhdCBhcmUgYXVnbWVudGVkXG4gKiB3aXRoIGZ1bmN0aW9uIHByb3BlcnRpZXMgZm9yIGFsbCB0aGUgbm9kZSBgQnVmZmVyYCBBUEkgZnVuY3Rpb25zLiBXZSB1c2VcbiAqIGBVaW50OEFycmF5YCBzbyB0aGF0IHNxdWFyZSBicmFja2V0IG5vdGF0aW9uIHdvcmtzIGFzIGV4cGVjdGVkIC0tIGl0IHJldHVybnNcbiAqIGEgc2luZ2xlIG9jdGV0LlxuICpcbiAqIEJ5IGF1Z21lbnRpbmcgdGhlIGluc3RhbmNlcywgd2UgY2FuIGF2b2lkIG1vZGlmeWluZyB0aGUgYFVpbnQ4QXJyYXlgXG4gKiBwcm90b3R5cGUuXG4gKi9cbmZ1bmN0aW9uIEJ1ZmZlciAoYXJnKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBCdWZmZXIpKSB7XG4gICAgLy8gQXZvaWQgZ29pbmcgdGhyb3VnaCBhbiBBcmd1bWVudHNBZGFwdG9yVHJhbXBvbGluZSBpbiB0aGUgY29tbW9uIGNhc2UuXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSByZXR1cm4gbmV3IEJ1ZmZlcihhcmcsIGFyZ3VtZW50c1sxXSlcbiAgICByZXR1cm4gbmV3IEJ1ZmZlcihhcmcpXG4gIH1cblxuICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpcy5sZW5ndGggPSAwXG4gICAgdGhpcy5wYXJlbnQgPSB1bmRlZmluZWRcbiAgfVxuXG4gIC8vIENvbW1vbiBjYXNlLlxuICBpZiAodHlwZW9mIGFyZyA9PT0gJ251bWJlcicpIHtcbiAgICByZXR1cm4gZnJvbU51bWJlcih0aGlzLCBhcmcpXG4gIH1cblxuICAvLyBTbGlnaHRseSBsZXNzIGNvbW1vbiBjYXNlLlxuICBpZiAodHlwZW9mIGFyZyA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZnJvbVN0cmluZyh0aGlzLCBhcmcsIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogJ3V0ZjgnKVxuICB9XG5cbiAgLy8gVW51c3VhbC5cbiAgcmV0dXJuIGZyb21PYmplY3QodGhpcywgYXJnKVxufVxuXG5mdW5jdGlvbiBmcm9tTnVtYmVyICh0aGF0LCBsZW5ndGgpIHtcbiAgdGhhdCA9IGFsbG9jYXRlKHRoYXQsIGxlbmd0aCA8IDAgPyAwIDogY2hlY2tlZChsZW5ndGgpIHwgMClcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoYXRbaV0gPSAwXG4gICAgfVxuICB9XG4gIHJldHVybiB0aGF0XG59XG5cbmZ1bmN0aW9uIGZyb21TdHJpbmcgKHRoYXQsIHN0cmluZywgZW5jb2RpbmcpIHtcbiAgaWYgKHR5cGVvZiBlbmNvZGluZyAhPT0gJ3N0cmluZycgfHwgZW5jb2RpbmcgPT09ICcnKSBlbmNvZGluZyA9ICd1dGY4J1xuXG4gIC8vIEFzc3VtcHRpb246IGJ5dGVMZW5ndGgoKSByZXR1cm4gdmFsdWUgaXMgYWx3YXlzIDwga01heExlbmd0aC5cbiAgdmFyIGxlbmd0aCA9IGJ5dGVMZW5ndGgoc3RyaW5nLCBlbmNvZGluZykgfCAwXG4gIHRoYXQgPSBhbGxvY2F0ZSh0aGF0LCBsZW5ndGgpXG5cbiAgdGhhdC53cml0ZShzdHJpbmcsIGVuY29kaW5nKVxuICByZXR1cm4gdGhhdFxufVxuXG5mdW5jdGlvbiBmcm9tT2JqZWN0ICh0aGF0LCBvYmplY3QpIHtcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihvYmplY3QpKSByZXR1cm4gZnJvbUJ1ZmZlcih0aGF0LCBvYmplY3QpXG5cbiAgaWYgKGlzQXJyYXkob2JqZWN0KSkgcmV0dXJuIGZyb21BcnJheSh0aGF0LCBvYmplY3QpXG5cbiAgaWYgKG9iamVjdCA9PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignbXVzdCBzdGFydCB3aXRoIG51bWJlciwgYnVmZmVyLCBhcnJheSBvciBzdHJpbmcnKVxuICB9XG5cbiAgaWYgKHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBpZiAob2JqZWN0LmJ1ZmZlciBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgICByZXR1cm4gZnJvbVR5cGVkQXJyYXkodGhhdCwgb2JqZWN0KVxuICAgIH1cbiAgICBpZiAob2JqZWN0IGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICAgIHJldHVybiBmcm9tQXJyYXlCdWZmZXIodGhhdCwgb2JqZWN0KVxuICAgIH1cbiAgfVxuXG4gIGlmIChvYmplY3QubGVuZ3RoKSByZXR1cm4gZnJvbUFycmF5TGlrZSh0aGF0LCBvYmplY3QpXG5cbiAgcmV0dXJuIGZyb21Kc29uT2JqZWN0KHRoYXQsIG9iamVjdClcbn1cblxuZnVuY3Rpb24gZnJvbUJ1ZmZlciAodGhhdCwgYnVmZmVyKSB7XG4gIHZhciBsZW5ndGggPSBjaGVja2VkKGJ1ZmZlci5sZW5ndGgpIHwgMFxuICB0aGF0ID0gYWxsb2NhdGUodGhhdCwgbGVuZ3RoKVxuICBidWZmZXIuY29weSh0aGF0LCAwLCAwLCBsZW5ndGgpXG4gIHJldHVybiB0aGF0XG59XG5cbmZ1bmN0aW9uIGZyb21BcnJheSAodGhhdCwgYXJyYXkpIHtcbiAgdmFyIGxlbmd0aCA9IGNoZWNrZWQoYXJyYXkubGVuZ3RoKSB8IDBcbiAgdGhhdCA9IGFsbG9jYXRlKHRoYXQsIGxlbmd0aClcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMSkge1xuICAgIHRoYXRbaV0gPSBhcnJheVtpXSAmIDI1NVxuICB9XG4gIHJldHVybiB0aGF0XG59XG5cbi8vIER1cGxpY2F0ZSBvZiBmcm9tQXJyYXkoKSB0byBrZWVwIGZyb21BcnJheSgpIG1vbm9tb3JwaGljLlxuZnVuY3Rpb24gZnJvbVR5cGVkQXJyYXkgKHRoYXQsIGFycmF5KSB7XG4gIHZhciBsZW5ndGggPSBjaGVja2VkKGFycmF5Lmxlbmd0aCkgfCAwXG4gIHRoYXQgPSBhbGxvY2F0ZSh0aGF0LCBsZW5ndGgpXG4gIC8vIFRydW5jYXRpbmcgdGhlIGVsZW1lbnRzIGlzIHByb2JhYmx5IG5vdCB3aGF0IHBlb3BsZSBleHBlY3QgZnJvbSB0eXBlZFxuICAvLyBhcnJheXMgd2l0aCBCWVRFU19QRVJfRUxFTUVOVCA+IDEgYnV0IGl0J3MgY29tcGF0aWJsZSB3aXRoIHRoZSBiZWhhdmlvclxuICAvLyBvZiB0aGUgb2xkIEJ1ZmZlciBjb25zdHJ1Y3Rvci5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMSkge1xuICAgIHRoYXRbaV0gPSBhcnJheVtpXSAmIDI1NVxuICB9XG4gIHJldHVybiB0aGF0XG59XG5cbmZ1bmN0aW9uIGZyb21BcnJheUJ1ZmZlciAodGhhdCwgYXJyYXkpIHtcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgLy8gUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2UsIGZvciBiZXN0IHBlcmZvcm1hbmNlXG4gICAgYXJyYXkuYnl0ZUxlbmd0aFxuICAgIHRoYXQgPSBCdWZmZXIuX2F1Z21lbnQobmV3IFVpbnQ4QXJyYXkoYXJyYXkpKVxuICB9IGVsc2Uge1xuICAgIC8vIEZhbGxiYWNrOiBSZXR1cm4gYW4gb2JqZWN0IGluc3RhbmNlIG9mIHRoZSBCdWZmZXIgY2xhc3NcbiAgICB0aGF0ID0gZnJvbVR5cGVkQXJyYXkodGhhdCwgbmV3IFVpbnQ4QXJyYXkoYXJyYXkpKVxuICB9XG4gIHJldHVybiB0aGF0XG59XG5cbmZ1bmN0aW9uIGZyb21BcnJheUxpa2UgKHRoYXQsIGFycmF5KSB7XG4gIHZhciBsZW5ndGggPSBjaGVja2VkKGFycmF5Lmxlbmd0aCkgfCAwXG4gIHRoYXQgPSBhbGxvY2F0ZSh0aGF0LCBsZW5ndGgpXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcbiAgICB0aGF0W2ldID0gYXJyYXlbaV0gJiAyNTVcbiAgfVxuICByZXR1cm4gdGhhdFxufVxuXG4vLyBEZXNlcmlhbGl6ZSB7IHR5cGU6ICdCdWZmZXInLCBkYXRhOiBbMSwyLDMsLi4uXSB9IGludG8gYSBCdWZmZXIgb2JqZWN0LlxuLy8gUmV0dXJucyBhIHplcm8tbGVuZ3RoIGJ1ZmZlciBmb3IgaW5wdXRzIHRoYXQgZG9uJ3QgY29uZm9ybSB0byB0aGUgc3BlYy5cbmZ1bmN0aW9uIGZyb21Kc29uT2JqZWN0ICh0aGF0LCBvYmplY3QpIHtcbiAgdmFyIGFycmF5XG4gIHZhciBsZW5ndGggPSAwXG5cbiAgaWYgKG9iamVjdC50eXBlID09PSAnQnVmZmVyJyAmJiBpc0FycmF5KG9iamVjdC5kYXRhKSkge1xuICAgIGFycmF5ID0gb2JqZWN0LmRhdGFcbiAgICBsZW5ndGggPSBjaGVja2VkKGFycmF5Lmxlbmd0aCkgfCAwXG4gIH1cbiAgdGhhdCA9IGFsbG9jYXRlKHRoYXQsIGxlbmd0aClcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG4gICAgdGhhdFtpXSA9IGFycmF5W2ldICYgMjU1XG4gIH1cbiAgcmV0dXJuIHRoYXRcbn1cblxuaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gIEJ1ZmZlci5wcm90b3R5cGUuX19wcm90b19fID0gVWludDhBcnJheS5wcm90b3R5cGVcbiAgQnVmZmVyLl9fcHJvdG9fXyA9IFVpbnQ4QXJyYXlcbn0gZWxzZSB7XG4gIC8vIHByZS1zZXQgZm9yIHZhbHVlcyB0aGF0IG1heSBleGlzdCBpbiB0aGUgZnV0dXJlXG4gIEJ1ZmZlci5wcm90b3R5cGUubGVuZ3RoID0gdW5kZWZpbmVkXG4gIEJ1ZmZlci5wcm90b3R5cGUucGFyZW50ID0gdW5kZWZpbmVkXG59XG5cbmZ1bmN0aW9uIGFsbG9jYXRlICh0aGF0LCBsZW5ndGgpIHtcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgLy8gUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2UsIGZvciBiZXN0IHBlcmZvcm1hbmNlXG4gICAgdGhhdCA9IEJ1ZmZlci5fYXVnbWVudChuZXcgVWludDhBcnJheShsZW5ndGgpKVxuICAgIHRoYXQuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZVxuICB9IGVsc2Uge1xuICAgIC8vIEZhbGxiYWNrOiBSZXR1cm4gYW4gb2JqZWN0IGluc3RhbmNlIG9mIHRoZSBCdWZmZXIgY2xhc3NcbiAgICB0aGF0Lmxlbmd0aCA9IGxlbmd0aFxuICAgIHRoYXQuX2lzQnVmZmVyID0gdHJ1ZVxuICB9XG5cbiAgdmFyIGZyb21Qb29sID0gbGVuZ3RoICE9PSAwICYmIGxlbmd0aCA8PSBCdWZmZXIucG9vbFNpemUgPj4+IDFcbiAgaWYgKGZyb21Qb29sKSB0aGF0LnBhcmVudCA9IHJvb3RQYXJlbnRcblxuICByZXR1cm4gdGhhdFxufVxuXG5mdW5jdGlvbiBjaGVja2VkIChsZW5ndGgpIHtcbiAgLy8gTm90ZTogY2Fubm90IHVzZSBgbGVuZ3RoIDwga01heExlbmd0aGAgaGVyZSBiZWNhdXNlIHRoYXQgZmFpbHMgd2hlblxuICAvLyBsZW5ndGggaXMgTmFOICh3aGljaCBpcyBvdGhlcndpc2UgY29lcmNlZCB0byB6ZXJvLilcbiAgaWYgKGxlbmd0aCA+PSBrTWF4TGVuZ3RoKCkpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQXR0ZW1wdCB0byBhbGxvY2F0ZSBCdWZmZXIgbGFyZ2VyIHRoYW4gbWF4aW11bSAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAnc2l6ZTogMHgnICsga01heExlbmd0aCgpLnRvU3RyaW5nKDE2KSArICcgYnl0ZXMnKVxuICB9XG4gIHJldHVybiBsZW5ndGggfCAwXG59XG5cbmZ1bmN0aW9uIFNsb3dCdWZmZXIgKHN1YmplY3QsIGVuY29kaW5nKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBTbG93QnVmZmVyKSkgcmV0dXJuIG5ldyBTbG93QnVmZmVyKHN1YmplY3QsIGVuY29kaW5nKVxuXG4gIHZhciBidWYgPSBuZXcgQnVmZmVyKHN1YmplY3QsIGVuY29kaW5nKVxuICBkZWxldGUgYnVmLnBhcmVudFxuICByZXR1cm4gYnVmXG59XG5cbkJ1ZmZlci5pc0J1ZmZlciA9IGZ1bmN0aW9uIGlzQnVmZmVyIChiKSB7XG4gIHJldHVybiAhIShiICE9IG51bGwgJiYgYi5faXNCdWZmZXIpXG59XG5cbkJ1ZmZlci5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZSAoYSwgYikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihhKSB8fCAhQnVmZmVyLmlzQnVmZmVyKGIpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnRzIG11c3QgYmUgQnVmZmVycycpXG4gIH1cblxuICBpZiAoYSA9PT0gYikgcmV0dXJuIDBcblxuICB2YXIgeCA9IGEubGVuZ3RoXG4gIHZhciB5ID0gYi5sZW5ndGhcblxuICB2YXIgaSA9IDBcbiAgdmFyIGxlbiA9IE1hdGgubWluKHgsIHkpXG4gIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgaWYgKGFbaV0gIT09IGJbaV0pIGJyZWFrXG5cbiAgICArK2lcbiAgfVxuXG4gIGlmIChpICE9PSBsZW4pIHtcbiAgICB4ID0gYVtpXVxuICAgIHkgPSBiW2ldXG4gIH1cblxuICBpZiAoeCA8IHkpIHJldHVybiAtMVxuICBpZiAoeSA8IHgpIHJldHVybiAxXG4gIHJldHVybiAwXG59XG5cbkJ1ZmZlci5pc0VuY29kaW5nID0gZnVuY3Rpb24gaXNFbmNvZGluZyAoZW5jb2RpbmcpIHtcbiAgc3dpdGNoIChTdHJpbmcoZW5jb2RpbmcpLnRvTG93ZXJDYXNlKCkpIHtcbiAgICBjYXNlICdoZXgnOlxuICAgIGNhc2UgJ3V0ZjgnOlxuICAgIGNhc2UgJ3V0Zi04JzpcbiAgICBjYXNlICdhc2NpaSc6XG4gICAgY2FzZSAnYmluYXJ5JzpcbiAgICBjYXNlICdiYXNlNjQnOlxuICAgIGNhc2UgJ3Jhdyc6XG4gICAgY2FzZSAndWNzMic6XG4gICAgY2FzZSAndWNzLTInOlxuICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgIHJldHVybiB0cnVlXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbkJ1ZmZlci5jb25jYXQgPSBmdW5jdGlvbiBjb25jYXQgKGxpc3QsIGxlbmd0aCkge1xuICBpZiAoIWlzQXJyYXkobGlzdCkpIHRocm93IG5ldyBUeXBlRXJyb3IoJ2xpc3QgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzLicpXG5cbiAgaWYgKGxpc3QubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIG5ldyBCdWZmZXIoMClcbiAgfVxuXG4gIHZhciBpXG4gIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGxlbmd0aCA9IDBcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgbGVuZ3RoICs9IGxpc3RbaV0ubGVuZ3RoXG4gICAgfVxuICB9XG5cbiAgdmFyIGJ1ZiA9IG5ldyBCdWZmZXIobGVuZ3RoKVxuICB2YXIgcG9zID0gMFxuICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgIHZhciBpdGVtID0gbGlzdFtpXVxuICAgIGl0ZW0uY29weShidWYsIHBvcylcbiAgICBwb3MgKz0gaXRlbS5sZW5ndGhcbiAgfVxuICByZXR1cm4gYnVmXG59XG5cbmZ1bmN0aW9uIGJ5dGVMZW5ndGggKHN0cmluZywgZW5jb2RpbmcpIHtcbiAgaWYgKHR5cGVvZiBzdHJpbmcgIT09ICdzdHJpbmcnKSBzdHJpbmcgPSAnJyArIHN0cmluZ1xuXG4gIHZhciBsZW4gPSBzdHJpbmcubGVuZ3RoXG4gIGlmIChsZW4gPT09IDApIHJldHVybiAwXG5cbiAgLy8gVXNlIGEgZm9yIGxvb3AgdG8gYXZvaWQgcmVjdXJzaW9uXG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXG4gIGZvciAoOzspIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgLy8gRGVwcmVjYXRlZFxuICAgICAgY2FzZSAncmF3JzpcbiAgICAgIGNhc2UgJ3Jhd3MnOlxuICAgICAgICByZXR1cm4gbGVuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhUb0J5dGVzKHN0cmluZykubGVuZ3RoXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gbGVuICogMlxuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGxlbiA+Pj4gMVxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgcmV0dXJuIGJhc2U2NFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGhcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgcmV0dXJuIHV0ZjhUb0J5dGVzKHN0cmluZykubGVuZ3RoIC8vIGFzc3VtZSB1dGY4XG4gICAgICAgIGVuY29kaW5nID0gKCcnICsgZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5CdWZmZXIuYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGhcblxuZnVuY3Rpb24gc2xvd1RvU3RyaW5nIChlbmNvZGluZywgc3RhcnQsIGVuZCkge1xuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxuXG4gIHN0YXJ0ID0gc3RhcnQgfCAwXG4gIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkIHx8IGVuZCA9PT0gSW5maW5pdHkgPyB0aGlzLmxlbmd0aCA6IGVuZCB8IDBcblxuICBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9ICd1dGY4J1xuICBpZiAoc3RhcnQgPCAwKSBzdGFydCA9IDBcbiAgaWYgKGVuZCA+IHRoaXMubGVuZ3RoKSBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAoZW5kIDw9IHN0YXJ0KSByZXR1cm4gJydcblxuICB3aGlsZSAodHJ1ZSkge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBoZXhTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICAgIHJldHVybiBhc2NpaVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBiaW5hcnlTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICByZXR1cm4gYmFzZTY0U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIHV0ZjE2bGVTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICAgICAgZW5jb2RpbmcgPSAoZW5jb2RpbmcgKyAnJykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nICgpIHtcbiAgdmFyIGxlbmd0aCA9IHRoaXMubGVuZ3RoIHwgMFxuICBpZiAobGVuZ3RoID09PSAwKSByZXR1cm4gJydcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHJldHVybiB1dGY4U2xpY2UodGhpcywgMCwgbGVuZ3RoKVxuICByZXR1cm4gc2xvd1RvU3RyaW5nLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiBlcXVhbHMgKGIpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYikpIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXInKVxuICBpZiAodGhpcyA9PT0gYikgcmV0dXJuIHRydWVcbiAgcmV0dXJuIEJ1ZmZlci5jb21wYXJlKHRoaXMsIGIpID09PSAwXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5zcGVjdCA9IGZ1bmN0aW9uIGluc3BlY3QgKCkge1xuICB2YXIgc3RyID0gJydcbiAgdmFyIG1heCA9IGV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVNcbiAgaWYgKHRoaXMubGVuZ3RoID4gMCkge1xuICAgIHN0ciA9IHRoaXMudG9TdHJpbmcoJ2hleCcsIDAsIG1heCkubWF0Y2goLy57Mn0vZykuam9pbignICcpXG4gICAgaWYgKHRoaXMubGVuZ3RoID4gbWF4KSBzdHIgKz0gJyAuLi4gJ1xuICB9XG4gIHJldHVybiAnPEJ1ZmZlciAnICsgc3RyICsgJz4nXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUgKGIpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYikpIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXInKVxuICBpZiAodGhpcyA9PT0gYikgcmV0dXJuIDBcbiAgcmV0dXJuIEJ1ZmZlci5jb21wYXJlKHRoaXMsIGIpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5kZXhPZiA9IGZ1bmN0aW9uIGluZGV4T2YgKHZhbCwgYnl0ZU9mZnNldCkge1xuICBpZiAoYnl0ZU9mZnNldCA+IDB4N2ZmZmZmZmYpIGJ5dGVPZmZzZXQgPSAweDdmZmZmZmZmXG4gIGVsc2UgaWYgKGJ5dGVPZmZzZXQgPCAtMHg4MDAwMDAwMCkgYnl0ZU9mZnNldCA9IC0weDgwMDAwMDAwXG4gIGJ5dGVPZmZzZXQgPj49IDBcblxuICBpZiAodGhpcy5sZW5ndGggPT09IDApIHJldHVybiAtMVxuICBpZiAoYnl0ZU9mZnNldCA+PSB0aGlzLmxlbmd0aCkgcmV0dXJuIC0xXG5cbiAgLy8gTmVnYXRpdmUgb2Zmc2V0cyBzdGFydCBmcm9tIHRoZSBlbmQgb2YgdGhlIGJ1ZmZlclxuICBpZiAoYnl0ZU9mZnNldCA8IDApIGJ5dGVPZmZzZXQgPSBNYXRoLm1heCh0aGlzLmxlbmd0aCArIGJ5dGVPZmZzZXQsIDApXG5cbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgaWYgKHZhbC5sZW5ndGggPT09IDApIHJldHVybiAtMSAvLyBzcGVjaWFsIGNhc2U6IGxvb2tpbmcgZm9yIGVtcHR5IHN0cmluZyBhbHdheXMgZmFpbHNcbiAgICByZXR1cm4gU3RyaW5nLnByb3RvdHlwZS5pbmRleE9mLmNhbGwodGhpcywgdmFsLCBieXRlT2Zmc2V0KVxuICB9XG4gIGlmIChCdWZmZXIuaXNCdWZmZXIodmFsKSkge1xuICAgIHJldHVybiBhcnJheUluZGV4T2YodGhpcywgdmFsLCBieXRlT2Zmc2V0KVxuICB9XG4gIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCAmJiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gVWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZi5jYWxsKHRoaXMsIHZhbCwgYnl0ZU9mZnNldClcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5SW5kZXhPZih0aGlzLCBbIHZhbCBdLCBieXRlT2Zmc2V0KVxuICB9XG5cbiAgZnVuY3Rpb24gYXJyYXlJbmRleE9mIChhcnIsIHZhbCwgYnl0ZU9mZnNldCkge1xuICAgIHZhciBmb3VuZEluZGV4ID0gLTFcbiAgICBmb3IgKHZhciBpID0gMDsgYnl0ZU9mZnNldCArIGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChhcnJbYnl0ZU9mZnNldCArIGldID09PSB2YWxbZm91bmRJbmRleCA9PT0gLTEgPyAwIDogaSAtIGZvdW5kSW5kZXhdKSB7XG4gICAgICAgIGlmIChmb3VuZEluZGV4ID09PSAtMSkgZm91bmRJbmRleCA9IGlcbiAgICAgICAgaWYgKGkgLSBmb3VuZEluZGV4ICsgMSA9PT0gdmFsLmxlbmd0aCkgcmV0dXJuIGJ5dGVPZmZzZXQgKyBmb3VuZEluZGV4XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3VuZEluZGV4ID0gLTFcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIC0xXG4gIH1cblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKCd2YWwgbXVzdCBiZSBzdHJpbmcsIG51bWJlciBvciBCdWZmZXInKVxufVxuXG4vLyBgZ2V0YCBpcyBkZXByZWNhdGVkXG5CdWZmZXIucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIGdldCAob2Zmc2V0KSB7XG4gIGNvbnNvbGUubG9nKCcuZ2V0KCkgaXMgZGVwcmVjYXRlZC4gQWNjZXNzIHVzaW5nIGFycmF5IGluZGV4ZXMgaW5zdGVhZC4nKVxuICByZXR1cm4gdGhpcy5yZWFkVUludDgob2Zmc2V0KVxufVxuXG4vLyBgc2V0YCBpcyBkZXByZWNhdGVkXG5CdWZmZXIucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIHNldCAodiwgb2Zmc2V0KSB7XG4gIGNvbnNvbGUubG9nKCcuc2V0KCkgaXMgZGVwcmVjYXRlZC4gQWNjZXNzIHVzaW5nIGFycmF5IGluZGV4ZXMgaW5zdGVhZC4nKVxuICByZXR1cm4gdGhpcy53cml0ZVVJbnQ4KHYsIG9mZnNldClcbn1cblxuZnVuY3Rpb24gaGV4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICBvZmZzZXQgPSBOdW1iZXIob2Zmc2V0KSB8fCAwXG4gIHZhciByZW1haW5pbmcgPSBidWYubGVuZ3RoIC0gb2Zmc2V0XG4gIGlmICghbGVuZ3RoKSB7XG4gICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gIH0gZWxzZSB7XG4gICAgbGVuZ3RoID0gTnVtYmVyKGxlbmd0aClcbiAgICBpZiAobGVuZ3RoID4gcmVtYWluaW5nKSB7XG4gICAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgICB9XG4gIH1cblxuICAvLyBtdXN0IGJlIGFuIGV2ZW4gbnVtYmVyIG9mIGRpZ2l0c1xuICB2YXIgc3RyTGVuID0gc3RyaW5nLmxlbmd0aFxuICBpZiAoc3RyTGVuICUgMiAhPT0gMCkgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGhleCBzdHJpbmcnKVxuXG4gIGlmIChsZW5ndGggPiBzdHJMZW4gLyAyKSB7XG4gICAgbGVuZ3RoID0gc3RyTGVuIC8gMlxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgcGFyc2VkID0gcGFyc2VJbnQoc3RyaW5nLnN1YnN0cihpICogMiwgMiksIDE2KVxuICAgIGlmIChpc05hTihwYXJzZWQpKSB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgaGV4IHN0cmluZycpXG4gICAgYnVmW29mZnNldCArIGldID0gcGFyc2VkXG4gIH1cbiAgcmV0dXJuIGlcbn1cblxuZnVuY3Rpb24gdXRmOFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIodXRmOFRvQnl0ZXMoc3RyaW5nLCBidWYubGVuZ3RoIC0gb2Zmc2V0KSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gYXNjaWlXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKGFzY2lpVG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBiaW5hcnlXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBhc2NpaVdyaXRlKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gYmFzZTY0V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcihiYXNlNjRUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIHVjczJXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKHV0ZjE2bGVUb0J5dGVzKHN0cmluZywgYnVmLmxlbmd0aCAtIG9mZnNldCksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiB3cml0ZSAoc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCwgZW5jb2RpbmcpIHtcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZylcbiAgaWYgKG9mZnNldCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZW5jb2RpbmcgPSAndXRmOCdcbiAgICBsZW5ndGggPSB0aGlzLmxlbmd0aFxuICAgIG9mZnNldCA9IDBcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZywgZW5jb2RpbmcpXG4gIH0gZWxzZSBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQgJiYgdHlwZW9mIG9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICBlbmNvZGluZyA9IG9mZnNldFxuICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoXG4gICAgb2Zmc2V0ID0gMFxuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nLCBvZmZzZXRbLCBsZW5ndGhdWywgZW5jb2RpbmddKVxuICB9IGVsc2UgaWYgKGlzRmluaXRlKG9mZnNldCkpIHtcbiAgICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gICAgaWYgKGlzRmluaXRlKGxlbmd0aCkpIHtcbiAgICAgIGxlbmd0aCA9IGxlbmd0aCB8IDBcbiAgICAgIGlmIChlbmNvZGluZyA9PT0gdW5kZWZpbmVkKSBlbmNvZGluZyA9ICd1dGY4J1xuICAgIH0gZWxzZSB7XG4gICAgICBlbmNvZGluZyA9IGxlbmd0aFxuICAgICAgbGVuZ3RoID0gdW5kZWZpbmVkXG4gICAgfVxuICAvLyBsZWdhY3kgd3JpdGUoc3RyaW5nLCBlbmNvZGluZywgb2Zmc2V0LCBsZW5ndGgpIC0gcmVtb3ZlIGluIHYwLjEzXG4gIH0gZWxzZSB7XG4gICAgdmFyIHN3YXAgPSBlbmNvZGluZ1xuICAgIGVuY29kaW5nID0gb2Zmc2V0XG4gICAgb2Zmc2V0ID0gbGVuZ3RoIHwgMFxuICAgIGxlbmd0aCA9IHN3YXBcbiAgfVxuXG4gIHZhciByZW1haW5pbmcgPSB0aGlzLmxlbmd0aCAtIG9mZnNldFxuICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQgfHwgbGVuZ3RoID4gcmVtYWluaW5nKSBsZW5ndGggPSByZW1haW5pbmdcblxuICBpZiAoKHN0cmluZy5sZW5ndGggPiAwICYmIChsZW5ndGggPCAwIHx8IG9mZnNldCA8IDApKSB8fCBvZmZzZXQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdhdHRlbXB0IHRvIHdyaXRlIG91dHNpZGUgYnVmZmVyIGJvdW5kcycpXG4gIH1cblxuICBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9ICd1dGY4J1xuXG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXG4gIGZvciAoOzspIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gaGV4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiB1dGY4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgICByZXR1cm4gYXNjaWlXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gYmluYXJ5V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgLy8gV2FybmluZzogbWF4TGVuZ3RoIG5vdCB0YWtlbiBpbnRvIGFjY291bnQgaW4gYmFzZTY0V3JpdGVcbiAgICAgICAgcmV0dXJuIGJhc2U2NFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiB1Y3MyV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgICAgIGVuY29kaW5nID0gKCcnICsgZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OICgpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiAnQnVmZmVyJyxcbiAgICBkYXRhOiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh0aGlzLl9hcnIgfHwgdGhpcywgMClcbiAgfVxufVxuXG5mdW5jdGlvbiBiYXNlNjRTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGlmIChzdGFydCA9PT0gMCAmJiBlbmQgPT09IGJ1Zi5sZW5ndGgpIHtcbiAgICByZXR1cm4gYmFzZTY0LmZyb21CeXRlQXJyYXkoYnVmKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYuc2xpY2Uoc3RhcnQsIGVuZCkpXG4gIH1cbn1cblxuZnVuY3Rpb24gdXRmOFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuICB2YXIgcmVzID0gW11cblxuICB2YXIgaSA9IHN0YXJ0XG4gIHdoaWxlIChpIDwgZW5kKSB7XG4gICAgdmFyIGZpcnN0Qnl0ZSA9IGJ1ZltpXVxuICAgIHZhciBjb2RlUG9pbnQgPSBudWxsXG4gICAgdmFyIGJ5dGVzUGVyU2VxdWVuY2UgPSAoZmlyc3RCeXRlID4gMHhFRikgPyA0XG4gICAgICA6IChmaXJzdEJ5dGUgPiAweERGKSA/IDNcbiAgICAgIDogKGZpcnN0Qnl0ZSA+IDB4QkYpID8gMlxuICAgICAgOiAxXG5cbiAgICBpZiAoaSArIGJ5dGVzUGVyU2VxdWVuY2UgPD0gZW5kKSB7XG4gICAgICB2YXIgc2Vjb25kQnl0ZSwgdGhpcmRCeXRlLCBmb3VydGhCeXRlLCB0ZW1wQ29kZVBvaW50XG5cbiAgICAgIHN3aXRjaCAoYnl0ZXNQZXJTZXF1ZW5jZSkge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgaWYgKGZpcnN0Qnl0ZSA8IDB4ODApIHtcbiAgICAgICAgICAgIGNvZGVQb2ludCA9IGZpcnN0Qnl0ZVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweDFGKSA8PCAweDYgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4N0YpIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICB0aGlyZEJ5dGUgPSBidWZbaSArIDJdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKHRoaXJkQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4RikgPDwgMHhDIHwgKHNlY29uZEJ5dGUgJiAweDNGKSA8PCAweDYgfCAodGhpcmRCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHg3RkYgJiYgKHRlbXBDb2RlUG9pbnQgPCAweEQ4MDAgfHwgdGVtcENvZGVQb2ludCA+IDB4REZGRikpIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICB0aGlyZEJ5dGUgPSBidWZbaSArIDJdXG4gICAgICAgICAgZm91cnRoQnl0ZSA9IGJ1ZltpICsgM11cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAodGhpcmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKGZvdXJ0aEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweEYpIDw8IDB4MTIgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpIDw8IDB4QyB8ICh0aGlyZEJ5dGUgJiAweDNGKSA8PCAweDYgfCAoZm91cnRoQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4RkZGRiAmJiB0ZW1wQ29kZVBvaW50IDwgMHgxMTAwMDApIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoY29kZVBvaW50ID09PSBudWxsKSB7XG4gICAgICAvLyB3ZSBkaWQgbm90IGdlbmVyYXRlIGEgdmFsaWQgY29kZVBvaW50IHNvIGluc2VydCBhXG4gICAgICAvLyByZXBsYWNlbWVudCBjaGFyIChVK0ZGRkQpIGFuZCBhZHZhbmNlIG9ubHkgMSBieXRlXG4gICAgICBjb2RlUG9pbnQgPSAweEZGRkRcbiAgICAgIGJ5dGVzUGVyU2VxdWVuY2UgPSAxXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPiAweEZGRkYpIHtcbiAgICAgIC8vIGVuY29kZSB0byB1dGYxNiAoc3Vycm9nYXRlIHBhaXIgZGFuY2UpXG4gICAgICBjb2RlUG9pbnQgLT0gMHgxMDAwMFxuICAgICAgcmVzLnB1c2goY29kZVBvaW50ID4+PiAxMCAmIDB4M0ZGIHwgMHhEODAwKVxuICAgICAgY29kZVBvaW50ID0gMHhEQzAwIHwgY29kZVBvaW50ICYgMHgzRkZcbiAgICB9XG5cbiAgICByZXMucHVzaChjb2RlUG9pbnQpXG4gICAgaSArPSBieXRlc1BlclNlcXVlbmNlXG4gIH1cblxuICByZXR1cm4gZGVjb2RlQ29kZVBvaW50c0FycmF5KHJlcylcbn1cblxuLy8gQmFzZWQgb24gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjI3NDcyNzIvNjgwNzQyLCB0aGUgYnJvd3NlciB3aXRoXG4vLyB0aGUgbG93ZXN0IGxpbWl0IGlzIENocm9tZSwgd2l0aCAweDEwMDAwIGFyZ3MuXG4vLyBXZSBnbyAxIG1hZ25pdHVkZSBsZXNzLCBmb3Igc2FmZXR5XG52YXIgTUFYX0FSR1VNRU5UU19MRU5HVEggPSAweDEwMDBcblxuZnVuY3Rpb24gZGVjb2RlQ29kZVBvaW50c0FycmF5IChjb2RlUG9pbnRzKSB7XG4gIHZhciBsZW4gPSBjb2RlUG9pbnRzLmxlbmd0aFxuICBpZiAobGVuIDw9IE1BWF9BUkdVTUVOVFNfTEVOR1RIKSB7XG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLCBjb2RlUG9pbnRzKSAvLyBhdm9pZCBleHRyYSBzbGljZSgpXG4gIH1cblxuICAvLyBEZWNvZGUgaW4gY2h1bmtzIHRvIGF2b2lkIFwiY2FsbCBzdGFjayBzaXplIGV4Y2VlZGVkXCIuXG4gIHZhciByZXMgPSAnJ1xuICB2YXIgaSA9IDBcbiAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShcbiAgICAgIFN0cmluZyxcbiAgICAgIGNvZGVQb2ludHMuc2xpY2UoaSwgaSArPSBNQVhfQVJHVU1FTlRTX0xFTkdUSClcbiAgICApXG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBhc2NpaVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHJldCA9ICcnXG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcblxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSAmIDB4N0YpXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5mdW5jdGlvbiBiaW5hcnlTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciByZXQgPSAnJ1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcbiAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0pXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5mdW5jdGlvbiBoZXhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciBsZW4gPSBidWYubGVuZ3RoXG5cbiAgaWYgKCFzdGFydCB8fCBzdGFydCA8IDApIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCB8fCBlbmQgPCAwIHx8IGVuZCA+IGxlbikgZW5kID0gbGVuXG5cbiAgdmFyIG91dCA9ICcnXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgb3V0ICs9IHRvSGV4KGJ1ZltpXSlcbiAgfVxuICByZXR1cm4gb3V0XG59XG5cbmZ1bmN0aW9uIHV0ZjE2bGVTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciBieXRlcyA9IGJ1Zi5zbGljZShzdGFydCwgZW5kKVxuICB2YXIgcmVzID0gJydcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkgKz0gMikge1xuICAgIHJlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ5dGVzW2ldICsgYnl0ZXNbaSArIDFdICogMjU2KVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zbGljZSA9IGZ1bmN0aW9uIHNsaWNlIChzdGFydCwgZW5kKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBzdGFydCA9IH5+c3RhcnRcbiAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyBsZW4gOiB+fmVuZFxuXG4gIGlmIChzdGFydCA8IDApIHtcbiAgICBzdGFydCArPSBsZW5cbiAgICBpZiAoc3RhcnQgPCAwKSBzdGFydCA9IDBcbiAgfSBlbHNlIGlmIChzdGFydCA+IGxlbikge1xuICAgIHN0YXJ0ID0gbGVuXG4gIH1cblxuICBpZiAoZW5kIDwgMCkge1xuICAgIGVuZCArPSBsZW5cbiAgICBpZiAoZW5kIDwgMCkgZW5kID0gMFxuICB9IGVsc2UgaWYgKGVuZCA+IGxlbikge1xuICAgIGVuZCA9IGxlblxuICB9XG5cbiAgaWYgKGVuZCA8IHN0YXJ0KSBlbmQgPSBzdGFydFxuXG4gIHZhciBuZXdCdWZcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgbmV3QnVmID0gQnVmZmVyLl9hdWdtZW50KHRoaXMuc3ViYXJyYXkoc3RhcnQsIGVuZCkpXG4gIH0gZWxzZSB7XG4gICAgdmFyIHNsaWNlTGVuID0gZW5kIC0gc3RhcnRcbiAgICBuZXdCdWYgPSBuZXcgQnVmZmVyKHNsaWNlTGVuLCB1bmRlZmluZWQpXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzbGljZUxlbjsgaSsrKSB7XG4gICAgICBuZXdCdWZbaV0gPSB0aGlzW2kgKyBzdGFydF1cbiAgICB9XG4gIH1cblxuICBpZiAobmV3QnVmLmxlbmd0aCkgbmV3QnVmLnBhcmVudCA9IHRoaXMucGFyZW50IHx8IHRoaXNcblxuICByZXR1cm4gbmV3QnVmXG59XG5cbi8qXG4gKiBOZWVkIHRvIG1ha2Ugc3VyZSB0aGF0IGJ1ZmZlciBpc24ndCB0cnlpbmcgdG8gd3JpdGUgb3V0IG9mIGJvdW5kcy5cbiAqL1xuZnVuY3Rpb24gY2hlY2tPZmZzZXQgKG9mZnNldCwgZXh0LCBsZW5ndGgpIHtcbiAgaWYgKChvZmZzZXQgJSAxKSAhPT0gMCB8fCBvZmZzZXQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignb2Zmc2V0IGlzIG5vdCB1aW50JylcbiAgaWYgKG9mZnNldCArIGV4dCA+IGxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RyeWluZyB0byBhY2Nlc3MgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50TEUgPSBmdW5jdGlvbiByZWFkVUludExFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XVxuICB2YXIgbXVsID0gMVxuICB2YXIgaSA9IDBcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyBpXSAqIG11bFxuICB9XG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50QkUgPSBmdW5jdGlvbiByZWFkVUludEJFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuICB9XG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgLS1ieXRlTGVuZ3RoXVxuICB2YXIgbXVsID0gMVxuICB3aGlsZSAoYnl0ZUxlbmd0aCA+IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyAtLWJ5dGVMZW5ndGhdICogbXVsXG4gIH1cblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQ4ID0gZnVuY3Rpb24gcmVhZFVJbnQ4IChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMSwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiB0aGlzW29mZnNldF1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2TEUgPSBmdW5jdGlvbiByZWFkVUludDE2TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIHRoaXNbb2Zmc2V0XSB8ICh0aGlzW29mZnNldCArIDFdIDw8IDgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkJFID0gZnVuY3Rpb24gcmVhZFVJbnQxNkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiAodGhpc1tvZmZzZXRdIDw8IDgpIHwgdGhpc1tvZmZzZXQgKyAxXVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJMRSA9IGZ1bmN0aW9uIHJlYWRVSW50MzJMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAoKHRoaXNbb2Zmc2V0XSkgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCkgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgMTYpKSArXG4gICAgICAodGhpc1tvZmZzZXQgKyAzXSAqIDB4MTAwMDAwMClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyQkUgPSBmdW5jdGlvbiByZWFkVUludDMyQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSAqIDB4MTAwMDAwMCkgK1xuICAgICgodGhpc1tvZmZzZXQgKyAxXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDgpIHxcbiAgICB0aGlzW29mZnNldCArIDNdKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnRMRSA9IGZ1bmN0aW9uIHJlYWRJbnRMRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF1cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgaV0gKiBtdWxcbiAgfVxuICBtdWwgKj0gMHg4MFxuXG4gIGlmICh2YWwgPj0gbXVsKSB2YWwgLT0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpXG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnRCRSA9IGZ1bmN0aW9uIHJlYWRJbnRCRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aFxuICB2YXIgbXVsID0gMVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAtLWldXG4gIHdoaWxlIChpID4gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIC0taV0gKiBtdWxcbiAgfVxuICBtdWwgKj0gMHg4MFxuXG4gIGlmICh2YWwgPj0gbXVsKSB2YWwgLT0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpXG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQ4ID0gZnVuY3Rpb24gcmVhZEludDggKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAxLCB0aGlzLmxlbmd0aClcbiAgaWYgKCEodGhpc1tvZmZzZXRdICYgMHg4MCkpIHJldHVybiAodGhpc1tvZmZzZXRdKVxuICByZXR1cm4gKCgweGZmIC0gdGhpc1tvZmZzZXRdICsgMSkgKiAtMSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZMRSA9IGZ1bmN0aW9uIHJlYWRJbnQxNkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF0gfCAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KVxuICByZXR1cm4gKHZhbCAmIDB4ODAwMCkgPyB2YWwgfCAweEZGRkYwMDAwIDogdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2QkUgPSBmdW5jdGlvbiByZWFkSW50MTZCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAxXSB8ICh0aGlzW29mZnNldF0gPDwgOClcbiAgcmV0dXJuICh2YWwgJiAweDgwMDApID8gdmFsIHwgMHhGRkZGMDAwMCA6IHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkxFID0gZnVuY3Rpb24gcmVhZEludDMyTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSkgfFxuICAgICh0aGlzW29mZnNldCArIDFdIDw8IDgpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDNdIDw8IDI0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkJFID0gZnVuY3Rpb24gcmVhZEludDMyQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSA8PCAyNCkgfFxuICAgICh0aGlzW29mZnNldCArIDFdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCkgfFxuICAgICh0aGlzW29mZnNldCArIDNdKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdExFID0gZnVuY3Rpb24gcmVhZEZsb2F0TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIHRydWUsIDIzLCA0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdEJFID0gZnVuY3Rpb24gcmVhZEZsb2F0QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIGZhbHNlLCAyMywgNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlTEUgPSBmdW5jdGlvbiByZWFkRG91YmxlTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIHRydWUsIDUyLCA4KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVCRSA9IGZ1bmN0aW9uIHJlYWREb3VibGVCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDgsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgZmFsc2UsIDUyLCA4KVxufVxuXG5mdW5jdGlvbiBjaGVja0ludCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBleHQsIG1heCwgbWluKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZikpIHRocm93IG5ldyBUeXBlRXJyb3IoJ2J1ZmZlciBtdXN0IGJlIGEgQnVmZmVyIGluc3RhbmNlJylcbiAgaWYgKHZhbHVlID4gbWF4IHx8IHZhbHVlIDwgbWluKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcigndmFsdWUgaXMgb3V0IG9mIGJvdW5kcycpXG4gIGlmIChvZmZzZXQgKyBleHQgPiBidWYubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignaW5kZXggb3V0IG9mIHJhbmdlJylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnRMRSA9IGZ1bmN0aW9uIHdyaXRlVUludExFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCksIDApXG5cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAodmFsdWUgLyBtdWwpICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnRCRSA9IGZ1bmN0aW9uIHdyaXRlVUludEJFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCksIDApXG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoIC0gMVxuICB2YXIgbXVsID0gMVxuICB0aGlzW29mZnNldCArIGldID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgtLWkgPj0gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAodmFsdWUgLyBtdWwpICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQ4ID0gZnVuY3Rpb24gd3JpdGVVSW50OCAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAxLCAweGZmLCAwKVxuICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB2YWx1ZSA9IE1hdGguZmxvb3IodmFsdWUpXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAxXG59XG5cbmZ1bmN0aW9uIG9iamVjdFdyaXRlVUludDE2IChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbikge1xuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmZmZiArIHZhbHVlICsgMVxuICBmb3IgKHZhciBpID0gMCwgaiA9IE1hdGgubWluKGJ1Zi5sZW5ndGggLSBvZmZzZXQsIDIpOyBpIDwgajsgaSsrKSB7XG4gICAgYnVmW29mZnNldCArIGldID0gKHZhbHVlICYgKDB4ZmYgPDwgKDggKiAobGl0dGxlRW5kaWFuID8gaSA6IDEgLSBpKSkpKSA+Pj5cbiAgICAgIChsaXR0bGVFbmRpYW4gPyBpIDogMSAtIGkpICogOFxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZMRSA9IGZ1bmN0aW9uIHdyaXRlVUludDE2TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHhmZmZmLCAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2QkUgPSBmdW5jdGlvbiB3cml0ZVVJbnQxNkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4ZmZmZiwgMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgJiAweGZmKVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbmZ1bmN0aW9uIG9iamVjdFdyaXRlVUludDMyIChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbikge1xuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmZmZmZmZmYgKyB2YWx1ZSArIDFcbiAgZm9yICh2YXIgaSA9IDAsIGogPSBNYXRoLm1pbihidWYubGVuZ3RoIC0gb2Zmc2V0LCA0KTsgaSA8IGo7IGkrKykge1xuICAgIGJ1ZltvZmZzZXQgKyBpXSA9ICh2YWx1ZSA+Pj4gKGxpdHRsZUVuZGlhbiA/IGkgOiAzIC0gaSkgKiA4KSAmIDB4ZmZcbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyTEUgPSBmdW5jdGlvbiB3cml0ZVVJbnQzMkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4ZmZmZmZmZmYsIDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgPj4+IDI0KVxuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDE2KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJCRSA9IGZ1bmN0aW9uIHdyaXRlVUludDMyQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHhmZmZmZmZmZiwgMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiAyNClcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiAxNilcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgJiAweGZmKVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnRMRSA9IGZ1bmN0aW9uIHdyaXRlSW50TEUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBsaW1pdCA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoIC0gMSlcblxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIGxpbWl0IC0gMSwgLWxpbWl0KVxuICB9XG5cbiAgdmFyIGkgPSAwXG4gIHZhciBtdWwgPSAxXG4gIHZhciBzdWIgPSB2YWx1ZSA8IDAgPyAxIDogMFxuICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB0aGlzW29mZnNldCArIGldID0gKCh2YWx1ZSAvIG11bCkgPj4gMCkgLSBzdWIgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50QkUgPSBmdW5jdGlvbiB3cml0ZUludEJFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbGltaXQgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCAtIDEpXG5cbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBsaW1pdCAtIDEsIC1saW1pdClcbiAgfVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aCAtIDFcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHN1YiA9IHZhbHVlIDwgMCA/IDEgOiAwXG4gIHRoaXNbb2Zmc2V0ICsgaV0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKC0taSA+PSAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICgodmFsdWUgLyBtdWwpID4+IDApIC0gc3ViICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDggPSBmdW5jdGlvbiB3cml0ZUludDggKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMSwgMHg3ZiwgLTB4ODApXG4gIGlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHZhbHVlID0gTWF0aC5mbG9vcih2YWx1ZSlcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmICsgdmFsdWUgKyAxXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAxXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkxFID0gZnVuY3Rpb24gd3JpdGVJbnQxNkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4N2ZmZiwgLTB4ODAwMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2QkUgPSBmdW5jdGlvbiB3cml0ZUludDE2QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHg3ZmZmLCAtMHg4MDAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyTEUgPSBmdW5jdGlvbiB3cml0ZUludDMyTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHg3ZmZmZmZmZiwgLTB4ODAwMDAwMDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiAxNilcbiAgICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlID4+PiAyNClcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkJFID0gZnVuY3Rpb24gd3JpdGVJbnQzMkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKVxuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmZmZmZmZmYgKyB2YWx1ZSArIDFcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiAyNClcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiAxNilcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgJiAweGZmKVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbmZ1bmN0aW9uIGNoZWNrSUVFRTc1NCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBleHQsIG1heCwgbWluKSB7XG4gIGlmICh2YWx1ZSA+IG1heCB8fCB2YWx1ZSA8IG1pbikgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3ZhbHVlIGlzIG91dCBvZiBib3VuZHMnKVxuICBpZiAob2Zmc2V0ICsgZXh0ID4gYnVmLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ2luZGV4IG91dCBvZiByYW5nZScpXG4gIGlmIChvZmZzZXQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignaW5kZXggb3V0IG9mIHJhbmdlJylcbn1cblxuZnVuY3Rpb24gd3JpdGVGbG9hdCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja0lFRUU3NTQoYnVmLCB2YWx1ZSwgb2Zmc2V0LCA0LCAzLjQwMjgyMzQ2NjM4NTI4ODZlKzM4LCAtMy40MDI4MjM0NjYzODUyODg2ZSszOClcbiAgfVxuICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCAyMywgNClcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0TEUgPSBmdW5jdGlvbiB3cml0ZUZsb2F0TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRCRSA9IGZ1bmN0aW9uIHdyaXRlRmxvYXRCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG5mdW5jdGlvbiB3cml0ZURvdWJsZSAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja0lFRUU3NTQoYnVmLCB2YWx1ZSwgb2Zmc2V0LCA4LCAxLjc5NzY5MzEzNDg2MjMxNTdFKzMwOCwgLTEuNzk3NjkzMTM0ODYyMzE1N0UrMzA4KVxuICB9XG4gIGllZWU3NTQud3JpdGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDUyLCA4KVxuICByZXR1cm4gb2Zmc2V0ICsgOFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlTEUgPSBmdW5jdGlvbiB3cml0ZURvdWJsZUxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVCRSA9IGZ1bmN0aW9uIHdyaXRlRG91YmxlQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbi8vIGNvcHkodGFyZ2V0QnVmZmVyLCB0YXJnZXRTdGFydD0wLCBzb3VyY2VTdGFydD0wLCBzb3VyY2VFbmQ9YnVmZmVyLmxlbmd0aClcbkJ1ZmZlci5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uIGNvcHkgKHRhcmdldCwgdGFyZ2V0U3RhcnQsIHN0YXJ0LCBlbmQpIHtcbiAgaWYgKCFzdGFydCkgc3RhcnQgPSAwXG4gIGlmICghZW5kICYmIGVuZCAhPT0gMCkgZW5kID0gdGhpcy5sZW5ndGhcbiAgaWYgKHRhcmdldFN0YXJ0ID49IHRhcmdldC5sZW5ndGgpIHRhcmdldFN0YXJ0ID0gdGFyZ2V0Lmxlbmd0aFxuICBpZiAoIXRhcmdldFN0YXJ0KSB0YXJnZXRTdGFydCA9IDBcbiAgaWYgKGVuZCA+IDAgJiYgZW5kIDwgc3RhcnQpIGVuZCA9IHN0YXJ0XG5cbiAgLy8gQ29weSAwIGJ5dGVzOyB3ZSdyZSBkb25lXG4gIGlmIChlbmQgPT09IHN0YXJ0KSByZXR1cm4gMFxuICBpZiAodGFyZ2V0Lmxlbmd0aCA9PT0gMCB8fCB0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIDBcblxuICAvLyBGYXRhbCBlcnJvciBjb25kaXRpb25zXG4gIGlmICh0YXJnZXRTdGFydCA8IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcigndGFyZ2V0U3RhcnQgb3V0IG9mIGJvdW5kcycpXG4gIH1cbiAgaWYgKHN0YXJ0IDwgMCB8fCBzdGFydCA+PSB0aGlzLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3NvdXJjZVN0YXJ0IG91dCBvZiBib3VuZHMnKVxuICBpZiAoZW5kIDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3NvdXJjZUVuZCBvdXQgb2YgYm91bmRzJylcblxuICAvLyBBcmUgd2Ugb29iP1xuICBpZiAoZW5kID4gdGhpcy5sZW5ndGgpIGVuZCA9IHRoaXMubGVuZ3RoXG4gIGlmICh0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0U3RhcnQgPCBlbmQgLSBzdGFydCkge1xuICAgIGVuZCA9IHRhcmdldC5sZW5ndGggLSB0YXJnZXRTdGFydCArIHN0YXJ0XG4gIH1cblxuICB2YXIgbGVuID0gZW5kIC0gc3RhcnRcbiAgdmFyIGlcblxuICBpZiAodGhpcyA9PT0gdGFyZ2V0ICYmIHN0YXJ0IDwgdGFyZ2V0U3RhcnQgJiYgdGFyZ2V0U3RhcnQgPCBlbmQpIHtcbiAgICAvLyBkZXNjZW5kaW5nIGNvcHkgZnJvbSBlbmRcbiAgICBmb3IgKGkgPSBsZW4gLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgdGFyZ2V0W2kgKyB0YXJnZXRTdGFydF0gPSB0aGlzW2kgKyBzdGFydF1cbiAgICB9XG4gIH0gZWxzZSBpZiAobGVuIDwgMTAwMCB8fCAhQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICAvLyBhc2NlbmRpbmcgY29weSBmcm9tIHN0YXJ0XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICB0YXJnZXRbaSArIHRhcmdldFN0YXJ0XSA9IHRoaXNbaSArIHN0YXJ0XVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0YXJnZXQuX3NldCh0aGlzLnN1YmFycmF5KHN0YXJ0LCBzdGFydCArIGxlbiksIHRhcmdldFN0YXJ0KVxuICB9XG5cbiAgcmV0dXJuIGxlblxufVxuXG4vLyBmaWxsKHZhbHVlLCBzdGFydD0wLCBlbmQ9YnVmZmVyLmxlbmd0aClcbkJ1ZmZlci5wcm90b3R5cGUuZmlsbCA9IGZ1bmN0aW9uIGZpbGwgKHZhbHVlLCBzdGFydCwgZW5kKSB7XG4gIGlmICghdmFsdWUpIHZhbHVlID0gMFxuICBpZiAoIXN0YXJ0KSBzdGFydCA9IDBcbiAgaWYgKCFlbmQpIGVuZCA9IHRoaXMubGVuZ3RoXG5cbiAgaWYgKGVuZCA8IHN0YXJ0KSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignZW5kIDwgc3RhcnQnKVxuXG4gIC8vIEZpbGwgMCBieXRlczsgd2UncmUgZG9uZVxuICBpZiAoZW5kID09PSBzdGFydCkgcmV0dXJuXG4gIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuXG5cbiAgaWYgKHN0YXJ0IDwgMCB8fCBzdGFydCA+PSB0aGlzLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3N0YXJ0IG91dCBvZiBib3VuZHMnKVxuICBpZiAoZW5kIDwgMCB8fCBlbmQgPiB0aGlzLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ2VuZCBvdXQgb2YgYm91bmRzJylcblxuICB2YXIgaVxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgIGZvciAoaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcbiAgICAgIHRoaXNbaV0gPSB2YWx1ZVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgYnl0ZXMgPSB1dGY4VG9CeXRlcyh2YWx1ZS50b1N0cmluZygpKVxuICAgIHZhciBsZW4gPSBieXRlcy5sZW5ndGhcbiAgICBmb3IgKGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgICB0aGlzW2ldID0gYnl0ZXNbaSAlIGxlbl1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpc1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgYEFycmF5QnVmZmVyYCB3aXRoIHRoZSAqY29waWVkKiBtZW1vcnkgb2YgdGhlIGJ1ZmZlciBpbnN0YW5jZS5cbiAqIEFkZGVkIGluIE5vZGUgMC4xMi4gT25seSBhdmFpbGFibGUgaW4gYnJvd3NlcnMgdGhhdCBzdXBwb3J0IEFycmF5QnVmZmVyLlxuICovXG5CdWZmZXIucHJvdG90eXBlLnRvQXJyYXlCdWZmZXIgPSBmdW5jdGlvbiB0b0FycmF5QnVmZmVyICgpIHtcbiAgaWYgKHR5cGVvZiBVaW50OEFycmF5ICE9PSAndW5kZWZpbmVkJykge1xuICAgIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgICAgcmV0dXJuIChuZXcgQnVmZmVyKHRoaXMpKS5idWZmZXJcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGJ1ZiA9IG5ldyBVaW50OEFycmF5KHRoaXMubGVuZ3RoKVxuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGJ1Zi5sZW5ndGg7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICBidWZbaV0gPSB0aGlzW2ldXG4gICAgICB9XG4gICAgICByZXR1cm4gYnVmLmJ1ZmZlclxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdCdWZmZXIudG9BcnJheUJ1ZmZlciBub3Qgc3VwcG9ydGVkIGluIHRoaXMgYnJvd3NlcicpXG4gIH1cbn1cblxuLy8gSEVMUEVSIEZVTkNUSU9OU1xuLy8gPT09PT09PT09PT09PT09PVxuXG52YXIgQlAgPSBCdWZmZXIucHJvdG90eXBlXG5cbi8qKlxuICogQXVnbWVudCBhIFVpbnQ4QXJyYXkgKmluc3RhbmNlKiAobm90IHRoZSBVaW50OEFycmF5IGNsYXNzISkgd2l0aCBCdWZmZXIgbWV0aG9kc1xuICovXG5CdWZmZXIuX2F1Z21lbnQgPSBmdW5jdGlvbiBfYXVnbWVudCAoYXJyKSB7XG4gIGFyci5jb25zdHJ1Y3RvciA9IEJ1ZmZlclxuICBhcnIuX2lzQnVmZmVyID0gdHJ1ZVxuXG4gIC8vIHNhdmUgcmVmZXJlbmNlIHRvIG9yaWdpbmFsIFVpbnQ4QXJyYXkgc2V0IG1ldGhvZCBiZWZvcmUgb3ZlcndyaXRpbmdcbiAgYXJyLl9zZXQgPSBhcnIuc2V0XG5cbiAgLy8gZGVwcmVjYXRlZFxuICBhcnIuZ2V0ID0gQlAuZ2V0XG4gIGFyci5zZXQgPSBCUC5zZXRcblxuICBhcnIud3JpdGUgPSBCUC53cml0ZVxuICBhcnIudG9TdHJpbmcgPSBCUC50b1N0cmluZ1xuICBhcnIudG9Mb2NhbGVTdHJpbmcgPSBCUC50b1N0cmluZ1xuICBhcnIudG9KU09OID0gQlAudG9KU09OXG4gIGFyci5lcXVhbHMgPSBCUC5lcXVhbHNcbiAgYXJyLmNvbXBhcmUgPSBCUC5jb21wYXJlXG4gIGFyci5pbmRleE9mID0gQlAuaW5kZXhPZlxuICBhcnIuY29weSA9IEJQLmNvcHlcbiAgYXJyLnNsaWNlID0gQlAuc2xpY2VcbiAgYXJyLnJlYWRVSW50TEUgPSBCUC5yZWFkVUludExFXG4gIGFyci5yZWFkVUludEJFID0gQlAucmVhZFVJbnRCRVxuICBhcnIucmVhZFVJbnQ4ID0gQlAucmVhZFVJbnQ4XG4gIGFyci5yZWFkVUludDE2TEUgPSBCUC5yZWFkVUludDE2TEVcbiAgYXJyLnJlYWRVSW50MTZCRSA9IEJQLnJlYWRVSW50MTZCRVxuICBhcnIucmVhZFVJbnQzMkxFID0gQlAucmVhZFVJbnQzMkxFXG4gIGFyci5yZWFkVUludDMyQkUgPSBCUC5yZWFkVUludDMyQkVcbiAgYXJyLnJlYWRJbnRMRSA9IEJQLnJlYWRJbnRMRVxuICBhcnIucmVhZEludEJFID0gQlAucmVhZEludEJFXG4gIGFyci5yZWFkSW50OCA9IEJQLnJlYWRJbnQ4XG4gIGFyci5yZWFkSW50MTZMRSA9IEJQLnJlYWRJbnQxNkxFXG4gIGFyci5yZWFkSW50MTZCRSA9IEJQLnJlYWRJbnQxNkJFXG4gIGFyci5yZWFkSW50MzJMRSA9IEJQLnJlYWRJbnQzMkxFXG4gIGFyci5yZWFkSW50MzJCRSA9IEJQLnJlYWRJbnQzMkJFXG4gIGFyci5yZWFkRmxvYXRMRSA9IEJQLnJlYWRGbG9hdExFXG4gIGFyci5yZWFkRmxvYXRCRSA9IEJQLnJlYWRGbG9hdEJFXG4gIGFyci5yZWFkRG91YmxlTEUgPSBCUC5yZWFkRG91YmxlTEVcbiAgYXJyLnJlYWREb3VibGVCRSA9IEJQLnJlYWREb3VibGVCRVxuICBhcnIud3JpdGVVSW50OCA9IEJQLndyaXRlVUludDhcbiAgYXJyLndyaXRlVUludExFID0gQlAud3JpdGVVSW50TEVcbiAgYXJyLndyaXRlVUludEJFID0gQlAud3JpdGVVSW50QkVcbiAgYXJyLndyaXRlVUludDE2TEUgPSBCUC53cml0ZVVJbnQxNkxFXG4gIGFyci53cml0ZVVJbnQxNkJFID0gQlAud3JpdGVVSW50MTZCRVxuICBhcnIud3JpdGVVSW50MzJMRSA9IEJQLndyaXRlVUludDMyTEVcbiAgYXJyLndyaXRlVUludDMyQkUgPSBCUC53cml0ZVVJbnQzMkJFXG4gIGFyci53cml0ZUludExFID0gQlAud3JpdGVJbnRMRVxuICBhcnIud3JpdGVJbnRCRSA9IEJQLndyaXRlSW50QkVcbiAgYXJyLndyaXRlSW50OCA9IEJQLndyaXRlSW50OFxuICBhcnIud3JpdGVJbnQxNkxFID0gQlAud3JpdGVJbnQxNkxFXG4gIGFyci53cml0ZUludDE2QkUgPSBCUC53cml0ZUludDE2QkVcbiAgYXJyLndyaXRlSW50MzJMRSA9IEJQLndyaXRlSW50MzJMRVxuICBhcnIud3JpdGVJbnQzMkJFID0gQlAud3JpdGVJbnQzMkJFXG4gIGFyci53cml0ZUZsb2F0TEUgPSBCUC53cml0ZUZsb2F0TEVcbiAgYXJyLndyaXRlRmxvYXRCRSA9IEJQLndyaXRlRmxvYXRCRVxuICBhcnIud3JpdGVEb3VibGVMRSA9IEJQLndyaXRlRG91YmxlTEVcbiAgYXJyLndyaXRlRG91YmxlQkUgPSBCUC53cml0ZURvdWJsZUJFXG4gIGFyci5maWxsID0gQlAuZmlsbFxuICBhcnIuaW5zcGVjdCA9IEJQLmluc3BlY3RcbiAgYXJyLnRvQXJyYXlCdWZmZXIgPSBCUC50b0FycmF5QnVmZmVyXG5cbiAgcmV0dXJuIGFyclxufVxuXG52YXIgSU5WQUxJRF9CQVNFNjRfUkUgPSAvW14rXFwvMC05QS1aYS16LV9dL2dcblxuZnVuY3Rpb24gYmFzZTY0Y2xlYW4gKHN0cikge1xuICAvLyBOb2RlIHN0cmlwcyBvdXQgaW52YWxpZCBjaGFyYWN0ZXJzIGxpa2UgXFxuIGFuZCBcXHQgZnJvbSB0aGUgc3RyaW5nLCBiYXNlNjQtanMgZG9lcyBub3RcbiAgc3RyID0gc3RyaW5ndHJpbShzdHIpLnJlcGxhY2UoSU5WQUxJRF9CQVNFNjRfUkUsICcnKVxuICAvLyBOb2RlIGNvbnZlcnRzIHN0cmluZ3Mgd2l0aCBsZW5ndGggPCAyIHRvICcnXG4gIGlmIChzdHIubGVuZ3RoIDwgMikgcmV0dXJuICcnXG4gIC8vIE5vZGUgYWxsb3dzIGZvciBub24tcGFkZGVkIGJhc2U2NCBzdHJpbmdzIChtaXNzaW5nIHRyYWlsaW5nID09PSksIGJhc2U2NC1qcyBkb2VzIG5vdFxuICB3aGlsZSAoc3RyLmxlbmd0aCAlIDQgIT09IDApIHtcbiAgICBzdHIgPSBzdHIgKyAnPSdcbiAgfVxuICByZXR1cm4gc3RyXG59XG5cbmZ1bmN0aW9uIHN0cmluZ3RyaW0gKHN0cikge1xuICBpZiAoc3RyLnRyaW0pIHJldHVybiBzdHIudHJpbSgpXG4gIHJldHVybiBzdHIucmVwbGFjZSgvXlxccyt8XFxzKyQvZywgJycpXG59XG5cbmZ1bmN0aW9uIHRvSGV4IChuKSB7XG4gIGlmIChuIDwgMTYpIHJldHVybiAnMCcgKyBuLnRvU3RyaW5nKDE2KVxuICByZXR1cm4gbi50b1N0cmluZygxNilcbn1cblxuZnVuY3Rpb24gdXRmOFRvQnl0ZXMgKHN0cmluZywgdW5pdHMpIHtcbiAgdW5pdHMgPSB1bml0cyB8fCBJbmZpbml0eVxuICB2YXIgY29kZVBvaW50XG4gIHZhciBsZW5ndGggPSBzdHJpbmcubGVuZ3RoXG4gIHZhciBsZWFkU3Vycm9nYXRlID0gbnVsbFxuICB2YXIgYnl0ZXMgPSBbXVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICBjb2RlUG9pbnQgPSBzdHJpbmcuY2hhckNvZGVBdChpKVxuXG4gICAgLy8gaXMgc3Vycm9nYXRlIGNvbXBvbmVudFxuICAgIGlmIChjb2RlUG9pbnQgPiAweEQ3RkYgJiYgY29kZVBvaW50IDwgMHhFMDAwKSB7XG4gICAgICAvLyBsYXN0IGNoYXIgd2FzIGEgbGVhZFxuICAgICAgaWYgKCFsZWFkU3Vycm9nYXRlKSB7XG4gICAgICAgIC8vIG5vIGxlYWQgeWV0XG4gICAgICAgIGlmIChjb2RlUG9pbnQgPiAweERCRkYpIHtcbiAgICAgICAgICAvLyB1bmV4cGVjdGVkIHRyYWlsXG4gICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfSBlbHNlIGlmIChpICsgMSA9PT0gbGVuZ3RoKSB7XG4gICAgICAgICAgLy8gdW5wYWlyZWQgbGVhZFxuICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cblxuICAgICAgICAvLyB2YWxpZCBsZWFkXG4gICAgICAgIGxlYWRTdXJyb2dhdGUgPSBjb2RlUG9pbnRcblxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICAvLyAyIGxlYWRzIGluIGEgcm93XG4gICAgICBpZiAoY29kZVBvaW50IDwgMHhEQzAwKSB7XG4gICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICBsZWFkU3Vycm9nYXRlID0gY29kZVBvaW50XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIC8vIHZhbGlkIHN1cnJvZ2F0ZSBwYWlyXG4gICAgICBjb2RlUG9pbnQgPSAobGVhZFN1cnJvZ2F0ZSAtIDB4RDgwMCA8PCAxMCB8IGNvZGVQb2ludCAtIDB4REMwMCkgKyAweDEwMDAwXG4gICAgfSBlbHNlIGlmIChsZWFkU3Vycm9nYXRlKSB7XG4gICAgICAvLyB2YWxpZCBibXAgY2hhciwgYnV0IGxhc3QgY2hhciB3YXMgYSBsZWFkXG4gICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICB9XG5cbiAgICBsZWFkU3Vycm9nYXRlID0gbnVsbFxuXG4gICAgLy8gZW5jb2RlIHV0ZjhcbiAgICBpZiAoY29kZVBvaW50IDwgMHg4MCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAxKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKGNvZGVQb2ludClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4ODAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDIpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgfCAweEMwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHgxMDAwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAzKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHhDIHwgMHhFMCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHgxMTAwMDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gNCkgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4MTIgfCAweEYwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHhDICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGNvZGUgcG9pbnQnKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBieXRlc1xufVxuXG5mdW5jdGlvbiBhc2NpaVRvQnl0ZXMgKHN0cikge1xuICB2YXIgYnl0ZUFycmF5ID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICAvLyBOb2RlJ3MgY29kZSBzZWVtcyB0byBiZSBkb2luZyB0aGlzIGFuZCBub3QgJiAweDdGLi5cbiAgICBieXRlQXJyYXkucHVzaChzdHIuY2hhckNvZGVBdChpKSAmIDB4RkYpXG4gIH1cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiB1dGYxNmxlVG9CeXRlcyAoc3RyLCB1bml0cykge1xuICB2YXIgYywgaGksIGxvXG4gIHZhciBieXRlQXJyYXkgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgIGlmICgodW5pdHMgLT0gMikgPCAwKSBicmVha1xuXG4gICAgYyA9IHN0ci5jaGFyQ29kZUF0KGkpXG4gICAgaGkgPSBjID4+IDhcbiAgICBsbyA9IGMgJSAyNTZcbiAgICBieXRlQXJyYXkucHVzaChsbylcbiAgICBieXRlQXJyYXkucHVzaChoaSlcbiAgfVxuXG4gIHJldHVybiBieXRlQXJyYXlcbn1cblxuZnVuY3Rpb24gYmFzZTY0VG9CeXRlcyAoc3RyKSB7XG4gIHJldHVybiBiYXNlNjQudG9CeXRlQXJyYXkoYmFzZTY0Y2xlYW4oc3RyKSlcbn1cblxuZnVuY3Rpb24gYmxpdEJ1ZmZlciAoc3JjLCBkc3QsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoKGkgKyBvZmZzZXQgPj0gZHN0Lmxlbmd0aCkgfHwgKGkgPj0gc3JjLmxlbmd0aCkpIGJyZWFrXG4gICAgZHN0W2kgKyBvZmZzZXRdID0gc3JjW2ldXG4gIH1cbiAgcmV0dXJuIGlcbn1cblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogL3Vzci9sb2NhbC9saWIvfi8ubnBtaW5zdGFsbC9idWZmZXIvMy42LjAvYnVmZmVyL2luZGV4LmpzXG4gKiogbW9kdWxlIGlkID0gMjQ0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgbG9va3VwID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nO1xuXG47KGZ1bmN0aW9uIChleHBvcnRzKSB7XG5cdCd1c2Ugc3RyaWN0JztcblxuICB2YXIgQXJyID0gKHR5cGVvZiBVaW50OEFycmF5ICE9PSAndW5kZWZpbmVkJylcbiAgICA/IFVpbnQ4QXJyYXlcbiAgICA6IEFycmF5XG5cblx0dmFyIFBMVVMgICA9ICcrJy5jaGFyQ29kZUF0KDApXG5cdHZhciBTTEFTSCAgPSAnLycuY2hhckNvZGVBdCgwKVxuXHR2YXIgTlVNQkVSID0gJzAnLmNoYXJDb2RlQXQoMClcblx0dmFyIExPV0VSICA9ICdhJy5jaGFyQ29kZUF0KDApXG5cdHZhciBVUFBFUiAgPSAnQScuY2hhckNvZGVBdCgwKVxuXHR2YXIgUExVU19VUkxfU0FGRSA9ICctJy5jaGFyQ29kZUF0KDApXG5cdHZhciBTTEFTSF9VUkxfU0FGRSA9ICdfJy5jaGFyQ29kZUF0KDApXG5cblx0ZnVuY3Rpb24gZGVjb2RlIChlbHQpIHtcblx0XHR2YXIgY29kZSA9IGVsdC5jaGFyQ29kZUF0KDApXG5cdFx0aWYgKGNvZGUgPT09IFBMVVMgfHxcblx0XHQgICAgY29kZSA9PT0gUExVU19VUkxfU0FGRSlcblx0XHRcdHJldHVybiA2MiAvLyAnKydcblx0XHRpZiAoY29kZSA9PT0gU0xBU0ggfHxcblx0XHQgICAgY29kZSA9PT0gU0xBU0hfVVJMX1NBRkUpXG5cdFx0XHRyZXR1cm4gNjMgLy8gJy8nXG5cdFx0aWYgKGNvZGUgPCBOVU1CRVIpXG5cdFx0XHRyZXR1cm4gLTEgLy9ubyBtYXRjaFxuXHRcdGlmIChjb2RlIDwgTlVNQkVSICsgMTApXG5cdFx0XHRyZXR1cm4gY29kZSAtIE5VTUJFUiArIDI2ICsgMjZcblx0XHRpZiAoY29kZSA8IFVQUEVSICsgMjYpXG5cdFx0XHRyZXR1cm4gY29kZSAtIFVQUEVSXG5cdFx0aWYgKGNvZGUgPCBMT1dFUiArIDI2KVxuXHRcdFx0cmV0dXJuIGNvZGUgLSBMT1dFUiArIDI2XG5cdH1cblxuXHRmdW5jdGlvbiBiNjRUb0J5dGVBcnJheSAoYjY0KSB7XG5cdFx0dmFyIGksIGosIGwsIHRtcCwgcGxhY2VIb2xkZXJzLCBhcnJcblxuXHRcdGlmIChiNjQubGVuZ3RoICUgNCA+IDApIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzdHJpbmcuIExlbmd0aCBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNCcpXG5cdFx0fVxuXG5cdFx0Ly8gdGhlIG51bWJlciBvZiBlcXVhbCBzaWducyAocGxhY2UgaG9sZGVycylcblx0XHQvLyBpZiB0aGVyZSBhcmUgdHdvIHBsYWNlaG9sZGVycywgdGhhbiB0aGUgdHdvIGNoYXJhY3RlcnMgYmVmb3JlIGl0XG5cdFx0Ly8gcmVwcmVzZW50IG9uZSBieXRlXG5cdFx0Ly8gaWYgdGhlcmUgaXMgb25seSBvbmUsIHRoZW4gdGhlIHRocmVlIGNoYXJhY3RlcnMgYmVmb3JlIGl0IHJlcHJlc2VudCAyIGJ5dGVzXG5cdFx0Ly8gdGhpcyBpcyBqdXN0IGEgY2hlYXAgaGFjayB0byBub3QgZG8gaW5kZXhPZiB0d2ljZVxuXHRcdHZhciBsZW4gPSBiNjQubGVuZ3RoXG5cdFx0cGxhY2VIb2xkZXJzID0gJz0nID09PSBiNjQuY2hhckF0KGxlbiAtIDIpID8gMiA6ICc9JyA9PT0gYjY0LmNoYXJBdChsZW4gLSAxKSA/IDEgOiAwXG5cblx0XHQvLyBiYXNlNjQgaXMgNC8zICsgdXAgdG8gdHdvIGNoYXJhY3RlcnMgb2YgdGhlIG9yaWdpbmFsIGRhdGFcblx0XHRhcnIgPSBuZXcgQXJyKGI2NC5sZW5ndGggKiAzIC8gNCAtIHBsYWNlSG9sZGVycylcblxuXHRcdC8vIGlmIHRoZXJlIGFyZSBwbGFjZWhvbGRlcnMsIG9ubHkgZ2V0IHVwIHRvIHRoZSBsYXN0IGNvbXBsZXRlIDQgY2hhcnNcblx0XHRsID0gcGxhY2VIb2xkZXJzID4gMCA/IGI2NC5sZW5ndGggLSA0IDogYjY0Lmxlbmd0aFxuXG5cdFx0dmFyIEwgPSAwXG5cblx0XHRmdW5jdGlvbiBwdXNoICh2KSB7XG5cdFx0XHRhcnJbTCsrXSA9IHZcblx0XHR9XG5cblx0XHRmb3IgKGkgPSAwLCBqID0gMDsgaSA8IGw7IGkgKz0gNCwgaiArPSAzKSB7XG5cdFx0XHR0bXAgPSAoZGVjb2RlKGI2NC5jaGFyQXQoaSkpIDw8IDE4KSB8IChkZWNvZGUoYjY0LmNoYXJBdChpICsgMSkpIDw8IDEyKSB8IChkZWNvZGUoYjY0LmNoYXJBdChpICsgMikpIDw8IDYpIHwgZGVjb2RlKGI2NC5jaGFyQXQoaSArIDMpKVxuXHRcdFx0cHVzaCgodG1wICYgMHhGRjAwMDApID4+IDE2KVxuXHRcdFx0cHVzaCgodG1wICYgMHhGRjAwKSA+PiA4KVxuXHRcdFx0cHVzaCh0bXAgJiAweEZGKVxuXHRcdH1cblxuXHRcdGlmIChwbGFjZUhvbGRlcnMgPT09IDIpIHtcblx0XHRcdHRtcCA9IChkZWNvZGUoYjY0LmNoYXJBdChpKSkgPDwgMikgfCAoZGVjb2RlKGI2NC5jaGFyQXQoaSArIDEpKSA+PiA0KVxuXHRcdFx0cHVzaCh0bXAgJiAweEZGKVxuXHRcdH0gZWxzZSBpZiAocGxhY2VIb2xkZXJzID09PSAxKSB7XG5cdFx0XHR0bXAgPSAoZGVjb2RlKGI2NC5jaGFyQXQoaSkpIDw8IDEwKSB8IChkZWNvZGUoYjY0LmNoYXJBdChpICsgMSkpIDw8IDQpIHwgKGRlY29kZShiNjQuY2hhckF0KGkgKyAyKSkgPj4gMilcblx0XHRcdHB1c2goKHRtcCA+PiA4KSAmIDB4RkYpXG5cdFx0XHRwdXNoKHRtcCAmIDB4RkYpXG5cdFx0fVxuXG5cdFx0cmV0dXJuIGFyclxuXHR9XG5cblx0ZnVuY3Rpb24gdWludDhUb0Jhc2U2NCAodWludDgpIHtcblx0XHR2YXIgaSxcblx0XHRcdGV4dHJhQnl0ZXMgPSB1aW50OC5sZW5ndGggJSAzLCAvLyBpZiB3ZSBoYXZlIDEgYnl0ZSBsZWZ0LCBwYWQgMiBieXRlc1xuXHRcdFx0b3V0cHV0ID0gXCJcIixcblx0XHRcdHRlbXAsIGxlbmd0aFxuXG5cdFx0ZnVuY3Rpb24gZW5jb2RlIChudW0pIHtcblx0XHRcdHJldHVybiBsb29rdXAuY2hhckF0KG51bSlcblx0XHR9XG5cblx0XHRmdW5jdGlvbiB0cmlwbGV0VG9CYXNlNjQgKG51bSkge1xuXHRcdFx0cmV0dXJuIGVuY29kZShudW0gPj4gMTggJiAweDNGKSArIGVuY29kZShudW0gPj4gMTIgJiAweDNGKSArIGVuY29kZShudW0gPj4gNiAmIDB4M0YpICsgZW5jb2RlKG51bSAmIDB4M0YpXG5cdFx0fVxuXG5cdFx0Ly8gZ28gdGhyb3VnaCB0aGUgYXJyYXkgZXZlcnkgdGhyZWUgYnl0ZXMsIHdlJ2xsIGRlYWwgd2l0aCB0cmFpbGluZyBzdHVmZiBsYXRlclxuXHRcdGZvciAoaSA9IDAsIGxlbmd0aCA9IHVpbnQ4Lmxlbmd0aCAtIGV4dHJhQnl0ZXM7IGkgPCBsZW5ndGg7IGkgKz0gMykge1xuXHRcdFx0dGVtcCA9ICh1aW50OFtpXSA8PCAxNikgKyAodWludDhbaSArIDFdIDw8IDgpICsgKHVpbnQ4W2kgKyAyXSlcblx0XHRcdG91dHB1dCArPSB0cmlwbGV0VG9CYXNlNjQodGVtcClcblx0XHR9XG5cblx0XHQvLyBwYWQgdGhlIGVuZCB3aXRoIHplcm9zLCBidXQgbWFrZSBzdXJlIHRvIG5vdCBmb3JnZXQgdGhlIGV4dHJhIGJ5dGVzXG5cdFx0c3dpdGNoIChleHRyYUJ5dGVzKSB7XG5cdFx0XHRjYXNlIDE6XG5cdFx0XHRcdHRlbXAgPSB1aW50OFt1aW50OC5sZW5ndGggLSAxXVxuXHRcdFx0XHRvdXRwdXQgKz0gZW5jb2RlKHRlbXAgPj4gMilcblx0XHRcdFx0b3V0cHV0ICs9IGVuY29kZSgodGVtcCA8PCA0KSAmIDB4M0YpXG5cdFx0XHRcdG91dHB1dCArPSAnPT0nXG5cdFx0XHRcdGJyZWFrXG5cdFx0XHRjYXNlIDI6XG5cdFx0XHRcdHRlbXAgPSAodWludDhbdWludDgubGVuZ3RoIC0gMl0gPDwgOCkgKyAodWludDhbdWludDgubGVuZ3RoIC0gMV0pXG5cdFx0XHRcdG91dHB1dCArPSBlbmNvZGUodGVtcCA+PiAxMClcblx0XHRcdFx0b3V0cHV0ICs9IGVuY29kZSgodGVtcCA+PiA0KSAmIDB4M0YpXG5cdFx0XHRcdG91dHB1dCArPSBlbmNvZGUoKHRlbXAgPDwgMikgJiAweDNGKVxuXHRcdFx0XHRvdXRwdXQgKz0gJz0nXG5cdFx0XHRcdGJyZWFrXG5cdFx0fVxuXG5cdFx0cmV0dXJuIG91dHB1dFxuXHR9XG5cblx0ZXhwb3J0cy50b0J5dGVBcnJheSA9IGI2NFRvQnl0ZUFycmF5XG5cdGV4cG9ydHMuZnJvbUJ5dGVBcnJheSA9IHVpbnQ4VG9CYXNlNjRcbn0odHlwZW9mIGV4cG9ydHMgPT09ICd1bmRlZmluZWQnID8gKHRoaXMuYmFzZTY0anMgPSB7fSkgOiBleHBvcnRzKSlcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogL3Vzci9sb2NhbC9saWIvfi8ubnBtaW5zdGFsbC9iYXNlNjQtanMvMC4wLjgvYmFzZTY0LWpzL2xpYi9iNjQuanNcbiAqKiBtb2R1bGUgaWQgPSAyNDVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsImV4cG9ydHMucmVhZCA9IGZ1bmN0aW9uIChidWZmZXIsIG9mZnNldCwgaXNMRSwgbUxlbiwgbkJ5dGVzKSB7XG4gIHZhciBlLCBtXG4gIHZhciBlTGVuID0gbkJ5dGVzICogOCAtIG1MZW4gLSAxXG4gIHZhciBlTWF4ID0gKDEgPDwgZUxlbikgLSAxXG4gIHZhciBlQmlhcyA9IGVNYXggPj4gMVxuICB2YXIgbkJpdHMgPSAtN1xuICB2YXIgaSA9IGlzTEUgPyAobkJ5dGVzIC0gMSkgOiAwXG4gIHZhciBkID0gaXNMRSA/IC0xIDogMVxuICB2YXIgcyA9IGJ1ZmZlcltvZmZzZXQgKyBpXVxuXG4gIGkgKz0gZFxuXG4gIGUgPSBzICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpXG4gIHMgPj49ICgtbkJpdHMpXG4gIG5CaXRzICs9IGVMZW5cbiAgZm9yICg7IG5CaXRzID4gMDsgZSA9IGUgKiAyNTYgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCkge31cblxuICBtID0gZSAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKVxuICBlID4+PSAoLW5CaXRzKVxuICBuQml0cyArPSBtTGVuXG4gIGZvciAoOyBuQml0cyA+IDA7IG0gPSBtICogMjU2ICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpIHt9XG5cbiAgaWYgKGUgPT09IDApIHtcbiAgICBlID0gMSAtIGVCaWFzXG4gIH0gZWxzZSBpZiAoZSA9PT0gZU1heCkge1xuICAgIHJldHVybiBtID8gTmFOIDogKChzID8gLTEgOiAxKSAqIEluZmluaXR5KVxuICB9IGVsc2Uge1xuICAgIG0gPSBtICsgTWF0aC5wb3coMiwgbUxlbilcbiAgICBlID0gZSAtIGVCaWFzXG4gIH1cbiAgcmV0dXJuIChzID8gLTEgOiAxKSAqIG0gKiBNYXRoLnBvdygyLCBlIC0gbUxlbilcbn1cblxuZXhwb3J0cy53cml0ZSA9IGZ1bmN0aW9uIChidWZmZXIsIHZhbHVlLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbSwgY1xuICB2YXIgZUxlbiA9IG5CeXRlcyAqIDggLSBtTGVuIC0gMVxuICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMVxuICB2YXIgZUJpYXMgPSBlTWF4ID4+IDFcbiAgdmFyIHJ0ID0gKG1MZW4gPT09IDIzID8gTWF0aC5wb3coMiwgLTI0KSAtIE1hdGgucG93KDIsIC03NykgOiAwKVxuICB2YXIgaSA9IGlzTEUgPyAwIDogKG5CeXRlcyAtIDEpXG4gIHZhciBkID0gaXNMRSA/IDEgOiAtMVxuICB2YXIgcyA9IHZhbHVlIDwgMCB8fCAodmFsdWUgPT09IDAgJiYgMSAvIHZhbHVlIDwgMCkgPyAxIDogMFxuXG4gIHZhbHVlID0gTWF0aC5hYnModmFsdWUpXG5cbiAgaWYgKGlzTmFOKHZhbHVlKSB8fCB2YWx1ZSA9PT0gSW5maW5pdHkpIHtcbiAgICBtID0gaXNOYU4odmFsdWUpID8gMSA6IDBcbiAgICBlID0gZU1heFxuICB9IGVsc2Uge1xuICAgIGUgPSBNYXRoLmZsb29yKE1hdGgubG9nKHZhbHVlKSAvIE1hdGguTE4yKVxuICAgIGlmICh2YWx1ZSAqIChjID0gTWF0aC5wb3coMiwgLWUpKSA8IDEpIHtcbiAgICAgIGUtLVxuICAgICAgYyAqPSAyXG4gICAgfVxuICAgIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgdmFsdWUgKz0gcnQgLyBjXG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbHVlICs9IHJ0ICogTWF0aC5wb3coMiwgMSAtIGVCaWFzKVxuICAgIH1cbiAgICBpZiAodmFsdWUgKiBjID49IDIpIHtcbiAgICAgIGUrK1xuICAgICAgYyAvPSAyXG4gICAgfVxuXG4gICAgaWYgKGUgKyBlQmlhcyA+PSBlTWF4KSB7XG4gICAgICBtID0gMFxuICAgICAgZSA9IGVNYXhcbiAgICB9IGVsc2UgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICBtID0gKHZhbHVlICogYyAtIDEpICogTWF0aC5wb3coMiwgbUxlbilcbiAgICAgIGUgPSBlICsgZUJpYXNcbiAgICB9IGVsc2Uge1xuICAgICAgbSA9IHZhbHVlICogTWF0aC5wb3coMiwgZUJpYXMgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pXG4gICAgICBlID0gMFxuICAgIH1cbiAgfVxuXG4gIGZvciAoOyBtTGVuID49IDg7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IG0gJiAweGZmLCBpICs9IGQsIG0gLz0gMjU2LCBtTGVuIC09IDgpIHt9XG5cbiAgZSA9IChlIDw8IG1MZW4pIHwgbVxuICBlTGVuICs9IG1MZW5cbiAgZm9yICg7IGVMZW4gPiAwOyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBlICYgMHhmZiwgaSArPSBkLCBlIC89IDI1NiwgZUxlbiAtPSA4KSB7fVxuXG4gIGJ1ZmZlcltvZmZzZXQgKyBpIC0gZF0gfD0gcyAqIDEyOFxufVxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAvdXNyL2xvY2FsL2xpYi9+Ly5ucG1pbnN0YWxsL2llZWU3NTQvMS4xLjYvaWVlZTc1NC9pbmRleC5qc1xuICoqIG1vZHVsZSBpZCA9IDI0NlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIHRvU3RyaW5nID0ge30udG9TdHJpbmc7XG5cbm1vZHVsZS5leHBvcnRzID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoYXJyKSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKGFycikgPT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC91c3IvbG9jYWwvbGliL34vLm5wbWluc3RhbGwvaXNhcnJheS8xLjAuMC9pc2FycmF5L2luZGV4LmpzXG4gKiogbW9kdWxlIGlkID0gMjQ3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxudmFyIGZvcm1hdFJlZ0V4cCA9IC8lW3NkaiVdL2c7XG5leHBvcnRzLmZvcm1hdCA9IGZ1bmN0aW9uKGYpIHtcbiAgaWYgKCFpc1N0cmluZyhmKSkge1xuICAgIHZhciBvYmplY3RzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIG9iamVjdHMucHVzaChpbnNwZWN0KGFyZ3VtZW50c1tpXSkpO1xuICAgIH1cbiAgICByZXR1cm4gb2JqZWN0cy5qb2luKCcgJyk7XG4gIH1cblxuICB2YXIgaSA9IDE7XG4gIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICB2YXIgbGVuID0gYXJncy5sZW5ndGg7XG4gIHZhciBzdHIgPSBTdHJpbmcoZikucmVwbGFjZShmb3JtYXRSZWdFeHAsIGZ1bmN0aW9uKHgpIHtcbiAgICBpZiAoeCA9PT0gJyUlJykgcmV0dXJuICclJztcbiAgICBpZiAoaSA+PSBsZW4pIHJldHVybiB4O1xuICAgIHN3aXRjaCAoeCkge1xuICAgICAgY2FzZSAnJXMnOiByZXR1cm4gU3RyaW5nKGFyZ3NbaSsrXSk7XG4gICAgICBjYXNlICclZCc6IHJldHVybiBOdW1iZXIoYXJnc1tpKytdKTtcbiAgICAgIGNhc2UgJyVqJzpcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoYXJnc1tpKytdKTtcbiAgICAgICAgfSBjYXRjaCAoXykge1xuICAgICAgICAgIHJldHVybiAnW0NpcmN1bGFyXSc7XG4gICAgICAgIH1cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiB4O1xuICAgIH1cbiAgfSk7XG4gIGZvciAodmFyIHggPSBhcmdzW2ldOyBpIDwgbGVuOyB4ID0gYXJnc1srK2ldKSB7XG4gICAgaWYgKGlzTnVsbCh4KSB8fCAhaXNPYmplY3QoeCkpIHtcbiAgICAgIHN0ciArPSAnICcgKyB4O1xuICAgIH0gZWxzZSB7XG4gICAgICBzdHIgKz0gJyAnICsgaW5zcGVjdCh4KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHN0cjtcbn07XG5cblxuLy8gTWFyayB0aGF0IGEgbWV0aG9kIHNob3VsZCBub3QgYmUgdXNlZC5cbi8vIFJldHVybnMgYSBtb2RpZmllZCBmdW5jdGlvbiB3aGljaCB3YXJucyBvbmNlIGJ5IGRlZmF1bHQuXG4vLyBJZiAtLW5vLWRlcHJlY2F0aW9uIGlzIHNldCwgdGhlbiBpdCBpcyBhIG5vLW9wLlxuZXhwb3J0cy5kZXByZWNhdGUgPSBmdW5jdGlvbihmbiwgbXNnKSB7XG4gIC8vIEFsbG93IGZvciBkZXByZWNhdGluZyB0aGluZ3MgaW4gdGhlIHByb2Nlc3Mgb2Ygc3RhcnRpbmcgdXAuXG4gIGlmIChpc1VuZGVmaW5lZChnbG9iYWwucHJvY2VzcykpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZXhwb3J0cy5kZXByZWNhdGUoZm4sIG1zZykuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9O1xuICB9XG5cbiAgaWYgKHByb2Nlc3Mubm9EZXByZWNhdGlvbiA9PT0gdHJ1ZSkge1xuICAgIHJldHVybiBmbjtcbiAgfVxuXG4gIHZhciB3YXJuZWQgPSBmYWxzZTtcbiAgZnVuY3Rpb24gZGVwcmVjYXRlZCgpIHtcbiAgICBpZiAoIXdhcm5lZCkge1xuICAgICAgaWYgKHByb2Nlc3MudGhyb3dEZXByZWNhdGlvbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbiAgICAgIH0gZWxzZSBpZiAocHJvY2Vzcy50cmFjZURlcHJlY2F0aW9uKSB7XG4gICAgICAgIGNvbnNvbGUudHJhY2UobXNnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IobXNnKTtcbiAgICAgIH1cbiAgICAgIHdhcm5lZCA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgcmV0dXJuIGRlcHJlY2F0ZWQ7XG59O1xuXG5cbnZhciBkZWJ1Z3MgPSB7fTtcbnZhciBkZWJ1Z0Vudmlyb247XG5leHBvcnRzLmRlYnVnbG9nID0gZnVuY3Rpb24oc2V0KSB7XG4gIGlmIChpc1VuZGVmaW5lZChkZWJ1Z0Vudmlyb24pKVxuICAgIGRlYnVnRW52aXJvbiA9IHByb2Nlc3MuZW52Lk5PREVfREVCVUcgfHwgJyc7XG4gIHNldCA9IHNldC50b1VwcGVyQ2FzZSgpO1xuICBpZiAoIWRlYnVnc1tzZXRdKSB7XG4gICAgaWYgKG5ldyBSZWdFeHAoJ1xcXFxiJyArIHNldCArICdcXFxcYicsICdpJykudGVzdChkZWJ1Z0Vudmlyb24pKSB7XG4gICAgICB2YXIgcGlkID0gcHJvY2Vzcy5waWQ7XG4gICAgICBkZWJ1Z3Nbc2V0XSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgbXNnID0gZXhwb3J0cy5mb3JtYXQuYXBwbHkoZXhwb3J0cywgYXJndW1lbnRzKTtcbiAgICAgICAgY29uc29sZS5lcnJvcignJXMgJWQ6ICVzJywgc2V0LCBwaWQsIG1zZyk7XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWJ1Z3Nbc2V0XSA9IGZ1bmN0aW9uKCkge307XG4gICAgfVxuICB9XG4gIHJldHVybiBkZWJ1Z3Nbc2V0XTtcbn07XG5cblxuLyoqXG4gKiBFY2hvcyB0aGUgdmFsdWUgb2YgYSB2YWx1ZS4gVHJ5cyB0byBwcmludCB0aGUgdmFsdWUgb3V0XG4gKiBpbiB0aGUgYmVzdCB3YXkgcG9zc2libGUgZ2l2ZW4gdGhlIGRpZmZlcmVudCB0eXBlcy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIFRoZSBvYmplY3QgdG8gcHJpbnQgb3V0LlxuICogQHBhcmFtIHtPYmplY3R9IG9wdHMgT3B0aW9uYWwgb3B0aW9ucyBvYmplY3QgdGhhdCBhbHRlcnMgdGhlIG91dHB1dC5cbiAqL1xuLyogbGVnYWN5OiBvYmosIHNob3dIaWRkZW4sIGRlcHRoLCBjb2xvcnMqL1xuZnVuY3Rpb24gaW5zcGVjdChvYmosIG9wdHMpIHtcbiAgLy8gZGVmYXVsdCBvcHRpb25zXG4gIHZhciBjdHggPSB7XG4gICAgc2VlbjogW10sXG4gICAgc3R5bGl6ZTogc3R5bGl6ZU5vQ29sb3JcbiAgfTtcbiAgLy8gbGVnYWN5Li4uXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID49IDMpIGN0eC5kZXB0aCA9IGFyZ3VtZW50c1syXTtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPj0gNCkgY3R4LmNvbG9ycyA9IGFyZ3VtZW50c1szXTtcbiAgaWYgKGlzQm9vbGVhbihvcHRzKSkge1xuICAgIC8vIGxlZ2FjeS4uLlxuICAgIGN0eC5zaG93SGlkZGVuID0gb3B0cztcbiAgfSBlbHNlIGlmIChvcHRzKSB7XG4gICAgLy8gZ290IGFuIFwib3B0aW9uc1wiIG9iamVjdFxuICAgIGV4cG9ydHMuX2V4dGVuZChjdHgsIG9wdHMpO1xuICB9XG4gIC8vIHNldCBkZWZhdWx0IG9wdGlvbnNcbiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5zaG93SGlkZGVuKSkgY3R4LnNob3dIaWRkZW4gPSBmYWxzZTtcbiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5kZXB0aCkpIGN0eC5kZXB0aCA9IDI7XG4gIGlmIChpc1VuZGVmaW5lZChjdHguY29sb3JzKSkgY3R4LmNvbG9ycyA9IGZhbHNlO1xuICBpZiAoaXNVbmRlZmluZWQoY3R4LmN1c3RvbUluc3BlY3QpKSBjdHguY3VzdG9tSW5zcGVjdCA9IHRydWU7XG4gIGlmIChjdHguY29sb3JzKSBjdHguc3R5bGl6ZSA9IHN0eWxpemVXaXRoQ29sb3I7XG4gIHJldHVybiBmb3JtYXRWYWx1ZShjdHgsIG9iaiwgY3R4LmRlcHRoKTtcbn1cbmV4cG9ydHMuaW5zcGVjdCA9IGluc3BlY3Q7XG5cblxuLy8gaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9BTlNJX2VzY2FwZV9jb2RlI2dyYXBoaWNzXG5pbnNwZWN0LmNvbG9ycyA9IHtcbiAgJ2JvbGQnIDogWzEsIDIyXSxcbiAgJ2l0YWxpYycgOiBbMywgMjNdLFxuICAndW5kZXJsaW5lJyA6IFs0LCAyNF0sXG4gICdpbnZlcnNlJyA6IFs3LCAyN10sXG4gICd3aGl0ZScgOiBbMzcsIDM5XSxcbiAgJ2dyZXknIDogWzkwLCAzOV0sXG4gICdibGFjaycgOiBbMzAsIDM5XSxcbiAgJ2JsdWUnIDogWzM0LCAzOV0sXG4gICdjeWFuJyA6IFszNiwgMzldLFxuICAnZ3JlZW4nIDogWzMyLCAzOV0sXG4gICdtYWdlbnRhJyA6IFszNSwgMzldLFxuICAncmVkJyA6IFszMSwgMzldLFxuICAneWVsbG93JyA6IFszMywgMzldXG59O1xuXG4vLyBEb24ndCB1c2UgJ2JsdWUnIG5vdCB2aXNpYmxlIG9uIGNtZC5leGVcbmluc3BlY3Quc3R5bGVzID0ge1xuICAnc3BlY2lhbCc6ICdjeWFuJyxcbiAgJ251bWJlcic6ICd5ZWxsb3cnLFxuICAnYm9vbGVhbic6ICd5ZWxsb3cnLFxuICAndW5kZWZpbmVkJzogJ2dyZXknLFxuICAnbnVsbCc6ICdib2xkJyxcbiAgJ3N0cmluZyc6ICdncmVlbicsXG4gICdkYXRlJzogJ21hZ2VudGEnLFxuICAvLyBcIm5hbWVcIjogaW50ZW50aW9uYWxseSBub3Qgc3R5bGluZ1xuICAncmVnZXhwJzogJ3JlZCdcbn07XG5cblxuZnVuY3Rpb24gc3R5bGl6ZVdpdGhDb2xvcihzdHIsIHN0eWxlVHlwZSkge1xuICB2YXIgc3R5bGUgPSBpbnNwZWN0LnN0eWxlc1tzdHlsZVR5cGVdO1xuXG4gIGlmIChzdHlsZSkge1xuICAgIHJldHVybiAnXFx1MDAxYlsnICsgaW5zcGVjdC5jb2xvcnNbc3R5bGVdWzBdICsgJ20nICsgc3RyICtcbiAgICAgICAgICAgJ1xcdTAwMWJbJyArIGluc3BlY3QuY29sb3JzW3N0eWxlXVsxXSArICdtJztcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gc3RyO1xuICB9XG59XG5cblxuZnVuY3Rpb24gc3R5bGl6ZU5vQ29sb3Ioc3RyLCBzdHlsZVR5cGUpIHtcbiAgcmV0dXJuIHN0cjtcbn1cblxuXG5mdW5jdGlvbiBhcnJheVRvSGFzaChhcnJheSkge1xuICB2YXIgaGFzaCA9IHt9O1xuXG4gIGFycmF5LmZvckVhY2goZnVuY3Rpb24odmFsLCBpZHgpIHtcbiAgICBoYXNoW3ZhbF0gPSB0cnVlO1xuICB9KTtcblxuICByZXR1cm4gaGFzaDtcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRWYWx1ZShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMpIHtcbiAgLy8gUHJvdmlkZSBhIGhvb2sgZm9yIHVzZXItc3BlY2lmaWVkIGluc3BlY3QgZnVuY3Rpb25zLlxuICAvLyBDaGVjayB0aGF0IHZhbHVlIGlzIGFuIG9iamVjdCB3aXRoIGFuIGluc3BlY3QgZnVuY3Rpb24gb24gaXRcbiAgaWYgKGN0eC5jdXN0b21JbnNwZWN0ICYmXG4gICAgICB2YWx1ZSAmJlxuICAgICAgaXNGdW5jdGlvbih2YWx1ZS5pbnNwZWN0KSAmJlxuICAgICAgLy8gRmlsdGVyIG91dCB0aGUgdXRpbCBtb2R1bGUsIGl0J3MgaW5zcGVjdCBmdW5jdGlvbiBpcyBzcGVjaWFsXG4gICAgICB2YWx1ZS5pbnNwZWN0ICE9PSBleHBvcnRzLmluc3BlY3QgJiZcbiAgICAgIC8vIEFsc28gZmlsdGVyIG91dCBhbnkgcHJvdG90eXBlIG9iamVjdHMgdXNpbmcgdGhlIGNpcmN1bGFyIGNoZWNrLlxuICAgICAgISh2YWx1ZS5jb25zdHJ1Y3RvciAmJiB2YWx1ZS5jb25zdHJ1Y3Rvci5wcm90b3R5cGUgPT09IHZhbHVlKSkge1xuICAgIHZhciByZXQgPSB2YWx1ZS5pbnNwZWN0KHJlY3Vyc2VUaW1lcywgY3R4KTtcbiAgICBpZiAoIWlzU3RyaW5nKHJldCkpIHtcbiAgICAgIHJldCA9IGZvcm1hdFZhbHVlKGN0eCwgcmV0LCByZWN1cnNlVGltZXMpO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9XG5cbiAgLy8gUHJpbWl0aXZlIHR5cGVzIGNhbm5vdCBoYXZlIHByb3BlcnRpZXNcbiAgdmFyIHByaW1pdGl2ZSA9IGZvcm1hdFByaW1pdGl2ZShjdHgsIHZhbHVlKTtcbiAgaWYgKHByaW1pdGl2ZSkge1xuICAgIHJldHVybiBwcmltaXRpdmU7XG4gIH1cblxuICAvLyBMb29rIHVwIHRoZSBrZXlzIG9mIHRoZSBvYmplY3QuXG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXModmFsdWUpO1xuICB2YXIgdmlzaWJsZUtleXMgPSBhcnJheVRvSGFzaChrZXlzKTtcblxuICBpZiAoY3R4LnNob3dIaWRkZW4pIHtcbiAgICBrZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModmFsdWUpO1xuICB9XG5cbiAgLy8gSUUgZG9lc24ndCBtYWtlIGVycm9yIGZpZWxkcyBub24tZW51bWVyYWJsZVxuICAvLyBodHRwOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvaWUvZHd3NTJzYnQodj12cy45NCkuYXNweFxuICBpZiAoaXNFcnJvcih2YWx1ZSlcbiAgICAgICYmIChrZXlzLmluZGV4T2YoJ21lc3NhZ2UnKSA+PSAwIHx8IGtleXMuaW5kZXhPZignZGVzY3JpcHRpb24nKSA+PSAwKSkge1xuICAgIHJldHVybiBmb3JtYXRFcnJvcih2YWx1ZSk7XG4gIH1cblxuICAvLyBTb21lIHR5cGUgb2Ygb2JqZWN0IHdpdGhvdXQgcHJvcGVydGllcyBjYW4gYmUgc2hvcnRjdXR0ZWQuXG4gIGlmIChrZXlzLmxlbmd0aCA9PT0gMCkge1xuICAgIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgICAgdmFyIG5hbWUgPSB2YWx1ZS5uYW1lID8gJzogJyArIHZhbHVlLm5hbWUgOiAnJztcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZSgnW0Z1bmN0aW9uJyArIG5hbWUgKyAnXScsICdzcGVjaWFsJyk7XG4gICAgfVxuICAgIGlmIChpc1JlZ0V4cCh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZShSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLCAncmVnZXhwJyk7XG4gICAgfVxuICAgIGlmIChpc0RhdGUodmFsdWUpKSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoRGF0ZS5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSksICdkYXRlJyk7XG4gICAgfVxuICAgIGlmIChpc0Vycm9yKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGZvcm1hdEVycm9yKHZhbHVlKTtcbiAgICB9XG4gIH1cblxuICB2YXIgYmFzZSA9ICcnLCBhcnJheSA9IGZhbHNlLCBicmFjZXMgPSBbJ3snLCAnfSddO1xuXG4gIC8vIE1ha2UgQXJyYXkgc2F5IHRoYXQgdGhleSBhcmUgQXJyYXlcbiAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgYXJyYXkgPSB0cnVlO1xuICAgIGJyYWNlcyA9IFsnWycsICddJ107XG4gIH1cblxuICAvLyBNYWtlIGZ1bmN0aW9ucyBzYXkgdGhhdCB0aGV5IGFyZSBmdW5jdGlvbnNcbiAgaWYgKGlzRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgdmFyIG4gPSB2YWx1ZS5uYW1lID8gJzogJyArIHZhbHVlLm5hbWUgOiAnJztcbiAgICBiYXNlID0gJyBbRnVuY3Rpb24nICsgbiArICddJztcbiAgfVxuXG4gIC8vIE1ha2UgUmVnRXhwcyBzYXkgdGhhdCB0aGV5IGFyZSBSZWdFeHBzXG4gIGlmIChpc1JlZ0V4cCh2YWx1ZSkpIHtcbiAgICBiYXNlID0gJyAnICsgUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgfVxuXG4gIC8vIE1ha2UgZGF0ZXMgd2l0aCBwcm9wZXJ0aWVzIGZpcnN0IHNheSB0aGUgZGF0ZVxuICBpZiAoaXNEYXRlKHZhbHVlKSkge1xuICAgIGJhc2UgPSAnICcgKyBEYXRlLnByb3RvdHlwZS50b1VUQ1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgfVxuXG4gIC8vIE1ha2UgZXJyb3Igd2l0aCBtZXNzYWdlIGZpcnN0IHNheSB0aGUgZXJyb3JcbiAgaWYgKGlzRXJyb3IodmFsdWUpKSB7XG4gICAgYmFzZSA9ICcgJyArIGZvcm1hdEVycm9yKHZhbHVlKTtcbiAgfVxuXG4gIGlmIChrZXlzLmxlbmd0aCA9PT0gMCAmJiAoIWFycmF5IHx8IHZhbHVlLmxlbmd0aCA9PSAwKSkge1xuICAgIHJldHVybiBicmFjZXNbMF0gKyBiYXNlICsgYnJhY2VzWzFdO1xuICB9XG5cbiAgaWYgKHJlY3Vyc2VUaW1lcyA8IDApIHtcbiAgICBpZiAoaXNSZWdFeHAodmFsdWUpKSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSwgJ3JlZ2V4cCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoJ1tPYmplY3RdJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gIH1cblxuICBjdHguc2Vlbi5wdXNoKHZhbHVlKTtcblxuICB2YXIgb3V0cHV0O1xuICBpZiAoYXJyYXkpIHtcbiAgICBvdXRwdXQgPSBmb3JtYXRBcnJheShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXlzKTtcbiAgfSBlbHNlIHtcbiAgICBvdXRwdXQgPSBrZXlzLm1hcChmdW5jdGlvbihrZXkpIHtcbiAgICAgIHJldHVybiBmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXksIGFycmF5KTtcbiAgICB9KTtcbiAgfVxuXG4gIGN0eC5zZWVuLnBvcCgpO1xuXG4gIHJldHVybiByZWR1Y2VUb1NpbmdsZVN0cmluZyhvdXRwdXQsIGJhc2UsIGJyYWNlcyk7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0UHJpbWl0aXZlKGN0eCwgdmFsdWUpIHtcbiAgaWYgKGlzVW5kZWZpbmVkKHZhbHVlKSlcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJ3VuZGVmaW5lZCcsICd1bmRlZmluZWQnKTtcbiAgaWYgKGlzU3RyaW5nKHZhbHVlKSkge1xuICAgIHZhciBzaW1wbGUgPSAnXFwnJyArIEpTT04uc3RyaW5naWZ5KHZhbHVlKS5yZXBsYWNlKC9eXCJ8XCIkL2csICcnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoLycvZywgXCJcXFxcJ1wiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcXFxcIi9nLCAnXCInKSArICdcXCcnO1xuICAgIHJldHVybiBjdHguc3R5bGl6ZShzaW1wbGUsICdzdHJpbmcnKTtcbiAgfVxuICBpZiAoaXNOdW1iZXIodmFsdWUpKVxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgnJyArIHZhbHVlLCAnbnVtYmVyJyk7XG4gIGlmIChpc0Jvb2xlYW4odmFsdWUpKVxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgnJyArIHZhbHVlLCAnYm9vbGVhbicpO1xuICAvLyBGb3Igc29tZSByZWFzb24gdHlwZW9mIG51bGwgaXMgXCJvYmplY3RcIiwgc28gc3BlY2lhbCBjYXNlIGhlcmUuXG4gIGlmIChpc051bGwodmFsdWUpKVxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgnbnVsbCcsICdudWxsJyk7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0RXJyb3IodmFsdWUpIHtcbiAgcmV0dXJuICdbJyArIEVycm9yLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSArICddJztcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRBcnJheShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXlzKSB7XG4gIHZhciBvdXRwdXQgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSB2YWx1ZS5sZW5ndGg7IGkgPCBsOyArK2kpIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkodmFsdWUsIFN0cmluZyhpKSkpIHtcbiAgICAgIG91dHB1dC5wdXNoKGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsXG4gICAgICAgICAgU3RyaW5nKGkpLCB0cnVlKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG91dHB1dC5wdXNoKCcnKTtcbiAgICB9XG4gIH1cbiAga2V5cy5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgIGlmICgha2V5Lm1hdGNoKC9eXFxkKyQvKSkge1xuICAgICAgb3V0cHV0LnB1c2goZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cyxcbiAgICAgICAgICBrZXksIHRydWUpKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gb3V0cHV0O1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleSwgYXJyYXkpIHtcbiAgdmFyIG5hbWUsIHN0ciwgZGVzYztcbiAgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodmFsdWUsIGtleSkgfHwgeyB2YWx1ZTogdmFsdWVba2V5XSB9O1xuICBpZiAoZGVzYy5nZXQpIHtcbiAgICBpZiAoZGVzYy5zZXQpIHtcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbR2V0dGVyL1NldHRlcl0nLCAnc3BlY2lhbCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW0dldHRlcl0nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoZGVzYy5zZXQpIHtcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbU2V0dGVyXScsICdzcGVjaWFsJyk7XG4gICAgfVxuICB9XG4gIGlmICghaGFzT3duUHJvcGVydHkodmlzaWJsZUtleXMsIGtleSkpIHtcbiAgICBuYW1lID0gJ1snICsga2V5ICsgJ10nO1xuICB9XG4gIGlmICghc3RyKSB7XG4gICAgaWYgKGN0eC5zZWVuLmluZGV4T2YoZGVzYy52YWx1ZSkgPCAwKSB7XG4gICAgICBpZiAoaXNOdWxsKHJlY3Vyc2VUaW1lcykpIHtcbiAgICAgICAgc3RyID0gZm9ybWF0VmFsdWUoY3R4LCBkZXNjLnZhbHVlLCBudWxsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0ciA9IGZvcm1hdFZhbHVlKGN0eCwgZGVzYy52YWx1ZSwgcmVjdXJzZVRpbWVzIC0gMSk7XG4gICAgICB9XG4gICAgICBpZiAoc3RyLmluZGV4T2YoJ1xcbicpID4gLTEpIHtcbiAgICAgICAgaWYgKGFycmF5KSB7XG4gICAgICAgICAgc3RyID0gc3RyLnNwbGl0KCdcXG4nKS5tYXAoZnVuY3Rpb24obGluZSkge1xuICAgICAgICAgICAgcmV0dXJuICcgICcgKyBsaW5lO1xuICAgICAgICAgIH0pLmpvaW4oJ1xcbicpLnN1YnN0cigyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdHIgPSAnXFxuJyArIHN0ci5zcGxpdCgnXFxuJykubWFwKGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgICAgICAgIHJldHVybiAnICAgJyArIGxpbmU7XG4gICAgICAgICAgfSkuam9pbignXFxuJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tDaXJjdWxhcl0nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgfVxuICBpZiAoaXNVbmRlZmluZWQobmFtZSkpIHtcbiAgICBpZiAoYXJyYXkgJiYga2V5Lm1hdGNoKC9eXFxkKyQvKSkge1xuICAgICAgcmV0dXJuIHN0cjtcbiAgICB9XG4gICAgbmFtZSA9IEpTT04uc3RyaW5naWZ5KCcnICsga2V5KTtcbiAgICBpZiAobmFtZS5tYXRjaCgvXlwiKFthLXpBLVpfXVthLXpBLVpfMC05XSopXCIkLykpIHtcbiAgICAgIG5hbWUgPSBuYW1lLnN1YnN0cigxLCBuYW1lLmxlbmd0aCAtIDIpO1xuICAgICAgbmFtZSA9IGN0eC5zdHlsaXplKG5hbWUsICduYW1lJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2UoLycvZywgXCJcXFxcJ1wiKVxuICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFxcXFwiL2csICdcIicpXG4gICAgICAgICAgICAgICAgIC5yZXBsYWNlKC8oXlwifFwiJCkvZywgXCInXCIpO1xuICAgICAgbmFtZSA9IGN0eC5zdHlsaXplKG5hbWUsICdzdHJpbmcnKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmFtZSArICc6ICcgKyBzdHI7XG59XG5cblxuZnVuY3Rpb24gcmVkdWNlVG9TaW5nbGVTdHJpbmcob3V0cHV0LCBiYXNlLCBicmFjZXMpIHtcbiAgdmFyIG51bUxpbmVzRXN0ID0gMDtcbiAgdmFyIGxlbmd0aCA9IG91dHB1dC5yZWR1Y2UoZnVuY3Rpb24ocHJldiwgY3VyKSB7XG4gICAgbnVtTGluZXNFc3QrKztcbiAgICBpZiAoY3VyLmluZGV4T2YoJ1xcbicpID49IDApIG51bUxpbmVzRXN0Kys7XG4gICAgcmV0dXJuIHByZXYgKyBjdXIucmVwbGFjZSgvXFx1MDAxYlxcW1xcZFxcZD9tL2csICcnKS5sZW5ndGggKyAxO1xuICB9LCAwKTtcblxuICBpZiAobGVuZ3RoID4gNjApIHtcbiAgICByZXR1cm4gYnJhY2VzWzBdICtcbiAgICAgICAgICAgKGJhc2UgPT09ICcnID8gJycgOiBiYXNlICsgJ1xcbiAnKSArXG4gICAgICAgICAgICcgJyArXG4gICAgICAgICAgIG91dHB1dC5qb2luKCcsXFxuICAnKSArXG4gICAgICAgICAgICcgJyArXG4gICAgICAgICAgIGJyYWNlc1sxXTtcbiAgfVxuXG4gIHJldHVybiBicmFjZXNbMF0gKyBiYXNlICsgJyAnICsgb3V0cHV0LmpvaW4oJywgJykgKyAnICcgKyBicmFjZXNbMV07XG59XG5cblxuLy8gTk9URTogVGhlc2UgdHlwZSBjaGVja2luZyBmdW5jdGlvbnMgaW50ZW50aW9uYWxseSBkb24ndCB1c2UgYGluc3RhbmNlb2ZgXG4vLyBiZWNhdXNlIGl0IGlzIGZyYWdpbGUgYW5kIGNhbiBiZSBlYXNpbHkgZmFrZWQgd2l0aCBgT2JqZWN0LmNyZWF0ZSgpYC5cbmZ1bmN0aW9uIGlzQXJyYXkoYXIpIHtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkoYXIpO1xufVxuZXhwb3J0cy5pc0FycmF5ID0gaXNBcnJheTtcblxuZnVuY3Rpb24gaXNCb29sZWFuKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Jvb2xlYW4nO1xufVxuZXhwb3J0cy5pc0Jvb2xlYW4gPSBpc0Jvb2xlYW47XG5cbmZ1bmN0aW9uIGlzTnVsbChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNOdWxsID0gaXNOdWxsO1xuXG5mdW5jdGlvbiBpc051bGxPclVuZGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PSBudWxsO1xufVxuZXhwb3J0cy5pc051bGxPclVuZGVmaW5lZCA9IGlzTnVsbE9yVW5kZWZpbmVkO1xuXG5mdW5jdGlvbiBpc051bWJlcihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdudW1iZXInO1xufVxuZXhwb3J0cy5pc051bWJlciA9IGlzTnVtYmVyO1xuXG5mdW5jdGlvbiBpc1N0cmluZyhhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnO1xufVxuZXhwb3J0cy5pc1N0cmluZyA9IGlzU3RyaW5nO1xuXG5mdW5jdGlvbiBpc1N5bWJvbChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdzeW1ib2wnO1xufVxuZXhwb3J0cy5pc1N5bWJvbCA9IGlzU3ltYm9sO1xuXG5mdW5jdGlvbiBpc1VuZGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gdm9pZCAwO1xufVxuZXhwb3J0cy5pc1VuZGVmaW5lZCA9IGlzVW5kZWZpbmVkO1xuXG5mdW5jdGlvbiBpc1JlZ0V4cChyZSkge1xuICByZXR1cm4gaXNPYmplY3QocmUpICYmIG9iamVjdFRvU3RyaW5nKHJlKSA9PT0gJ1tvYmplY3QgUmVnRXhwXSc7XG59XG5leHBvcnRzLmlzUmVnRXhwID0gaXNSZWdFeHA7XG5cbmZ1bmN0aW9uIGlzT2JqZWN0KGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ29iamVjdCcgJiYgYXJnICE9PSBudWxsO1xufVxuZXhwb3J0cy5pc09iamVjdCA9IGlzT2JqZWN0O1xuXG5mdW5jdGlvbiBpc0RhdGUoZCkge1xuICByZXR1cm4gaXNPYmplY3QoZCkgJiYgb2JqZWN0VG9TdHJpbmcoZCkgPT09ICdbb2JqZWN0IERhdGVdJztcbn1cbmV4cG9ydHMuaXNEYXRlID0gaXNEYXRlO1xuXG5mdW5jdGlvbiBpc0Vycm9yKGUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KGUpICYmXG4gICAgICAob2JqZWN0VG9TdHJpbmcoZSkgPT09ICdbb2JqZWN0IEVycm9yXScgfHwgZSBpbnN0YW5jZW9mIEVycm9yKTtcbn1cbmV4cG9ydHMuaXNFcnJvciA9IGlzRXJyb3I7XG5cbmZ1bmN0aW9uIGlzRnVuY3Rpb24oYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnZnVuY3Rpb24nO1xufVxuZXhwb3J0cy5pc0Z1bmN0aW9uID0gaXNGdW5jdGlvbjtcblxuZnVuY3Rpb24gaXNQcmltaXRpdmUoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IG51bGwgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdib29sZWFuJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ251bWJlcicgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnc3ltYm9sJyB8fCAgLy8gRVM2IHN5bWJvbFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3VuZGVmaW5lZCc7XG59XG5leHBvcnRzLmlzUHJpbWl0aXZlID0gaXNQcmltaXRpdmU7XG5cbmV4cG9ydHMuaXNCdWZmZXIgPSByZXF1aXJlKCcuL3N1cHBvcnQvaXNCdWZmZXInKTtcblxuZnVuY3Rpb24gb2JqZWN0VG9TdHJpbmcobykge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pO1xufVxuXG5cbmZ1bmN0aW9uIHBhZChuKSB7XG4gIHJldHVybiBuIDwgMTAgPyAnMCcgKyBuLnRvU3RyaW5nKDEwKSA6IG4udG9TdHJpbmcoMTApO1xufVxuXG5cbnZhciBtb250aHMgPSBbJ0phbicsICdGZWInLCAnTWFyJywgJ0FwcicsICdNYXknLCAnSnVuJywgJ0p1bCcsICdBdWcnLCAnU2VwJyxcbiAgICAgICAgICAgICAgJ09jdCcsICdOb3YnLCAnRGVjJ107XG5cbi8vIDI2IEZlYiAxNjoxOTozNFxuZnVuY3Rpb24gdGltZXN0YW1wKCkge1xuICB2YXIgZCA9IG5ldyBEYXRlKCk7XG4gIHZhciB0aW1lID0gW3BhZChkLmdldEhvdXJzKCkpLFxuICAgICAgICAgICAgICBwYWQoZC5nZXRNaW51dGVzKCkpLFxuICAgICAgICAgICAgICBwYWQoZC5nZXRTZWNvbmRzKCkpXS5qb2luKCc6Jyk7XG4gIHJldHVybiBbZC5nZXREYXRlKCksIG1vbnRoc1tkLmdldE1vbnRoKCldLCB0aW1lXS5qb2luKCcgJyk7XG59XG5cblxuLy8gbG9nIGlzIGp1c3QgYSB0aGluIHdyYXBwZXIgdG8gY29uc29sZS5sb2cgdGhhdCBwcmVwZW5kcyBhIHRpbWVzdGFtcFxuZXhwb3J0cy5sb2cgPSBmdW5jdGlvbigpIHtcbiAgY29uc29sZS5sb2coJyVzIC0gJXMnLCB0aW1lc3RhbXAoKSwgZXhwb3J0cy5mb3JtYXQuYXBwbHkoZXhwb3J0cywgYXJndW1lbnRzKSk7XG59O1xuXG5cbi8qKlxuICogSW5oZXJpdCB0aGUgcHJvdG90eXBlIG1ldGhvZHMgZnJvbSBvbmUgY29uc3RydWN0b3IgaW50byBhbm90aGVyLlxuICpcbiAqIFRoZSBGdW5jdGlvbi5wcm90b3R5cGUuaW5oZXJpdHMgZnJvbSBsYW5nLmpzIHJld3JpdHRlbiBhcyBhIHN0YW5kYWxvbmVcbiAqIGZ1bmN0aW9uIChub3Qgb24gRnVuY3Rpb24ucHJvdG90eXBlKS4gTk9URTogSWYgdGhpcyBmaWxlIGlzIHRvIGJlIGxvYWRlZFxuICogZHVyaW5nIGJvb3RzdHJhcHBpbmcgdGhpcyBmdW5jdGlvbiBuZWVkcyB0byBiZSByZXdyaXR0ZW4gdXNpbmcgc29tZSBuYXRpdmVcbiAqIGZ1bmN0aW9ucyBhcyBwcm90b3R5cGUgc2V0dXAgdXNpbmcgbm9ybWFsIEphdmFTY3JpcHQgZG9lcyBub3Qgd29yayBhc1xuICogZXhwZWN0ZWQgZHVyaW5nIGJvb3RzdHJhcHBpbmcgKHNlZSBtaXJyb3IuanMgaW4gcjExNDkwMykuXG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbn0gY3RvciBDb25zdHJ1Y3RvciBmdW5jdGlvbiB3aGljaCBuZWVkcyB0byBpbmhlcml0IHRoZVxuICogICAgIHByb3RvdHlwZS5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IHN1cGVyQ3RvciBDb25zdHJ1Y3RvciBmdW5jdGlvbiB0byBpbmhlcml0IHByb3RvdHlwZSBmcm9tLlxuICovXG5leHBvcnRzLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcblxuZXhwb3J0cy5fZXh0ZW5kID0gZnVuY3Rpb24ob3JpZ2luLCBhZGQpIHtcbiAgLy8gRG9uJ3QgZG8gYW55dGhpbmcgaWYgYWRkIGlzbid0IGFuIG9iamVjdFxuICBpZiAoIWFkZCB8fCAhaXNPYmplY3QoYWRkKSkgcmV0dXJuIG9yaWdpbjtcblxuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGFkZCk7XG4gIHZhciBpID0ga2V5cy5sZW5ndGg7XG4gIHdoaWxlIChpLS0pIHtcbiAgICBvcmlnaW5ba2V5c1tpXV0gPSBhZGRba2V5c1tpXV07XG4gIH1cbiAgcmV0dXJuIG9yaWdpbjtcbn07XG5cbmZ1bmN0aW9uIGhhc093blByb3BlcnR5KG9iaiwgcHJvcCkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCk7XG59XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC91c3IvbG9jYWwvbGliL34vLm5wbWluc3RhbGwvdXRpbC8wLjEwLjMvdXRpbC91dGlsLmpzXG4gKiogbW9kdWxlIGlkID0gMjQ4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzQnVmZmVyKGFyZykge1xuICByZXR1cm4gYXJnICYmIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnXG4gICAgJiYgdHlwZW9mIGFyZy5jb3B5ID09PSAnZnVuY3Rpb24nXG4gICAgJiYgdHlwZW9mIGFyZy5maWxsID09PSAnZnVuY3Rpb24nXG4gICAgJiYgdHlwZW9mIGFyZy5yZWFkVUludDggPT09ICdmdW5jdGlvbic7XG59XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAvdXNyL2xvY2FsL2xpYi9+Ly5ucG1pbnN0YWxsL3V0aWwvMC4xMC4zL3V0aWwvc3VwcG9ydC9pc0J1ZmZlckJyb3dzZXIuanNcbiAqKiBtb2R1bGUgaWQgPSAyNDlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsImlmICh0eXBlb2YgT2JqZWN0LmNyZWF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAvLyBpbXBsZW1lbnRhdGlvbiBmcm9tIHN0YW5kYXJkIG5vZGUuanMgJ3V0aWwnIG1vZHVsZVxuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluaGVyaXRzKGN0b3IsIHN1cGVyQ3Rvcikge1xuICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yXG4gICAgY3Rvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ3Rvci5wcm90b3R5cGUsIHtcbiAgICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICAgIHZhbHVlOiBjdG9yLFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgfVxuICAgIH0pO1xuICB9O1xufSBlbHNlIHtcbiAgLy8gb2xkIHNjaG9vbCBzaGltIGZvciBvbGQgYnJvd3NlcnNcbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbmhlcml0cyhjdG9yLCBzdXBlckN0b3IpIHtcbiAgICBjdG9yLnN1cGVyXyA9IHN1cGVyQ3RvclxuICAgIHZhciBUZW1wQ3RvciA9IGZ1bmN0aW9uICgpIHt9XG4gICAgVGVtcEN0b3IucHJvdG90eXBlID0gc3VwZXJDdG9yLnByb3RvdHlwZVxuICAgIGN0b3IucHJvdG90eXBlID0gbmV3IFRlbXBDdG9yKClcbiAgICBjdG9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGN0b3JcbiAgfVxufVxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAvdXNyL2xvY2FsL2xpYi9+Ly5ucG1pbnN0YWxsL2luaGVyaXRzLzIuMC4xL2luaGVyaXRzL2luaGVyaXRzX2Jyb3dzZXIuanNcbiAqKiBtb2R1bGUgaWQgPSAyNTBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHR5cGVvZiBPYmplY3Qua2V5cyA9PT0gJ2Z1bmN0aW9uJ1xuICA/IE9iamVjdC5rZXlzIDogc2hpbTtcblxuZXhwb3J0cy5zaGltID0gc2hpbTtcbmZ1bmN0aW9uIHNoaW0gKG9iaikge1xuICB2YXIga2V5cyA9IFtdO1xuICBmb3IgKHZhciBrZXkgaW4gb2JqKSBrZXlzLnB1c2goa2V5KTtcbiAgcmV0dXJuIGtleXM7XG59XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi91eGNvcmUtdGFibGUvfi9kZWVwLWVxdWFsL2xpYi9rZXlzLmpzXG4gKiogbW9kdWxlIGlkID0gMjUyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgc3VwcG9ydHNBcmd1bWVudHNDbGFzcyA9IChmdW5jdGlvbigpe1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGFyZ3VtZW50cylcbn0pKCkgPT0gJ1tvYmplY3QgQXJndW1lbnRzXSc7XG5cbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHN1cHBvcnRzQXJndW1lbnRzQ2xhc3MgPyBzdXBwb3J0ZWQgOiB1bnN1cHBvcnRlZDtcblxuZXhwb3J0cy5zdXBwb3J0ZWQgPSBzdXBwb3J0ZWQ7XG5mdW5jdGlvbiBzdXBwb3J0ZWQob2JqZWN0KSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqZWN0KSA9PSAnW29iamVjdCBBcmd1bWVudHNdJztcbn07XG5cbmV4cG9ydHMudW5zdXBwb3J0ZWQgPSB1bnN1cHBvcnRlZDtcbmZ1bmN0aW9uIHVuc3VwcG9ydGVkKG9iamVjdCl7XG4gIHJldHVybiBvYmplY3QgJiZcbiAgICB0eXBlb2Ygb2JqZWN0ID09ICdvYmplY3QnICYmXG4gICAgdHlwZW9mIG9iamVjdC5sZW5ndGggPT0gJ251bWJlcicgJiZcbiAgICBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCAnY2FsbGVlJykgJiZcbiAgICAhT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKG9iamVjdCwgJ2NhbGxlZScpIHx8XG4gICAgZmFsc2U7XG59O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vdXhjb3JlLXRhYmxlL34vZGVlcC1lcXVhbC9saWIvaXNfYXJndW1lbnRzLmpzXG4gKiogbW9kdWxlIGlkID0gMjUzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxuLyoqXG4gKiBAYXV0aG9yOiB6aG91cXVhbi55ZXpxXG4gKiBAdGltZSA6IDgvMTIgMjAxNVxuICovXG5cbnZhciBjbGFzc25hbWVzID0gcmVxdWlyZShcImNsYXNzbmFtZXNcIik7XG5cbnZhciBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG52YXIgUmVhY3RET00gPSByZXF1aXJlKCdyZWFjdC1kb20nKTtcblxudmFyIE1hc2sgPSBmdW5jdGlvbiAoX1JlYWN0JENvbXBvbmVudCkge1xuICAgIF9pbmhlcml0cyhNYXNrLCBfUmVhY3QkQ29tcG9uZW50KTtcblxuICAgIGZ1bmN0aW9uIE1hc2socHJvcHMpIHtcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIE1hc2spO1xuXG4gICAgICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfUmVhY3QkQ29tcG9uZW50LmNhbGwodGhpcywgcHJvcHMpKTtcbiAgICB9XG5cbiAgICBNYXNrLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgICAgIHZhciBfY2xhc3NuYW1lcztcblxuICAgICAgICB2YXIgcHJvcHMgPSB0aGlzLnByb3BzO1xuICAgICAgICB2YXIgdmlzaWJsZSA9IHByb3BzLnZpc2libGU7XG4gICAgICAgIHZhciB0ZXh0ID0gcHJvcHMudGV4dDtcblxuICAgICAgICB2YXIgY2xhc3NOYW1lID0gY2xhc3NuYW1lcygoX2NsYXNzbmFtZXMgPSB7fSwgX2NsYXNzbmFtZXNbcHJvcHMucHJlZml4Q2xzXSA9IHRydWUsIF9jbGFzc25hbWVzW3Byb3BzLnByZWZpeENscyArIFwiLWhpZGVcIl0gPSAhdmlzaWJsZSwgX2NsYXNzbmFtZXMpKTtcbiAgICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgICAnZGl2JyxcbiAgICAgICAgICAgIHsgY2xhc3NOYW1lOiBjbGFzc05hbWUgfSxcbiAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgICAgICAgJ2RpdicsXG4gICAgICAgICAgICAgICAgeyBjbGFzc05hbWU6IHByb3BzLnByZWZpeENscyArICctY2VudGVyYmxrJyB9LFxuICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nLCB7IGNsYXNzTmFtZTogJ2t1bWEtbG9hZGluZycgfSksXG4gICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAgICAgICAgICAgJ3NwYW4nLFxuICAgICAgICAgICAgICAgICAgICB7IGNsYXNzTmFtZTogcHJvcHMucHJlZml4Q2xzICsgJy10ZXh0JyB9LFxuICAgICAgICAgICAgICAgICAgICB0ZXh0XG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKVxuICAgICAgICApO1xuICAgIH07XG5cbiAgICByZXR1cm4gTWFzaztcbn0oUmVhY3QuQ29tcG9uZW50KTtcblxuTWFzay5wcm9wVHlwZXMgPSB7XG4gICAgcHJlZml4Q2xzOiBSZWFjdC5Qcm9wVHlwZXMuc3RyaW5nXG59O1xuXG5NYXNrLmRlZmF1bHRQcm9wcyA9IHtcbiAgICBwcmVmaXhDbHM6IFwia3VtYS11eG1hc2tcIixcbiAgICB0ZXh0OiAn5Yqg6L295LitJ1xufTtcblxuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBNYXNrO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vdXhjb3JlLXRhYmxlL2J1aWxkL01hc2suanNcbiAqKiBtb2R1bGUgaWQgPSAyNTRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlwidXNlIHN0cmljdFwiO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBpc0lFOiBmdW5jdGlvbiBpc0lFKHZlcnNpb24pIHtcbiAgICAgICAgaWYgKG5hdmlnYXRvci5hcHBOYW1lID09IFwiTWljcm9zb2Z0IEludGVybmV0IEV4cGxvcmVyXCIpIHtcbiAgICAgICAgICAgIGlmICghdmVyc2lvbikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmF2aWdhdG9yLmFwcFZlcnNpb24uc3BsaXQoXCI7XCIpWzFdLnJlcGxhY2UoL1sgXS9nLCBcIlwiKSA9PSBcIk1TSUVcIiArIHZlcnNpb24gKyBcIi4wXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3V4Y29yZS10YWJsZS9idWlsZC91dGlsLmpzXG4gKiogbW9kdWxlIGlkID0gMjU1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxuLyoqXG4gKiBHcmlkIENvbXBvbmVudCBmb3IgdXhjb3JlXG4gKiBAYXV0aG9yIHpob3VxdWFuLnllenFcbiAqXG4gKiBDb3B5cmlnaHQgMjAxNC0yMDE1LCBVWENvcmUgVGVhbSwgQWxpbncuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICovXG5cbnZhciBTZWFyY2hCYXIgPSByZXF1aXJlKFwiLi9TZWFyY2hCYXJcIik7XG52YXIgY2xhc3NuYW1lcyA9IHJlcXVpcmUoXCJjbGFzc25hbWVzXCIpO1xudmFyIEJ1dHRvbiA9IHJlcXVpcmUoXCJ1eGNvcmUtYnV0dG9uXCIpO1xudmFyIFJlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcbnZhciBSZWFjdERPTSA9IHJlcXVpcmUoJ3JlYWN0LWRvbScpO1xuXG52YXIgQWN0aW9uQmFyID0gZnVuY3Rpb24gKF9SZWFjdCRDb21wb25lbnQpIHtcbiAgICBfaW5oZXJpdHMoQWN0aW9uQmFyLCBfUmVhY3QkQ29tcG9uZW50KTtcblxuICAgIGZ1bmN0aW9uIEFjdGlvbkJhcihwcm9wcykge1xuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQWN0aW9uQmFyKTtcblxuICAgICAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX1JlYWN0JENvbXBvbmVudC5jYWxsKHRoaXMsIHByb3BzKSk7XG4gICAgfVxuXG4gICAgQWN0aW9uQmFyLnByb3RvdHlwZS5oYW5kbGVTZWFyY2ggPSBmdW5jdGlvbiBoYW5kbGVTZWFyY2godmFsdWUpIHtcbiAgICAgICAgdGhpcy5wcm9wcy5vblNlYXJjaCh2YWx1ZSk7XG4gICAgfTtcblxuICAgIEFjdGlvbkJhci5wcm90b3R5cGUucmVuZGVyQWN0aW9uQnRuID0gZnVuY3Rpb24gcmVuZGVyQWN0aW9uQnRuKGl0ZW0sIGluZGV4KSB7XG4gICAgICAgIHZhciBtZSA9IHRoaXM7XG4gICAgICAgIHZhciBpdGVtUHJvcHMgPSB7XG4gICAgICAgICAgICBjbGFzc05hbWU6IG1lLnByb3BzLmpzeHByZWZpeENscyArIFwiLWl0ZW1cIixcbiAgICAgICAgICAgIG9uQ2xpY2s6IGl0ZW0uY2FsbGJhY2sgfHwgZnVuY3Rpb24gKCkge30sXG4gICAgICAgICAgICBrZXk6IGluZGV4XG4gICAgICAgIH07XG4gICAgICAgIGlmICghIWl0ZW0ucmVuZGVyICYmIHR5cGVvZiBpdGVtLnJlbmRlciA9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICAgICAgIFwiZGl2XCIsXG4gICAgICAgICAgICAgICAgaXRlbVByb3BzLFxuICAgICAgICAgICAgICAgIGl0ZW0ucmVuZGVyKGl0ZW0udGl0bGUpXG4gICAgICAgICAgICApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgICAgICAgQnV0dG9uLFxuICAgICAgICAgICAgICAgIF9leHRlbmRzKHsgdHlwZTogXCJvdXRsaW5lXCIsIHNpemU6IFwibWVkaXVtXCIgfSwgaXRlbVByb3BzKSxcbiAgICAgICAgICAgICAgICBpdGVtLnRpdGxlXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIEFjdGlvbkJhci5wcm90b3R5cGUucmVuZGVyU2VhcmNoQmFyID0gZnVuY3Rpb24gcmVuZGVyU2VhcmNoQmFyKCkge1xuICAgICAgICBpZiAodGhpcy5wcm9wcy5zaG93U2VhcmNoKSB7XG4gICAgICAgICAgICB2YXIgbWUgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIHNlYXJjaEJhclByb3BzID0ge1xuICAgICAgICAgICAgICAgIG9uU2VhcmNoOiBtZS5oYW5kbGVTZWFyY2guYmluZChtZSksXG4gICAgICAgICAgICAgICAga2V5OiAnc2VhcmNoYmFyJyxcbiAgICAgICAgICAgICAgICBwbGFjZWhvbGRlcjogbWUucHJvcHMuc2VhcmNoQmFyUGxhY2Vob2xkZXJcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChTZWFyY2hCYXIsIHNlYXJjaEJhclByb3BzKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiAgY29udmVydCBBY3Rpb25CYXIgY29uZmlnIGZyb20gaGFzaCB0byBhcnJheVxuICAgICAqL1xuXG5cbiAgICBBY3Rpb25CYXIucHJvdG90eXBlLmdldEFjdGlvbkl0ZW0gPSBmdW5jdGlvbiBnZXRBY3Rpb25JdGVtKGNvbmZpZykge1xuICAgICAgICB2YXIgaXRlbXMgPSBbXTtcbiAgICAgICAgaWYgKGNvbmZpZyBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgICBpdGVtcyA9IGNvbmZpZztcbiAgICAgICAgfSBlbHNlIGlmICgodHlwZW9mIGNvbmZpZyA9PT0gXCJ1bmRlZmluZWRcIiA/IFwidW5kZWZpbmVkXCIgOiBfdHlwZW9mKGNvbmZpZykpID09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGl0ZW0gaW4gY29uZmlnKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvbmZpZy5oYXNPd25Qcm9wZXJ0eShpdGVtKSkge1xuICAgICAgICAgICAgICAgICAgICBpdGVtcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlOiBpdGVtLFxuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2s6IGNvbmZpZ1tpdGVtXVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGl0ZW1zO1xuICAgIH07XG5cbiAgICBBY3Rpb25CYXIucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICAgICAgdmFyIF9jbGFzc25hbWVzO1xuXG4gICAgICAgIHZhciBtZSA9IHRoaXMsXG4gICAgICAgICAgICBfcHJvcHMgPSB0aGlzLnByb3BzLFxuICAgICAgICAgICAgX2JhckNvbmZpZyA9IF9wcm9wcy5hY3Rpb25CYXJDb25maWc7XG5cbiAgICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgICBcImRpdlwiLFxuICAgICAgICAgICAgeyBjbGFzc05hbWU6IGNsYXNzbmFtZXMoKF9jbGFzc25hbWVzID0ge30sIF9jbGFzc25hbWVzW19wcm9wcy5qc3hwcmVmaXhDbHNdID0gX3Byb3BzLmpzeHByZWZpeENscywgX2NsYXNzbmFtZXNbXCJmbi1jbGVhclwiXSA9IHRydWUsIF9jbGFzc25hbWVzKSkgfSxcbiAgICAgICAgICAgIG1lLmdldEFjdGlvbkl0ZW0oX2JhckNvbmZpZykubWFwKGZ1bmN0aW9uIChpdGVtLCBpbmRleCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBtZS5yZW5kZXJBY3Rpb25CdG4oaXRlbSwgaW5kZXgpO1xuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBtZS5yZW5kZXJTZWFyY2hCYXIoKVxuICAgICAgICApO1xuICAgIH07XG5cbiAgICByZXR1cm4gQWN0aW9uQmFyO1xufShSZWFjdC5Db21wb25lbnQpO1xuXG47XG5cbkFjdGlvbkJhci5wcm9wVHlwZXMgPSB7fTtcblxuQWN0aW9uQmFyLmRlZmF1bHRQcm9wcyA9IHtcbiAgICBqc3hwcmVmaXhDbHM6IFwia3VtYS11eHRhYmxlLWFjdGlvbmJhclwiXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEFjdGlvbkJhcjtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi91eGNvcmUtdGFibGUvYnVpbGQvQWN0aW9uQmFyLmpzXG4gKiogbW9kdWxlIGlkID0gMjU2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxuLyoqXG4gKiBHcmlkIENvbXBvbmVudCBmb3IgdXhjb3JlXG4gKiBAYXV0aG9yIHpob3VxdWFuLnllenFcbiAqXG4gKiBDb3B5cmlnaHQgMjAxNC0yMDE1LCBVWENvcmUgVGVhbSwgQWxpbncuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICovXG5cbnZhciBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG52YXIgUmVhY3RET00gPSByZXF1aXJlKCdyZWFjdC1kb20nKTtcblxudmFyIFNlYXJjaEJhciA9IGZ1bmN0aW9uIChfUmVhY3QkQ29tcG9uZW50KSB7XG4gICAgX2luaGVyaXRzKFNlYXJjaEJhciwgX1JlYWN0JENvbXBvbmVudCk7XG5cbiAgICBmdW5jdGlvbiBTZWFyY2hCYXIocHJvcHMpIHtcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFNlYXJjaEJhcik7XG5cbiAgICAgICAgdmFyIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX1JlYWN0JENvbXBvbmVudC5jYWxsKHRoaXMsIHByb3BzKSk7XG5cbiAgICAgICAgX3RoaXMuc3RhdGUgPSB7XG4gICAgICAgICAgICBzZWFyY2hUeHQ6IFwiXCJcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cblxuICAgIFNlYXJjaEJhci5wcm90b3R5cGUuZG9TZWFyY2ggPSBmdW5jdGlvbiBkb1NlYXJjaCgpIHtcbiAgICAgICAgdGhpcy5wcm9wcy5vblNlYXJjaCh0aGlzLnN0YXRlLnNlYXJjaFR4dCk7XG4gICAgfTtcblxuICAgIFNlYXJjaEJhci5wcm90b3R5cGUub25LZXlEb3duID0gZnVuY3Rpb24gb25LZXlEb3duKGUpIHtcbiAgICAgICAgaWYgKGUua2V5Q29kZSA9PSAxMykge1xuICAgICAgICAgICAgdGhpcy5kb1NlYXJjaCgpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIFNlYXJjaEJhci5wcm90b3R5cGUuaGFuZGxlQ2hhbmdlID0gZnVuY3Rpb24gaGFuZGxlQ2hhbmdlKGUpIHtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICBzZWFyY2hUeHQ6IGUudGFyZ2V0LnZhbHVlXG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICBTZWFyY2hCYXIucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICAgICAgdmFyIG1lID0gdGhpcztcbiAgICAgICAgdmFyIHBsYWNlaG9sZGVyID0gbWUucHJvcHMucGxhY2Vob2xkZXI7XG5cbiAgICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgICAnZGl2JyxcbiAgICAgICAgICAgIHsgY2xhc3NOYW1lOiB0aGlzLnByb3BzLmpzeHByZWZpeENscyB9LFxuICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudCgnaW5wdXQnLCB7IHR5cGU6ICd0ZXh0JywgY2xhc3NOYW1lOiAna3VtYS1pbnB1dCcsIHBsYWNlaG9sZGVyOiBwbGFjZWhvbGRlciwgdmFsdWU6IHRoaXMuc3RhdGUudmFsdWUsIG9uS2V5RG93bjogdGhpcy5vbktleURvd24uYmluZCh0aGlzKSwgb25DaGFuZ2U6IHRoaXMuaGFuZGxlQ2hhbmdlLmJpbmQodGhpcykgfSksXG4gICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KCdpJywgeyBjbGFzc05hbWU6ICdrdW1hLWljb24ga3VtYS1pY29uLXNlYXJjaCcsIG9uQ2xpY2s6IHRoaXMuZG9TZWFyY2guYmluZCh0aGlzKSB9KVxuICAgICAgICApO1xuICAgIH07XG5cbiAgICByZXR1cm4gU2VhcmNoQmFyO1xufShSZWFjdC5Db21wb25lbnQpO1xuXG47XG5cblNlYXJjaEJhci5wcm9wVHlwZXMgPSB7fTtcblxuU2VhcmNoQmFyLmRlZmF1bHRQcm9wcyA9IHtcbiAgICBqc3hwcmVmaXhDbHM6IFwia3VtYS11eHRhYmxlLXNlYXJjaGJhclwiLFxuICAgIG9uU2VhcmNoOiBmdW5jdGlvbiBvblNlYXJjaCgpIHt9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNlYXJjaEJhcjtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi91eGNvcmUtdGFibGUvYnVpbGQvU2VhcmNoQmFyLmpzXG4gKiogbW9kdWxlIGlkID0gMjU3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbnZhciBfQnV0dG9uID0gcmVxdWlyZSgnLi9CdXR0b24nKTtcblxudmFyIF9CdXR0b24yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfQnV0dG9uKTtcblxudmFyIF9CdXR0b25Hcm91cCA9IHJlcXVpcmUoJy4vQnV0dG9uR3JvdXAnKTtcblxudmFyIF9CdXR0b25Hcm91cDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9CdXR0b25Hcm91cCk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IFwiZGVmYXVsdFwiOiBvYmogfTsgfVxuXG4vKipcbiAqIEJ1dHRvbiBDb21wb25lbnQgZm9yIHV4Y29yZVxuICogQGF1dGhvclxuICpcbiAqIENvcHlyaWdodCAyMDE0LTIwMTUsIFV4Y29yZSBUZWFtLCBBbGludy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKi9cblxuX0J1dHRvbjJbXCJkZWZhdWx0XCJdLkJ1dHRvbkdyb3VwID0gX0J1dHRvbkdyb3VwMltcImRlZmF1bHRcIl07XG5tb2R1bGUuZXhwb3J0cyA9IF9CdXR0b24yW1wiZGVmYXVsdFwiXTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi91eGNvcmUtYnV0dG9uL2J1aWxkL2luZGV4LmpzXG4gKiogbW9kdWxlIGlkID0gMjU4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbnZhciBfcmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xuXG52YXIgX3JlYWN0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JlYWN0KTtcblxudmFyIF9yZWFjdERvbSA9IHJlcXVpcmUoJ3JlYWN0LWRvbScpO1xuXG52YXIgX3JlYWN0RG9tMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JlYWN0RG9tKTtcblxudmFyIF9jbGFzc25hbWVzID0gcmVxdWlyZSgnY2xhc3NuYW1lcycpO1xuXG52YXIgX2NsYXNzbmFtZXMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY2xhc3NuYW1lcyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IFwiZGVmYXVsdFwiOiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMob2JqLCBrZXlzKSB7IHZhciB0YXJnZXQgPSB7fTsgZm9yICh2YXIgaSBpbiBvYmopIHsgaWYgKGtleXMuaW5kZXhPZihpKSA+PSAwKSBjb250aW51ZTsgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBpKSkgY29udGludWU7IHRhcmdldFtpXSA9IG9ialtpXTsgfSByZXR1cm4gdGFyZ2V0OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIHNpemVNYXAgPSB7XG4gICAgc21hbGw6ICdzbScsXG4gICAgbWVkaXVtOiAnJyxcbiAgICBsYXJnZTogJ2xnJ1xufSxcbiAgICB0eXBlTWFwID0ge1xuICAgIHByaW1hcnk6ICdwcmltYXJ5JyxcbiAgICBzZWNvbmRhcnk6ICdzZWNvbmRhcnknLFxuICAgIG91dGxpbmU6ICdvdXRsaW5lJyxcbiAgICBkaXNhYmxlZDogJ2Rpc2FibGVkJ1xufSxcbiAgICBjbHNQcmVmaXggPSAna3VtYS1idXR0b24nO1xuXG52YXIgQnV0dG9uID0gZnVuY3Rpb24gKF9SZWFjdCRDb21wb25lbnQpIHtcbiAgICBfaW5oZXJpdHMoQnV0dG9uLCBfUmVhY3QkQ29tcG9uZW50KTtcblxuICAgIGZ1bmN0aW9uIEJ1dHRvbihwcm9wcykge1xuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQnV0dG9uKTtcblxuICAgICAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX1JlYWN0JENvbXBvbmVudC5jYWxsKHRoaXMsIHByb3BzKSk7XG4gICAgfVxuXG4gICAgQnV0dG9uLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgICAgIHZhciBwcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgICAgIHZhciB0eXBlID0gcHJvcHMudHlwZTtcbiAgICAgICAgdmFyIGRpc2FibGVkID0gcHJvcHMuZGlzYWJsZWQ7XG4gICAgICAgIHZhciBjbGFzc05hbWUgPSBwcm9wcy5jbGFzc05hbWU7XG4gICAgICAgIHZhciBzaXplID0gcHJvcHMuc2l6ZTtcbiAgICAgICAgdmFyIGNoaWxkcmVuID0gcHJvcHMuY2hpbGRyZW47XG4gICAgICAgIHZhciBodG1sVHlwZSA9IHByb3BzLmh0bWxUeXBlO1xuXG4gICAgICAgIHZhciBvdGhlcnMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMocHJvcHMsIFsndHlwZScsICdkaXNhYmxlZCcsICdjbGFzc05hbWUnLCAnc2l6ZScsICdjaGlsZHJlbicsICdodG1sVHlwZSddKTtcblxuICAgICAgICB0eXBlID0gZGlzYWJsZWQgPyAnZGlzYWJsZWQnIDogdHlwZTtcbiAgICAgICAgdmFyIGNsc09iaiA9IHt9O1xuICAgICAgICBpZiAoY2xhc3NOYW1lKSB7XG4gICAgICAgICAgICBjbHNPYmpbY2xhc3NOYW1lXSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNpemVNYXBbc2l6ZV0pIHtcbiAgICAgICAgICAgIGNsc09ialtjbHNQcmVmaXggKyAnLScgKyBzaXplTWFwW3NpemVdXSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNsYXNzTmFtZXMgPSAoMCwgX2NsYXNzbmFtZXMyW1wiZGVmYXVsdFwiXSkoY2xzUHJlZml4LCBjbHNQcmVmaXggKyAnLScgKyB0eXBlTWFwW3R5cGVdLCBjbHNPYmopO1xuICAgICAgICByZXR1cm4gX3JlYWN0MltcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAgICdidXR0b24nLFxuICAgICAgICAgICAgX2V4dGVuZHMoe1xuICAgICAgICAgICAgICAgIHR5cGU6IGh0bWxUeXBlLFxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogY2xhc3NOYW1lcyxcbiAgICAgICAgICAgICAgICBkaXNhYmxlZDogZGlzYWJsZWRcbiAgICAgICAgICAgIH0sIG90aGVycyksXG4gICAgICAgICAgICBwcm9wcy5jaGlsZHJlblxuICAgICAgICApO1xuICAgIH07XG5cbiAgICByZXR1cm4gQnV0dG9uO1xufShfcmVhY3QyW1wiZGVmYXVsdFwiXS5Db21wb25lbnQpO1xuXG5CdXR0b24uZGlzcGxheU5hbWUgPSAndXhjb3JlLWJ1dHRvbic7XG5CdXR0b24ucHJvcFR5cGVzID0ge1xuICAgIC8qKlxuICAgICAqIEB0aXRsZSDlsLrlr7hcbiAgICAgKi9cbiAgICBzaXplOiBfcmVhY3QyW1wiZGVmYXVsdFwiXS5Qcm9wVHlwZXMub25lT2YoWydzbWFsbCcsICdtZWRpdW0nLCAnbGFyZ2UnXSksXG4gICAgLyoqXG4gICAgICogQHRpdGxlIOagt+W8j1xuICAgICAqL1xuICAgIHN0eWxlOiBfcmVhY3QyW1wiZGVmYXVsdFwiXS5Qcm9wVHlwZXMub2JqZWN0LFxuICAgIC8qKlxuICAgICogQHRpdGxlIOexu+Wei1xuICAgICovXG4gICAgdHlwZTogX3JlYWN0MltcImRlZmF1bHRcIl0uUHJvcFR5cGVzLm9uZU9mKFsncHJpbWFyeScsICdzZWNvbmRhcnknLCAnb3V0bGluZScsICdkaXNhYmxlZCddKSxcbiAgICAvKipcbiAgICAgKiBAdGl0bGUg5piv5ZCm56aB55SoXG4gICAgICogQHZlSWdub3JlXG4gICAgICovXG4gICAgZGlzYWJsZWQ6IF9yZWFjdDJbXCJkZWZhdWx0XCJdLlByb3BUeXBlcy5ib29sLFxuICAgIC8qKlxuICAgICAqIEB0aXRsZSDnsbvlkI1cbiAgICAgKiBAdmVJZ25vcmVcbiAgICAgKi9cbiAgICBjbGFzc05hbWU6IF9yZWFjdDJbXCJkZWZhdWx0XCJdLlByb3BUeXBlcy5zdHJpbmcsXG4gICAgLyoqXG4gICAgICogQHRpdGxlIOWGheWuuVxuICAgICAqL1xuICAgIGNoaWxkcmVuOiBfcmVhY3QyW1wiZGVmYXVsdFwiXS5Qcm9wVHlwZXMub25lT2ZUeXBlKFtfcmVhY3QyW1wiZGVmYXVsdFwiXS5Qcm9wVHlwZXMuZWxlbWVudCwgX3JlYWN0MltcImRlZmF1bHRcIl0uUHJvcFR5cGVzLnN0cmluZ10pLFxuICAgIC8qKlxuICAgICAqIEB0aXRsZSA8YnV0dG9uPiDnmoQgdHlwZVxuICAgICAqIEB2ZUlnbm9yZVxuICAgICAqL1xuICAgIGh0bWxUeXBlOiBfcmVhY3QyW1wiZGVmYXVsdFwiXS5Qcm9wVHlwZXMub25lT2YoWydzdWJtaXQnLCAnYnV0dG9uJywgJ3Jlc2V0J10pXG59O1xuQnV0dG9uLmRlZmF1bHRQcm9wcyA9IHtcbiAgICBzaXplOiAnbWVkaXVtJyxcbiAgICB0eXBlOiAncHJpbWFyeScsXG4gICAgZGlzYWJsZWQ6IGZhbHNlLFxuICAgIGNsYXNzTmFtZTogJycsXG4gICAgY2hpbGRyZW46ICdCdXR0b24nLFxuICAgIGh0bWxUeXBlOiAnYnV0dG9uJ1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBCdXR0b247XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vdXhjb3JlLWJ1dHRvbi9idWlsZC9CdXR0b24uanNcbiAqKiBtb2R1bGUgaWQgPSAyNTlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxudmFyIF9yZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5cbnZhciBfcmVhY3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmVhY3QpO1xuXG52YXIgX3JlYWN0RG9tID0gcmVxdWlyZSgncmVhY3QtZG9tJyk7XG5cbnZhciBfcmVhY3REb20yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmVhY3REb20pO1xuXG52YXIgX2NsYXNzbmFtZXMgPSByZXF1aXJlKCdjbGFzc25hbWVzJyk7XG5cbnZhciBfY2xhc3NuYW1lczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jbGFzc25hbWVzKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgXCJkZWZhdWx0XCI6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIEJ1dHRvbkdyb3VwID0gZnVuY3Rpb24gKF9SZWFjdCRDb21wb25lbnQpIHtcblx0X2luaGVyaXRzKEJ1dHRvbkdyb3VwLCBfUmVhY3QkQ29tcG9uZW50KTtcblxuXHRmdW5jdGlvbiBCdXR0b25Hcm91cChwcm9wcykge1xuXHRcdF9jbGFzc0NhbGxDaGVjayh0aGlzLCBCdXR0b25Hcm91cCk7XG5cblx0XHRyZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX1JlYWN0JENvbXBvbmVudC5jYWxsKHRoaXMsIHByb3BzKSk7XG5cdH1cblxuXHRCdXR0b25Hcm91cC5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKCkge1xuXHRcdHJldHVybiBfcmVhY3QyW1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFxuXHRcdFx0J2RpdicsXG5cdFx0XHR7IGNsYXNzTmFtZTogJ2t1bWEtYnV0dG9uLWdyb3VwJyB9LFxuXHRcdFx0dGhpcy5wcm9wcy5jaGlsZHJlblxuXHRcdCk7XG5cdH07XG5cblx0cmV0dXJuIEJ1dHRvbkdyb3VwO1xufShfcmVhY3QyW1wiZGVmYXVsdFwiXS5Db21wb25lbnQpO1xuXG5CdXR0b25Hcm91cC5kaXNwbGF5TmFtZSA9ICdCdXR0b25Hcm91cCc7XG5CdXR0b25Hcm91cC5wcm9wVHlwZXMgPSB7fTtcbkJ1dHRvbkdyb3VwLmRlZmF1bHRQcm9wcyA9IHt9O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEJ1dHRvbkdyb3VwO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3V4Y29yZS1idXR0b24vYnVpbGQvQnV0dG9uR3JvdXAuanNcbiAqKiBtb2R1bGUgaWQgPSAyNjBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBQYWdpbmF0aW9uIENvbXBvbmVudCBmb3IgdXhjb3JlXG4gKiBAYXV0aG9yIFxuICpcbiAqIENvcHlyaWdodCAyMDE0LTIwMTUsIFV4Y29yZSBUZWFtLCBBbGludy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL1BhZ2luYXRpb24nKTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi91eGNvcmUtdGFibGUvfi91eGNvcmUtcGFnaW5hdGlvbi9idWlsZC9pbmRleC5qc1xuICoqIG1vZHVsZSBpZCA9IDI2MVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbi8qKlxuICogRm9ya2VkIGZyb20gcHJvamVjdCByYy1wYWdpbmF0aW9uXG4gKiBAbWFpbnRhaW5lciBldGVybmFsc2t5XG4gKi9cblxudmFyIFNlbGVjdCA9IHJlcXVpcmUoJ3V4Y29yZS1zZWxlY3QyJyk7XG52YXIgUGFnZXIgPSByZXF1aXJlKCcuL1BhZ2VyJyk7XG52YXIgT3B0aW9ucyA9IHJlcXVpcmUoJy4vT3B0aW9ucycpO1xudmFyIEtFWUNPREUgPSByZXF1aXJlKCcuL0tleUNvZGUnKTtcbnZhciBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG52YXIgUmVhY3RET00gPSByZXF1aXJlKCdyZWFjdC1kb20nKTtcbnZhciBpMThuID0gcmVxdWlyZSgnLi9sb2NhbGUnKTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnZhciBQYWdpbmF0aW9uID0gZnVuY3Rpb24gKF9SZWFjdCRDb21wb25lbnQpIHtcbiAgX2luaGVyaXRzKFBhZ2luYXRpb24sIF9SZWFjdCRDb21wb25lbnQpO1xuXG4gIGZ1bmN0aW9uIFBhZ2luYXRpb24ocHJvcHMpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUGFnaW5hdGlvbik7XG5cbiAgICB2YXIgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfUmVhY3QkQ29tcG9uZW50LmNhbGwodGhpcywgcHJvcHMpKTtcblxuICAgIF90aGlzLnN0YXRlID0ge1xuICAgICAgY3VycmVudDogcHJvcHMuY3VycmVudCxcbiAgICAgIF9jdXJyZW50OiBwcm9wcy5jdXJyZW50LFxuICAgICAgcGFnZVNpemU6IHByb3BzLnBhZ2VTaXplXG4gICAgfTtcblxuICAgIFsncmVuZGVyJywgJ19oYW5kbGVDaGFuZ2UnLCAnX2hhbmRsZUtleVVwJywgJ19oYW5kbGVLZXlEb3duJywgJ19jaGFuZ2VQYWdlU2l6ZScsICdfaXNWYWxpZCcsICdfcHJldicsICdfbmV4dCcsICdfaGFzUHJldicsICdfaGFzTmV4dCcsICdfanVtcFByZXYnLCAnX2p1bXBOZXh0J10uZm9yRWFjaChmdW5jdGlvbiAobWV0aG9kKSB7XG4gICAgICByZXR1cm4gX3RoaXNbbWV0aG9kXSA9IF90aGlzW21ldGhvZF0uYmluZChfdGhpcyk7XG4gICAgfSk7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgUGFnaW5hdGlvbi5wcm90b3R5cGUuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyA9IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMobmV4dFByb3BzKSB7XG4gICAgaWYgKG5leHRQcm9wcy5jdXJyZW50ICE9IHRoaXMucHJvcHMuY3VycmVudCkge1xuICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgIGN1cnJlbnQ6IG5leHRQcm9wcy5jdXJyZW50LFxuICAgICAgICBfY3VycmVudDogbmV4dFByb3BzLmN1cnJlbnRcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChuZXh0UHJvcHMucGFnZVNpemUgIT0gdGhpcy5wcm9wcy5wYWdlU2l6ZSkge1xuICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgIHBhZ2VTaXplOiBuZXh0UHJvcHMucGFnZVNpemVcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcblxuICBQYWdpbmF0aW9uLnByb3RvdHlwZS5yZW5kZXJUb3RhbCA9IGZ1bmN0aW9uIHJlbmRlclRvdGFsKCkge1xuICAgIHZhciBwcmVmaXggPSB0aGlzLnByb3BzLmxvY2FsZSA9PSAnemgtY24nID8gXCLlhbFcIiA6IFwiXCI7XG4gICAgaWYgKHRoaXMucHJvcHMuc2hvd1RvdGFsKSB7XG4gICAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgICAgJ2xpJyxcbiAgICAgICAgeyBjbGFzc05hbWU6IHRoaXMucHJvcHMucHJlZml4Q2xzICsgXCItdG90YWxcIiB9LFxuICAgICAgICBwcmVmaXggKyB0aGlzLnByb3BzLnRvdGFsICsgaTE4blt0aGlzLnByb3BzLmxvY2FsZV1bJ2l0ZW0nXVxuICAgICAgKTtcbiAgICB9XG4gIH07XG5cbiAgUGFnaW5hdGlvbi5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgIHZhciBwcm9wcyA9IHRoaXMucHJvcHM7XG5cbiAgICB2YXIgcHJlZml4Q2xzID0gcHJvcHMucHJlZml4Q2xzO1xuICAgIHZhciBhbGxQYWdlcyA9IHRoaXMuX2NhbGNQYWdlKCk7XG4gICAgdmFyIHBhZ2VyTGlzdCA9IFtdO1xuICAgIHZhciBqdW1wUHJldiA9IG51bGw7XG4gICAgdmFyIGp1bXBOZXh0ID0gbnVsbDtcbiAgICB2YXIgZmlyc3RQYWdlciA9IG51bGw7XG4gICAgdmFyIGxhc3RQYWdlciA9IG51bGw7XG5cbiAgICBpZiAocHJvcHMuc2ltcGxlKSB7XG4gICAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgICAgJ3VsJyxcbiAgICAgICAgeyBjbGFzc05hbWU6IHByZWZpeENscyArICcgJyArIHByZWZpeENscyArICctc2ltcGxlICcgKyBwcm9wcy5jbGFzc05hbWUgfSxcbiAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAnZGl2JyxcbiAgICAgICAgICB7IHRpdGxlOiAnUGFnZSAnICsgdGhpcy5zdGF0ZS5jdXJyZW50ICsgJyBvZiAnICsgYWxsUGFnZXMsIGNsYXNzTmFtZTogcHJlZml4Q2xzICsgJy1zaW1wbGUtcGFnZXInIH0sXG4gICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAgICdzcGFuJyxcbiAgICAgICAgICAgIHsgY2xhc3NOYW1lOiBwcmVmaXhDbHMgKyAnLWN1cnJlbnQnIH0sXG4gICAgICAgICAgICB0aGlzLnN0YXRlLl9jdXJyZW50XG4gICAgICAgICAgKSxcbiAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICAgJ3NwYW4nLFxuICAgICAgICAgICAgeyBjbGFzc05hbWU6IHByZWZpeENscyArICctc2xhc2gnIH0sXG4gICAgICAgICAgICAnLydcbiAgICAgICAgICApLFxuICAgICAgICAgIGFsbFBhZ2VzXG4gICAgICAgICksXG4gICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgJ2xpJyxcbiAgICAgICAgICB7IHRpdGxlOiAnUHJldmlvdXMgUGFnZScsIG9uQ2xpY2s6IHRoaXMuX3ByZXYsIGNsYXNzTmFtZTogKHRoaXMuX2hhc1ByZXYoKSA/ICcnIDogcHJlZml4Q2xzICsgJy1kaXNhYmxlZCAnKSArIChwcmVmaXhDbHMgKyAnLXByZXYnKSB9LFxuICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoJ2EnLCB7IGNsYXNzTmFtZTogJ2t1bWEtaWNvbiBrdW1hLWljb24tdHJpYW5nbGUtbGVmdCcgfSlcbiAgICAgICAgKSxcbiAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAnbGknLFxuICAgICAgICAgIHsgdGl0bGU6ICdOZXh0IFBhZ2UnLCBvbkNsaWNrOiB0aGlzLl9uZXh0LCBjbGFzc05hbWU6ICh0aGlzLl9oYXNOZXh0KCkgPyAnJyA6IHByZWZpeENscyArICctZGlzYWJsZWQgJykgKyAocHJlZml4Q2xzICsgJy1uZXh0JykgfSxcbiAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KCdhJywgeyBjbGFzc05hbWU6ICdrdW1hLWljb24ga3VtYS1pY29uLXRyaWFuZ2xlLXJpZ2h0JyB9KVxuICAgICAgICApXG4gICAgICApO1xuICAgIH1cblxuICAgIGlmIChhbGxQYWdlcyA8PSA5KSB7XG4gICAgICBmb3IgKHZhciBpID0gMTsgaSA8PSBhbGxQYWdlczsgaSsrKSB7XG4gICAgICAgIHZhciBhY3RpdmUgPSB0aGlzLnN0YXRlLmN1cnJlbnQgPT09IGk7XG4gICAgICAgIHBhZ2VyTGlzdC5wdXNoKFJlYWN0LmNyZWF0ZUVsZW1lbnQoUGFnZXIsIHsgcm9vdFByZWZpeENsczogcHJlZml4Q2xzLCBvbkNsaWNrOiB0aGlzLl9oYW5kbGVDaGFuZ2UuYmluZCh0aGlzLCBpKSwga2V5OiBpLCBwYWdlOiBpLCBhY3RpdmU6IGFjdGl2ZSB9KSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGp1bXBQcmV2ID0gUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgICAgJ2xpJyxcbiAgICAgICAgeyB0aXRsZTogJ1ByZXZpb3VzIDUgUGFnZScsIGtleTogJ3ByZXYnLCBvbkNsaWNrOiB0aGlzLl9qdW1wUHJldiwgY2xhc3NOYW1lOiBwcmVmaXhDbHMgKyAnLWp1bXAtcHJldicgfSxcbiAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudCgnYScsIG51bGwpXG4gICAgICApO1xuICAgICAganVtcE5leHQgPSBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAnbGknLFxuICAgICAgICB7IHRpdGxlOiAnTmV4dCA1IFBhZ2UnLCBrZXk6ICduZXh0Jywgb25DbGljazogdGhpcy5fanVtcE5leHQsIGNsYXNzTmFtZTogcHJlZml4Q2xzICsgJy1qdW1wLW5leHQnIH0sXG4gICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoJ2EnLCBudWxsKVxuICAgICAgKTtcbiAgICAgIGxhc3RQYWdlciA9IFJlYWN0LmNyZWF0ZUVsZW1lbnQoUGFnZXIsIHsgbGFzdDogdHJ1ZSwgcm9vdFByZWZpeENsczogcHJlZml4Q2xzLCBvbkNsaWNrOiB0aGlzLl9oYW5kbGVDaGFuZ2UuYmluZCh0aGlzLCBhbGxQYWdlcyksIGtleTogYWxsUGFnZXMsIHBhZ2U6IGFsbFBhZ2VzLCBhY3RpdmU6IGZhbHNlIH0pO1xuICAgICAgZmlyc3RQYWdlciA9IFJlYWN0LmNyZWF0ZUVsZW1lbnQoUGFnZXIsIHsgcm9vdFByZWZpeENsczogcHJlZml4Q2xzLCBvbkNsaWNrOiB0aGlzLl9oYW5kbGVDaGFuZ2UuYmluZCh0aGlzLCAxKSwga2V5OiAxLCBwYWdlOiAxLCBhY3RpdmU6IGZhbHNlIH0pO1xuXG4gICAgICB2YXIgY3VycmVudCA9IHRoaXMuc3RhdGUuY3VycmVudDtcblxuICAgICAgdmFyIGxlZnQgPSBNYXRoLm1heCgxLCBjdXJyZW50IC0gMik7XG4gICAgICB2YXIgcmlnaHQgPSBNYXRoLm1pbihjdXJyZW50ICsgMiwgYWxsUGFnZXMpO1xuXG4gICAgICBpZiAoY3VycmVudCAtIDEgPD0gMikge1xuICAgICAgICByaWdodCA9IDEgKyA0O1xuICAgICAgfVxuXG4gICAgICBpZiAoYWxsUGFnZXMgLSBjdXJyZW50IDw9IDIpIHtcbiAgICAgICAgbGVmdCA9IGFsbFBhZ2VzIC0gNDtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgX2kgPSBsZWZ0OyBfaSA8PSByaWdodDsgX2krKykge1xuICAgICAgICB2YXIgX2FjdGl2ZSA9IGN1cnJlbnQgPT09IF9pO1xuICAgICAgICBwYWdlckxpc3QucHVzaChSZWFjdC5jcmVhdGVFbGVtZW50KFBhZ2VyLCB7IHJvb3RQcmVmaXhDbHM6IHByZWZpeENscywgb25DbGljazogdGhpcy5faGFuZGxlQ2hhbmdlLmJpbmQodGhpcywgX2kpLCBrZXk6IF9pLCBwYWdlOiBfaSwgYWN0aXZlOiBfYWN0aXZlIH0pKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGN1cnJlbnQgLSAxID49IDQpIHtcbiAgICAgICAgcGFnZXJMaXN0LnVuc2hpZnQoanVtcFByZXYpO1xuICAgICAgfVxuICAgICAgaWYgKGFsbFBhZ2VzIC0gY3VycmVudCA+PSA0KSB7XG4gICAgICAgIHBhZ2VyTGlzdC5wdXNoKGp1bXBOZXh0KTtcbiAgICAgIH1cblxuICAgICAgaWYgKGxlZnQgIT09IDEpIHtcbiAgICAgICAgcGFnZXJMaXN0LnVuc2hpZnQoZmlyc3RQYWdlcik7XG4gICAgICB9XG4gICAgICBpZiAocmlnaHQgIT09IGFsbFBhZ2VzKSB7XG4gICAgICAgIHBhZ2VyTGlzdC5wdXNoKGxhc3RQYWdlcik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAndWwnLFxuICAgICAgeyBjbGFzc05hbWU6IHByZWZpeENscyArICcgJyArIHByb3BzLmNsYXNzTmFtZSxcbiAgICAgICAgdW5zZWxlY3RhYmxlOiAndW5zZWxlY3RhYmxlJyB9LFxuICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgICAgJ2xpJyxcbiAgICAgICAgeyB0aXRsZTogJ1ByZXZpb3VzIFBhZ2UnLCBvbkNsaWNrOiB0aGlzLl9wcmV2LCBjbGFzc05hbWU6ICh0aGlzLl9oYXNQcmV2KCkgPyAnJyA6IHByZWZpeENscyArICctZGlzYWJsZWQgJykgKyAocHJlZml4Q2xzICsgJy1wcmV2JykgfSxcbiAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudCgnYScsIHsgY2xhc3NOYW1lOiAna3VtYS1pY29uIGt1bWEtaWNvbi10cmlhbmdsZS1sZWZ0JyB9KVxuICAgICAgKSxcbiAgICAgIHBhZ2VyTGlzdCxcbiAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICdsaScsXG4gICAgICAgIHsgdGl0bGU6ICdOZXh0IFBhZ2UnLCBvbkNsaWNrOiB0aGlzLl9uZXh0LCBjbGFzc05hbWU6ICh0aGlzLl9oYXNOZXh0KCkgPyAnJyA6IHByZWZpeENscyArICctZGlzYWJsZWQgJykgKyAocHJlZml4Q2xzICsgJy1uZXh0JykgfSxcbiAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudCgnYScsIHsgY2xhc3NOYW1lOiAna3VtYS1pY29uIGt1bWEtaWNvbi10cmlhbmdsZS1yaWdodCcgfSlcbiAgICAgICksXG4gICAgICB0aGlzLnJlbmRlclRvdGFsKCksXG4gICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KE9wdGlvbnMsIHsgcm9vdFByZWZpeENsczogcHJlZml4Q2xzLFxuICAgICAgICBsb2NhbGU6IHByb3BzLmxvY2FsZSxcbiAgICAgICAgc2VsZWN0Q29tcG9uZW50Q2xhc3M6IHByb3BzLnNlbGVjdENvbXBvbmVudENsYXNzLFxuICAgICAgICBzZWxlY3RQcmVmaXhDbHM6IHByb3BzLnNlbGVjdFByZWZpeENscyxcbiAgICAgICAgY2hhbmdlU2l6ZTogdGhpcy5wcm9wcy5zaG93U2l6ZUNoYW5nZXIgPyB0aGlzLl9jaGFuZ2VQYWdlU2l6ZS5iaW5kKHRoaXMpIDogbnVsbCxcbiAgICAgICAgY3VycmVudDogdGhpcy5zdGF0ZS5jdXJyZW50LFxuICAgICAgICBwYWdlU2l6ZTogcHJvcHMucGFnZVNpemUsXG4gICAgICAgIHNpemVPcHRpb25zOiBwcm9wcy5zaXplT3B0aW9ucyxcbiAgICAgICAgcXVpY2tHbzogdGhpcy5wcm9wcy5zaG93UXVpY2tKdW1wZXIgPyB0aGlzLl9oYW5kbGVDaGFuZ2UuYmluZCh0aGlzKSA6IG51bGwgfSlcbiAgICApO1xuICB9O1xuXG4gIC8vIHByaXZhdGUgbWV0aG9kc1xuXG4gIFBhZ2luYXRpb24ucHJvdG90eXBlLl9jYWxjUGFnZSA9IGZ1bmN0aW9uIF9jYWxjUGFnZShwKSB7XG4gICAgdmFyIHBhZ2VTaXplID0gcDtcbiAgICBpZiAodHlwZW9mIHBhZ2VTaXplID09PSAndW5kZWZpbmVkJykge1xuICAgICAgcGFnZVNpemUgPSB0aGlzLnN0YXRlLnBhZ2VTaXplO1xuICAgIH1cbiAgICByZXR1cm4gTWF0aC5mbG9vcigodGhpcy5wcm9wcy50b3RhbCAtIDEpIC8gcGFnZVNpemUpICsgMTtcbiAgfTtcblxuICBQYWdpbmF0aW9uLnByb3RvdHlwZS5faXNWYWxpZCA9IGZ1bmN0aW9uIF9pc1ZhbGlkKHBhZ2UpIHtcbiAgICByZXR1cm4gdHlwZW9mIHBhZ2UgPT09ICdudW1iZXInICYmIHBhZ2UgPj0gMSAmJiBwYWdlICE9PSB0aGlzLnN0YXRlLmN1cnJlbnQ7XG4gIH07XG5cbiAgUGFnaW5hdGlvbi5wcm90b3R5cGUuX2hhbmRsZUtleURvd24gPSBmdW5jdGlvbiBfaGFuZGxlS2V5RG93bihldnQpIHtcbiAgICBpZiAoZXZ0LmtleUNvZGUgPT09IEtFWUNPREUuQVJST1dfVVAgfHwgZXZ0LmtleUNvZGUgPT09IEtFWUNPREUuQVJST1dfRE9XTikge1xuICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxuICB9O1xuXG4gIFBhZ2luYXRpb24ucHJvdG90eXBlLl9oYW5kbGVLZXlVcCA9IGZ1bmN0aW9uIF9oYW5kbGVLZXlVcChldnQpIHtcbiAgICB2YXIgX3ZhbCA9IGV2dC50YXJnZXQudmFsdWU7XG4gICAgdmFyIHZhbCA9IHZvaWQgMDtcblxuICAgIGlmIChfdmFsID09PSAnJykge1xuICAgICAgdmFsID0gX3ZhbDtcbiAgICB9IGVsc2UgaWYgKGlzTmFOKE51bWJlcihfdmFsKSkpIHtcbiAgICAgIHZhbCA9IHRoaXMuc3RhdGUuX2N1cnJlbnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbCA9IE51bWJlcihfdmFsKTtcbiAgICB9XG5cbiAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgIF9jdXJyZW50OiB2YWxcbiAgICB9KTtcblxuICAgIGlmIChldnQua2V5Q29kZSA9PT0gS0VZQ09ERS5FTlRFUikge1xuICAgICAgdGhpcy5faGFuZGxlQ2hhbmdlKHZhbCk7XG4gICAgfSBlbHNlIGlmIChldnQua2V5Q29kZSA9PT0gS0VZQ09ERS5BUlJPV19VUCkge1xuICAgICAgdGhpcy5faGFuZGxlQ2hhbmdlKHZhbCAtIDEpO1xuICAgIH0gZWxzZSBpZiAoZXZ0LmtleUNvZGUgPT09IEtFWUNPREUuQVJST1dfRE9XTikge1xuICAgICAgdGhpcy5faGFuZGxlQ2hhbmdlKHZhbCArIDEpO1xuICAgIH1cbiAgfTtcblxuICBQYWdpbmF0aW9uLnByb3RvdHlwZS5fY2hhbmdlUGFnZVNpemUgPSBmdW5jdGlvbiBfY2hhbmdlUGFnZVNpemUoc2l6ZSkge1xuICAgIGlmICh0eXBlb2Ygc2l6ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgIHZhciBjdXJyZW50ID0gdGhpcy5zdGF0ZS5jdXJyZW50O1xuXG4gICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgcGFnZVNpemU6IHNpemVcbiAgICAgIH0pO1xuXG4gICAgICBpZiAodGhpcy5zdGF0ZS5jdXJyZW50ID4gdGhpcy5fY2FsY1BhZ2Uoc2l6ZSkpIHtcbiAgICAgICAgY3VycmVudCA9IHRoaXMuX2NhbGNQYWdlKHNpemUpO1xuICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICBjdXJyZW50OiBjdXJyZW50LFxuICAgICAgICAgIF9jdXJyZW50OiBjdXJyZW50XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnByb3BzLm9uU2hvd1NpemVDaGFuZ2UoY3VycmVudCwgc2l6ZSk7XG4gICAgfVxuICB9O1xuXG4gIFBhZ2luYXRpb24ucHJvdG90eXBlLl9oYW5kbGVDaGFuZ2UgPSBmdW5jdGlvbiBfaGFuZGxlQ2hhbmdlKHApIHtcbiAgICB2YXIgcGFnZSA9IHA7XG4gICAgdmFyIG1lID0gdGhpcztcbiAgICBpZiAodGhpcy5faXNWYWxpZChwYWdlKSkge1xuICAgICAgaWYgKHBhZ2UgPiB0aGlzLl9jYWxjUGFnZSgpKSB7XG4gICAgICAgIHBhZ2UgPSB0aGlzLl9jYWxjUGFnZSgpO1xuICAgICAgfVxuICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgIGN1cnJlbnQ6IHBhZ2UsXG4gICAgICAgIF9jdXJyZW50OiBwYWdlXG4gICAgICB9LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIG1lLnByb3BzLm9uQ2hhbmdlKHBhZ2UpO1xuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiBwYWdlO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnN0YXRlLmN1cnJlbnQ7XG4gIH07XG5cbiAgUGFnaW5hdGlvbi5wcm90b3R5cGUuX3ByZXYgPSBmdW5jdGlvbiBfcHJldigpIHtcbiAgICBpZiAodGhpcy5faGFzUHJldigpKSB7XG4gICAgICB0aGlzLl9oYW5kbGVDaGFuZ2UodGhpcy5zdGF0ZS5jdXJyZW50IC0gMSk7XG4gICAgfVxuICB9O1xuXG4gIFBhZ2luYXRpb24ucHJvdG90eXBlLl9uZXh0ID0gZnVuY3Rpb24gX25leHQoKSB7XG4gICAgaWYgKHRoaXMuX2hhc05leHQoKSkge1xuICAgICAgdGhpcy5faGFuZGxlQ2hhbmdlKHRoaXMuc3RhdGUuY3VycmVudCArIDEpO1xuICAgIH1cbiAgfTtcblxuICBQYWdpbmF0aW9uLnByb3RvdHlwZS5fanVtcFByZXYgPSBmdW5jdGlvbiBfanVtcFByZXYoKSB7XG4gICAgdGhpcy5faGFuZGxlQ2hhbmdlKE1hdGgubWF4KDEsIHRoaXMuc3RhdGUuY3VycmVudCAtIDUpKTtcbiAgfTtcblxuICBQYWdpbmF0aW9uLnByb3RvdHlwZS5fanVtcE5leHQgPSBmdW5jdGlvbiBfanVtcE5leHQoKSB7XG4gICAgdGhpcy5faGFuZGxlQ2hhbmdlKE1hdGgubWluKHRoaXMuX2NhbGNQYWdlKCksIHRoaXMuc3RhdGUuY3VycmVudCArIDUpKTtcbiAgfTtcblxuICBQYWdpbmF0aW9uLnByb3RvdHlwZS5faGFzUHJldiA9IGZ1bmN0aW9uIF9oYXNQcmV2KCkge1xuICAgIHJldHVybiB0aGlzLnN0YXRlLmN1cnJlbnQgPiAxO1xuICB9O1xuXG4gIFBhZ2luYXRpb24ucHJvdG90eXBlLl9oYXNOZXh0ID0gZnVuY3Rpb24gX2hhc05leHQoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdGUuY3VycmVudCA8IHRoaXMuX2NhbGNQYWdlKCk7XG4gIH07XG5cbiAgcmV0dXJuIFBhZ2luYXRpb247XG59KFJlYWN0LkNvbXBvbmVudCk7XG5cblBhZ2luYXRpb24ucHJvcFR5cGVzID0ge1xuICBjdXJyZW50OiBSZWFjdC5Qcm9wVHlwZXMubnVtYmVyLFxuICB0b3RhbDogUmVhY3QuUHJvcFR5cGVzLm51bWJlcixcbiAgbG9jYWxlOiBSZWFjdC5Qcm9wVHlwZXMuc3RyaW5nLFxuICBzaG93VG90YWw6IFJlYWN0LlByb3BUeXBlcy5ib29sLFxuICBwYWdlU2l6ZTogUmVhY3QuUHJvcFR5cGVzLm51bWJlcixcbiAgc2l6ZU9wdGlvbnM6IFJlYWN0LlByb3BUeXBlcy5hcnJheSxcbiAgb25DaGFuZ2U6IFJlYWN0LlByb3BUeXBlcy5mdW5jLFxuICBzaG93U2l6ZUNoYW5nZXI6IFJlYWN0LlByb3BUeXBlcy5ib29sLFxuICBvblNob3dTaXplQ2hhbmdlOiBSZWFjdC5Qcm9wVHlwZXMuZnVuYyxcbiAgc2VsZWN0Q29tcG9uZW50Q2xhc3M6IFJlYWN0LlByb3BUeXBlcy5mdW5jLFxuICBzaG93UXVpY2tKdW1wZXI6IFJlYWN0LlByb3BUeXBlcy5ib29sXG59O1xuXG5QYWdpbmF0aW9uLmRlZmF1bHRQcm9wcyA9IHtcbiAgY3VycmVudDogMSxcbiAgdG90YWw6IDAsXG4gIGxvY2FsZTogJ3poLWNuJyxcbiAgc2hvd1RvdGFsOiBmYWxzZSxcbiAgcGFnZVNpemU6IDEwLFxuICBzaXplT3B0aW9uczogWzEwLCAyMCwgMzAsIDQwXSxcbiAgb25DaGFuZ2U6IG5vb3AsXG4gIGNsYXNzTmFtZTogJycsXG4gIHNlbGVjdFByZWZpeENsczogJ2t1bWEtc2VsZWN0MicsXG4gIHByZWZpeENsczogJ2t1bWEtcGFnZScsXG4gIHNlbGVjdENvbXBvbmVudENsYXNzOiBTZWxlY3QsXG4gIHNob3dRdWlja0p1bXBlcjogZmFsc2UsXG4gIHNob3dTaXplQ2hhbmdlcjogZmFsc2UsXG4gIG9uU2hvd1NpemVDaGFuZ2U6IG5vb3Bcbn07XG5cblBhZ2luYXRpb24uZGlzcGxheU5hbWUgPSAnUGFnaW5hdGlvbic7XG5cbm1vZHVsZS5leHBvcnRzID0gUGFnaW5hdGlvbjtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi91eGNvcmUtdGFibGUvfi91eGNvcmUtcGFnaW5hdGlvbi9idWlsZC9QYWdpbmF0aW9uLmpzXG4gKiogbW9kdWxlIGlkID0gMjYyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIFJlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcbnZhciBSZWFjdERPTSA9IHJlcXVpcmUoJ3JlYWN0LWRvbScpO1xuXG52YXIgUGFnZXIgPSBmdW5jdGlvbiAoX1JlYWN0JENvbXBvbmVudCkge1xuICBfaW5oZXJpdHMoUGFnZXIsIF9SZWFjdCRDb21wb25lbnQpO1xuXG4gIGZ1bmN0aW9uIFBhZ2VyKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBQYWdlcik7XG5cbiAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX1JlYWN0JENvbXBvbmVudC5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgfVxuXG4gIFBhZ2VyLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgdmFyIHByb3BzID0gdGhpcy5wcm9wcztcbiAgICB2YXIgcHJlZml4Q2xzID0gcHJvcHMucm9vdFByZWZpeENscyArICctaXRlbSc7XG4gICAgdmFyIGNscyA9IHByZWZpeENscyArICcgJyArIHByZWZpeENscyArICctJyArIHByb3BzLnBhZ2U7XG5cbiAgICBpZiAocHJvcHMuYWN0aXZlKSB7XG4gICAgICBjbHMgPSBjbHMgKyAnICcgKyBwcmVmaXhDbHMgKyAnLWFjdGl2ZSc7XG4gICAgfVxuXG4gICAgdmFyIHRpdGxlID0gdm9pZCAwO1xuICAgIGlmIChwcm9wcy5wYWdlID09PSAxKSB7XG4gICAgICB0aXRsZSA9ICdGaXJzdCBQYWdlJztcbiAgICB9IGVsc2UgaWYgKHByb3BzLmxhc3QpIHtcbiAgICAgIHRpdGxlID0gJ0xhc3QgUGFnZTogJyArIHByb3BzLnBhZ2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRpdGxlID0gJ1BhZ2UgJyArIHByb3BzLnBhZ2U7XG4gICAgfVxuICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgJ2xpJyxcbiAgICAgIHsgdGl0bGU6IHRpdGxlLCBjbGFzc05hbWU6IGNscywgb25DbGljazogcHJvcHMub25DbGljayB9LFxuICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgICAgJ2EnLFxuICAgICAgICBudWxsLFxuICAgICAgICBwcm9wcy5wYWdlXG4gICAgICApXG4gICAgKTtcbiAgfTtcblxuICByZXR1cm4gUGFnZXI7XG59KFJlYWN0LkNvbXBvbmVudCk7XG5cblBhZ2VyLnByb3BUeXBlcyA9IHtcbiAgcGFnZTogUmVhY3QuUHJvcFR5cGVzLm51bWJlcixcbiAgYWN0aXZlOiBSZWFjdC5Qcm9wVHlwZXMuYm9vbCxcbiAgbGFzdDogUmVhY3QuUHJvcFR5cGVzLmJvb2xcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUGFnZXI7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vdXhjb3JlLXRhYmxlL34vdXhjb3JlLXBhZ2luYXRpb24vYnVpbGQvUGFnZXIuanNcbiAqKiBtb2R1bGUgaWQgPSAyNjNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgUmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xudmFyIFJlYWN0RE9NID0gcmVxdWlyZSgncmVhY3QtZG9tJyk7XG52YXIgS0VZQ09ERSA9IHJlcXVpcmUoJy4vS2V5Q29kZScpO1xudmFyIGkxOG4gPSByZXF1aXJlKCcuL2xvY2FsZScpO1xuXG52YXIgT3B0aW9ucyA9IGZ1bmN0aW9uIChfUmVhY3QkQ29tcG9uZW50KSB7XG4gIF9pbmhlcml0cyhPcHRpb25zLCBfUmVhY3QkQ29tcG9uZW50KTtcblxuICBmdW5jdGlvbiBPcHRpb25zKHByb3BzKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIE9wdGlvbnMpO1xuXG4gICAgdmFyIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX1JlYWN0JENvbXBvbmVudC5jYWxsKHRoaXMsIHByb3BzKSk7XG5cbiAgICBfdGhpcy5zdGF0ZSA9IHtcbiAgICAgIGN1cnJlbnQ6IHByb3BzLmN1cnJlbnQsXG4gICAgICBfY3VycmVudDogcHJvcHMuY3VycmVudFxuICAgIH07XG5cbiAgICBbJ19oYW5kbGVDaGFuZ2UnLCAnX2NoYW5nZVNpemUnLCAnX2dvJ10uZm9yRWFjaChmdW5jdGlvbiAobWV0aG9kKSB7XG4gICAgICByZXR1cm4gX3RoaXNbbWV0aG9kXSA9IF90aGlzW21ldGhvZF0uYmluZChfdGhpcyk7XG4gICAgfSk7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgT3B0aW9ucy5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgdmFyIHByb3BzID0gdGhpcy5wcm9wcztcbiAgICB2YXIgc3RhdGUgPSB0aGlzLnN0YXRlO1xuICAgIHZhciBwcmVmaXhDbHMgPSBwcm9wcy5yb290UHJlZml4Q2xzICsgJy1vcHRpb25zJztcbiAgICB2YXIgc2l6ZU9wdGlvbnMgPSBwcm9wcy5zaXplT3B0aW9ucztcbiAgICB2YXIgcGFnZVNpemUgPSBwcm9wcy5wYWdlU2l6ZTtcbiAgICB2YXIgY2hhbmdlU2l6ZSA9IHByb3BzLmNoYW5nZVNpemU7XG4gICAgdmFyIHF1aWNrR28gPSBwcm9wcy5xdWlja0dvO1xuICAgIHZhciBTZWxlY3QgPSBwcm9wcy5zZWxlY3RDb21wb25lbnRDbGFzcztcbiAgICB2YXIgY2hhbmdlU2VsZWN0ID0gbnVsbDtcbiAgICB2YXIgZ29JbnB1dCA9IG51bGw7XG5cbiAgICBpZiAoIShjaGFuZ2VTaXplIHx8IHF1aWNrR28pKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAoY2hhbmdlU2l6ZSAmJiBTZWxlY3QpIHtcbiAgICAgIChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBPcHRpb24gPSBTZWxlY3QuT3B0aW9uO1xuICAgICAgICBjaGFuZ2VTZWxlY3QgPSBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgIFNlbGVjdCxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBwcmVmaXhDbHM6IHByb3BzLnNlbGVjdFByZWZpeENscywgc2hvd1NlYXJjaDogZmFsc2UsXG4gICAgICAgICAgICBjbGFzc05hbWU6IHByZWZpeENscyArICctc2l6ZS1jaGFuZ2VyJyxcbiAgICAgICAgICAgIG9wdGlvbkxhYmVsUHJvcDogJ2NoaWxkcmVuJyxcbiAgICAgICAgICAgIGRyb3Bkb3duQ2xhc3NOYW1lOiBwcmVmaXhDbHMgKyAnLXNpemUtY2hhbmdlci1kcm9wZG93bicsXG4gICAgICAgICAgICBkZWZhdWx0VmFsdWU6IHNpemVPcHRpb25zLmluZGV4T2YocGFnZVNpemUpID09IC0xID8gc2l6ZU9wdGlvbnNbMF0gKyBcIlwiIDogcGFnZVNpemUgKyBcIlwiLFxuICAgICAgICAgICAgb25DaGFuZ2U6IF90aGlzMi5fY2hhbmdlU2l6ZSB9LFxuICAgICAgICAgIHNpemVPcHRpb25zLm1hcChmdW5jdGlvbiAob3B0aW9uLCBpbmRleCkge1xuICAgICAgICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgICAgIE9wdGlvbixcbiAgICAgICAgICAgICAgeyBrZXk6IG9wdGlvbiwgdmFsdWU6IG9wdGlvbiArIFwiXCIgfSxcbiAgICAgICAgICAgICAgb3B0aW9uICsgaTE4bltwcm9wcy5sb2NhbGVdWydpdGVtc19wZXJfcGFnZSddXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0pXG4gICAgICAgICk7XG4gICAgICB9KSgpO1xuICAgIH1cblxuICAgIGlmIChxdWlja0dvKSB7XG4gICAgICBnb0lucHV0ID0gUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgICAgJ2RpdicsXG4gICAgICAgIHsgdGl0bGU6ICdRdWljayBqdW1wIHRvIHBhZ2UnLCBjbGFzc05hbWU6IHByZWZpeENscyArICctcXVpY2stanVtcGVyJyB9LFxuICAgICAgICBpMThuW3Byb3BzLmxvY2FsZV1bJ2p1bXBfdG8nXSxcbiAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudCgnaW5wdXQnLCB7IHR5cGU6ICd0ZXh0JywgdmFsdWU6IHN0YXRlLl9jdXJyZW50LCBvbkNoYW5nZTogdGhpcy5faGFuZGxlQ2hhbmdlLmJpbmQodGhpcyksIG9uS2V5VXA6IHRoaXMuX2dvLmJpbmQodGhpcykgfSksXG4gICAgICAgIGkxOG5bcHJvcHMubG9jYWxlXVsncGFnZSddXG4gICAgICApO1xuICAgIH1cblxuICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgJ2RpdicsXG4gICAgICB7IGNsYXNzTmFtZTogJycgKyBwcmVmaXhDbHMgfSxcbiAgICAgIGNoYW5nZVNlbGVjdCxcbiAgICAgIGdvSW5wdXRcbiAgICApO1xuICB9O1xuXG4gIE9wdGlvbnMucHJvdG90eXBlLl9jaGFuZ2VTaXplID0gZnVuY3Rpb24gX2NoYW5nZVNpemUodmFsdWUpIHtcbiAgICB0aGlzLnByb3BzLmNoYW5nZVNpemUoTnVtYmVyKHZhbHVlKSk7XG4gIH07XG5cbiAgT3B0aW9ucy5wcm90b3R5cGUuX2hhbmRsZUNoYW5nZSA9IGZ1bmN0aW9uIF9oYW5kbGVDaGFuZ2UoZXZ0KSB7XG4gICAgdmFyIF92YWwgPSBldnQudGFyZ2V0LnZhbHVlO1xuXG4gICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICBfY3VycmVudDogX3ZhbFxuICAgIH0pO1xuICB9O1xuXG4gIE9wdGlvbnMucHJvdG90eXBlLl9nbyA9IGZ1bmN0aW9uIF9nbyhlKSB7XG4gICAgdmFyIF92YWwgPSBlLnRhcmdldC52YWx1ZTtcbiAgICBpZiAoX3ZhbCA9PT0gJycpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHZhbCA9IE51bWJlcih0aGlzLnN0YXRlLl9jdXJyZW50KTtcbiAgICBpZiAoaXNOYU4odmFsKSkge1xuICAgICAgdmFsID0gdGhpcy5zdGF0ZS5jdXJyZW50O1xuICAgIH1cbiAgICBpZiAoZS5rZXlDb2RlID09PSBLRVlDT0RFLkVOVEVSKSB7XG4gICAgICB2YXIgYyA9IHRoaXMucHJvcHMucXVpY2tHbyh2YWwpO1xuICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgIF9jdXJyZW50OiBjLFxuICAgICAgICBjdXJyZW50OiBjXG4gICAgICB9KTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIE9wdGlvbnM7XG59KFJlYWN0LkNvbXBvbmVudCk7XG5cbk9wdGlvbnMucHJvcFR5cGVzID0ge1xuICBjaGFuZ2VTaXplOiBSZWFjdC5Qcm9wVHlwZXMuZnVuYyxcbiAgcXVpY2tHbzogUmVhY3QuUHJvcFR5cGVzLmZ1bmMsXG4gIHNlbGVjdENvbXBvbmVudENsYXNzOiBSZWFjdC5Qcm9wVHlwZXMuZnVuYyxcbiAgY3VycmVudDogUmVhY3QuUHJvcFR5cGVzLm51bWJlclxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBPcHRpb25zO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3V4Y29yZS10YWJsZS9+L3V4Y29yZS1wYWdpbmF0aW9uL2J1aWxkL09wdGlvbnMuanNcbiAqKiBtb2R1bGUgaWQgPSAyNjRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlwidXNlIHN0cmljdFwiO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgWkVSTzogNDgsXG4gIE5JTkU6IDU3LFxuXG4gIE5VTVBBRF9aRVJPOiA5NixcbiAgTlVNUEFEX05JTkU6IDEwNSxcblxuICBCQUNLU1BBQ0U6IDgsXG4gIERFTEVURTogNDYsXG4gIEVOVEVSOiAxMyxcblxuICBBUlJPV19VUDogMzgsXG4gIEFSUk9XX0RPV046IDQwXG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3V4Y29yZS10YWJsZS9+L3V4Y29yZS1wYWdpbmF0aW9uL2J1aWxkL0tleUNvZGUuanNcbiAqKiBtb2R1bGUgaWQgPSAyNjVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxudmFyIGxvY2FsZSA9IHtcbiAgICBcImVuLXVzXCI6IHtcbiAgICAgICAgaXRlbXNfcGVyX3BhZ2U6ICcvcGFnZScsXG4gICAgICAgIGp1bXBfdG86ICdHb3RvJyxcbiAgICAgICAgcGFnZTogJycsXG5cbiAgICAgICAgLy8gUGFnaW5hdGlvbi5qc1xuICAgICAgICBpdGVtOiAnIGVudHJpZXMnXG4gICAgfSxcbiAgICBcInpoLWNuXCI6IHtcbiAgICAgICAgLy8gT3B0aW9ucy5qc1xuICAgICAgICBpdGVtc19wZXJfcGFnZTogJ+adoS/pobUnLFxuICAgICAgICBqdW1wX3RvOiAn6Lez6IezJyxcbiAgICAgICAgcGFnZTogJ+mhtScsXG5cbiAgICAgICAgLy8gUGFnaW5hdGlvbi5qc1xuICAgICAgICBpdGVtOiAn5p2hJ1xuICAgIH1cbn07XG5sb2NhbGVbJ2VuJ10gPSBsb2NhbGVbJ2VuLXVzJ107XG5cbm1vZHVsZS5leHBvcnRzID0gbG9jYWxlO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3V4Y29yZS10YWJsZS9+L3V4Y29yZS1wYWdpbmF0aW9uL2J1aWxkL2xvY2FsZS5qc1xuICoqIG1vZHVsZSBpZCA9IDI2NlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qKlxuICogRm9ybSBDb21wb25lbnQgZm9yIHV4Y29yZVxuICogQGF1dGhvciBldGVybmFsc2t5XG4gKlxuICogQ29weXJpZ2h0IDIwMTQtMjAxNSwgVXhjb3JlIFRlYW0sIEFsaW53LlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqL1xudmFyIEZvcm0gPSByZXF1aXJlKCcuL0Zvcm0nKTtcblxuLy8g5LulIEZvcm0g5o+S5Lu255qE5b2i5byP57uZ5Ye6XG5Gb3JtLlRleHRBcmVhRm9ybUZpZWxkID0gcmVxdWlyZShcInV4Y29yZS10ZXh0YXJlYS1mb3JtLWZpZWxkXCIpO1xuRm9ybS5JbnB1dEZvcm1GaWVsZCA9IHJlcXVpcmUoXCJ1eGNvcmUtaW5wdXQtZm9ybS1maWVsZFwiKTtcbkZvcm0uUmFkaW9Hcm91cEZvcm1GaWVsZCA9IHJlcXVpcmUoXCIuL0Zvcm1GaWVsZC9SYWRpb0dyb3VwRm9ybUZpZWxkXCIpO1xuRm9ybS5TZWxlY3RGb3JtRmllbGQgPSByZXF1aXJlKFwidXhjb3JlLXNlbGVjdC1mb3JtLWZpZWxkXCIpO1xuRm9ybS5OdW1iZXJJbnB1dEZvcm1GaWVsZCA9IHJlcXVpcmUoJy4vRm9ybUZpZWxkL051bWJlcklucHV0Rm9ybUZpZWxkJyk7XG5Gb3JtLkRhdGVGb3JtRmllbGQgPSByZXF1aXJlKCd1eGNvcmUtZGF0ZS1mb3JtLWZpZWxkJyk7XG5Gb3JtLkNoZWNrYm94R3JvdXBGb3JtRmllbGQgPSByZXF1aXJlKFwiLi9Gb3JtRmllbGQvQ2hlY2tib3hHcm91cEZvcm1GaWVsZFwiKTtcbkZvcm0uQ2FzY2FkZVNlbGVjdEZvcm1GaWVsZCA9IHJlcXVpcmUoXCIuL0Zvcm1GaWVsZC9DYXNjYWRlU2VsZWN0Rm9ybUZpZWxkXCIpO1xuRm9ybS5PdGhlckZvcm1GaWVsZCA9IHJlcXVpcmUoXCJ1eGNvcmUtb3RoZXItZm9ybS1maWVsZFwiKTtcbkZvcm0uQnV0dG9uR3JvdXBGb3JtRmllbGQgPSByZXF1aXJlKFwiLi9Gb3JtRmllbGQvQnV0dG9uR3JvdXBGb3JtRmllbGRcIik7XG5Gb3JtLkVkaXRvckZvcm1GaWVsZCA9IHJlcXVpcmUoXCIuL0Zvcm1GaWVsZC9FZGl0b3JGb3JtRmllbGRcIik7XG5Gb3JtLlNlYXJjaEZvcm1GaWVsZCA9IHJlcXVpcmUoXCIuL0Zvcm1GaWVsZC9TZWFyY2hGb3JtRmllbGRcIik7XG5cbm1vZHVsZS5leHBvcnRzID0gRm9ybTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi91eGNvcmUtZm9ybS9idWlsZC9pbmRleC5qc1xuICoqIG1vZHVsZSBpZCA9IDI2N1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG4vKipcbiAqIEZvcm0gQ29tcG9uZW50IGZvciB1eGNvcmVcbiAqIEBhdXRob3IgZXRlcm5hbHNreVxuICpcbiAqIENvcHlyaWdodCAyMDE0LTIwMTUsIFV4Y29yZSBUZWFtLCBBbGludy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKi9cblxudmFyIFJlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcbnZhciBSZWFjdERPTSA9IHJlcXVpcmUoJ3JlYWN0LWRvbScpO1xudmFyIEZvcm1Sb3cgPSByZXF1aXJlKFwidXhjb3JlLWZvcm0tcm93XCIpO1xudmFyIEZvcm1Sb3dUaXRsZSA9IHJlcXVpcmUoXCIuL0Zvcm1Sb3dUaXRsZVwiKTtcbnZhciBGb3JtRmllbGQgPSByZXF1aXJlKFwidXhjb3JlLWZvcm0tZmllbGRcIik7XG5cbnZhciBDb25zdGFudHMgPSByZXF1aXJlKFwidXhjb3JlLWNvbnN0XCIpO1xudmFyIFZhbGlkYXRvcnMgPSByZXF1aXJlKFwiLi9WYWxpZGF0b3JzXCIpO1xudmFyIEtleUNvZGUgPSByZXF1aXJlKCcuL0tleUNvZGUnKTtcblxudmFyIGNsYXNzbmFtZXMgPSByZXF1aXJlKCdjbGFzc25hbWVzJyk7XG52YXIgYXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xudmFyIGRlZXBjb3B5ID0gcmVxdWlyZSgnZGVlcGNvcHknKTtcbnZhciBkZWVwRXF1YWwgPSByZXF1aXJlKCdkZWVwLWVxdWFsJyk7XG5cbnZhciBGb3JtID0gZnVuY3Rpb24gKF9SZWFjdCRDb21wb25lbnQpIHtcbiAgICBfaW5oZXJpdHMoRm9ybSwgX1JlYWN0JENvbXBvbmVudCk7XG5cbiAgICBmdW5jdGlvbiBGb3JtKHByb3BzKSB7XG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBGb3JtKTtcblxuICAgICAgICB2YXIgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfUmVhY3QkQ29tcG9uZW50LmNhbGwodGhpcywgcHJvcHMpKTtcblxuICAgICAgICBfdGhpcy5maWVsZHMgPSB7fTtcbiAgICAgICAgX3RoaXMuZXJyb3JzID0ge307XG4gICAgICAgIF90aGlzLmRhdGEgPSB7fTtcbiAgICAgICAgX3RoaXMuc3RhdGUgPSB7fTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cblxuICAgIEZvcm0ucHJvdG90eXBlLmNvbXBvbmVudERpZE1vdW50ID0gZnVuY3Rpb24gY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgICAgIHZhciBtZSA9IHRoaXM7XG4gICAgfTtcblxuICAgIEZvcm0ucHJvdG90eXBlLl9jb3B5ID0gZnVuY3Rpb24gX2NvcHkoYSkge1xuICAgICAgICByZXR1cm4gZGVlcGNvcHkoYSk7XG4gICAgfTtcblxuICAgIEZvcm0ucHJvdG90eXBlLmF0dGFjaEZvcm1GaWVsZCA9IGZ1bmN0aW9uIGF0dGFjaEZvcm1GaWVsZChmaWVsZCkge1xuICAgICAgICB2YXIgbmFtZSA9IGZpZWxkLmdldE5hbWUoKTtcbiAgICAgICAgaWYgKCFuYW1lKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJFYWNoIGZpZWxkIG5lZWRzIGEgbmFtZSB0byBpZGVudGlmeSBpdHNlbGZcIik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmZpZWxkc1tuYW1lXSA9IGZpZWxkO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIEZvcm0ucHJvdG90eXBlLmRldGFjaEZvcm1GaWVsZCA9IGZ1bmN0aW9uIGRldGFjaEZvcm1GaWVsZChmaWVsZCkge1xuICAgICAgICB2YXIgbmFtZSA9IGZpZWxkLmdldE5hbWUoKTtcbiAgICAgICAgZGVsZXRlIHRoaXMuZmllbGRzW25hbWVdO1xuICAgICAgICBkZWxldGUgdGhpcy5kYXRhW25hbWVdO1xuICAgIH07XG5cbiAgICBGb3JtLnByb3RvdHlwZS5oYW5kbGVEYXRhQ2hhbmdlID0gZnVuY3Rpb24gaGFuZGxlRGF0YUNoYW5nZShmaWVsZCwgZmllbGREYXRhLCBmcm9tTW91bnQpIHtcbiAgICAgICAgdmFyIG1lID0gdGhpcztcbiAgICAgICAgbWUuZGF0YVtmaWVsZC5wcm9wcy5qc3huYW1lXSA9IGZpZWxkRGF0YS52YWx1ZTtcbiAgICAgICAgaWYgKCFmcm9tTW91bnQpIHtcbiAgICAgICAgICAgIG1lLnByb3BzLmpzeG9uQ2hhbmdlKG1lLl9jb3B5KG1lLmRhdGEpLCBmaWVsZC5wcm9wcy5qc3huYW1lLCBmaWVsZERhdGEucGFzcyk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgRm9ybS5wcm90b3R5cGUuZ2V0VmFsdWVzID0gZnVuY3Rpb24gZ2V0VmFsdWVzKGZvcmNlKSB7XG4gICAgICAgIHZhciBtZSA9IHRoaXM7XG4gICAgICAgIHZhciBfZmxhZyA9IG1lLmRvVmFsaWRhdGUoZm9yY2UpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdmFsdWVzOiBtZS5fY29weShtZS5kYXRhKSxcbiAgICAgICAgICAgIHBhc3M6IF9mbGFnXG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIEZvcm0ucHJvdG90eXBlLnJlc2V0VmFsdWVzID0gZnVuY3Rpb24gcmVzZXRWYWx1ZXMoKSB7XG4gICAgICAgIHZhciBtZSA9IHRoaXM7XG4gICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMobWUuZmllbGRzKTtcbiAgICAgICAgdmFyIGRhdGEgPSBtZS5wcm9wcy5qc3h2YWx1ZXMgfHwgbWUucHJvcHMucGFzc2VkRGF0YSB8fCB7fTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBtZS5maWVsZHNba2V5c1tpXV0gJiYgbWUuZmllbGRzW2tleXNbaV1dLmhhbmRsZURhdGFDaGFuZ2UoZGF0YVtrZXlzW2ldXSA9PSB1bmRlZmluZWQgPyBudWxsIDogZGF0YVtrZXlzW2ldXSwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLypcbiAgICAgKiBzZXQgRm9ybSB2YWx1ZXMgbWFudWFsbHlcbiAgICAgKi9cblxuICAgIEZvcm0ucHJvdG90eXBlLnNldFZhbHVlcyA9IGZ1bmN0aW9uIHNldFZhbHVlcyhkYXRhKSB7XG4gICAgICAgIGlmICgodHlwZW9mIGRhdGEgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKGRhdGEpKSAhPSAnb2JqZWN0JykgcmV0dXJuO1xuICAgICAgICB2YXIgbWUgPSB0aGlzO1xuICAgICAgICB2YXIgc2F2ZWREYXRhID0gbWUuZGF0YTtcbiAgICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhkYXRhKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoIWRlZXBFcXVhbChkYXRhW2tleXNbaV1dLCBzYXZlZERhdGFba2V5c1tpXV0pKSB7XG4gICAgICAgICAgICAgICAgbWUuZmllbGRzW2tleXNbaV1dLmhhbmRsZURhdGFDaGFuZ2UoZGF0YVtrZXlzW2ldXSA9PSB1bmRlZmluZWQgPyBudWxsIDogZGF0YVtrZXlzW2ldXSwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgRm9ybS5wcm90b3R5cGUuZG9WYWxpZGF0ZSA9IGZ1bmN0aW9uIGRvVmFsaWRhdGUoZm9yY2UpIHtcbiAgICAgICAgdmFyIG1lID0gdGhpcztcbiAgICAgICAgdmFyIHBhc3MgPSB0cnVlO1xuICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG1lLmZpZWxkcyk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGl0ZW1QYXNzID0gbWUuZmllbGRzW2tleXNbaV1dLmRvVmFsaWRhdGUoZm9yY2UpO1xuICAgICAgICAgICAgbWUuZXJyb3JzW2tleXNbaV1dID0gIWl0ZW1QYXNzO1xuICAgICAgICAgICAgaWYgKCFpdGVtUGFzcykge1xuICAgICAgICAgICAgICAgIHBhc3MgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGFzcztcbiAgICB9O1xuXG4gICAgRm9ybS5wcm90b3R5cGUuaXNEaXJ0eSA9IGZ1bmN0aW9uIGlzRGlydHkoKSB7XG4gICAgICAgIHJldHVybiAhdGhpcy5kb1ZhbGlkYXRlKCk7XG4gICAgfTtcblxuICAgIC8qXG4gICAgICog57uf5LiA5pWw5o2u5rWB77yM5omA5pyJ55qEIHByb3Bz77yM6YCa6L+HIEZvcm0gLT4gRm9ybVJvdyAtPiBGb3JtRmllbGQg5ZCR5LiL5Lyg6YCS77yM5aaC5p6c5pyJ55qEXG4gICAgICog5a2Q5YWD57Sg5pivIEZvcm1GaWVsZO+8jOWImeiHquWKqOWcqOS7lueahOWklumdouWMheS4gOWxgiBGb3JtUm9344CCXG4gICAgICogQHBhcmFtIHtSZWFjdCBFbGVtZW50cyBBcnJheX0gY2hpbGRyZW4gdGhpcy5wcm9wcy5jaGlsZHJlblxuICAgICAqL1xuXG4gICAgRm9ybS5wcm90b3R5cGUuX3Byb2Nlc3NDaGlsZCA9IGZ1bmN0aW9uIF9wcm9jZXNzQ2hpbGQoY2hpbGRyZW4pIHtcbiAgICAgICAgdmFyIGxlbmd0aCA9IFJlYWN0LkNoaWxkcmVuLmNvdW50KGNoaWxkcmVuKTtcbiAgICAgICAgdmFyIGVsZW1lbnRzID0gW107XG4gICAgICAgIGlmIChsZW5ndGggPT0gMCkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKFwiRk9STTogWW91IG11c3QgcGFzcyBjaGlsZHJlbiB0byB0aGUgZm9ybSBjb21wb25lbnRcIik7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBSZWFjdC5DaGlsZHJlbi5mb3JFYWNoKGNoaWxkcmVuLCBmdW5jdGlvbiAoY2hpbGQsIGluZGV4KSB7XG4gICAgICAgICAgICAvLyDlpoLmnpzmmK/oh6rlt7Hmt7vliqDnmoQgRE9NIOebtOaOpeaKm+W8g1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBjaGlsZC50eXBlID09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICB2YXIgZGlzcGxheU5hbWUgPSBjaGlsZC50eXBlLmRpc3BsYXlOYW1lO1xuICAgICAgICAgICAgICAgIGlmIChkaXNwbGF5TmFtZSA9PT0gJ0VuZ2luZU5vZGUnKSB7XG4gICAgICAgICAgICAgICAgICAgIGRpc3BsYXlOYW1lID0gY2hpbGQucHJvcHMuX2NvbXBvbmVudE5hbWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICgvRm9ybUZpZWxkLy50ZXN0KGRpc3BsYXlOYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICBlbGVtZW50cy5wdXNoKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgICAgICAgICAgICAgICBGb3JtUm93LFxuICAgICAgICAgICAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkXG4gICAgICAgICAgICAgICAgICAgICkpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoL0Zvcm1Sb3cvLnRlc3QoZGlzcGxheU5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnRzLnB1c2goY2hpbGQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIGVsZW1lbnRzO1xuICAgIH07XG5cbiAgICBGb3JtLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgICAgIHZhciBfY2xhc3NuYW1lcztcblxuICAgICAgICB2YXIgbWUgPSB0aGlzO1xuICAgICAgICB2YXIgZWxlbWVudHMgPSBtZS5fcHJvY2Vzc0NoaWxkKG1lLnByb3BzLmNoaWxkcmVuKTtcblxuICAgICAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAgICdkaXYnLFxuICAgICAgICAgICAgeyBjbGFzc05hbWU6IGNsYXNzbmFtZXMoKF9jbGFzc25hbWVzID0ge30sIF9jbGFzc25hbWVzW21lLnByb3BzLmpzeHByZWZpeENsc10gPSB0cnVlLCBfY2xhc3NuYW1lc1ttZS5wcm9wcy5jbGFzc05hbWVdID0gISFtZS5wcm9wcy5jbGFzc05hbWUsIF9jbGFzc25hbWVzW1wia3VtYS11eGZvcm0tZWRpdC1tb2RlXCJdID0gbWUucHJvcHMuanN4bW9kZSA9PSBDb25zdGFudHMuTU9ERS5FRElULCBfY2xhc3NuYW1lc1tcImt1bWEtdXhmb3JtLXZpZXctbW9kZVwiXSA9IG1lLnByb3BzLmpzeG1vZGUgPT0gQ29uc3RhbnRzLk1PREUuVklFVywgX2NsYXNzbmFtZXMpKSB9LFxuICAgICAgICAgICAgISFlbGVtZW50cyAmJiBlbGVtZW50cy5tYXAoZnVuY3Rpb24gKGNoaWxkLCBpbmRleCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBSZWFjdC5jbG9uZUVsZW1lbnQoY2hpbGQsIHtcbiAgICAgICAgICAgICAgICAgICAgbW9kZTogbWUucHJvcHMuanN4bW9kZSxcbiAgICAgICAgICAgICAgICAgICAgaW5zdGFudFZhbGlkYXRlOiBtZS5wcm9wcy5pbnN0YW50VmFsaWRhdGUsXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IGRlZXBjb3B5KG1lLnByb3BzLmpzeHZhbHVlcyB8fCBtZS5wcm9wcy5wYXNzZWREYXRhIHx8IHt9KSxcbiAgICAgICAgICAgICAgICAgICAga2V5OiBpbmRleCxcbiAgICAgICAgICAgICAgICAgICAgYXR0YWNoRm9ybUZpZWxkOiBtZS5hdHRhY2hGb3JtRmllbGQuYmluZChtZSksXG4gICAgICAgICAgICAgICAgICAgIGRldGFjaEZvcm1GaWVsZDogbWUuZGV0YWNoRm9ybUZpZWxkLmJpbmQobWUpLFxuICAgICAgICAgICAgICAgICAgICBoYW5kbGVEYXRhQ2hhbmdlOiBtZS5oYW5kbGVEYXRhQ2hhbmdlLmJpbmQobWUpLFxuICAgICAgICAgICAgICAgICAgICBnZXRWYWx1ZXM6IG1lLmdldFZhbHVlcy5iaW5kKG1lKSxcbiAgICAgICAgICAgICAgICAgICAgcmVzZXRWYWx1ZXM6IG1lLnJlc2V0VmFsdWVzLmJpbmQobWUpXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KVxuICAgICAgICApO1xuICAgIH07XG5cbiAgICByZXR1cm4gRm9ybTtcbn0oUmVhY3QuQ29tcG9uZW50KTtcblxuLy8g5LulIEZvcm0g55qE5o+S5Lu255qE5b2i5byP57uZ5Ye6XG5cblxuRm9ybS5Gb3JtUm93ID0gRm9ybVJvdztcbkZvcm0uRm9ybVJvd1RpdGxlID0gRm9ybVJvd1RpdGxlO1xuRm9ybS5Gb3JtRmllbGQgPSBGb3JtRmllbGQ7XG5cbi8vIEZvcm0uTWVudGlvbkZvcm1GaWVsZCA9IE1lbnRpb25Gb3JtRmllbGQ7XG5Gb3JtLkNvbnN0YW50cyA9IENvbnN0YW50cztcbkZvcm0uVmFsaWRhdG9ycyA9IFZhbGlkYXRvcnM7XG5Gb3JtLktleUNvZGUgPSBLZXlDb2RlO1xuXG5Gb3JtLmRlZmF1bHRQcm9wcyA9IHtcbiAgICBqc3hwcmVmaXhDbHM6IFwia3VtYS11eGZvcm1cIixcbiAgICBqc3htb2RlOiBDb25zdGFudHMuTU9ERS5FRElULFxuICAgIGluc3RhbnRWYWxpZGF0ZTogdHJ1ZSxcbiAgICBqc3hvbkNoYW5nZTogZnVuY3Rpb24ganN4b25DaGFuZ2UoKSB7fVxufTtcblxuLy8gaHR0cDovL2ZhY2Vib29rLmdpdGh1Yi5pby9yZWFjdC9kb2NzL3JldXNhYmxlLWNvbXBvbmVudHMuaHRtbFxuRm9ybS5wcm9wVHlwZXMgPSB7XG4gICAgLyoqXG4gICAgICogQHRpdGxlOiDnsbvlkI3liY3nvIBcbiAgICAgKiBAdmVJZ25vcmVcbiAgICAgKi9cbiAgICBqc3hwcmVmaXhDbHM6IFJlYWN0LlByb3BUeXBlcy5zdHJpbmcsXG4gICAgLyoqXG4gICAgICogQHRpdGxlIENTU+exu+WQjVxuICAgICAqIEB2ZUlnbm9yZVxuICAgICAqL1xuICAgIGNsYXNzTmFtZTogUmVhY3QuUHJvcFR5cGVzLnN0cmluZyxcbiAgICAvKipcbiAgICAgKiBAdGl0bGUg5pi+56S65qih5byPXG4gICAgICovXG4gICAganN4bW9kZTogUmVhY3QuUHJvcFR5cGVzLnN0cmluZyxcbiAgICAvKipcbiAgICAgKiBAdGl0bGUg6buY6K6k5YC8XG4gICAgICovXG4gICAganN4dmFsdWVzOiBSZWFjdC5Qcm9wVHlwZXMub2JqZWN0LFxuICAgIC8qKlxuICAgICAqIEB0aXRsZSDmmK/lkKbljbPml7bmoKHpqoxcbiAgICAgKiBAdmVGaWVsZFN0eWxlIGJsb2NrXG4gICAgICovXG4gICAgaW5zdGFudFZhbGlkYXRlOiBSZWFjdC5Qcm9wVHlwZXMuYm9vbCxcbiAgICAvKipcbiAgICAgKiBAdGl0bGUg6KGo5Y2V5Z+f5pS55Y+Y5pe255qE5Zue6LCDXG4gICAgICovXG4gICAganN4b25DaGFuZ2U6IFJlYWN0LlByb3BUeXBlcy5mdW5jXG59O1xuXG5Gb3JtLmRpc3BsYXlOYW1lID0gXCJGb3JtXCI7XG5cbm1vZHVsZS5leHBvcnRzID0gRm9ybTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi91eGNvcmUtZm9ybS9idWlsZC9Gb3JtLmpzXG4gKiogbW9kdWxlIGlkID0gMjY4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogRm9ybVJvdyBDb21wb25lbnQgZm9yIHV4Y29yZVxuICogQGF1dGhvciBldGVybmFsc2t5XG4gKlxuICogQ29weXJpZ2h0IDIwMTQtMjAxNSwgVXhjb3JlIFRlYW0sIEFsaW53LlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vRm9ybVJvdycpO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3V4Y29yZS1mb3JtL34vdXhjb3JlLWZvcm0tcm93L2J1aWxkL2luZGV4LmpzXG4gKiogbW9kdWxlIGlkID0gMjY5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIFJlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcbnZhciBSZWFjdERPTSA9IHJlcXVpcmUoJ3JlYWN0LWRvbScpO1xudmFyIGNsYXNzbmFtZXMgPSByZXF1aXJlKFwiY2xhc3NuYW1lc1wiKTtcblxudmFyIEZvcm1Sb3cgPSBmdW5jdGlvbiAoX1JlYWN0JENvbXBvbmVudCkge1xuICAgIF9pbmhlcml0cyhGb3JtUm93LCBfUmVhY3QkQ29tcG9uZW50KTtcblxuICAgIGZ1bmN0aW9uIEZvcm1Sb3cocHJvcHMpIHtcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEZvcm1Sb3cpO1xuXG4gICAgICAgIHZhciBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9SZWFjdCRDb21wb25lbnQuY2FsbCh0aGlzLCBwcm9wcykpO1xuXG4gICAgICAgIF90aGlzLnRvdGFsRmxleCA9IDA7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG5cbiAgICBGb3JtUm93LnByb3RvdHlwZS5fcHJvY2Vzc0NoaWxkID0gZnVuY3Rpb24gX3Byb2Nlc3NDaGlsZChjaGlsZHJlbikge1xuICAgICAgICB2YXIgbWUgPSB0aGlzO1xuICAgICAgICBtZS50b3RhbEZsZXggPSAwO1xuICAgICAgICB2YXIgbGVuZ3RoID0gUmVhY3QuQ2hpbGRyZW4uY291bnQoY2hpbGRyZW4pO1xuICAgICAgICB2YXIgZWxlbWVudHMgPSBbXTtcbiAgICAgICAgaWYgKGxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJGT1JNOiBZb3UgbXVzdCBwYXNzIGNoaWxkcmVuIHRvIHRoZSBmb3JtIGNvbXBvbmVudFwiKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBSZWFjdC5DaGlsZHJlbi5mb3JFYWNoKGNoaWxkcmVuLCBmdW5jdGlvbiAoY2hpbGQsIGluZGV4KSB7XG4gICAgICAgICAgICAvLyDlpoLmnpzmmK/oh6rlt7Hmt7vliqDnmoQgRE9NIOebtOaOpeaKm+W8g1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBjaGlsZC50eXBlID09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICB2YXIgZGlzcGxheU5hbWUgPSBjaGlsZC50eXBlLmRpc3BsYXlOYW1lO1xuICAgICAgICAgICAgICAgIGlmIChkaXNwbGF5TmFtZSA9PT0gJ0VuZ2luZU5vZGUnKSB7XG4gICAgICAgICAgICAgICAgICAgIGRpc3BsYXlOYW1lID0gY2hpbGQucHJvcHMuX2NvbXBvbmVudE5hbWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICgvRm9ybUZpZWxkLy50ZXN0KGRpc3BsYXlOYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2hpbGQucHJvcHMuanN4c2hvdykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWUudG90YWxGbGV4ICs9IGNoaWxkLnByb3BzLmpzeGZsZXggfHwgMTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbGVtZW50cy5wdXNoKGNoaWxkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBlbGVtZW50cztcbiAgICB9O1xuXG4gICAgRm9ybVJvdy5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgICAgICB2YXIgX2NsYXNzbmFtZXM7XG5cbiAgICAgICAgdmFyIG1lID0gdGhpcztcbiAgICAgICAgdmFyIGVsZW1lbnRzID0gbWUuX3Byb2Nlc3NDaGlsZChtZS5wcm9wcy5jaGlsZHJlbik7XG4gICAgICAgIHZhciB0b3RhbEZsZXggPSBtZS5wcm9wcy50b3RhbEZsZXggfHwgbWUudG90YWxGbGV4O1xuICAgICAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAgICdkaXYnLFxuICAgICAgICAgICAgeyBjbGFzc05hbWU6IGNsYXNzbmFtZXMoKF9jbGFzc25hbWVzID0ge30sIF9jbGFzc25hbWVzW21lLnByb3BzLmpzeHByZWZpeENsc10gPSB0cnVlLCBfY2xhc3NuYW1lc1ttZS5wcm9wcy5jbGFzc05hbWVdID0gISFtZS5wcm9wcy5jbGFzc05hbWUsIF9jbGFzc25hbWVzKSkgfSxcbiAgICAgICAgICAgICEhZWxlbWVudHMgJiYgZWxlbWVudHMubWFwKGZ1bmN0aW9uIChjaGlsZCwgaW5kZXgpIHtcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBtZS5wcm9wcy5kYXRhW2NoaWxkLnByb3BzLmpzeG5hbWVdO1xuICAgICAgICAgICAgICAgIHJldHVybiBSZWFjdC5jbG9uZUVsZW1lbnQoY2hpbGQsIHtcbiAgICAgICAgICAgICAgICAgICAgbW9kZTogbWUucHJvcHMubW9kZSxcbiAgICAgICAgICAgICAgICAgICAganN4aW5zdGFudDogbWUucHJvcHMuaW5zdGFudFZhbGlkYXRlLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIGtleTogY2hpbGQucHJvcHMuanN4bmFtZSB8fCBpbmRleCxcbiAgICAgICAgICAgICAgICAgICAgdG90YWxGbGV4OiB0b3RhbEZsZXgsXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlOiB7IHdpZHRoOiBjaGlsZC5wcm9wcy5qc3hmbGV4IC8gbWUudG90YWxGbGV4ICogMTAwICsgJyUnIH0sXG4gICAgICAgICAgICAgICAgICAgIGF0dGFjaEZvcm1GaWVsZDogbWUucHJvcHMuYXR0YWNoRm9ybUZpZWxkLFxuICAgICAgICAgICAgICAgICAgICBkZXRhY2hGb3JtRmllbGQ6IG1lLnByb3BzLmRldGFjaEZvcm1GaWVsZCxcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlRGF0YUNoYW5nZTogbWUucHJvcHMuaGFuZGxlRGF0YUNoYW5nZSxcbiAgICAgICAgICAgICAgICAgICAgZ2V0VmFsdWVzOiBtZS5wcm9wcy5nZXRWYWx1ZXMsXG4gICAgICAgICAgICAgICAgICAgIHJlc2V0VmFsdWVzOiBtZS5wcm9wcy5yZXNldFZhbHVlc1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNoaWxkO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIEZvcm1Sb3c7XG59KFJlYWN0LkNvbXBvbmVudCk7XG5cbkZvcm1Sb3cuZGVmYXVsdFByb3BzID0ge1xuICAgIGpzeHByZWZpeENsczogXCJrdW1hLXV4Zm9ybS1yb3dcIlxufTtcbkZvcm1Sb3cucHJvcFR5cGVzID0ge1xuICAgIC8qKlxuICAgICAqIEB0aXRsZSDnsbvlkI3liY3nvIBcbiAgICAgKiBAdmVJZ25vcmVcbiAgICAgKi9cbiAgICBqc3hwcmVmaXhDbHM6IFJlYWN0LlByb3BUeXBlcy5zdHJpbmcsXG4gICAgLyoqXG4gICAgICogQHRpdGxlIOW8ueaAp+avlOS+i+aAu+WSjFxuICAgICAqL1xuICAgIHRvdGFsRmxleDogUmVhY3QuUHJvcFR5cGVzLm51bWJlcixcbiAgICAvKipcbiAgICAgKiBAdGl0bGUgQ1NT57G75ZCNXG4gICAgICogQHZlSWdub3JlXG4gICAgICovXG4gICAgY2xhc3NOYW1lOiBSZWFjdC5Qcm9wVHlwZXMuc3RyaW5nXG59O1xuRm9ybVJvdy5kaXNwbGF5TmFtZSA9IFwiRm9ybVJvd1wiO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEZvcm1Sb3c7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vdXhjb3JlLWZvcm0vfi91eGNvcmUtZm9ybS1yb3cvYnVpbGQvRm9ybVJvdy5qc1xuICoqIG1vZHVsZSBpZCA9IDI3MFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbi8qKlxuICogQGF1dGhvcjogemhvdXF1YW4ueWV6cVxuICogQHRpbWU6IDgvNyAyMDE1XG4gKiBGb3JtIFJvdyBUaXRsZVxuICovXG52YXIgUmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xudmFyIFJlYWN0RE9NID0gcmVxdWlyZSgncmVhY3QtZG9tJyk7XG52YXIgQ29uc3RhbnRzID0gcmVxdWlyZShcInV4Y29yZS1jb25zdFwiKTtcbnZhciBjbGFzc25hbWVzID0gcmVxdWlyZShcImNsYXNzbmFtZXNcIik7XG5cbnZhciBGb3JtUm93VGl0bGUgPSBmdW5jdGlvbiAoX1JlYWN0JENvbXBvbmVudCkge1xuICAgIF9pbmhlcml0cyhGb3JtUm93VGl0bGUsIF9SZWFjdCRDb21wb25lbnQpO1xuXG4gICAgZnVuY3Rpb24gRm9ybVJvd1RpdGxlKHByb3BzKSB7XG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBGb3JtUm93VGl0bGUpO1xuXG4gICAgICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfUmVhY3QkQ29tcG9uZW50LmNhbGwodGhpcywgcHJvcHMpKTtcbiAgICB9XG5cbiAgICBGb3JtUm93VGl0bGUucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICAgICAgdmFyIF9jbGFzc25hbWVzO1xuXG4gICAgICAgIHZhciBtZSA9IHRoaXM7XG4gICAgICAgIHZhciBsZW5ndGggPSBSZWFjdC5DaGlsZHJlbi5jb3VudChtZS5wcm9wcy5jaGlsZHJlbik7XG4gICAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICAgJ2RpdicsXG4gICAgICAgICAgICB7IGNsYXNzTmFtZTogY2xhc3NuYW1lcygoX2NsYXNzbmFtZXMgPSB7fSwgX2NsYXNzbmFtZXNbbWUucHJvcHMuanN4cHJlZml4Q2xzXSA9IHRydWUsIF9jbGFzc25hbWVzW21lLnByb3BzLmNsYXNzTmFtZV0gPSAhIW1lLnByb3BzLmNsYXNzTmFtZSwgX2NsYXNzbmFtZXMpKSB9LFxuICAgICAgICAgICAgbWUucHJvcHMuanN4dGl0bGUsXG4gICAgICAgICAgICAhIWxlbmd0aCAmJiBSZWFjdC5DaGlsZHJlbi5tYXAobWUucHJvcHMuY2hpbGRyZW4sIGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICAgICAgICB9KVxuICAgICAgICApO1xuICAgIH07XG5cbiAgICByZXR1cm4gRm9ybVJvd1RpdGxlO1xufShSZWFjdC5Db21wb25lbnQpO1xuXG47XG5cbkZvcm1Sb3dUaXRsZS5wcm9wVHlwZXMgPSB7XG4gICAganN4cHJlZml4Q2xzOiBSZWFjdC5Qcm9wVHlwZXMuc3RyaW5nLFxuICAgIGpzeHRpdGxlOiBSZWFjdC5Qcm9wVHlwZXMuc3RyaW5nXG59O1xuXG5Gb3JtUm93VGl0bGUuZGVmYXVsdFByb3BzID0ge1xuICAgIGpzeHByZWZpeENsczogXCJrdW1hLXV4Zm9ybS1yb3ctdGl0bGVcIixcbiAgICBqc3h0aXRsZTogXCJcIlxufTtcblxuRm9ybVJvd1RpdGxlLmRpc3BsYXlOYW1lID0gXCJGb3JtUm93VGl0bGVcIjtcblxubW9kdWxlLmV4cG9ydHMgPSBGb3JtUm93VGl0bGU7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vdXhjb3JlLWZvcm0vYnVpbGQvRm9ybVJvd1RpdGxlLmpzXG4gKiogbW9kdWxlIGlkID0gMjcxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogRm9ybUZpZWxkIENvbXBvbmVudCBmb3IgdXhjb3JlXG4gKiBAYXV0aG9yIGV0ZXJuYWxza3lcbiAqXG4gKiBDb3B5cmlnaHQgMjAxNC0yMDE1LCBVeGNvcmUgVGVhbSwgQWxpbncuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9Gb3JtRmllbGQnKTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi91eGNvcmUtZm9ybS9+L3V4Y29yZS1mb3JtLWZpZWxkL2J1aWxkL2luZGV4LmpzXG4gKiogbW9kdWxlIGlkID0gMjc0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbnZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9O1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG52YXIgUmVhY3RET00gPSByZXF1aXJlKCdyZWFjdC1kb20nKTtcbnZhciBDb25zdGFudHMgPSByZXF1aXJlKFwidXhjb3JlLWNvbnN0XCIpO1xudmFyIGNsYXNzbmFtZXMgPSByZXF1aXJlKFwiY2xhc3NuYW1lc1wiKTtcbnZhciBhc3NpZ24gPSByZXF1aXJlKFwib2JqZWN0LWFzc2lnblwiKTtcbnZhciBkZWVwZXF1YWwgPSByZXF1aXJlKFwiZGVlcC1lcXVhbFwiKTtcblxudmFyIEZvcm1GaWVsZCA9IGZ1bmN0aW9uIChfUmVhY3QkQ29tcG9uZW50KSB7XG4gICAgX2luaGVyaXRzKEZvcm1GaWVsZCwgX1JlYWN0JENvbXBvbmVudCk7XG5cbiAgICBmdW5jdGlvbiBGb3JtRmllbGQocHJvcHMpIHtcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEZvcm1GaWVsZCk7XG5cbiAgICAgICAgdmFyIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX1JlYWN0JENvbXBvbmVudC5jYWxsKHRoaXMsIHByb3BzKSk7XG5cbiAgICAgICAgX3RoaXMuc3RhdGUgPSB7XG4gICAgICAgICAgICB2YWx1ZTogcHJvcHMudmFsdWUsXG4gICAgICAgICAgICBmb3JtYXRWYWx1ZTogX3RoaXMuZm9ybWF0VmFsdWUocHJvcHMudmFsdWUpLFxuICAgICAgICAgICAgZXJyb3I6IGZhbHNlLFxuICAgICAgICAgICAgZXJyTXNnOiAnJ1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuXG4gICAgRm9ybUZpZWxkLnByb3RvdHlwZS5jb21wb25lbnREaWRNb3VudCA9IGZ1bmN0aW9uIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgICAgICB2YXIgbWUgPSB0aGlzO1xuICAgICAgICBpZiAoIW1lLnByb3BzLnN0YW5kYWxvbmUpIHtcbiAgICAgICAgICAgIG1lLnByb3BzLmF0dGFjaEZvcm1GaWVsZChtZSk7XG4gICAgICAgICAgICBtZS5wcm9wcy5oYW5kbGVEYXRhQ2hhbmdlKG1lLCB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IG1lLnByb3BzLnZhbHVlLFxuICAgICAgICAgICAgICAgIHBhc3M6IHRydWVcbiAgICAgICAgICAgIH0sIHRydWUpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIEZvcm1GaWVsZC5wcm90b3R5cGUuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyA9IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMobmV4dFByb3BzKSB7XG4gICAgICAgIHZhciBtZSA9IHRoaXM7XG4gICAgICAgIGlmICghbWUuX2lzRXF1YWwobmV4dFByb3BzLnZhbHVlLCBtZS5wcm9wcy52YWx1ZSkpIHtcbiAgICAgICAgICAgIG1lLmhhbmRsZURhdGFDaGFuZ2UobmV4dFByb3BzLnZhbHVlLCB0cnVlKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBGb3JtRmllbGQucHJvdG90eXBlLl9pc0VxdWFsID0gZnVuY3Rpb24gX2lzRXF1YWwoYSwgYikge1xuICAgICAgICByZXR1cm4gZGVlcGVxdWFsKGEsIGIpO1xuICAgIH07XG5cbiAgICBGb3JtRmllbGQucHJvdG90eXBlLmNvbXBvbmVudFdpbGxVbm1vdW50ID0gZnVuY3Rpb24gY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgICAgIHZhciBtZSA9IHRoaXM7XG4gICAgICAgIGlmICghbWUucHJvcHMuc3RhbmRhbG9uZSkge1xuICAgICAgICAgICAgdGhpcy5wcm9wcy5kZXRhY2hGb3JtRmllbGQodGhpcyk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgRm9ybUZpZWxkLnByb3RvdHlwZS5nZXROYW1lID0gZnVuY3Rpb24gZ2V0TmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJvcHMuanN4bmFtZTtcbiAgICB9O1xuXG4gICAgLypcbiAgICAgKiBGaXJlZCB3aGVuIGZpZWxkIHZhbHVlIGNoYW5nZXPvvIx1cGRhdGUgZm9ybSdzIHN0YXRlIGFuZCB0aGVuIHRyaWdnZXIgcmUtcmVuZGVyLlxuICAgICAqIEBwYXJhbSBmcm9tUmVzZXQge2Jvb2xlYW59IGlmIGhhbmRsZURhdGFDaGFuZ2UgaXMgaW52b2tlZCBieSBmb3JtJ3MgcmVzZXRWYWx1ZXMsXG4gICAgICogZG9WYWxpZGF0ZSBzaG91bGQgbm90IGJlIGludm9rZWQuXG4gICAgICovXG5cbiAgICBGb3JtRmllbGQucHJvdG90eXBlLmhhbmRsZURhdGFDaGFuZ2UgPSBmdW5jdGlvbiBoYW5kbGVEYXRhQ2hhbmdlKHZhbHVlLCBmcm9tUmVzZXQpIHtcbiAgICAgICAgdmFyIG1lID0gdGhpcztcbiAgICAgICAgbWUuc2V0U3RhdGUoe1xuICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgZm9ybWF0VmFsdWU6IG1lLmZvcm1hdFZhbHVlKHZhbHVlKSxcbiAgICAgICAgICAgIGVycm9yOiAhIWZyb21SZXNldCA/IGZhbHNlIDogbWUuc3RhdGUuZXJyb3IsXG4gICAgICAgICAgICAvKlxuICAgICAgICAgICAgICogd2h5IHNldCBzdGF0ZSBmcm9tUmVzZXQ/IHNvbWUgZmllbGQgbGlrZSBlZGl0b3IgY2Fubm90IGJlIHJlc2V0IGluIHRoZSBjb21tb24gd2F5XG4gICAgICAgICAgICAgKiBzbyBzZXQgdGhpcyBzdGF0ZSB0byB0ZWxsIHRoZSBmaWVsZCB0aGF0IHlvdSBuZWVkIHRvIHJlc2V0IGJ5IHlvdXJzZWxmLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBmcm9tUmVzZXQ6ICEhZnJvbVJlc2V0XG4gICAgICAgIH0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBwYXNzID0gdHJ1ZTtcbiAgICAgICAgICAgIC8vIHZhbGlkYXRlT25CbHVyIG9ubHkgc3VwcG9ydCBJbnB1dEZvcm1GaWVsZCAmIFRleHRBcmFlRm9ybUZpZWxkIG5vd1xuICAgICAgICAgICAgaWYgKCFmcm9tUmVzZXQgJiYgIW1lLnByb3BzLnN0YW5kYWxvbmUgJiYgIW1lLnByb3BzLnZhbGlkYXRlT25CbHVyKSB7XG4gICAgICAgICAgICAgICAgcGFzcyA9IG1lLmRvVmFsaWRhdGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICEhbWUucHJvcHMuaGFuZGxlRGF0YUNoYW5nZSAmJiBtZS5wcm9wcy5oYW5kbGVEYXRhQ2hhbmdlKG1lLCB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgICAgIHBhc3M6IHBhc3NcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gaWYgdmFsaWRhdGUgcGFzcywgcmV0dXJuIHRydWUsIG9yLCByZXR1cm4gZmFsc2VcbiAgICAgKiBpZiBubyBydWxlLCBpdCBtZWFucyB2YWxpZGF0ZSBwYXNzLlxuICAgICAqL1xuXG4gICAgRm9ybUZpZWxkLnByb3RvdHlwZS5kb1ZhbGlkYXRlID0gZnVuY3Rpb24gZG9WYWxpZGF0ZShmb3JjZSkge1xuICAgICAgICB2YXIgbWUgPSB0aGlzO1xuICAgICAgICB2YXIgaW5zdGFudCA9IHRydWU7XG4gICAgICAgIGlmICgnaW5zdGFudFZhbGlkYXRlJyBpbiBtZS5wcm9wcykge1xuICAgICAgICAgICAgaW5zdGFudCA9IG1lLnByb3BzLmluc3RhbnRWYWxpZGF0ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGluc3RhbnQgPSBtZS5wcm9wcy5qc3hpbnN0YW50O1xuICAgICAgICB9XG4gICAgICAgIC8vIGBmb3JjZWAgaGFzIHRoZSB0b3AgcHJpb3JpdHksIGB1bmRlZmluZWRgIGlzIG5vdCBlcXVhbCB0byBgZmFsc2VgXG4gICAgICAgIC8vIGBpbnN0YW50YCBoYXMgdGhlIHNjZW9uZCBwcmlvcml0eSBoZXJlXG4gICAgICAgIC8vIGV0ZXJuYWxza3lAMjAxNi4wMy4xNVxuICAgICAgICBpZiAoZm9yY2UgPT09IHRydWUgfHwgZm9yY2UgIT09IGZhbHNlICYmIGluc3RhbnQpIHtcbiAgICAgICAgICAgIGlmIChtZS5wcm9wcy5qc3hydWxlcykge1xuICAgICAgICAgICAgICAgIHZhciBlcnJvciA9IG1lLmlzRGlydHkoKTtcbiAgICAgICAgICAgICAgICBtZS5zZXRTdGF0ZSh7IGVycm9yOiBlcnJvci5pc0RpcnR5LCBlcnJNc2c6IGVycm9yLmVyck1zZyB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gIWVycm9yLmlzRGlydHk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLypcbiAgICAgKiBydWxlIGNhbiBiZSBhbiBvYmplY3QsIGNvbnRhaW5pbmcgZXJyTXNnICYgdmFsaWRhdG9yLFxuICAgICAqIGFuZCBydWxlIGNhbiBhbHNvIGJlIGFuIGFycmF5IGNvbnRhaW5pbmcgc3VjaCBvYmplY3RzLlxuICAgICAqIHRoaXMgZnVuYyB3aWxsIGNoZWNrIHRoZW0gb25lIGJ5IG9uZSwgYW5kIHJldHVybiBmYWxzZVxuICAgICAqIHVubGVzcyBhbGwgcnVsZXMgcGFzc1xuICAgICAqL1xuXG4gICAgRm9ybUZpZWxkLnByb3RvdHlwZS5pc0RpcnR5ID0gZnVuY3Rpb24gaXNEaXJ0eSgpIHtcbiAgICAgICAgdmFyIG1lID0gdGhpcztcbiAgICAgICAgdmFyIHJ1bGVzID0gbWUucHJvcHMuanN4cnVsZXM7XG4gICAgICAgIHZhciBpc0RpcnR5ID0gZmFsc2U7XG4gICAgICAgIHZhciBlcnJNc2cgPSBcIlwiO1xuICAgICAgICBpZiAoKHR5cGVvZiBydWxlcyA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YocnVsZXMpKSA9PSBcIm9iamVjdFwiICYmICFBcnJheS5pc0FycmF5KHJ1bGVzKSkge1xuICAgICAgICAgICAgaXNEaXJ0eSA9ICFydWxlcy52YWxpZGF0b3IobWUuc3RhdGUudmFsdWUpO1xuICAgICAgICAgICAgZXJyTXNnID0gcnVsZXMuZXJyTXNnO1xuICAgICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkocnVsZXMpKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJ1bGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaXNEaXJ0eSA9ICFydWxlc1tpXS52YWxpZGF0b3IobWUuc3RhdGUudmFsdWUpO1xuICAgICAgICAgICAgICAgIGlmIChpc0RpcnR5KSB7XG4gICAgICAgICAgICAgICAgICAgIGVyck1zZyA9IHJ1bGVzW2ldLmVyck1zZztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpc0RpcnR5OiBpc0RpcnR5LFxuICAgICAgICAgICAgZXJyTXNnOiBlcnJNc2dcbiAgICAgICAgfTtcbiAgICB9O1xuXG4gICAgRm9ybUZpZWxkLnByb3RvdHlwZS5yZW5kZXJUaXBzID0gZnVuY3Rpb24gcmVuZGVyVGlwcygpIHtcbiAgICAgICAgdmFyIG1lID0gdGhpcztcbiAgICAgICAgdmFyIG1vZGUgPSBtZS5wcm9wcy5qc3htb2RlIHx8IG1lLnByb3BzLm1vZGU7XG4gICAgICAgIGlmIChtb2RlICE9IENvbnN0YW50cy5NT0RFLkVESVQpIHJldHVybjtcbiAgICAgICAgaWYgKG1lLnByb3BzLnN0YW5kYWxvbmUgJiYgbWUucHJvcHMubWVzc2FnZSAmJiBtZS5wcm9wcy5tZXNzYWdlLnR5cGUgPT0gXCJ0aXBcIikge1xuICAgICAgICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgICAgICAgJ2xpJyxcbiAgICAgICAgICAgICAgICB7IGNsYXNzTmFtZTogJ2t1bWEtdXhmb3JtLXRpcHMnIH0sXG4gICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudCgnaScsIHsgY2xhc3NOYW1lOiAna3VtYS1pY29uIGt1bWEtaWNvbi1pbmZvcm1hdGlvbicgfSksXG4gICAgICAgICAgICAgICAgbWUucHJvcHMubWVzc2FnZS5tZXNzYWdlXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGlmICghIXRoaXMucHJvcHMuanN4dGlwcyAmJiAhbWUuc3RhdGUuZXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICAgICAgICdsaScsXG4gICAgICAgICAgICAgICAgeyBjbGFzc05hbWU6ICdrdW1hLXV4Zm9ybS10aXBzJyB9LFxuICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoJ2knLCB7IGNsYXNzTmFtZTogJ2t1bWEtaWNvbiBrdW1hLWljb24taW5mb3JtYXRpb24nIH0pLFxuICAgICAgICAgICAgICAgIHRoaXMucHJvcHMuanN4dGlwc1xuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKlxuICAgICAqIFlvdSBzaG91bGQgcmV3cml0ZSB0aGlzIG1ldGhvZO+8jHdoZW4geW91IG5lZWQgdG8gZm9ybWF0IHRoZSB2YWx1ZSBhcyB5b3UgY29uY2Vybi5cbiAgICAgKi9cblxuICAgIEZvcm1GaWVsZC5wcm90b3R5cGUuZm9ybWF0VmFsdWUgPSBmdW5jdGlvbiBmb3JtYXRWYWx1ZSh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfTtcblxuICAgIC8qXG4gICAgICogWW91IHNob3VsZCByZXdyaXRlIHRoaXMgbWV0aG9kLCB3aGVuIHlvdSBhcmUgZGV2ZWxvcGluZyBhIG5ldyB0eXBlIG9mIGZvcm0gZmllbGQuXG4gICAgICovXG5cbiAgICBGb3JtRmllbGQucHJvdG90eXBlLnJlbmRlckZpZWxkID0gZnVuY3Rpb24gcmVuZGVyRmllbGQoKSB7fTtcblxuICAgIEZvcm1GaWVsZC5wcm90b3R5cGUucmVuZGVyRXJyb3JNc2cgPSBmdW5jdGlvbiByZW5kZXJFcnJvck1zZygpIHtcbiAgICAgICAgdmFyIG1lID0gdGhpcztcbiAgICAgICAgdmFyIG1vZGUgPSBtZS5wcm9wcy5qc3htb2RlIHx8IG1lLnByb3BzLm1vZGU7XG4gICAgICAgIGlmIChtb2RlICE9IENvbnN0YW50cy5NT0RFLkVESVQpIHJldHVybjtcbiAgICAgICAgaWYgKG1lLnByb3BzLnN0YW5kYWxvbmUgJiYgbWUucHJvcHMubWVzc2FnZSAmJiBtZS5wcm9wcy5tZXNzYWdlLnR5cGUgPT0gXCJlcnJvclwiKSB7XG4gICAgICAgICAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAgICAgICAnbGknLFxuICAgICAgICAgICAgICAgIHsgY2xhc3NOYW1lOiAna3VtYS11eGZvcm0tZXJyb3Jtc2cnIH0sXG4gICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudCgnaScsIHsgY2xhc3NOYW1lOiAna3VtYS1pY29uIGt1bWEtaWNvbi1lcnJvcicgfSksXG4gICAgICAgICAgICAgICAgbWUucHJvcHMubWVzc2FnZS5tZXNzYWdlXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGlmICghIW1lLnN0YXRlLmVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAgICAgICAnbGknLFxuICAgICAgICAgICAgICAgIHsgY2xhc3NOYW1lOiAna3VtYS11eGZvcm0tZXJyb3Jtc2cnIH0sXG4gICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudCgnaScsIHsgY2xhc3NOYW1lOiAna3VtYS1pY29uIGt1bWEtaWNvbi1lcnJvcicgfSksXG4gICAgICAgICAgICAgICAgbWUuc3RhdGUuZXJyTXNnXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIEZvcm1GaWVsZC5wcm90b3R5cGUucmVuZGVyTGFiZWwgPSBmdW5jdGlvbiByZW5kZXJMYWJlbCgpIHtcbiAgICAgICAgdmFyIG1lID0gdGhpcztcbiAgICAgICAgdmFyIG1vZGUgPSBtZS5wcm9wcy5qc3htb2RlIHx8IG1lLnByb3BzLm1vZGU7XG4gICAgICAgIHZhciBhbGlnbiA9IG1lLnByb3BzLnZlcnRpY2FsQWxpZ24gfHwgbWUucHJvcHMuanN4VmVydGljYWxBbGlnbjsgLy8ganN4VmVydGljYWxBbGlnbiBpcyBhbiBpbnRlcm5hbCB2YXJpYmxlLlxuICAgICAgICBpZiAobWUucHJvcHMuanN4c2hvd0xhYmVsKSB7XG4gICAgICAgICAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAgICAgICAnbGFiZWwnLFxuICAgICAgICAgICAgICAgIHsgY2xhc3NOYW1lOiBjbGFzc25hbWVzKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwia3VtYS1sYWJlbFwiOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJ2ZXJ0aWNhbC1hbGlnblwiOiBhbGlnblxuICAgICAgICAgICAgICAgICAgICB9KSB9LFxuICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgICAgICAgICAgICdzcGFuJyxcbiAgICAgICAgICAgICAgICAgICAgeyBjbGFzc05hbWU6ICdyZXF1aXJlZCcgfSxcbiAgICAgICAgICAgICAgICAgICAgbWUucHJvcHMucmVxdWlyZWQgJiYgbW9kZSA9PSBDb25zdGFudHMuTU9ERS5FRElUID8gXCIqIFwiIDogXCJcIlxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudCgnc3BhbicsIHsgY2xhc3NOYW1lOiAnbGFiZWwtY29udGVudCcsIGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MOiB7IF9faHRtbDogbWUucHJvcHMuanN4bGFiZWwgfSB9KVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBGb3JtRmllbGQucHJvdG90eXBlLmFkZFNwZWNpZmljQ2xhc3MgPSBmdW5jdGlvbiBhZGRTcGVjaWZpY0NsYXNzKGNsYXNzbmFtZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5wcm9wcy5qc3hwcmVmaXhDbHM7XG4gICAgfTtcblxuICAgIEZvcm1GaWVsZC5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgICAgICB2YXIgX2NsYXNzbmFtZXM7XG5cbiAgICAgICAgdmFyIG1lID0gdGhpcztcbiAgICAgICAgdmFyIHNwZWNpZmljQ2xzID0gbWUuYWRkU3BlY2lmaWNDbGFzcygpO1xuICAgICAgICB2YXIgbW9kZSA9IG1lLnByb3BzLmpzeG1vZGUgfHwgbWUucHJvcHMubW9kZTtcbiAgICAgICAgdmFyIHN0eWxlID0ge1xuICAgICAgICAgICAgd2lkdGg6IG1lLnByb3BzLmpzeGZsZXggLyBtZS5wcm9wcy50b3RhbEZsZXggKiAxMDAgKyAnJSdcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgICAnZGl2JyxcbiAgICAgICAgICAgIHsgY2xhc3NOYW1lOiBjbGFzc25hbWVzKChfY2xhc3NuYW1lcyA9IHt9LCBfY2xhc3NuYW1lc1tzcGVjaWZpY0Nsc10gPSB0cnVlLCBfY2xhc3NuYW1lc1ttZS5wcm9wcy5jbGFzc05hbWVdID0gISFtZS5wcm9wcy5jbGFzc05hbWUsIF9jbGFzc25hbWVzKSksIHN0eWxlOiBhc3NpZ24oe30sIHN0eWxlLCB7XG4gICAgICAgICAgICAgICAgICAgIGRpc3BsYXk6IG1lLnByb3BzLmpzeHNob3cgPyBcInRhYmxlXCIgOiBcIm5vbmVcIlxuICAgICAgICAgICAgICAgIH0pIH0sXG4gICAgICAgICAgICBtZS5yZW5kZXJMYWJlbCgpLFxuICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAgICAgICAndWwnLFxuICAgICAgICAgICAgICAgIHsgY2xhc3NOYW1lOiBjbGFzc25hbWVzKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwia3VtYS11eGZvcm0tZmllbGQtY29udGVudFwiOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJ2aWV3LW1vZGVcIjogbW9kZSA9PSBDb25zdGFudHMuTU9ERS5WSUVXLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJlZGl0LW1vZGVcIjogbW9kZSA9PSBDb25zdGFudHMuTU9ERS5FRElULFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJoYXMtZXJyb3JcIjogISFtZS5zdGF0ZS5lcnJvclxuICAgICAgICAgICAgICAgICAgICB9KSB9LFxuICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgICAgICAgICAgICdsaScsXG4gICAgICAgICAgICAgICAgICAgIHsgY2xhc3NOYW1lOiAna3VtYS11eGZvcm0tZmllbGQtY29yZScgfSxcbiAgICAgICAgICAgICAgICAgICAgbWUucmVuZGVyRmllbGQoKVxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgbWUucmVuZGVyVGlwcygpLFxuICAgICAgICAgICAgICAgIG1lLnJlbmRlckVycm9yTXNnKClcbiAgICAgICAgICAgIClcbiAgICAgICAgKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIEZvcm1GaWVsZDtcbn0oUmVhY3QuQ29tcG9uZW50KTtcblxuO1xuXG5Gb3JtRmllbGQucHJvcFR5cGVzID0ge1xuICAgIGluc3RhbnRWYWxpZGF0ZTogUmVhY3QuUHJvcFR5cGVzLmJvb2wsXG4gICAganN4c2hvdzogUmVhY3QuUHJvcFR5cGVzLmJvb2wsXG4gICAganN4bW9kZTogUmVhY3QuUHJvcFR5cGVzLnN0cmluZyxcbiAgICBqc3hzaG93TGFiZWw6IFJlYWN0LlByb3BUeXBlcy5ib29sLFxuICAgIGpzeHByZWZpeENsczogUmVhY3QuUHJvcFR5cGVzLnN0cmluZyxcbiAgICBqc3hmbGV4OiBSZWFjdC5Qcm9wVHlwZXMubnVtYmVyLFxuICAgIGpzeG5hbWU6IFJlYWN0LlByb3BUeXBlcy5zdHJpbmcuaXNSZXF1aXJlZCxcbiAgICBqc3hwbGFjZWhvbGRlcjogUmVhY3QuUHJvcFR5cGVzLnN0cmluZyxcbiAgICBqc3hsYWJlbDogUmVhY3QuUHJvcFR5cGVzLnN0cmluZyxcbiAgICBqc3h0aXBzOiBSZWFjdC5Qcm9wVHlwZXMuc3RyaW5nLFxuICAgIGpzeHJ1bGVzOiBSZWFjdC5Qcm9wVHlwZXMub25lT2ZUeXBlKFtSZWFjdC5Qcm9wVHlwZXMub2JqZWN0LCBSZWFjdC5Qcm9wVHlwZXMuYXJyYXldKSxcbiAgICB0b3RhbEZsZXg6IFJlYWN0LlByb3BUeXBlcy5udW1iZXIsXG4gICAgc3RhbmRhbG9uZTogUmVhY3QuUHJvcFR5cGVzLmJvb2wsXG4gICAgcmVxdWlyZWQ6IFJlYWN0LlByb3BUeXBlcy5ib29sXG59O1xuXG5Gb3JtRmllbGQuZGVmYXVsdFByb3BzID0ge1xuICAgIGpzeHNob3c6IHRydWUsXG4gICAganN4c2hvd0xhYmVsOiB0cnVlLFxuICAgIGpzeHByZWZpeENsczogXCJrdW1hLXV4Zm9ybS1maWVsZFwiLFxuICAgIGpzeGZsZXg6IDEsXG4gICAganN4bmFtZTogXCJcIixcbiAgICBqc3hwbGFjZWhvbGRlcjogXCJcIixcbiAgICBqc3hsYWJlbDogXCJcIixcbiAgICBqc3h0aXBzOiBcIlwiLFxuICAgIHN0YW5kYWxvbmU6IGZhbHNlLFxuICAgIG1vZGU6IENvbnN0YW50cy5NT0RFLkVESVQsXG4gICAgcmVxdWlyZWQ6IGZhbHNlXG59O1xuXG5Gb3JtRmllbGQuZGlzcGxheU5hbWUgPSBcIkZvcm1GaWVsZFwiO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEZvcm1GaWVsZDtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi91eGNvcmUtZm9ybS9+L3V4Y29yZS1mb3JtLWZpZWxkL2J1aWxkL0Zvcm1GaWVsZC5qc1xuICoqIG1vZHVsZSBpZCA9IDI3NVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMgKi9cbid1c2Ugc3RyaWN0JztcbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgcHJvcElzRW51bWVyYWJsZSA9IE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGU7XG5cbmZ1bmN0aW9uIHRvT2JqZWN0KHZhbCkge1xuXHRpZiAodmFsID09PSBudWxsIHx8IHZhbCA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignT2JqZWN0LmFzc2lnbiBjYW5ub3QgYmUgY2FsbGVkIHdpdGggbnVsbCBvciB1bmRlZmluZWQnKTtcblx0fVxuXG5cdHJldHVybiBPYmplY3QodmFsKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQsIHNvdXJjZSkge1xuXHR2YXIgZnJvbTtcblx0dmFyIHRvID0gdG9PYmplY3QodGFyZ2V0KTtcblx0dmFyIHN5bWJvbHM7XG5cblx0Zm9yICh2YXIgcyA9IDE7IHMgPCBhcmd1bWVudHMubGVuZ3RoOyBzKyspIHtcblx0XHRmcm9tID0gT2JqZWN0KGFyZ3VtZW50c1tzXSk7XG5cblx0XHRmb3IgKHZhciBrZXkgaW4gZnJvbSkge1xuXHRcdFx0aWYgKGhhc093blByb3BlcnR5LmNhbGwoZnJvbSwga2V5KSkge1xuXHRcdFx0XHR0b1trZXldID0gZnJvbVtrZXldO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG5cdFx0XHRzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhmcm9tKTtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgc3ltYm9scy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRpZiAocHJvcElzRW51bWVyYWJsZS5jYWxsKGZyb20sIHN5bWJvbHNbaV0pKSB7XG5cdFx0XHRcdFx0dG9bc3ltYm9sc1tpXV0gPSBmcm9tW3N5bWJvbHNbaV1dO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHRvO1xufTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3V4Y29yZS1mb3JtL34vdXhjb3JlLWZvcm0tZmllbGQvfi9vYmplY3QtYXNzaWduL2luZGV4LmpzXG4gKiogbW9kdWxlIGlkID0gMjc2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcInVzZSBzdHJpY3RcIjtcblxuLyoqXG4gKiBDcmVhdGVkIGJ5IHh5IG9uIDE1LzQvMTYuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwidXhjb3JlLXZhbGlkYXRvclwiKTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi91eGNvcmUtZm9ybS9idWlsZC9WYWxpZGF0b3JzLmpzXG4gKiogbW9kdWxlIGlkID0gMjgwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbnZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9O1xuXG4vKipcbiAqIENyZWF0ZWQgYnkgeHkgb24gMTUvNC8xNi5cbiAqL1xuXG52YXIgVmFsaWRhdG9yID0ge307XG5cbnZhciBQQVRURVJOID0ge1xuICAgIEVNQUlMOiAvXihbYS16MC05X1xcLi1dKylAKFtcXGRhLXpcXC4tXSspXFwuKFthLXpcXC5dezIsNn0pJC8sXG4gICAgVVJMOiAvXmh0dHBzPzpcXC9cXC8oPyFcXC0pKD86W2EtekEtWlxcZFxcLV17MCw2Mn1bYS16QS1aXFxkXVxcLil7MSwxMjZ9KD8hXFxkKylbYS16QS1aXFxkXXsxLDYzfS8sXG4gICAgSEVYOiAvXiM/KFthLWYwLTldezZ9fFthLWYwLTldezN9KSQvaSxcbiAgICBOVU06IC9eKCgtP1xcZCtcXC5cXGQrKXwoLT9cXGQrKXwoLT9cXC5cXGQrKSkkLyxcbiAgICBJRENBUkQ6IC8oXlxcZHsxNX0kKXwoXlxcZHsxN30oWzAtOV18WCkkKS9pLFxuICAgIENOTU9CSUxFOiAvXigwfDg2fDE3OTUxKT8oMTNbMC05XXwxNVswMTIzNTY3ODldfDE3WzA2NzhdfDE4WzAtOV18MTRbNTddKVswLTldezh9JC9cbn07XG5cblZhbGlkYXRvci5pc05vdEVtcHR5ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgLy8gZW1wdHkgbWVhbnMgZW1wdHkgc3RyaW5nLCBlbXB0eSBhcnJheSwgZW1wdHkgb2JqZWN0ICYgbnVsbCAmIHVuZGVmaW5lZFxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT0gXCJzdHJpbmdcIikge1xuICAgICAgICByZXR1cm4gdmFsdWUubGVuZ3RoICE9PSAwO1xuICAgIH0gZWxzZSBpZiAoKHR5cGVvZiB2YWx1ZSA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YodmFsdWUpKSA9PSAnb2JqZWN0Jykge1xuICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlLmxlbmd0aCAhPT0gMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAhIWk7XG4gICAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJykge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gISF2YWx1ZTtcbiAgICB9XG59O1xuXG5WYWxpZGF0b3IuaXNOdW0gPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICByZXR1cm4gUEFUVEVSTi5OVU0udGVzdCh2YWx1ZSk7XG59O1xuXG5WYWxpZGF0b3IuaXNJbnQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICByZXR1cm4gVmFsaWRhdG9yLmlzTnVtKHZhbHVlKSAmJiBwYXJzZUludCh2YWx1ZSkgPT0gdmFsdWU7XG59O1xuXG5WYWxpZGF0b3IuaXNEZWNpbWFsID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgcmV0dXJuIFZhbGlkYXRvci5pc051bSh2YWx1ZSkgJiYgIVZhbGlkYXRvci5pc0ludCh2YWx1ZSk7XG59O1xuXG5WYWxpZGF0b3IuaXNBcnJheSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KHZhbHVlKTtcbn07XG5cblZhbGlkYXRvci5pc1JlZ0V4cCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuICEhbmV3IFJlZ0V4cCh2YWx1ZSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufTtcblxuVmFsaWRhdG9yLmlzT2JqZWN0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgcmV0dXJuICh0eXBlb2YgdmFsdWUgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKHZhbHVlKSkgPT09ICdvYmplY3QnICYmICFWYWxpZGF0b3IuaXNBcnJheSh2YWx1ZSk7XG59O1xuXG5WYWxpZGF0b3IuaXNGdW5jID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJztcbn07XG5cblZhbGlkYXRvci5pc0VtYWlsID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgJiYgUEFUVEVSTi5FTUFJTC50ZXN0KHZhbHVlKTtcbn07XG5cblZhbGlkYXRvci5pc1VybCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnICYmIFBBVFRFUk4uVVJMLnRlc3QodmFsdWUpO1xufTtcblxuVmFsaWRhdG9yLmlzSGV4ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgJiYgUEFUVEVSTi5IRVgudGVzdCh2YWx1ZSk7XG59O1xuXG5WYWxpZGF0b3IuaXNJZENhcmQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyAmJiBQQVRURVJOLklEQ0FSRC50ZXN0KHZhbHVlKTtcbn07XG5cblZhbGlkYXRvci5pc0NOTW9iaWxlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgJiYgUEFUVEVSTi5DTk1PQklMRS50ZXN0KHZhbHVlKTtcbn07XG5tb2R1bGUuZXhwb3J0cyA9IFZhbGlkYXRvcjtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi91eGNvcmUtZm9ybS9+L3V4Y29yZS12YWxpZGF0b3IvYnVpbGQvVmFsaWRhdG9yLmpzXG4gKiogbW9kdWxlIGlkID0gMjgyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcInVzZSBzdHJpY3RcIjtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIC8qXG4gICAqIEVudGVyXG4gICAqL1xuICBFbnRlcjogMTNcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vdXhjb3JlLWZvcm0vYnVpbGQvS2V5Q29kZS5qc1xuICoqIG1vZHVsZSBpZCA9IDI4M1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIFRleHRhcmVhRm9ybUZpZWxkIENvbXBvbmVudCBmb3IgdXhjb3JlXG4gKiBAYXV0aG9yIGV0ZXJuYWxza3lcbiAqXG4gKiBDb3B5cmlnaHQgMjAxNC0yMDE1LCBVeGNvcmUgVGVhbSwgQWxpbncuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9UZXh0YXJlYUZvcm1GaWVsZCcpO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3V4Y29yZS1mb3JtL34vdXhjb3JlLXRleHRhcmVhLWZvcm0tZmllbGQvYnVpbGQvaW5kZXguanNcbiAqKiBtb2R1bGUgaWQgPSAyODZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG4vKipcbiAqIFRleHRhcmVhRm9ybUZpZWxkIENvbXBvbmVudCBmb3IgdXhjb3JlXG4gKiBAYXV0aG9yIGV0ZXJuYWxza3lcbiAqXG4gKiBDb3B5cmlnaHQgMjAxNS0yMDE2LCBVeGNvcmUgVGVhbSwgQWxpbncuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICovXG5cbnZhciBGb3JtRmllbGQgPSByZXF1aXJlKCd1eGNvcmUtZm9ybS1maWVsZCcpO1xudmFyIENvbnN0YW50cyA9IHJlcXVpcmUoXCJ1eGNvcmUtY29uc3RcIik7XG52YXIgYXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xudmFyIGF1dG9zaXplID0gcmVxdWlyZSgnYXV0b3NpemUnKTtcblxudmFyIFRleHRBcmVhRm9ybUZpZWxkID0gZnVuY3Rpb24gKF9Gb3JtRmllbGQpIHtcbiAgICBfaW5oZXJpdHMoVGV4dEFyZWFGb3JtRmllbGQsIF9Gb3JtRmllbGQpO1xuXG4gICAgZnVuY3Rpb24gVGV4dEFyZWFGb3JtRmllbGQocHJvcHMpIHtcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFRleHRBcmVhRm9ybUZpZWxkKTtcblxuICAgICAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX0Zvcm1GaWVsZC5jYWxsKHRoaXMsIHByb3BzKSk7XG4gICAgfVxuXG4gICAgVGV4dEFyZWFGb3JtRmllbGQucHJvdG90eXBlLmNvbXBvbmVudERpZE1vdW50ID0gZnVuY3Rpb24gY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgICAgIHZhciBtZSA9IHRoaXM7XG4gICAgICAgIGlmICghbWUucHJvcHMuc3RhbmRhbG9uZSkge1xuICAgICAgICAgICAgbWUucHJvcHMuYXR0YWNoRm9ybUZpZWxkKG1lKTtcbiAgICAgICAgICAgIG1lLnByb3BzLmhhbmRsZURhdGFDaGFuZ2UobWUsIHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogbWUucHJvcHMudmFsdWUsXG4gICAgICAgICAgICAgICAgcGFzczogdHJ1ZVxuICAgICAgICAgICAgfSwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgbWUucHJvcHMuYXV0b3NpemUgJiYgYXV0b3NpemUobWUucmVmcy5yb290KTtcbiAgICB9O1xuXG4gICAgVGV4dEFyZWFGb3JtRmllbGQucHJvdG90eXBlLmNvbXBvbmVudFdpbGxVbm1vdW50ID0gZnVuY3Rpb24gY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgICAgIHZhciBtZSA9IHRoaXM7XG4gICAgICAgIGlmICghbWUucHJvcHMuc3RhbmRhbG9uZSkge1xuICAgICAgICAgICAgdGhpcy5wcm9wcy5kZXRhY2hGb3JtRmllbGQodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgbWUucHJvcHMuYXV0b3NpemUgJiYgYXV0b3NpemUuZGVzdHJveShtZS5yZWZzLnJvb3QpO1xuICAgIH07XG5cbiAgICBUZXh0QXJlYUZvcm1GaWVsZC5wcm90b3R5cGUuY29tcG9uZW50RGlkVXBkYXRlID0gZnVuY3Rpb24gY29tcG9uZW50RGlkVXBkYXRlKHByZXZQcm9wcywgcHJldlN0YXRlKSB7XG4gICAgICAgIHZhciBtZSA9IHRoaXM7XG4gICAgICAgIHZhciBtb2RlID0gbWUucHJvcHMuanN4bW9kZSB8fCBtZS5wcm9wcy5tb2RlO1xuICAgICAgICB2YXIgcHJldk1vZGUgPSBwcmV2UHJvcHMuanN4bW9kZSB8fCBwcmV2UHJvcHMubW9kZTtcbiAgICAgICAgaWYgKHByZXZNb2RlID09IENvbnN0YW50cy5NT0RFLlZJRVcgJiYgbW9kZSA9PSBDb25zdGFudHMuTU9ERS5FRElUKSB7XG4gICAgICAgICAgICBhdXRvc2l6ZShtZS5yZWZzLnJvb3QpO1xuICAgICAgICB9IGVsc2UgaWYgKHByZXZNb2RlID09IENvbnN0YW50cy5NT0RFLkVESVQgJiYgbW9kZSA9PSBDb25zdGFudHMuTU9ERS5NT0RFKSB7XG4gICAgICAgICAgICBhdXRvc2l6ZS5kZXN0cm95KG1lLnJlZnMucm9vdCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgVGV4dEFyZWFGb3JtRmllbGQucHJvdG90eXBlLmhhbmRsZUNoYW5nZSA9IGZ1bmN0aW9uIGhhbmRsZUNoYW5nZShlKSB7XG4gICAgICAgIHZhciBtZSA9IHRoaXM7XG4gICAgICAgIHZhciBhdXRvVHJpbSA9IG1lLnByb3BzLmF1dG9UcmltO1xuXG4gICAgICAgIHZhciB2YWx1ZSA9IGUuY3VycmVudFRhcmdldC52YWx1ZTtcbiAgICAgICAgaWYgKGF1dG9UcmltKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IG1lLnRyaW0odmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIG1lLmhhbmRsZURhdGFDaGFuZ2UodmFsdWUpO1xuICAgIH07XG5cbiAgICBUZXh0QXJlYUZvcm1GaWVsZC5wcm90b3R5cGUudHJpbSA9IGZ1bmN0aW9uIHRyaW0oc3RyKSB7XG4gICAgICAgIHJldHVybiBzdHIucmVwbGFjZSgvKF5cXHMrfFxccyskKS9nLCBcIlwiKTtcbiAgICB9O1xuXG4gICAgVGV4dEFyZWFGb3JtRmllbGQucHJvdG90eXBlLmFkZFNwZWNpZmljQ2xhc3MgPSBmdW5jdGlvbiBhZGRTcGVjaWZpY0NsYXNzKCkge1xuICAgICAgICB2YXIgbWUgPSB0aGlzO1xuICAgICAgICBpZiAobWUucHJvcHMuanN4cHJlZml4Q2xzID09IFwia3VtYS11eGZvcm0tZmllbGRcIikge1xuICAgICAgICAgICAgcmV0dXJuIG1lLnByb3BzLmpzeHByZWZpeENscyArIFwiIGt1bWEtdGV4dGFyZWEtdXhmb3JtLWZpZWxkXCI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbWUucHJvcHMuanN4cHJlZml4Q2xzO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIFRleHRBcmVhRm9ybUZpZWxkLnByb3RvdHlwZS5oYW5kbGVGb2N1cyA9IGZ1bmN0aW9uIGhhbmRsZUZvY3VzKGUpIHtcbiAgICAgICAgdGhpcy5wcm9wcy5vbkZvY3VzKGUpO1xuICAgIH07XG5cbiAgICBUZXh0QXJlYUZvcm1GaWVsZC5wcm90b3R5cGUuaGFuZGxlQmx1ciA9IGZ1bmN0aW9uIGhhbmRsZUJsdXIoZSkge1xuICAgICAgICB2YXIgbWUgPSB0aGlzO1xuICAgICAgICB2YXIgcGFzcyA9IHRydWU7XG4gICAgICAgIGlmIChtZS5wcm9wcy52YWxpZGF0ZU9uQmx1cikge1xuICAgICAgICAgICAgcGFzcyA9IG1lLmRvVmFsaWRhdGUoKTtcbiAgICAgICAgfVxuICAgICAgICBtZS5wcm9wcy5vbkJsdXIoZSwgcGFzcyk7XG4gICAgfTtcblxuICAgIFRleHRBcmVhRm9ybUZpZWxkLnByb3RvdHlwZS5oYW5kbGVLZXlEb3duID0gZnVuY3Rpb24gaGFuZGxlS2V5RG93bihlKSB7XG4gICAgICAgIHZhciBtZSA9IHRoaXM7XG4gICAgICAgIG1lLnByb3BzLm9uS2V5RG93bihlKTtcbiAgICB9O1xuXG4gICAgVGV4dEFyZWFGb3JtRmllbGQucHJvdG90eXBlLnJlbmRlckZpZWxkID0gZnVuY3Rpb24gcmVuZGVyRmllbGQoKSB7XG4gICAgICAgIHZhciBtZSA9IHRoaXM7XG4gICAgICAgIHZhciBtb2RlID0gbWUucHJvcHMuanN4bW9kZSB8fCBtZS5wcm9wcy5tb2RlO1xuICAgICAgICBpZiAobW9kZSA9PSBDb25zdGFudHMuTU9ERS5FRElUKSB7XG4gICAgICAgICAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudCgndGV4dGFyZWEnLCB7XG4gICAgICAgICAgICAgICAgZGlzYWJsZWQ6IG1lLnByb3BzLmpzeGRpc2FibGVkLFxuICAgICAgICAgICAgICAgIHBsYWNlaG9sZGVyOiBtZS5wcm9wcy5qc3hwbGFjZWhvbGRlcixcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU6ICdrdW1hLXRleHRhcmVhJyxcbiAgICAgICAgICAgICAgICByZWY6ICdyb290JyxcbiAgICAgICAgICAgICAgICB2YWx1ZTogbWUuc3RhdGUudmFsdWUgfHwgXCJcIixcbiAgICAgICAgICAgICAgICBvbkNoYW5nZTogbWUuaGFuZGxlQ2hhbmdlLmJpbmQobWUpLFxuICAgICAgICAgICAgICAgIG9uRm9jdXM6IG1lLmhhbmRsZUZvY3VzLmJpbmQobWUpLFxuICAgICAgICAgICAgICAgIG9uQmx1cjogbWUuaGFuZGxlQmx1ci5iaW5kKG1lKSxcbiAgICAgICAgICAgICAgICBvbktleURvd246IG1lLmhhbmRsZUtleURvd24uYmluZChtZSkgfSk7XG4gICAgICAgIH0gZWxzZSBpZiAobW9kZSA9PSBDb25zdGFudHMuTU9ERS5WSUVXKSB7XG4gICAgICAgICAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAgICAgICAnc3BhbicsXG4gICAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgICBtZS5zdGF0ZS52YWx1ZVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICByZXR1cm4gVGV4dEFyZWFGb3JtRmllbGQ7XG59KEZvcm1GaWVsZCk7XG5cblRleHRBcmVhRm9ybUZpZWxkLmRpc3BsYXlOYW1lID0gXCJUZXh0QXJlYUZvcm1GaWVsZFwiO1xuXG5UZXh0QXJlYUZvcm1GaWVsZC5wcm9wVHlwZXMgPSBhc3NpZ24oe30sIEZvcm1GaWVsZC5wcm9wVHlwZXMsIHtcbiAgICBvbkJsdXI6IFJlYWN0LlByb3BUeXBlcy5mdW5jLFxuICAgIG9uRm9jdXM6IFJlYWN0LlByb3BUeXBlcy5mdW5jLFxuICAgIG9uS2V5RG93bjogUmVhY3QuUHJvcFR5cGVzLmZ1bmMsXG4gICAgdmFsaWRhdGVPbkJsdXI6IFJlYWN0LlByb3BUeXBlcy5ib29sLFxuICAgIGF1dG9UcmltOiBSZWFjdC5Qcm9wVHlwZXMuYm9vbCxcbiAgICBhdXRvc2l6ZTogUmVhY3QuUHJvcFR5cGVzLmJvb2xcbn0pO1xuXG5UZXh0QXJlYUZvcm1GaWVsZC5kZWZhdWx0UHJvcHMgPSBhc3NpZ24oe30sIEZvcm1GaWVsZC5kZWZhdWx0UHJvcHMsIHtcbiAgICBvbkJsdXI6IGZ1bmN0aW9uIG9uQmx1cigpIHt9LFxuICAgIG9uRm9jdXM6IGZ1bmN0aW9uIG9uRm9jdXMoKSB7fSxcbiAgICBvbktleURvd246IGZ1bmN0aW9uIG9uS2V5RG93bigpIHt9LFxuICAgIHZhbGlkYXRlT25CbHVyOiBmYWxzZSxcbiAgICBhdXRvc2l6ZTogdHJ1ZVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gVGV4dEFyZWFGb3JtRmllbGQ7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vdXhjb3JlLWZvcm0vfi91eGNvcmUtdGV4dGFyZWEtZm9ybS1maWVsZC9idWlsZC9UZXh0YXJlYUZvcm1GaWVsZC5qc1xuICoqIG1vZHVsZSBpZCA9IDI4N1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyohXG5cdEF1dG9zaXplIDMuMC4xNVxuXHRsaWNlbnNlOiBNSVRcblx0aHR0cDovL3d3dy5qYWNrbG1vb3JlLmNvbS9hdXRvc2l6ZVxuKi9cbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG5cdGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcblx0XHRkZWZpbmUoWydleHBvcnRzJywgJ21vZHVsZSddLCBmYWN0b3J5KTtcblx0fSBlbHNlIGlmICh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcpIHtcblx0XHRmYWN0b3J5KGV4cG9ydHMsIG1vZHVsZSk7XG5cdH0gZWxzZSB7XG5cdFx0dmFyIG1vZCA9IHtcblx0XHRcdGV4cG9ydHM6IHt9XG5cdFx0fTtcblx0XHRmYWN0b3J5KG1vZC5leHBvcnRzLCBtb2QpO1xuXHRcdGdsb2JhbC5hdXRvc2l6ZSA9IG1vZC5leHBvcnRzO1xuXHR9XG59KSh0aGlzLCBmdW5jdGlvbiAoZXhwb3J0cywgbW9kdWxlKSB7XG5cdCd1c2Ugc3RyaWN0JztcblxuXHR2YXIgc2V0ID0gdHlwZW9mIFNldCA9PT0gJ2Z1bmN0aW9uJyA/IG5ldyBTZXQoKSA6IChmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIGxpc3QgPSBbXTtcblxuXHRcdHJldHVybiB7XG5cdFx0XHRoYXM6IGZ1bmN0aW9uIGhhcyhrZXkpIHtcblx0XHRcdFx0cmV0dXJuIEJvb2xlYW4obGlzdC5pbmRleE9mKGtleSkgPiAtMSk7XG5cdFx0XHR9LFxuXHRcdFx0YWRkOiBmdW5jdGlvbiBhZGQoa2V5KSB7XG5cdFx0XHRcdGxpc3QucHVzaChrZXkpO1xuXHRcdFx0fSxcblx0XHRcdCdkZWxldGUnOiBmdW5jdGlvbiBfZGVsZXRlKGtleSkge1xuXHRcdFx0XHRsaXN0LnNwbGljZShsaXN0LmluZGV4T2Yoa2V5KSwgMSk7XG5cdFx0XHR9IH07XG5cdH0pKCk7XG5cblx0dmFyIGNyZWF0ZUV2ZW50ID0gZnVuY3Rpb24gY3JlYXRlRXZlbnQobmFtZSkge1xuXHRcdHJldHVybiBuZXcgRXZlbnQobmFtZSk7XG5cdH07XG5cdHRyeSB7XG5cdFx0bmV3IEV2ZW50KCd0ZXN0Jyk7XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHQvLyBJRSBkb2VzIG5vdCBzdXBwb3J0IGBuZXcgRXZlbnQoKWBcblx0XHRjcmVhdGVFdmVudCA9IGZ1bmN0aW9uIChuYW1lKSB7XG5cdFx0XHR2YXIgZXZ0ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0V2ZW50Jyk7XG5cdFx0XHRldnQuaW5pdEV2ZW50KG5hbWUsIHRydWUsIGZhbHNlKTtcblx0XHRcdHJldHVybiBldnQ7XG5cdFx0fTtcblx0fVxuXG5cdGZ1bmN0aW9uIGFzc2lnbih0YSkge1xuXHRcdHZhciBfcmVmID0gYXJndW1lbnRzWzFdID09PSB1bmRlZmluZWQgPyB7fSA6IGFyZ3VtZW50c1sxXTtcblxuXHRcdHZhciBfcmVmJHNldE92ZXJmbG93WCA9IF9yZWYuc2V0T3ZlcmZsb3dYO1xuXHRcdHZhciBzZXRPdmVyZmxvd1ggPSBfcmVmJHNldE92ZXJmbG93WCA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IF9yZWYkc2V0T3ZlcmZsb3dYO1xuXHRcdHZhciBfcmVmJHNldE92ZXJmbG93WSA9IF9yZWYuc2V0T3ZlcmZsb3dZO1xuXHRcdHZhciBzZXRPdmVyZmxvd1kgPSBfcmVmJHNldE92ZXJmbG93WSA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IF9yZWYkc2V0T3ZlcmZsb3dZO1xuXG5cdFx0aWYgKCF0YSB8fCAhdGEubm9kZU5hbWUgfHwgdGEubm9kZU5hbWUgIT09ICdURVhUQVJFQScgfHwgc2V0Lmhhcyh0YSkpIHJldHVybjtcblxuXHRcdHZhciBoZWlnaHRPZmZzZXQgPSBudWxsO1xuXHRcdHZhciBvdmVyZmxvd1kgPSBudWxsO1xuXHRcdHZhciBjbGllbnRXaWR0aCA9IHRhLmNsaWVudFdpZHRoO1xuXG5cdFx0ZnVuY3Rpb24gaW5pdCgpIHtcblx0XHRcdHZhciBzdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHRhLCBudWxsKTtcblxuXHRcdFx0b3ZlcmZsb3dZID0gc3R5bGUub3ZlcmZsb3dZO1xuXG5cdFx0XHRpZiAoc3R5bGUucmVzaXplID09PSAndmVydGljYWwnKSB7XG5cdFx0XHRcdHRhLnN0eWxlLnJlc2l6ZSA9ICdub25lJztcblx0XHRcdH0gZWxzZSBpZiAoc3R5bGUucmVzaXplID09PSAnYm90aCcpIHtcblx0XHRcdFx0dGEuc3R5bGUucmVzaXplID0gJ2hvcml6b250YWwnO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoc3R5bGUuYm94U2l6aW5nID09PSAnY29udGVudC1ib3gnKSB7XG5cdFx0XHRcdGhlaWdodE9mZnNldCA9IC0ocGFyc2VGbG9hdChzdHlsZS5wYWRkaW5nVG9wKSArIHBhcnNlRmxvYXQoc3R5bGUucGFkZGluZ0JvdHRvbSkpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aGVpZ2h0T2Zmc2V0ID0gcGFyc2VGbG9hdChzdHlsZS5ib3JkZXJUb3BXaWR0aCkgKyBwYXJzZUZsb2F0KHN0eWxlLmJvcmRlckJvdHRvbVdpZHRoKTtcblx0XHRcdH1cblx0XHRcdC8vIEZpeCB3aGVuIGEgdGV4dGFyZWEgaXMgbm90IG9uIGRvY3VtZW50IGJvZHkgYW5kIGhlaWdodE9mZnNldCBpcyBOb3QgYSBOdW1iZXJcblx0XHRcdGlmIChpc05hTihoZWlnaHRPZmZzZXQpKSB7XG5cdFx0XHRcdGhlaWdodE9mZnNldCA9IDA7XG5cdFx0XHR9XG5cblx0XHRcdHVwZGF0ZSgpO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGNoYW5nZU92ZXJmbG93KHZhbHVlKSB7XG5cdFx0XHR7XG5cdFx0XHRcdC8vIENocm9tZS9TYWZhcmktc3BlY2lmaWMgZml4OlxuXHRcdFx0XHQvLyBXaGVuIHRoZSB0ZXh0YXJlYSB5LW92ZXJmbG93IGlzIGhpZGRlbiwgQ2hyb21lL1NhZmFyaSBkbyBub3QgcmVmbG93IHRoZSB0ZXh0IHRvIGFjY291bnQgZm9yIHRoZSBzcGFjZVxuXHRcdFx0XHQvLyBtYWRlIGF2YWlsYWJsZSBieSByZW1vdmluZyB0aGUgc2Nyb2xsYmFyLiBUaGUgZm9sbG93aW5nIGZvcmNlcyB0aGUgbmVjZXNzYXJ5IHRleHQgcmVmbG93LlxuXHRcdFx0XHR2YXIgd2lkdGggPSB0YS5zdHlsZS53aWR0aDtcblx0XHRcdFx0dGEuc3R5bGUud2lkdGggPSAnMHB4Jztcblx0XHRcdFx0Ly8gRm9yY2UgcmVmbG93OlxuXHRcdFx0XHQvKiBqc2hpbnQgaWdub3JlOnN0YXJ0ICovXG5cdFx0XHRcdHRhLm9mZnNldFdpZHRoO1xuXHRcdFx0XHQvKiBqc2hpbnQgaWdub3JlOmVuZCAqL1xuXHRcdFx0XHR0YS5zdHlsZS53aWR0aCA9IHdpZHRoO1xuXHRcdFx0fVxuXG5cdFx0XHRvdmVyZmxvd1kgPSB2YWx1ZTtcblxuXHRcdFx0aWYgKHNldE92ZXJmbG93WSkge1xuXHRcdFx0XHR0YS5zdHlsZS5vdmVyZmxvd1kgPSB2YWx1ZTtcblx0XHRcdH1cblxuXHRcdFx0cmVzaXplKCk7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gcmVzaXplKCkge1xuXHRcdFx0dmFyIGh0bWxUb3AgPSB3aW5kb3cucGFnZVlPZmZzZXQ7XG5cdFx0XHR2YXIgYm9keVRvcCA9IGRvY3VtZW50LmJvZHkuc2Nyb2xsVG9wO1xuXHRcdFx0dmFyIG9yaWdpbmFsSGVpZ2h0ID0gdGEuc3R5bGUuaGVpZ2h0O1xuXG5cdFx0XHR0YS5zdHlsZS5oZWlnaHQgPSAnYXV0byc7XG5cblx0XHRcdHZhciBlbmRIZWlnaHQgPSB0YS5zY3JvbGxIZWlnaHQgKyBoZWlnaHRPZmZzZXQ7XG5cblx0XHRcdGlmICh0YS5zY3JvbGxIZWlnaHQgPT09IDApIHtcblx0XHRcdFx0Ly8gSWYgdGhlIHNjcm9sbEhlaWdodCBpcyAwLCB0aGVuIHRoZSBlbGVtZW50IHByb2JhYmx5IGhhcyBkaXNwbGF5Om5vbmUgb3IgaXMgZGV0YWNoZWQgZnJvbSB0aGUgRE9NLlxuXHRcdFx0XHR0YS5zdHlsZS5oZWlnaHQgPSBvcmlnaW5hbEhlaWdodDtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHR0YS5zdHlsZS5oZWlnaHQgPSBlbmRIZWlnaHQgKyAncHgnO1xuXG5cdFx0XHQvLyB1c2VkIHRvIGNoZWNrIGlmIGFuIHVwZGF0ZSBpcyBhY3R1YWxseSBuZWNlc3Nhcnkgb24gd2luZG93LnJlc2l6ZVxuXHRcdFx0Y2xpZW50V2lkdGggPSB0YS5jbGllbnRXaWR0aDtcblxuXHRcdFx0Ly8gcHJldmVudHMgc2Nyb2xsLXBvc2l0aW9uIGp1bXBpbmdcblx0XHRcdGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxUb3AgPSBodG1sVG9wO1xuXHRcdFx0ZG9jdW1lbnQuYm9keS5zY3JvbGxUb3AgPSBib2R5VG9wO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHVwZGF0ZSgpIHtcblx0XHRcdHZhciBzdGFydEhlaWdodCA9IHRhLnN0eWxlLmhlaWdodDtcblxuXHRcdFx0cmVzaXplKCk7XG5cblx0XHRcdHZhciBzdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHRhLCBudWxsKTtcblxuXHRcdFx0aWYgKHN0eWxlLmhlaWdodCAhPT0gdGEuc3R5bGUuaGVpZ2h0KSB7XG5cdFx0XHRcdGlmIChvdmVyZmxvd1kgIT09ICd2aXNpYmxlJykge1xuXHRcdFx0XHRcdGNoYW5nZU92ZXJmbG93KCd2aXNpYmxlJyk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGlmIChvdmVyZmxvd1kgIT09ICdoaWRkZW4nKSB7XG5cdFx0XHRcdFx0Y2hhbmdlT3ZlcmZsb3coJ2hpZGRlbicpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGlmIChzdGFydEhlaWdodCAhPT0gdGEuc3R5bGUuaGVpZ2h0KSB7XG5cdFx0XHRcdHZhciBldnQgPSBjcmVhdGVFdmVudCgnYXV0b3NpemU6cmVzaXplZCcpO1xuXHRcdFx0XHR0YS5kaXNwYXRjaEV2ZW50KGV2dCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dmFyIHBhZ2VSZXNpemUgPSBmdW5jdGlvbiBwYWdlUmVzaXplKCkge1xuXHRcdFx0aWYgKHRhLmNsaWVudFdpZHRoICE9PSBjbGllbnRXaWR0aCkge1xuXHRcdFx0XHR1cGRhdGUoKTtcblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0dmFyIGRlc3Ryb3kgPSAoZnVuY3Rpb24gKHN0eWxlKSB7XG5cdFx0XHR3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgcGFnZVJlc2l6ZSwgZmFsc2UpO1xuXHRcdFx0dGEucmVtb3ZlRXZlbnRMaXN0ZW5lcignaW5wdXQnLCB1cGRhdGUsIGZhbHNlKTtcblx0XHRcdHRhLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleXVwJywgdXBkYXRlLCBmYWxzZSk7XG5cdFx0XHR0YS5yZW1vdmVFdmVudExpc3RlbmVyKCdhdXRvc2l6ZTpkZXN0cm95JywgZGVzdHJveSwgZmFsc2UpO1xuXHRcdFx0dGEucmVtb3ZlRXZlbnRMaXN0ZW5lcignYXV0b3NpemU6dXBkYXRlJywgdXBkYXRlLCBmYWxzZSk7XG5cdFx0XHRzZXRbJ2RlbGV0ZSddKHRhKTtcblxuXHRcdFx0T2JqZWN0LmtleXMoc3R5bGUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuXHRcdFx0XHR0YS5zdHlsZVtrZXldID0gc3R5bGVba2V5XTtcblx0XHRcdH0pO1xuXHRcdH0pLmJpbmQodGEsIHtcblx0XHRcdGhlaWdodDogdGEuc3R5bGUuaGVpZ2h0LFxuXHRcdFx0cmVzaXplOiB0YS5zdHlsZS5yZXNpemUsXG5cdFx0XHRvdmVyZmxvd1k6IHRhLnN0eWxlLm92ZXJmbG93WSxcblx0XHRcdG92ZXJmbG93WDogdGEuc3R5bGUub3ZlcmZsb3dYLFxuXHRcdFx0d29yZFdyYXA6IHRhLnN0eWxlLndvcmRXcmFwIH0pO1xuXG5cdFx0dGEuYWRkRXZlbnRMaXN0ZW5lcignYXV0b3NpemU6ZGVzdHJveScsIGRlc3Ryb3ksIGZhbHNlKTtcblxuXHRcdC8vIElFOSBkb2VzIG5vdCBmaXJlIG9ucHJvcGVydHljaGFuZ2Ugb3Igb25pbnB1dCBmb3IgZGVsZXRpb25zLFxuXHRcdC8vIHNvIGJpbmRpbmcgdG8gb25rZXl1cCB0byBjYXRjaCBtb3N0IG9mIHRob3NlIGV2ZW50cy5cblx0XHQvLyBUaGVyZSBpcyBubyB3YXkgdGhhdCBJIGtub3cgb2YgdG8gZGV0ZWN0IHNvbWV0aGluZyBsaWtlICdjdXQnIGluIElFOS5cblx0XHRpZiAoJ29ucHJvcGVydHljaGFuZ2UnIGluIHRhICYmICdvbmlucHV0JyBpbiB0YSkge1xuXHRcdFx0dGEuYWRkRXZlbnRMaXN0ZW5lcigna2V5dXAnLCB1cGRhdGUsIGZhbHNlKTtcblx0XHR9XG5cblx0XHR3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgcGFnZVJlc2l6ZSwgZmFsc2UpO1xuXHRcdHRhLmFkZEV2ZW50TGlzdGVuZXIoJ2lucHV0JywgdXBkYXRlLCBmYWxzZSk7XG5cdFx0dGEuYWRkRXZlbnRMaXN0ZW5lcignYXV0b3NpemU6dXBkYXRlJywgdXBkYXRlLCBmYWxzZSk7XG5cdFx0c2V0LmFkZCh0YSk7XG5cblx0XHRpZiAoc2V0T3ZlcmZsb3dYKSB7XG5cdFx0XHR0YS5zdHlsZS5vdmVyZmxvd1ggPSAnaGlkZGVuJztcblx0XHRcdHRhLnN0eWxlLndvcmRXcmFwID0gJ2JyZWFrLXdvcmQnO1xuXHRcdH1cblxuXHRcdGluaXQoKTtcblx0fVxuXG5cdGZ1bmN0aW9uIGRlc3Ryb3kodGEpIHtcblx0XHRpZiAoISh0YSAmJiB0YS5ub2RlTmFtZSAmJiB0YS5ub2RlTmFtZSA9PT0gJ1RFWFRBUkVBJykpIHJldHVybjtcblx0XHR2YXIgZXZ0ID0gY3JlYXRlRXZlbnQoJ2F1dG9zaXplOmRlc3Ryb3knKTtcblx0XHR0YS5kaXNwYXRjaEV2ZW50KGV2dCk7XG5cdH1cblxuXHRmdW5jdGlvbiB1cGRhdGUodGEpIHtcblx0XHRpZiAoISh0YSAmJiB0YS5ub2RlTmFtZSAmJiB0YS5ub2RlTmFtZSA9PT0gJ1RFWFRBUkVBJykpIHJldHVybjtcblx0XHR2YXIgZXZ0ID0gY3JlYXRlRXZlbnQoJ2F1dG9zaXplOnVwZGF0ZScpO1xuXHRcdHRhLmRpc3BhdGNoRXZlbnQoZXZ0KTtcblx0fVxuXG5cdHZhciBhdXRvc2l6ZSA9IG51bGw7XG5cblx0Ly8gRG8gbm90aGluZyBpbiBOb2RlLmpzIGVudmlyb25tZW50IGFuZCBJRTggKG9yIGxvd2VyKVxuXHRpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcgfHwgdHlwZW9mIHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlICE9PSAnZnVuY3Rpb24nKSB7XG5cdFx0YXV0b3NpemUgPSBmdW5jdGlvbiAoZWwpIHtcblx0XHRcdHJldHVybiBlbDtcblx0XHR9O1xuXHRcdGF1dG9zaXplLmRlc3Ryb3kgPSBmdW5jdGlvbiAoZWwpIHtcblx0XHRcdHJldHVybiBlbDtcblx0XHR9O1xuXHRcdGF1dG9zaXplLnVwZGF0ZSA9IGZ1bmN0aW9uIChlbCkge1xuXHRcdFx0cmV0dXJuIGVsO1xuXHRcdH07XG5cdH0gZWxzZSB7XG5cdFx0YXV0b3NpemUgPSBmdW5jdGlvbiAoZWwsIG9wdGlvbnMpIHtcblx0XHRcdGlmIChlbCkge1xuXHRcdFx0XHRBcnJheS5wcm90b3R5cGUuZm9yRWFjaC5jYWxsKGVsLmxlbmd0aCA/IGVsIDogW2VsXSwgZnVuY3Rpb24gKHgpIHtcblx0XHRcdFx0XHRyZXR1cm4gYXNzaWduKHgsIG9wdGlvbnMpO1xuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBlbDtcblx0XHR9O1xuXHRcdGF1dG9zaXplLmRlc3Ryb3kgPSBmdW5jdGlvbiAoZWwpIHtcblx0XHRcdGlmIChlbCkge1xuXHRcdFx0XHRBcnJheS5wcm90b3R5cGUuZm9yRWFjaC5jYWxsKGVsLmxlbmd0aCA/IGVsIDogW2VsXSwgZGVzdHJveSk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZWw7XG5cdFx0fTtcblx0XHRhdXRvc2l6ZS51cGRhdGUgPSBmdW5jdGlvbiAoZWwpIHtcblx0XHRcdGlmIChlbCkge1xuXHRcdFx0XHRBcnJheS5wcm90b3R5cGUuZm9yRWFjaC5jYWxsKGVsLmxlbmd0aCA/IGVsIDogW2VsXSwgdXBkYXRlKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBlbDtcblx0XHR9O1xuXHR9XG5cblx0bW9kdWxlLmV4cG9ydHMgPSBhdXRvc2l6ZTtcbn0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3V4Y29yZS1mb3JtL34vdXhjb3JlLXRleHRhcmVhLWZvcm0tZmllbGQvfi9hdXRvc2l6ZS9kaXN0L2F1dG9zaXplLmpzXG4gKiogbW9kdWxlIGlkID0gMjg4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogSW5wdXRGb3JtRmllbGQgQ29tcG9uZW50IGZvciB1eGNvcmVcbiAqIEBhdXRob3IgZXRlcm5hbHNreVxuICpcbiAqIENvcHlyaWdodCAyMDE1LTIwMTYsIFV4Y29yZSBUZWFtLCBBbGludy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL0lucHV0Rm9ybUZpZWxkJyk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vdXhjb3JlLWZvcm0vfi91eGNvcmUtaW5wdXQtZm9ybS1maWVsZC9idWlsZC9pbmRleC5qc1xuICoqIG1vZHVsZSBpZCA9IDI4OVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbi8qKlxuICogSW5wdXRGb3JtRmllbGQgQ29tcG9uZW50IGZvciB1eGNvcmVcbiAqIEBhdXRob3IgZXRlcm5hbHNreVxuICpcbiAqIENvcHlyaWdodCAyMDE1LTIwMTYsIFV4Y29yZSBUZWFtLCBBbGludy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKi9cblxudmFyIFJlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcbnZhciBSZWFjdERPTSA9IHJlcXVpcmUoJ3JlYWN0LWRvbScpO1xudmFyIEZvcm1GaWVsZCA9IHJlcXVpcmUoJ3V4Y29yZS1mb3JtLWZpZWxkJyk7XG52YXIgQ29uc3RhbnRzID0gcmVxdWlyZShcInV4Y29yZS1jb25zdFwiKTtcbnZhciBjbGFzc25hbWVzID0gcmVxdWlyZSgnY2xhc3NuYW1lcycpO1xudmFyIGFzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcbnZhciB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG5cbnZhciBGb3JtQ291bnQgPSBmdW5jdGlvbiAoX1JlYWN0JENvbXBvbmVudCkge1xuICAgIF9pbmhlcml0cyhGb3JtQ291bnQsIF9SZWFjdCRDb21wb25lbnQpO1xuXG4gICAgZnVuY3Rpb24gRm9ybUNvdW50KHByb3BzKSB7XG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBGb3JtQ291bnQpO1xuXG4gICAgICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfUmVhY3QkQ29tcG9uZW50LmNhbGwodGhpcywgcHJvcHMpKTtcbiAgICB9XG5cbiAgICBGb3JtQ291bnQucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICAgICAgdmFyIG1lID0gdGhpcztcbiAgICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgICAnZGl2JyxcbiAgICAgICAgICAgIHsgY2xhc3NOYW1lOiAna3VtYS11eGZvcm0tY291bnQnIH0sXG4gICAgICAgICAgICBtZS5wcm9wcy5sZW5ndGggKyBcIi9cIiArIG1lLnByb3BzLnRvdGFsXG4gICAgICAgICk7XG4gICAgfTtcblxuICAgIHJldHVybiBGb3JtQ291bnQ7XG59KFJlYWN0LkNvbXBvbmVudCk7XG5cbkZvcm1Db3VudC5kZWZhdWx0UHJvcHMgPSB7fTtcbkZvcm1Db3VudC5wcm9wVHlwZXMgPSB7XG4gICAgbGVuZ3RoOiBSZWFjdC5Qcm9wVHlwZXMubnVtYmVyLFxuICAgIHRvdGFsOiBSZWFjdC5Qcm9wVHlwZXMubnVtYmVyXG59O1xuXG5Gb3JtQ291bnQuZGlzcGxheU5hbWUgPSBcIkZvcm1Db3VudFwiO1xuXG52YXIgTGVmdEFkZG9uID0gZnVuY3Rpb24gKF9SZWFjdCRDb21wb25lbnQyKSB7XG4gICAgX2luaGVyaXRzKExlZnRBZGRvbiwgX1JlYWN0JENvbXBvbmVudDIpO1xuXG4gICAgZnVuY3Rpb24gTGVmdEFkZG9uKHByb3BzKSB7XG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBMZWZ0QWRkb24pO1xuXG4gICAgICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfUmVhY3QkQ29tcG9uZW50Mi5jYWxsKHRoaXMsIHByb3BzKSk7XG4gICAgfVxuXG4gICAgTGVmdEFkZG9uLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgICAgIHZhciBtZSA9IHRoaXM7XG4gICAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICAgJ2RpdicsXG4gICAgICAgICAgICB7IGNsYXNzTmFtZTogY2xhc3NuYW1lcyh7XG4gICAgICAgICAgICAgICAgICAgIFwia3VtYS11eGZvcm0tbGVmdC1pY29uXCI6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIFwia3VtYS11eGZvcm0tbGVmdC1pY29uLWZvY3VzXCI6ICEhbWUucHJvcHMuZm9jdXNcbiAgICAgICAgICAgICAgICB9KSB9LFxuICAgICAgICAgICAgbWUucHJvcHMuY2hpbGRyZW5cbiAgICAgICAgKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIExlZnRBZGRvbjtcbn0oUmVhY3QuQ29tcG9uZW50KTtcblxuTGVmdEFkZG9uLmRlZmF1bHRQcm9wcyA9IHt9O1xuTGVmdEFkZG9uLnByb3BUeXBlcyA9IHt9O1xuTGVmdEFkZG9uLmRpc3BsYXlOYW1lID0gXCJMZWZ0QWRkb25cIjtcblxudmFyIFJpZ2h0QWRkb24gPSBmdW5jdGlvbiAoX1JlYWN0JENvbXBvbmVudDMpIHtcbiAgICBfaW5oZXJpdHMoUmlnaHRBZGRvbiwgX1JlYWN0JENvbXBvbmVudDMpO1xuXG4gICAgZnVuY3Rpb24gUmlnaHRBZGRvbihwcm9wcykge1xuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUmlnaHRBZGRvbik7XG5cbiAgICAgICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9SZWFjdCRDb21wb25lbnQzLmNhbGwodGhpcywgcHJvcHMpKTtcbiAgICB9XG5cbiAgICBSaWdodEFkZG9uLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgICAgIHZhciBtZSA9IHRoaXM7XG4gICAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICAgJ2RpdicsXG4gICAgICAgICAgICB7IGNsYXNzTmFtZTogJ2t1bWEtdXhmb3JtLXJpZ2h0LWljb24gJyB9LFxuICAgICAgICAgICAgbWUucHJvcHMuY2hpbGRyZW5cbiAgICAgICAgKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIFJpZ2h0QWRkb247XG59KFJlYWN0LkNvbXBvbmVudCk7XG5cblJpZ2h0QWRkb24uZGVmYXVsdFByb3BzID0ge307XG5SaWdodEFkZG9uLnByb3BUeXBlcyA9IHt9O1xuUmlnaHRBZGRvbi5kaXNwbGF5TmFtZSA9IFwiUmlnaHRBZGRvblwiO1xuXG4vKipcbiAqIGV4dGVuZCBGb3JtRmllbGQsIHJld3JpdGUgcmVuZGVyRmllbGQgbWV0aG9kXG4gKi9cblxudmFyIElucHV0Rm9ybUZpZWxkID0gZnVuY3Rpb24gKF9Gb3JtRmllbGQpIHtcbiAgICBfaW5oZXJpdHMoSW5wdXRGb3JtRmllbGQsIF9Gb3JtRmllbGQpO1xuXG4gICAgZnVuY3Rpb24gSW5wdXRGb3JtRmllbGQocHJvcHMpIHtcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIElucHV0Rm9ybUZpZWxkKTtcblxuICAgICAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX0Zvcm1GaWVsZC5jYWxsKHRoaXMsIHByb3BzKSk7XG4gICAgfVxuXG4gICAgSW5wdXRGb3JtRmllbGQucHJvdG90eXBlLmdldFZhbHVlID0gZnVuY3Rpb24gZ2V0VmFsdWUoKSB7XG4gICAgICAgIHJldHVybiBSZWFjdERPTS5maW5kRE9NTm9kZSh0aGlzLnJlZnMucm9vdCkudmFsdWUoKTtcbiAgICB9O1xuXG4gICAgSW5wdXRGb3JtRmllbGQucHJvdG90eXBlLmhhbmRsZUNoYW5nZSA9IGZ1bmN0aW9uIGhhbmRsZUNoYW5nZShlKSB7XG4gICAgICAgIHZhciBtZSA9IHRoaXM7XG4gICAgICAgIHZhciBhdXRvVHJpbSA9IG1lLnByb3BzLmF1dG9UcmltO1xuXG4gICAgICAgIHZhciB2YWx1ZSA9IGUuY3VycmVudFRhcmdldC52YWx1ZTtcbiAgICAgICAgaWYgKGF1dG9UcmltKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IG1lLnRyaW0odmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIG1lLmhhbmRsZURhdGFDaGFuZ2UobWUuZGVGb3JtYXRWYWx1ZSh2YWx1ZSkpO1xuICAgIH07XG5cbiAgICBJbnB1dEZvcm1GaWVsZC5wcm90b3R5cGUudHJpbSA9IGZ1bmN0aW9uIHRyaW0oc3RyKSB7XG4gICAgICAgIHJldHVybiBzdHIucmVwbGFjZSgvKF5cXHMrfFxccyskKS9nLCBcIlwiKTtcbiAgICB9O1xuXG4gICAgSW5wdXRGb3JtRmllbGQucHJvdG90eXBlLmhhbmRsZUZvY3VzID0gZnVuY3Rpb24gaGFuZGxlRm9jdXMoZSkge1xuICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgIGZvY3VzOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnByb3BzLm9uRm9jdXMoZSk7XG4gICAgfTtcblxuICAgIElucHV0Rm9ybUZpZWxkLnByb3RvdHlwZS5oYW5kbGVCbHVyID0gZnVuY3Rpb24gaGFuZGxlQmx1cihlKSB7XG4gICAgICAgIHZhciBtZSA9IHRoaXM7XG4gICAgICAgIG1lLnNldFN0YXRlKHtcbiAgICAgICAgICAgIGZvY3VzOiBmYWxzZVxuICAgICAgICB9KTtcbiAgICAgICAgdmFyIHBhc3MgPSB0cnVlO1xuICAgICAgICBpZiAobWUucHJvcHMudmFsaWRhdGVPbkJsdXIpIHtcbiAgICAgICAgICAgIHBhc3MgPSBtZS5kb1ZhbGlkYXRlKCk7XG4gICAgICAgIH1cbiAgICAgICAgbWUucHJvcHMub25CbHVyKGUsIHBhc3MpO1xuICAgIH07XG5cbiAgICBJbnB1dEZvcm1GaWVsZC5wcm90b3R5cGUuaGFuZGxlS2V5RG93biA9IGZ1bmN0aW9uIGhhbmRsZUtleURvd24oZSkge1xuICAgICAgICB2YXIgbWUgPSB0aGlzO1xuICAgICAgICBtZS5wcm9wcy5vbktleURvd24oZSk7XG4gICAgfTtcblxuICAgIElucHV0Rm9ybUZpZWxkLnByb3RvdHlwZS5kZUZvcm1hdFZhbHVlID0gZnVuY3Rpb24gZGVGb3JtYXRWYWx1ZSh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfTtcblxuICAgIElucHV0Rm9ybUZpZWxkLnByb3RvdHlwZS5hZGRTcGVjaWZpY0NsYXNzID0gZnVuY3Rpb24gYWRkU3BlY2lmaWNDbGFzcygpIHtcbiAgICAgICAgdmFyIG1lID0gdGhpcztcbiAgICAgICAgaWYgKG1lLnByb3BzLmpzeHByZWZpeENscyA9PSBcImt1bWEtdXhmb3JtLWZpZWxkXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBtZS5wcm9wcy5qc3hwcmVmaXhDbHMgKyBcIiBrdW1hLWlucHV0LXV4Zm9ybS1maWVsZFwiO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG1lLnByb3BzLmpzeHByZWZpeENscztcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBJbnB1dEZvcm1GaWVsZC5wcm90b3R5cGUuZ2V0Q291bnQgPSBmdW5jdGlvbiBnZXRDb3VudCgpIHtcbiAgICAgICAgdmFyIG1lID0gdGhpcztcbiAgICAgICAgdmFyIGNoaWxkcmVuID0gbWUucHJvcHMuY2hpbGRyZW47XG4gICAgICAgIHZhciBlbGVtZW50ID0gdm9pZCAwO1xuICAgICAgICBSZWFjdC5DaGlsZHJlbi5tYXAoY2hpbGRyZW4sIGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICAgICAgaWYgKGNoaWxkICYmIHR5cGVvZiBjaGlsZC50eXBlID09ICdmdW5jdGlvbicgJiYgY2hpbGQudHlwZS5kaXNwbGF5TmFtZSA9PSAnRm9ybUNvdW50Jykge1xuICAgICAgICAgICAgICAgIGVsZW1lbnQgPSBjaGlsZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGlmICghIWVsZW1lbnQpIHtcbiAgICAgICAgICAgIHZhciB0b3RhbCA9IGVsZW1lbnQucHJvcHMudG90YWw7XG4gICAgICAgICAgICB2YXIgQ291bnQgPSBSZWFjdC5jbG9uZUVsZW1lbnQoZWxlbWVudCwge1xuICAgICAgICAgICAgICAgIGxlbmd0aDogISFtZS5zdGF0ZS52YWx1ZSA/IG1lLnN0YXRlLnZhbHVlLmxlbmd0aCA6IDAsXG4gICAgICAgICAgICAgICAga2V5OiBcImNvdW50XCJcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGVsZW1lbnQ6IENvdW50LFxuICAgICAgICAgICAgICAgIHRvdGFsOiB0b3RhbFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBJbnB1dEZvcm1GaWVsZC5wcm90b3R5cGUucmVuZGVyTGVmdEFkZG9uID0gZnVuY3Rpb24gcmVuZGVyTGVmdEFkZG9uKCkge1xuICAgICAgICB2YXIgbWUgPSB0aGlzO1xuICAgICAgICB2YXIgY2hpbGRyZW4gPSBtZS5wcm9wcy5jaGlsZHJlbjtcbiAgICAgICAgdmFyIGVsZW1lbnQgPSB2b2lkIDA7XG4gICAgICAgIFJlYWN0LkNoaWxkcmVuLm1hcChjaGlsZHJlbiwgZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgICAgICBpZiAoY2hpbGQgJiYgdHlwZW9mIGNoaWxkLnR5cGUgPT0gJ2Z1bmN0aW9uJyAmJiBjaGlsZC50eXBlLmRpc3BsYXlOYW1lID09ICdMZWZ0QWRkb24nKSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudCA9IGNoaWxkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKCEhZWxlbWVudCkge1xuICAgICAgICAgICAgcmV0dXJuIFJlYWN0LmNsb25lRWxlbWVudChlbGVtZW50LCB7XG4gICAgICAgICAgICAgICAgZm9jdXM6ICEhbWUuc3RhdGUuZm9jdXMsXG4gICAgICAgICAgICAgICAga2V5OiBcImxlZnRcIlxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgSW5wdXRGb3JtRmllbGQucHJvdG90eXBlLnJlbmRlclJpZ2h0QWRkb24gPSBmdW5jdGlvbiByZW5kZXJSaWdodEFkZG9uKCkge1xuICAgICAgICB2YXIgbWUgPSB0aGlzO1xuICAgICAgICB2YXIgY2hpbGRyZW4gPSBtZS5wcm9wcy5jaGlsZHJlbjtcbiAgICAgICAgdmFyIGVsZW1lbnQgPSB2b2lkIDA7XG4gICAgICAgIFJlYWN0LkNoaWxkcmVuLm1hcChjaGlsZHJlbiwgZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgICAgICBpZiAoY2hpbGQgJiYgdHlwZW9mIGNoaWxkLnR5cGUgPT0gJ2Z1bmN0aW9uJyAmJiBjaGlsZC50eXBlLmRpc3BsYXlOYW1lID09ICdSaWdodEFkZG9uJykge1xuICAgICAgICAgICAgICAgIGVsZW1lbnQgPSBjaGlsZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKCEhZWxlbWVudCkge1xuICAgICAgICAgICAgcmV0dXJuIFJlYWN0LmNsb25lRWxlbWVudChlbGVtZW50LCB7XG4gICAgICAgICAgICAgICAga2V5OiBcInJpZ2h0XCJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIElucHV0Rm9ybUZpZWxkLnByb3RvdHlwZS5yZW5kZXJGaWVsZCA9IGZ1bmN0aW9uIHJlbmRlckZpZWxkKCkge1xuICAgICAgICB2YXIgbWUgPSB0aGlzO1xuICAgICAgICB2YXIgYXJyID0gW107XG4gICAgICAgIHZhciBtb2RlID0gbWUucHJvcHMuanN4bW9kZSB8fCBtZS5wcm9wcy5tb2RlO1xuICAgICAgICB2YXIgY291bnQgPSBtZS5nZXRDb3VudCgpO1xuICAgICAgICB2YXIgbGVmdEFkZG9uID0gbWUucmVuZGVyTGVmdEFkZG9uKCk7XG4gICAgICAgIHZhciByaWdodEFkZG9uID0gbWUucmVuZGVyUmlnaHRBZGRvbigpO1xuICAgICAgICB2YXIgY2hpbGRyZW4gPSBtZS5wcm9wcy5jaGlsZHJlbjtcbiAgICAgICAgaWYgKG1vZGUgPT0gQ29uc3RhbnRzLk1PREUuRURJVCkge1xuICAgICAgICAgICAgdmFyIG90aGVyT3B0aW9ucyA9IHt9O1xuICAgICAgICAgICAgLy8gaWYgKCEhY291bnQpIHtcbiAgICAgICAgICAgIC8vICAgICBvdGhlck9wdGlvbnMubWF4TGVuZ3RoID0gY291bnQudG90YWwgKyBcIlwiO1xuICAgICAgICAgICAgLy8gfVxuICAgICAgICAgICAgaWYgKCEhbGVmdEFkZG9uKSB7XG4gICAgICAgICAgICAgICAgYXJyLnB1c2gobGVmdEFkZG9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBJRXZlciA9IHV0aWwuZ2V0SUVWZXIoKTtcbiAgICAgICAgICAgIHZhciBwbGFjZWhvbGRlciA9IElFdmVyID49IDEwID8gXCJcIiA6IG1lLnByb3BzLmpzeHBsYWNlaG9sZGVyO1xuICAgICAgICAgICAgYXJyLnB1c2goUmVhY3QuY3JlYXRlRWxlbWVudCgnaW5wdXQnLCBfZXh0ZW5kcyh7XG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lOiBjbGFzc25hbWVzKHtcbiAgICAgICAgICAgICAgICAgICAgXCJrdW1hLWlucHV0XCI6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICdrdW1hLXV4Zm9ybS1pbnB1dC1oYXMtcmlnaHQnOiAhIWNvdW50IHx8ICEhcmlnaHRBZGRvbixcbiAgICAgICAgICAgICAgICAgICAgXCJrdW1hLXV4Zm9ybS1pbnB1dC1oYXMtbGVmdFwiOiAhIWxlZnRBZGRvblxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIHJlZjogJ3Jvb3QnLFxuICAgICAgICAgICAgICAgIGtleTogbWUucHJvcHMuaW5wdXRUeXBlLFxuICAgICAgICAgICAgICAgIHR5cGU6IG1lLnByb3BzLmlucHV0VHlwZSxcbiAgICAgICAgICAgICAgICBwbGFjZWhvbGRlcjogcGxhY2Vob2xkZXIsXG4gICAgICAgICAgICAgICAgZGlzYWJsZWQ6IG1lLnByb3BzLmpzeGRpc2FibGVkID09IFwiZGlzYWJsZWRcIiB8fCBtZS5wcm9wcy5qc3hkaXNhYmxlZCA9PSB0cnVlID8gXCJkaXNhYmxlZFwiIDogXCJcIixcbiAgICAgICAgICAgICAgICBuYW1lOiBtZS5wcm9wcy5rZXksXG4gICAgICAgICAgICAgICAgdmFsdWU6IG1lLnN0YXRlLmZvcm1hdFZhbHVlLFxuICAgICAgICAgICAgICAgIG9uRm9jdXM6IG1lLmhhbmRsZUZvY3VzLmJpbmQobWUpLFxuICAgICAgICAgICAgICAgIG9uQmx1cjogbWUuaGFuZGxlQmx1ci5iaW5kKG1lKSxcbiAgICAgICAgICAgICAgICBvbkNoYW5nZTogbWUuaGFuZGxlQ2hhbmdlLmJpbmQobWUpLFxuICAgICAgICAgICAgICAgIG9uS2V5RG93bjogbWUuaGFuZGxlS2V5RG93bi5iaW5kKG1lKVxuICAgICAgICAgICAgfSwgb3RoZXJPcHRpb25zKSkpO1xuXG4gICAgICAgICAgICBpZiAoISFyaWdodEFkZG9uKSB7XG4gICAgICAgICAgICAgICAgYXJyLnB1c2gocmlnaHRBZGRvbik7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCEhY291bnQpIHtcbiAgICAgICAgICAgICAgICBhcnIucHVzaChjb3VudC5lbGVtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChtb2RlID09IENvbnN0YW50cy5NT0RFLlZJRVcpIHtcbiAgICAgICAgICAgIGFyci5wdXNoKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgICAgICAgJ3NwYW4nLFxuICAgICAgICAgICAgICAgIHsga2V5OiAndGV4dCcgfSxcbiAgICAgICAgICAgICAgICBtZS5zdGF0ZS5mb3JtYXRWYWx1ZVxuICAgICAgICAgICAgKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFycjtcbiAgICB9O1xuXG4gICAgcmV0dXJuIElucHV0Rm9ybUZpZWxkO1xufShGb3JtRmllbGQpO1xuXG5JbnB1dEZvcm1GaWVsZC5Db3VudCA9IEZvcm1Db3VudDtcbklucHV0Rm9ybUZpZWxkLkxlZnRBZGRvbiA9IExlZnRBZGRvbjtcbklucHV0Rm9ybUZpZWxkLlJpZ2h0QWRkb24gPSBSaWdodEFkZG9uO1xuSW5wdXRGb3JtRmllbGQucHJvcFR5cGVzID0gYXNzaWduKHt9LCBGb3JtRmllbGQucHJvcFR5cGVzLCB7XG4gICAgb25CbHVyOiBSZWFjdC5Qcm9wVHlwZXMuZnVuYyxcbiAgICBvbkZvY3VzOiBSZWFjdC5Qcm9wVHlwZXMuZnVuYyxcbiAgICBvbktleURvd246IFJlYWN0LlByb3BUeXBlcy5mdW5jLFxuICAgIHZhbGlkYXRlT25CbHVyOiBSZWFjdC5Qcm9wVHlwZXMuYm9vbCxcbiAgICBhdXRvVHJpbTogUmVhY3QuUHJvcFR5cGVzLmJvb2wsXG4gICAgaW5wdXRUeXBlOiBSZWFjdC5Qcm9wVHlwZXMuc3RyaW5nXG59KTtcbklucHV0Rm9ybUZpZWxkLmRlZmF1bHRQcm9wcyA9IGFzc2lnbih7fSwgRm9ybUZpZWxkLmRlZmF1bHRQcm9wcywge1xuICAgIG9uQmx1cjogZnVuY3Rpb24gb25CbHVyKCkge30sXG4gICAgb25Gb2N1czogZnVuY3Rpb24gb25Gb2N1cygpIHt9LFxuICAgIG9uS2V5RG93bjogZnVuY3Rpb24gb25LZXlEb3duKCkge30sXG4gICAgdmFsaWRhdGVPbkJsdXI6IGZhbHNlLFxuICAgIGlucHV0VHlwZTogJ3RleHQnXG59KTtcbklucHV0Rm9ybUZpZWxkLmRpc3BsYXlOYW1lID0gXCJJbnB1dEZvcm1GaWVsZFwiO1xubW9kdWxlLmV4cG9ydHMgPSBJbnB1dEZvcm1GaWVsZDtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi91eGNvcmUtZm9ybS9+L3V4Y29yZS1pbnB1dC1mb3JtLWZpZWxkL2J1aWxkL0lucHV0Rm9ybUZpZWxkLmpzXG4gKiogbW9kdWxlIGlkID0gMjkwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcInVzZSBzdHJpY3RcIjtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgZ2V0SUVWZXI6IGZ1bmN0aW9uIGdldElFVmVyKCkge1xuICAgICAgICBpZiAod2luZG93KSB7XG4gICAgICAgICAgICB2YXIgdWEgPSB3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudDtcbiAgICAgICAgICAgIHZhciBpZHggPSB1YS5pbmRleE9mKCdNU0lFJyk7XG4gICAgICAgICAgICBpZiAoaWR4ID4gMCkge1xuICAgICAgICAgICAgICAgIC8vIFwiTW96aWxsYS81LjAgKGNvbXBhdGlibGU7IE1TSUUgMTAuMDsgV2luZG93cyBOVCA2LjE7IFdPVzY0OyBUcmlkZW50LzYuMDsgU0xDQzI7IC5ORVQgQ0xSIDIuMC41MDcyNylcIlxuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZUludCh1YS5zdWJzdHJpbmcoaWR4ICsgNSwgdWEuaW5kZXhPZihcIi5cIiwgaWR4KSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCEhdWEubWF0Y2goL1RyaWRlbnRcXC83XFwuLykpIHtcbiAgICAgICAgICAgICAgICAvLyBcIk1vemlsbGEvNS4wIChXaW5kb3dzIE5UIDYuMTsgV09XNjQ7IFRyaWRlbnQvNy4wOyBTTENDMjsgLk5FVCBDTFIgMi4wLjUwNzI3OyBydjoxMS4wKSBsaWtlIEdlY2tvXCJcbiAgICAgICAgICAgICAgICByZXR1cm4gMTE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3V4Y29yZS1mb3JtL34vdXhjb3JlLWlucHV0LWZvcm0tZmllbGQvYnVpbGQvdXRpbC5qc1xuICoqIG1vZHVsZSBpZCA9IDI5MVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbi8qKlxuICogQ3JlYXRlZCBieSB4eSBvbiAxNS80LzEzLlxuICovXG52YXIgRm9ybUZpZWxkID0gcmVxdWlyZSgndXhjb3JlLWZvcm0tZmllbGQnKTtcbnZhciBDb25zdGFudHMgPSByZXF1aXJlKFwidXhjb3JlLWNvbnN0XCIpO1xudmFyIFJhZGlvR3JvdXAgPSByZXF1aXJlKCd1eGNvcmUtcmFkaW9ncm91cCcpO1xudmFyIEl0ZW0gPSBSYWRpb0dyb3VwLkl0ZW07XG5cbnZhciBSYWRpb0dyb3VwRm9ybUZpZWxkID0gZnVuY3Rpb24gKF9Gb3JtRmllbGQpIHtcbiAgICBfaW5oZXJpdHMoUmFkaW9Hcm91cEZvcm1GaWVsZCwgX0Zvcm1GaWVsZCk7XG5cbiAgICBmdW5jdGlvbiBSYWRpb0dyb3VwRm9ybUZpZWxkKHByb3BzKSB7XG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBSYWRpb0dyb3VwRm9ybUZpZWxkKTtcblxuICAgICAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX0Zvcm1GaWVsZC5jYWxsKHRoaXMsIHByb3BzKSk7XG4gICAgfVxuXG4gICAgUmFkaW9Hcm91cEZvcm1GaWVsZC5wcm90b3R5cGUuaGFuZGxlQ2hhbmdlID0gZnVuY3Rpb24gaGFuZGxlQ2hhbmdlKHZhbHVlKSB7XG4gICAgICAgIHZhciBtZSA9IHRoaXM7XG4gICAgICAgIG1lLmhhbmRsZURhdGFDaGFuZ2UodmFsdWUpO1xuICAgIH07XG5cbiAgICBSYWRpb0dyb3VwRm9ybUZpZWxkLnByb3RvdHlwZS5hZGRTcGVjaWZpY0NsYXNzID0gZnVuY3Rpb24gYWRkU3BlY2lmaWNDbGFzcygpIHtcbiAgICAgICAgdmFyIG1lID0gdGhpcztcbiAgICAgICAgaWYgKG1lLnByb3BzLmpzeHByZWZpeENscyA9PSBcImt1bWEtdXhmb3JtLWZpZWxkXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBtZS5wcm9wcy5qc3hwcmVmaXhDbHMgKyBcIiBrdW1hLXJhZGlvLWdyb3VwLXV4Zm9ybS1maWVsZFwiO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG1lLnByb3BzLmpzeHByZWZpeENscztcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBSYWRpb0dyb3VwRm9ybUZpZWxkLnByb3RvdHlwZS5yZW5kZXJGaWVsZCA9IGZ1bmN0aW9uIHJlbmRlckZpZWxkKCkge1xuICAgICAgICB2YXIgbWUgPSB0aGlzO1xuICAgICAgICB2YXIgYXJyID0gW107XG4gICAgICAgIHZhciBtb2RlID0gbWUucHJvcHMuanN4bW9kZSB8fCBtZS5wcm9wcy5tb2RlO1xuICAgICAgICBpZiAobW9kZSA9PSBDb25zdGFudHMuTU9ERS5FRElUKSB7XG4gICAgICAgICAgICBhcnIucHVzaChSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICAgICAgIFJhZGlvR3JvdXAsXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICByZWY6ICdlbCcsXG4gICAgICAgICAgICAgICAgICAgIGtleTogJ3JhZGlvZ3JvdXAnLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogbWUuc3RhdGUudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIG9uQ2hhbmdlOiBtZS5oYW5kbGVDaGFuZ2UuYmluZChtZSkgfSxcbiAgICAgICAgICAgICAgICBtZS5wcm9wcy5jaGlsZHJlblxuICAgICAgICAgICAgKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgdGV4dCA9IG1lLnByb3BzLmNoaWxkcmVuLmZpbHRlcihmdW5jdGlvbiAoY2hpbGQsIGluZGV4KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNoaWxkLnByb3BzLnZhbHVlID09IG1lLnN0YXRlLnZhbHVlO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGlmICh0ZXh0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGFyci5wdXNoKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgICAgICAgICAgICdzcGFuJyxcbiAgICAgICAgICAgICAgICAgICAgeyBrZXk6ICdyYWRpb2dyb3VwJyB9LFxuICAgICAgICAgICAgICAgICAgICB0ZXh0WzBdLnByb3BzLnRleHRcbiAgICAgICAgICAgICAgICApKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXJyO1xuICAgIH07XG5cbiAgICByZXR1cm4gUmFkaW9Hcm91cEZvcm1GaWVsZDtcbn0oRm9ybUZpZWxkKTtcblxuUmFkaW9Hcm91cEZvcm1GaWVsZC5kaXNwbGF5TmFtZSA9IFwiUmFkaW9Hcm91cEZvcm1GaWVsZFwiO1xuUmFkaW9Hcm91cEZvcm1GaWVsZC5wcm9wVHlwZXMgPSBGb3JtRmllbGQucHJvcFR5cGVzO1xuUmFkaW9Hcm91cEZvcm1GaWVsZC5kZWZhdWx0UHJvcHMgPSBGb3JtRmllbGQuZGVmYXVsdFByb3BzO1xuUmFkaW9Hcm91cEZvcm1GaWVsZC5JdGVtID0gSXRlbTtcbm1vZHVsZS5leHBvcnRzID0gUmFkaW9Hcm91cEZvcm1GaWVsZDtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi91eGNvcmUtZm9ybS9idWlsZC9Gb3JtRmllbGQvUmFkaW9Hcm91cEZvcm1GaWVsZC5qc1xuICoqIG1vZHVsZSBpZCA9IDI5MlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIFNlbGVjdEZvcm1GaWVsZCBDb21wb25lbnQgZm9yIHV4Y29yZVxuICogQGF1dGhvciBldGVybmFsc2t5XG4gKlxuICogQ29weXJpZ2h0IDIwMTQtMjAxNSwgVXhjb3JlIFRlYW0sIEFsaW53LlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vU2VsZWN0Rm9ybUZpZWxkJyk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vdXhjb3JlLWZvcm0vfi91eGNvcmUtc2VsZWN0LWZvcm0tZmllbGQvYnVpbGQvaW5kZXguanNcbiAqKiBtb2R1bGUgaWQgPSAyOTZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxudmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxuLyoqXG4gKiBDcmVhdGVkIGJ5IHh5IG9uIDE1LzQvMTMuXG4gKi9cbnZhciBGb3JtRmllbGQgPSByZXF1aXJlKCd1eGNvcmUtZm9ybS1maWVsZCcpO1xudmFyIENvbnN0YW50cyA9IHJlcXVpcmUoXCJ1eGNvcmUtY29uc3RcIik7XG52YXIgU2VsZWN0ID0gcmVxdWlyZSgndXhjb3JlLXNlbGVjdDInKTtcbnZhciBhc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG52YXIgVmFsaWRhdG9yID0gcmVxdWlyZSgndXhjb3JlLXZhbGlkYXRvcicpO1xudmFyIGlzT2JqZWN0ID0gVmFsaWRhdG9yLmlzT2JqZWN0O1xudmFyIGlzQXJyYXkgPSBWYWxpZGF0b3IuaXNBcnJheTtcbnZhciBPcHRpb24gPSBTZWxlY3QuT3B0aW9uO1xuXG52YXIgc2VsZWN0T3B0aW9ucyA9IFsnb25TZWxlY3QnLCAnb25EZXNlbGVjdCcsICdnZXRQb3B1cENvbnRhaW5lcicsICdtdWx0aXBsZScsICdmaWx0ZXJPcHRpb24nLCAnYWxsb3dDbGVhcicsICdjb21ib2JveCcsICdzZWFyY2hQbGFjZWhvbGRlcicsICd0YWdzJywgJ2Rpc2FibGVkJywgJ3Nob3dTZWFyY2gnLCAncGxhY2Vob2xkZXInLCAnb3B0aW9uTGFiZWxQcm9wJywgJ21heFRhZ1RleHRMZW5ndGgnLCAnZHJvcGRvd25NYXRjaFNlbGVjdFdpZHRoJywgJ2Ryb3Bkb3duQ2xhc3NOYW1lJywgJ25vdEZvdW5kQ29udGVudCddO1xuXG52YXIgU2VsZWN0Rm9ybUZpZWxkID0gZnVuY3Rpb24gKF9Gb3JtRmllbGQpIHtcbiAgICBfaW5oZXJpdHMoU2VsZWN0Rm9ybUZpZWxkLCBfRm9ybUZpZWxkKTtcblxuICAgIGZ1bmN0aW9uIFNlbGVjdEZvcm1GaWVsZChwcm9wcykge1xuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgU2VsZWN0Rm9ybUZpZWxkKTtcblxuICAgICAgICB2YXIgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfRm9ybUZpZWxkLmNhbGwodGhpcywgcHJvcHMpKTtcblxuICAgICAgICB2YXIgbWUgPSBfdGhpcztcbiAgICAgICAgYXNzaWduKG1lLnN0YXRlLCB7XG4gICAgICAgICAgICBkYXRhOiBtZS5fcHJvY2Vzc0RhdGEocHJvcHMuanN4ZGF0YSlcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG5cbiAgICBTZWxlY3RGb3JtRmllbGQucHJvdG90eXBlLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgPSBmdW5jdGlvbiBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKG5leHRQcm9wcykge1xuICAgICAgICB2YXIgbWUgPSB0aGlzO1xuICAgICAgICBpZiAoIW1lLl9pc0VxdWFsKG5leHRQcm9wcy52YWx1ZSwgbWUucHJvcHMudmFsdWUpKSB7XG4gICAgICAgICAgICBtZS5oYW5kbGVEYXRhQ2hhbmdlKG1lLl9wcm9jZXNzVmFsdWUobmV4dFByb3BzLnZhbHVlKSwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFtZS5faXNFcXVhbChuZXh0UHJvcHMuanN4ZGF0YSwgbWUucHJvcHMuanN4ZGF0YSkpIHtcbiAgICAgICAgICAgIG1lLnNldFN0YXRlKHtcbiAgICAgICAgICAgICAgICBkYXRhOiBtZS5fcHJvY2Vzc0RhdGEobmV4dFByb3BzLmpzeGRhdGEpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBTZWxlY3RGb3JtRmllbGQucHJvdG90eXBlLmNvbXBvbmVudFdpbGxNb3VudCA9IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxNb3VudCgpIHtcbiAgICAgICAgdmFyIG1lID0gdGhpcztcbiAgICAgICAgaWYgKG1lLnByb3BzLmpzeGZldGNoVXJsKSB7XG4gICAgICAgICAgICBtZS5mZXRjaERhdGEoKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBTZWxlY3RGb3JtRmllbGQucHJvdG90eXBlLmNvbXBvbmVudERpZE1vdW50ID0gZnVuY3Rpb24gY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgICAgIHZhciBtZSA9IHRoaXM7XG4gICAgICAgIGlmICghbWUucHJvcHMuc3RhbmRhbG9uZSkge1xuICAgICAgICAgICAgbWUucHJvcHMuYXR0YWNoRm9ybUZpZWxkKG1lKTtcbiAgICAgICAgICAgIG1lLnByb3BzLmhhbmRsZURhdGFDaGFuZ2UobWUsIHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogbWUuX3Byb2Nlc3NWYWx1ZShtZS5wcm9wcy52YWx1ZSksXG4gICAgICAgICAgICAgICAgcGFzczogdHJ1ZVxuICAgICAgICAgICAgfSwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgbWUuaGFzRGVwcmVjYXRlZFByb3BzKCk7XG4gICAgfTtcblxuICAgIFNlbGVjdEZvcm1GaWVsZC5wcm90b3R5cGUuaGFuZGxlRGF0YUNoYW5nZSA9IGZ1bmN0aW9uIGhhbmRsZURhdGFDaGFuZ2UodmFsdWUsIGZyb21SZXNldCkge1xuICAgICAgICB2YXIgbWUgPSB0aGlzO1xuICAgICAgICBtZS5zZXRTdGF0ZSh7XG4gICAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgICBmb3JtYXRWYWx1ZTogbWUuZm9ybWF0VmFsdWUodmFsdWUpLFxuICAgICAgICAgICAgZXJyb3I6ICEhZnJvbVJlc2V0ID8gZmFsc2UgOiBtZS5zdGF0ZS5lcnJvcixcbiAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgKiB3aHkgc2V0IHN0YXRlIGZyb21SZXNldD8gc29tZSBmaWVsZCBsaWtlIGVkaXRvciBjYW5ub3QgYmUgcmVzZXQgaW4gdGhlIGNvbW1vbiB3YXlcbiAgICAgICAgICAgICAqIHNvIHNldCB0aGlzIHN0YXRlIHRvIHRlbGwgdGhlIGZpZWxkIHRoYXQgeW91IG5lZWQgdG8gcmVzZXQgYnkgeW91cnNlbGYuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGZyb21SZXNldDogZnJvbVJlc2V0XG4gICAgICAgIH0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBwYXNzID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmICghZnJvbVJlc2V0KSB7XG4gICAgICAgICAgICAgICAgcGFzcyA9IG1lLmRvVmFsaWRhdGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG1lLnByb3BzLmhhbmRsZURhdGFDaGFuZ2UobWUsIHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgICAgICAgcGFzczogcGFzc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICBTZWxlY3RGb3JtRmllbGQucHJvdG90eXBlLmZldGNoRGF0YSA9IGZ1bmN0aW9uIGZldGNoRGF0YSh2YWx1ZSkge1xuICAgICAgICB2YXIgbWUgPSB0aGlzO1xuICAgICAgICB2YXIgYWpheE9wdGlvbnMgPSB7XG4gICAgICAgICAgICB1cmw6IG1lLnByb3BzLmpzeGZldGNoVXJsLFxuICAgICAgICAgICAgZGF0YVR5cGU6IG1lLnByb3BzLmRhdGFUeXBlLFxuICAgICAgICAgICAgZGF0YTogbWUucHJvcHMuYmVmb3JlRmV0Y2goe1xuICAgICAgICAgICAgICAgIHE6IHZhbHVlXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIHN1Y2Nlc3M6IGZ1bmN0aW9uIHN1Y2Nlc3MoZGF0YSkge1xuICAgICAgICAgICAgICAgIHZhciBmZXRjaERhdGEgPSBtZS5fcHJvY2Vzc0RhdGEobWUucHJvcHMuYWZ0ZXJGZXRjaChkYXRhKSk7XG4gICAgICAgICAgICAgICAgaWYgKCEhbWUucHJvcHMuanN4ZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICBmZXRjaERhdGEgPSBtZS5fcHJvY2Vzc0RhdGEobWUucHJvcHMuanN4ZGF0YSkuY29uY2F0KGZldGNoRGF0YSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG1lLnNldFN0YXRlKHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogZmV0Y2hEYXRhXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZmFpbDogZnVuY3Rpb24gZmFpbCgpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIkZldGNoIERhdGEgZmFpbGVkXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBpZiAoL1xcLmpzb25wLy50ZXN0KG1lLnByb3BzLmpzeGZldGNoVXJsKSkge1xuICAgICAgICAgICAgYWpheE9wdGlvbnMuZGF0YVR5cGUgPSBcImpzb25wXCI7XG4gICAgICAgIH1cbiAgICAgICAgJC5hamF4KGFqYXhPcHRpb25zKTtcbiAgICB9O1xuXG4gICAgU2VsZWN0Rm9ybUZpZWxkLnByb3RvdHlwZS5oYW5kbGVDaGFuZ2UgPSBmdW5jdGlvbiBoYW5kbGVDaGFuZ2UodmFsdWUsIGxhYmVsKSB7XG4gICAgICAgIHZhciBtZSA9IHRoaXM7XG4gICAgICAgIG1lLmhhbmRsZURhdGFDaGFuZ2UodmFsdWUsIGZhbHNlLCBsYWJlbCk7XG4gICAgfTtcblxuICAgIFNlbGVjdEZvcm1GaWVsZC5wcm90b3R5cGUuaGFuZGxlU2VhcmNoID0gZnVuY3Rpb24gaGFuZGxlU2VhcmNoKHZhbHVlKSB7XG4gICAgICAgIHZhciBtZSA9IHRoaXM7XG4gICAgICAgIGlmIChtZS5wcm9wcy5qc3hmZXRjaFVybCkge1xuICAgICAgICAgICAgbWUuZmV0Y2hEYXRhKHZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1lLnByb3BzLm9uU2VhcmNoICYmIG1lLnByb3BzLm9uU2VhcmNoKHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICoganN4ZGF0YSBjYW4gYmUgb25lIG9mIHR3byB0eXBlczogaGFzaCBtYXAgb3IgYXJyYXlcbiAgICAgKiBoYXNoIG1hcCBpcyBsaWtlIHt2YWx1ZTogdGV4dH1cbiAgICAgKiBhcnJheSBpcyBsaWtlIFt7dmFsdWU6IHh4eCwgdGV4dDogeHh4fV1cbiAgICAgKi9cblxuICAgIFNlbGVjdEZvcm1GaWVsZC5wcm90b3R5cGUuX3Byb2Nlc3NEYXRhID0gZnVuY3Rpb24gX3Byb2Nlc3NEYXRhKGRhdGEpIHtcbiAgICAgICAgdmFyIHZhbHVlcyA9IFtdO1xuICAgICAgICBpZiAoKHR5cGVvZiBkYXRhID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihkYXRhKSkgPT0gJ29iamVjdCcgJiYgIShkYXRhIGluc3RhbmNlb2YgQXJyYXkpKSB7XG4gICAgICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGRhdGEpO1xuICAgICAgICAgICAgdmFsdWVzID0ga2V5cy5tYXAoZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBrZXksXG4gICAgICAgICAgICAgICAgICAgIHRleHQ6IGRhdGFba2V5XVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhbHVlcyA9IGRhdGE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlcztcbiAgICB9O1xuXG4gICAgU2VsZWN0Rm9ybUZpZWxkLnByb3RvdHlwZS5fdHJhbnNmZXJEYXRhVG9PYmogPSBmdW5jdGlvbiBfdHJhbnNmZXJEYXRhVG9PYmooZGF0YSkge1xuICAgICAgICB2YXIgb2JqID0ge307XG4gICAgICAgIGRhdGEuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSwgaW5kZXgpIHtcbiAgICAgICAgICAgIHZhciBrZXkgPSBpdGVtLnZhbHVlID09IFwiXCIgPyBcIl9fYWxsX19cIiA6IGl0ZW0udmFsdWU7XG4gICAgICAgICAgICBvYmpba2V5XSA9IGl0ZW0udGV4dDtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfTtcblxuICAgIFNlbGVjdEZvcm1GaWVsZC5wcm90b3R5cGUuX2dlbmVyYXRlT3B0aW9uc0Zyb21EYXRhID0gZnVuY3Rpb24gX2dlbmVyYXRlT3B0aW9uc0Zyb21EYXRhKCkge1xuICAgICAgICB2YXIgbWUgPSB0aGlzO1xuICAgICAgICB2YXIgdmFsdWVzID0gbWUuc3RhdGUuZGF0YTtcbiAgICAgICAgdmFyIGNoaWxkcmVuID0gbWUucHJvcHMuY2hpbGRyZW47XG4gICAgICAgIGlmICghdmFsdWVzLmxlbmd0aCkge1xuICAgICAgICAgICAgLy8gY29uc29sZS53YXJuKFwiWW91IG5lZWQgdG8gcGFzcyBkYXRhIHRvIGluaXRpYWxpemUgU2VsZWN0LlwiKTtcbiAgICAgICAgICAgIGlmICghIWNoaWxkcmVuKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNoaWxkcmVuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIGFyciA9IHZhbHVlcy5tYXAoZnVuY3Rpb24gKGl0ZW0sIGluZGV4KSB7XG4gICAgICAgICAgICAgICAgdmFyIF9tZSRwcm9wcyA9IG1lLnByb3BzO1xuICAgICAgICAgICAgICAgIHZhciBtdWx0aXBsZSA9IF9tZSRwcm9wcy5tdWx0aXBsZTtcbiAgICAgICAgICAgICAgICB2YXIganN4bXVsdGlwbGUgPSBfbWUkcHJvcHMuanN4bXVsdGlwbGU7XG4gICAgICAgICAgICAgICAgdmFyIGNvbWJvYm94ID0gX21lJHByb3BzLmNvbWJvYm94O1xuICAgICAgICAgICAgICAgIHZhciBqc3hjb21ib2JveCA9IF9tZSRwcm9wcy5qc3hjb21ib2JveDtcblxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgICAgICAgICAgIE9wdGlvbixcbiAgICAgICAgICAgICAgICAgICAgeyBrZXk6IGl0ZW0udmFsdWUsIHRpdGxlOiBpdGVtLnRleHQgfSxcbiAgICAgICAgICAgICAgICAgICAgaXRlbS50ZXh0XG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGFycjtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBTZWxlY3RGb3JtRmllbGQucHJvdG90eXBlLl9wcm9jZXNzVmFsdWUgPSBmdW5jdGlvbiBfcHJvY2Vzc1ZhbHVlKHZhbHVlKSB7XG4gICAgICAgIHZhciBtZSA9IHRoaXM7XG4gICAgICAgIHZhbHVlID0gdmFsdWUgfHwgbWUuc3RhdGUudmFsdWU7XG4gICAgICAgIGlmICghbWUucHJvcHMuanN4ZmV0Y2hVcmwgJiYgIW1lLnByb3BzLm9uU2VhcmNoKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGtleTogdmFsdWVcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSBpZiAodmFsdWUgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgaXRlbSA9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBrZXk6IGl0ZW1cbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBTZWxlY3RGb3JtRmllbGQucHJvdG90eXBlLmFkZFNwZWNpZmljQ2xhc3MgPSBmdW5jdGlvbiBhZGRTcGVjaWZpY0NsYXNzKCkge1xuICAgICAgICB2YXIgbWUgPSB0aGlzO1xuICAgICAgICBpZiAobWUucHJvcHMuanN4cHJlZml4Q2xzID09IFwia3VtYS11eGZvcm0tZmllbGRcIikge1xuICAgICAgICAgICAgcmV0dXJuIG1lLnByb3BzLmpzeHByZWZpeENscyArIFwiIGt1bWEtc2VsZWN0LXV4Zm9ybS1maWVsZFwiO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG1lLnByb3BzLmpzeHByZWZpeENscztcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBTZWxlY3RGb3JtRmllbGQucHJvdG90eXBlLmdldFZhbHVlUHJvcFZhbHVlID0gZnVuY3Rpb24gZ2V0VmFsdWVQcm9wVmFsdWUoY2hpbGQpIHtcbiAgICAgICAgdmFyIGtleSA9IFwiXCI7XG4gICAgICAgIGlmICgndmFsdWUnIGluIGNoaWxkLnByb3BzKSB7XG4gICAgICAgICAgICBrZXkgPSBjaGlsZC5wcm9wcy52YWx1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGtleSA9IGNoaWxkLmtleTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ga2V5O1xuICAgIH07XG5cbiAgICBTZWxlY3RGb3JtRmllbGQucHJvdG90eXBlLmhhc0RlcHJlY2F0ZWRQcm9wcyA9IGZ1bmN0aW9uIGhhc0RlcHJlY2F0ZWRQcm9wcygpIHtcbiAgICAgICAgdmFyIGFyciA9IFsnanN4bXVsdGlwbGUnLCAnanN4YWxsb3dDbGVhcicsICdqc3hjb21ib2JveCcsICdqc3hzZWFyY2hQbGFjZWhvbGRlcicsICdqc3h0YWdzJywgJ2pzeGRpc2FibGVkJywgJ2pzeHNob3dTZWFyY2gnLCAnanN4cGxhY2Vob2xkZXInXTtcbiAgICAgICAgdmFyIG1lID0gdGhpcztcbiAgICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhtZS5wcm9wcyk7XG4gICAgICAgIHZhciBoYXNEZXByZWNhdGVkID0ga2V5cy5zb21lKGZ1bmN0aW9uIChpdGVtLCBpbmRleCkge1xuICAgICAgICAgICAgcmV0dXJuIGFyci5pbmRleE9mKGl0ZW0pICE9IC0xO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGhhc0RlcHJlY2F0ZWQpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcIlNlbGVjdEZvcm1GaWVsZDogcHJvcHMgc2FtZSBhcyB1eGNvcmUtc2VsZWN0MiBjYW4gYmUgcGFzc2VkIHdpdGhvdXQgcHJlZml4ICdqc3gnIG5vdyAoZXhjbHVkZSBzdHlsZSkuIHdlIHdpbGwgcmVtb3ZlIHRoZSBzdXBwb3J0IG9mIHRoZSBwcm9wcyBtZW50aW9uZWQgYWJvdmUgd2l0aCBwcmVmaXggJ2pzeCcgYXQgdXhjb3JlLWZvcm1AMS4zLjAgLlwiKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBTZWxlY3RGb3JtRmllbGQucHJvdG90eXBlLnJlbmRlckZpZWxkID0gZnVuY3Rpb24gcmVuZGVyRmllbGQoKSB7XG4gICAgICAgIHZhciBtZSA9IHRoaXM7XG4gICAgICAgIHZhciBhcnIgPSBbXTtcbiAgICAgICAgdmFyIG1vZGUgPSBtZS5wcm9wcy5qc3htb2RlIHx8IG1lLnByb3BzLm1vZGU7XG5cbiAgICAgICAgaWYgKG1vZGUgPT0gQ29uc3RhbnRzLk1PREUuRURJVCkge1xuICAgICAgICAgICAgKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgICAgICAgICAgcmVmOiBcImVsXCIsXG4gICAgICAgICAgICAgICAgICAgIGtleTogXCJzZWxlY3RcIixcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9uTGFiZWxQcm9wOiBtZS5wcm9wcy5vcHRpb25MYWJlbFByb3AsXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlOiBtZS5wcm9wcy5qc3hzdHlsZSxcbiAgICAgICAgICAgICAgICAgICAgbXVsdGlwbGU6IG1lLnByb3BzLmpzeG11bHRpcGxlLFxuICAgICAgICAgICAgICAgICAgICBhbGxvd0NsZWFyOiBtZS5wcm9wcy5qc3hhbGxvd0NsZWFyLFxuICAgICAgICAgICAgICAgICAgICBjb21ib2JveDogbWUucHJvcHMuanN4Y29tYm9ib3gsXG4gICAgICAgICAgICAgICAgICAgIHNlYXJjaFBsYWNlaG9sZGVyOiBtZS5wcm9wcy5qc3hzZWFyY2hQbGFjZWhvbGRlcixcbiAgICAgICAgICAgICAgICAgICAgdGFnczogbWUucHJvcHMuanN4dGFncyxcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9uRmlsdGVyUHJvcDogbWUucHJvcHMub3B0aW9uRmlsdGVyUHJvcCxcbiAgICAgICAgICAgICAgICAgICAgZGlzYWJsZWQ6ICEhbWUucHJvcHMuanN4ZGlzYWJsZWQsXG4gICAgICAgICAgICAgICAgICAgIHNob3dTZWFyY2g6IG1lLnByb3BzLmpzeHNob3dTZWFyY2gsXG4gICAgICAgICAgICAgICAgICAgIHBsYWNlaG9sZGVyOiBtZS5wcm9wcy5qc3hwbGFjZWhvbGRlcixcbiAgICAgICAgICAgICAgICAgICAgb25DaGFuZ2U6IG1lLmhhbmRsZUNoYW5nZS5iaW5kKG1lKSxcbiAgICAgICAgICAgICAgICAgICAgb25TZWFyY2g6IG1lLmhhbmRsZVNlYXJjaC5iaW5kKG1lKVxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBzZWxlY3RPcHRpb25zLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0sIGluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpdGVtIGluIG1lLnByb3BzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zW2l0ZW1dID0gbWUucHJvcHNbaXRlbV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIC8vIG9ubHkganN4ZmV0Y2hVcmwgbW9kZSBuZWVkIHBhc3MgbGFiZWwsIGZvciB0aGUgb3B0aW9ucyBhbHdheXMgY2hhbmdlLlxuICAgICAgICAgICAgICAgIC8vIHdoZW4gbW91bnQsIHN0YXRlLmxhYmVsIGlzIHVuZGVmaW5lZCwgd2hpY2ggY2F1c2UgZGVmYWx1dFZhbHVlIGNhbm5vdCBiZSB1c2VkLlxuICAgICAgICAgICAgICAgIGlmICghIW1lLnByb3BzLmpzeGZldGNoVXJsIHx8ICEhbWUucHJvcHMub25TZWFyY2gpIHtcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5sYWJlbEluVmFsdWUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICghbWUucHJvcHMuY29tYm9ib3ggfHwgbWUuc3RhdGUuZnJvbVJlc2V0KSB7XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMudmFsdWUgPSBtZS5fcHJvY2Vzc1ZhbHVlKCkgfHwgW107XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKCEhbWUucHJvcHMuanN4ZmV0Y2hVcmwpIHtcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5maWx0ZXJPcHRpb24gPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYXJyLnB1c2goUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAgICAgICAgICAgU2VsZWN0LFxuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLFxuICAgICAgICAgICAgICAgICAgICBtZS5fZ2VuZXJhdGVPcHRpb25zRnJvbURhdGEoKVxuICAgICAgICAgICAgICAgICkpO1xuICAgICAgICAgICAgfSkoKTtcbiAgICAgICAgfSBlbHNlIGlmIChtb2RlID09IENvbnN0YW50cy5NT0RFLlZJRVcpIHtcbiAgICAgICAgICAgIHZhciBzdHIgPSAnJztcbiAgICAgICAgICAgIGlmIChtZS5zdGF0ZS52YWx1ZSkge1xuICAgICAgICAgICAgICAgIChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IG1lLl9wcm9jZXNzVmFsdWUoKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlcyA9ICFpc0FycmF5KHZhbHVlKSA/IFt2YWx1ZV0gOiB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgLy8gbGFiZWxJblZhbHVlIG1vZGVcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1lLnByb3BzLmpzeGZldGNoVXJsIHx8IG1lLnByb3BzLm9uU2VhcmNoIHx8IG1lLnByb3BzLmxhYmVsSW5WYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RyID0gdmFsdWVzLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpdGVtLmxhYmVsO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSkuam9pbihcIiBcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gPE9wdGlvbj4gbW9kZVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChtZS5wcm9wcy5jaGlsZHJlbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lLnByb3BzLmNoaWxkcmVuICYmIG1lLnByb3BzLmNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkLCBpbmRleCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWVQcm9wVmFsdWUgPSBtZS5nZXRWYWx1ZVByb3BWYWx1ZShjaGlsZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZXMuaW5kZXhPZih2YWx1ZVByb3BWYWx1ZSkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHIgKz0gY2hpbGQucHJvcHNbbWUucHJvcHMub3B0aW9uTGFiZWxQcm9wXSArIFwiIFwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBvbmx5IGpzeGRhdGFcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZXMuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUsIGluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHIgKz0gbWUuX3RyYW5zZmVyRGF0YVRvT2JqKG1lLnN0YXRlLmRhdGEpW3ZhbHVlID09IFwiXCIgPyBcIl9fYWxsX19cIiA6IHZhbHVlXSArIFwiIFwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSkoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFyci5wdXNoKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgICAgICAgJ3NwYW4nLFxuICAgICAgICAgICAgICAgIHsga2V5OiAnc2VsZWN0JyB9LFxuICAgICAgICAgICAgICAgIHN0clxuICAgICAgICAgICAgKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFycjtcbiAgICB9O1xuXG4gICAgcmV0dXJuIFNlbGVjdEZvcm1GaWVsZDtcbn0oRm9ybUZpZWxkKTtcblxuU2VsZWN0Rm9ybUZpZWxkLk9wdGlvbiA9IE9wdGlvbjtcblNlbGVjdEZvcm1GaWVsZC5kaXNwbGF5TmFtZSA9IFwiU2VsZWN0Rm9ybUZpZWxkXCI7XG5TZWxlY3RGb3JtRmllbGQucHJvcFR5cGVzID0gYXNzaWduKHt9LCBGb3JtRmllbGQucHJvcFR5cGVzLCB7XG4gICAganN4c3R5bGU6IFJlYWN0LlByb3BUeXBlcy5vYmplY3QsXG4gICAganN4cGxhY2Vob2xkZXI6IFJlYWN0LlByb3BUeXBlcy5zdHJpbmcsXG4gICAganN4Y29tYm9ib3g6IFJlYWN0LlByb3BUeXBlcy5ib29sLFxuICAgIGpzeGRhdGE6IFJlYWN0LlByb3BUeXBlcy5vbmVPZlR5cGUoW1JlYWN0LlByb3BUeXBlcy5vYmplY3QsIFJlYWN0LlByb3BUeXBlcy5hcnJheV0pLFxuICAgIGJlZm9yZUZldGNoOiBSZWFjdC5Qcm9wVHlwZXMuZnVuYyxcbiAgICBhZnRlckZldGNoOiBSZWFjdC5Qcm9wVHlwZXMuZnVuYyxcbiAgICBqc3hzaG93U2VhcmNoOiBSZWFjdC5Qcm9wVHlwZXMuYm9vbCxcbiAgICBqc3h0YWdzOiBSZWFjdC5Qcm9wVHlwZXMuYm9vbCxcbiAgICBqc3htdWx0aXBsZTogUmVhY3QuUHJvcFR5cGVzLmJvb2wsXG4gICAganN4YWxsb3dDbGVhcjogUmVhY3QuUHJvcFR5cGVzLmJvb2wsXG4gICAganN4c2VhcmNoUGxhY2Vob2xkZXI6IFJlYWN0LlByb3BUeXBlcy5zdHJpbmcsXG4gICAgb3B0aW9uRmlsdGVyUHJvcDogUmVhY3QuUHJvcFR5cGVzLnN0cmluZyxcbiAgICBkYXRhVHlwZTogUmVhY3QuUHJvcFR5cGVzLnN0cmluZ1xufSk7XG5cblNlbGVjdEZvcm1GaWVsZC5kZWZhdWx0UHJvcHMgPSBhc3NpZ24oe30sIEZvcm1GaWVsZC5kZWZhdWx0UHJvcHMsIHtcbiAgICBqc3hzdHlsZToge30sXG4gICAganN4cGxhY2Vob2xkZXI6IFwi6K+35LiL5ouJ6YCJ5oupXCIsXG4gICAganN4Y29tYm9ib3g6IGZhbHNlLFxuICAgIGpzeGRhdGE6IHt9LFxuICAgIGJlZm9yZUZldGNoOiBmdW5jdGlvbiBiZWZvcmVGZXRjaChvYmopIHtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuICAgIGFmdGVyRmV0Y2g6IGZ1bmN0aW9uIGFmdGVyRmV0Y2gob2JqKSB7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBqc3hzaG93U2VhcmNoOiB0cnVlLFxuICAgIGpzeGFsbG93Q2xlYXI6IGZhbHNlLFxuICAgIGpzeHRhZ3M6IGZhbHNlLFxuICAgIGpzeG11bHRpcGxlOiBmYWxzZSxcbiAgICBqc3hzZWFyY2hQbGFjZWhvbGRlcjogXCJcIixcbiAgICBvcHRpb25GaWx0ZXJQcm9wOiBcImNoaWxkcmVuXCIsXG4gICAgb3B0aW9uTGFiZWxQcm9wOiBcImNoaWxkcmVuXCIsXG4gICAgZGF0YVR5cGU6ICdqc29uJ1xufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gU2VsZWN0Rm9ybUZpZWxkO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3V4Y29yZS1mb3JtL34vdXhjb3JlLXNlbGVjdC1mb3JtLWZpZWxkL2J1aWxkL1NlbGVjdEZvcm1GaWVsZC5qc1xuICoqIG1vZHVsZSBpZCA9IDI5N1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblxuLyoqXG4gKiBDcmVhdGVkIGJ5IHh5IG9uIDE1LzQvMTYuXG4gKi9cblxudmFyIFZhbGlkYXRvciA9IHt9O1xuXG52YXIgUEFUVEVSTiA9IHtcbiAgICBFTUFJTDogL14oW2EtejAtOV9cXC4tXSspQChbXFxkYS16XFwuLV0rKVxcLihbYS16XFwuXXsyLDZ9KSQvLFxuICAgIFVSTDogL14oaHR0cHM/OlxcL1xcLyk/KFtcXGRhLXpcXC4tXSspXFwuKFthLXpcXC5dezIsNn0pKFtcXC9cXHcgXFwuLV0qKSpcXC8/JC8sXG4gICAgSEVYOiAvXiM/KFthLWYwLTldezZ9fFthLWYwLTldezN9KSQvaSxcbiAgICBOVU06IC9eKCgtP1xcZCtcXC5cXGQrKXwoLT9cXGQrKXwoLT9cXC5cXGQrKSkkLyxcbiAgICBJRENBUkQ6IC8oXlxcZHsxNX0kKXwoXlxcZHsxN30oWzAtOV18WCkkKS9pLFxuICAgIENOTU9CSUxFOiAvXigwfDg2fDE3OTUxKT8oMTNbMC05XXwxNVswMTIzNTY3ODldfDE3WzA2NzhdfDE4WzAtOV18MTRbNTddKVswLTldezh9JC9cbn07XG5cblZhbGlkYXRvci5pc05vdEVtcHR5ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgLy8gZW1wdHkgbWVhbnMgZW1wdHkgc3RyaW5nLCBlbXB0eSBhcnJheSwgZW1wdHkgb2JqZWN0ICYgbnVsbCAmIHVuZGVmaW5lZFxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT0gXCJzdHJpbmdcIikge1xuICAgICAgICByZXR1cm4gdmFsdWUubGVuZ3RoICE9PSAwO1xuICAgIH0gZWxzZSBpZiAoKHR5cGVvZiB2YWx1ZSA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YodmFsdWUpKSA9PSAnb2JqZWN0Jykge1xuICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlLmxlbmd0aCAhPT0gMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAhIWk7XG4gICAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJykge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gISF2YWx1ZTtcbiAgICB9XG59O1xuXG5WYWxpZGF0b3IuaXNOdW0gPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICByZXR1cm4gUEFUVEVSTi5OVU0udGVzdCh2YWx1ZSk7XG59O1xuXG5WYWxpZGF0b3IuaXNJbnQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICByZXR1cm4gVmFsaWRhdG9yLmlzTnVtKHZhbHVlKSAmJiBwYXJzZUludCh2YWx1ZSkgPT0gdmFsdWU7XG59O1xuXG5WYWxpZGF0b3IuaXNEZWNpbWFsID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgcmV0dXJuIFZhbGlkYXRvci5pc051bSh2YWx1ZSkgJiYgIVZhbGlkYXRvci5pc0ludCh2YWx1ZSk7XG59O1xuXG5WYWxpZGF0b3IuaXNBcnJheSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KHZhbHVlKTtcbn07XG5cblZhbGlkYXRvci5pc1JlZ0V4cCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuICEhbmV3IFJlZ0V4cCh2YWx1ZSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufTtcblxuVmFsaWRhdG9yLmlzT2JqZWN0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgcmV0dXJuICh0eXBlb2YgdmFsdWUgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKHZhbHVlKSkgPT09ICdvYmplY3QnICYmICFWYWxpZGF0b3IuaXNBcnJheSh2YWx1ZSk7XG59O1xuXG5WYWxpZGF0b3IuaXNGdW5jID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJztcbn07XG5cblZhbGlkYXRvci5pc0VtYWlsID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgJiYgUEFUVEVSTi5FTUFJTC50ZXN0KHZhbHVlKTtcbn07XG5cblZhbGlkYXRvci5pc1VybCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnICYmIFBBVFRFUk4uVVJMLnRlc3QodmFsdWUpO1xufTtcblxuVmFsaWRhdG9yLmlzSGV4ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgJiYgUEFUVEVSTi5IRVgudGVzdCh2YWx1ZSk7XG59O1xuXG5WYWxpZGF0b3IuaXNJZENhcmQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyAmJiBQQVRURVJOLklEQ0FSRC50ZXN0KHZhbHVlKTtcbn07XG5cblZhbGlkYXRvci5pc0NOTW9iaWxlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgJiYgUEFUVEVSTi5DTk1PQklMRS50ZXN0KHZhbHVlKTtcbn07XG5tb2R1bGUuZXhwb3J0cyA9IFZhbGlkYXRvcjtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi91eGNvcmUtZm9ybS9+L3V4Y29yZS1zZWxlY3QtZm9ybS1maWVsZC9+L3V4Y29yZS12YWxpZGF0b3IvYnVpbGQvVmFsaWRhdG9yLmpzXG4gKiogbW9kdWxlIGlkID0gMzY5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIElucHV0Rm9ybUZpZWxkID0gcmVxdWlyZSgnLi9JbnB1dEZvcm1GaWVsZCcpO1xudmFyIEZvcm1hdHRlciA9IHJlcXVpcmUoXCJ1eGNvcmUtZm9ybWF0dGVyXCIpO1xudmFyIGFzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcblxudmFyIE51bWJlcklucHV0Rm9ybUZpZWxkID0gZnVuY3Rpb24gKF9JbnB1dEZvcm1GaWVsZCkge1xuICAgIF9pbmhlcml0cyhOdW1iZXJJbnB1dEZvcm1GaWVsZCwgX0lucHV0Rm9ybUZpZWxkKTtcblxuICAgIGZ1bmN0aW9uIE51bWJlcklucHV0Rm9ybUZpZWxkKHByb3BzKSB7XG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBOdW1iZXJJbnB1dEZvcm1GaWVsZCk7XG5cbiAgICAgICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9JbnB1dEZvcm1GaWVsZC5jYWxsKHRoaXMsIHByb3BzKSk7XG4gICAgfVxuXG4gICAgTnVtYmVySW5wdXRGb3JtRmllbGQucHJvdG90eXBlLmZvcm1hdFZhbHVlID0gZnVuY3Rpb24gZm9ybWF0VmFsdWUodmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQgfHwgdmFsdWUgPT09IG51bGwpIHJldHVybiBcIlwiO1xuICAgICAgICB2YXIgbWUgPSB0aGlzO1xuICAgICAgICB2YWx1ZSA9IHZhbHVlICsgXCJcIjtcbiAgICAgICAgaWYgKG1lLnByb3BzLmpzeHR5cGUgPT0gXCJtb25leVwiKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUubWF0Y2goL1xcLihcXGQrKS8pICYmIHZhbHVlLm1hdGNoKC9cXC4oXFxkKykvKVsxXS5sZW5ndGggPiBtZS5wcm9wcy5maXhlZE51bSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBGb3JtYXR0ZXIubW9uZXkodmFsdWUsIG1lLnByb3BzLmRlbGltaXRlciwgbWUucHJvcHMuZml4ZWROdW0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gRm9ybWF0dGVyLm1vbmV5KHZhbHVlLCBtZS5wcm9wcy5kZWxpbWl0ZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKG1lLnByb3BzLmpzeHR5cGUgPT0gXCJjbm1vYmlsZVwiKSB7XG4gICAgICAgICAgICByZXR1cm4gRm9ybWF0dGVyLmNubW9iaWxlKHZhbHVlLCBtZS5wcm9wcy5kZWxpbWl0ZXIpO1xuICAgICAgICB9IGVsc2UgaWYgKG1lLnByb3BzLmpzeHR5cGUgPT0gXCJjYXJkXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBGb3JtYXR0ZXIuY2FyZCh2YWx1ZSwgbWUucHJvcHMuZGVsaW1pdGVyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBOdW1iZXJJbnB1dEZvcm1GaWVsZC5wcm90b3R5cGUuZGVGb3JtYXRWYWx1ZSA9IGZ1bmN0aW9uIGRlRm9ybWF0VmFsdWUodmFsdWUpIHtcbiAgICAgICAgdmFyIG1lID0gdGhpcztcbiAgICAgICAgaWYgKG1lLnByb3BzLmpzeHR5cGUgPT0gXCJtb25leVwiIHx8IG1lLnByb3BzLmpzeHR5cGUgPT0gXCJjbm1vYmlsZVwiIHx8IG1lLnByb3BzLmpzeHR5cGUgPT0gXCJjYXJkXCIpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZS5zcGxpdChtZS5wcm9wcy5kZWxpbWl0ZXIpLmpvaW4oXCJcIik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgTnVtYmVySW5wdXRGb3JtRmllbGQucHJvdG90eXBlLmFkZFNwZWNpZmljQ2xhc3MgPSBmdW5jdGlvbiBhZGRTcGVjaWZpY0NsYXNzKCkge1xuICAgICAgICB2YXIgbWUgPSB0aGlzO1xuICAgICAgICBpZiAobWUucHJvcHMuanN4cHJlZml4Q2xzID09IFwia3VtYS11eGZvcm0tZmllbGRcIikge1xuICAgICAgICAgICAgcmV0dXJuIG1lLnByb3BzLmpzeHByZWZpeENscyArIFwiIGt1bWEtbnVtYmVyLWlucHV0LXV4Zm9ybS1maWVsZFwiO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG1lLnByb3BzLmpzeHByZWZpeENscztcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICByZXR1cm4gTnVtYmVySW5wdXRGb3JtRmllbGQ7XG59KElucHV0Rm9ybUZpZWxkKTtcblxuTnVtYmVySW5wdXRGb3JtRmllbGQuZGlzcGxheU5hbWUgPSBcIk51bWJlcklucHV0Rm9ybUZpZWxkXCI7XG5OdW1iZXJJbnB1dEZvcm1GaWVsZC5wcm9wVHlwZXMgPSBhc3NpZ24oe30sIElucHV0Rm9ybUZpZWxkLnByb3BUeXBlcywge1xuICAgIGpzeHR5cGU6IFJlYWN0LlByb3BUeXBlcy5zdHJpbmcsXG4gICAgZGVsaW1pdGVyOiBSZWFjdC5Qcm9wVHlwZXMuc3RyaW5nLFxuICAgIGZpeGVkTnVtOiBSZWFjdC5Qcm9wVHlwZXMubnVtYmVyXG59KTtcbk51bWJlcklucHV0Rm9ybUZpZWxkLmRlZmF1bHRQcm9wcyA9IGFzc2lnbih7fSwgSW5wdXRGb3JtRmllbGQuZGVmYXVsdFByb3BzLCB7XG4gICAganN4dHlwZTogJycsXG4gICAgZGVsaW1pdGVyOiAnICdcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IE51bWJlcklucHV0Rm9ybUZpZWxkO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3V4Y29yZS1mb3JtL2J1aWxkL0Zvcm1GaWVsZC9OdW1iZXJJbnB1dEZvcm1GaWVsZC5qc1xuICoqIG1vZHVsZSBpZCA9IDM3MFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG52YXIgUmVhY3RET00gPSByZXF1aXJlKCdyZWFjdC1kb20nKTtcbnZhciBGb3JtRmllbGQgPSByZXF1aXJlKCd1eGNvcmUtZm9ybS1maWVsZCcpO1xudmFyIENvbnN0YW50cyA9IHJlcXVpcmUoXCJ1eGNvcmUtY29uc3RcIik7XG52YXIgY2xhc3NuYW1lcyA9IHJlcXVpcmUoJ2NsYXNzbmFtZXMnKTtcbnZhciBhc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG5cbnZhciBGb3JtQ291bnQgPSBmdW5jdGlvbiAoX1JlYWN0JENvbXBvbmVudCkge1xuICAgIF9pbmhlcml0cyhGb3JtQ291bnQsIF9SZWFjdCRDb21wb25lbnQpO1xuXG4gICAgZnVuY3Rpb24gRm9ybUNvdW50KHByb3BzKSB7XG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBGb3JtQ291bnQpO1xuXG4gICAgICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfUmVhY3QkQ29tcG9uZW50LmNhbGwodGhpcywgcHJvcHMpKTtcbiAgICB9XG5cbiAgICBGb3JtQ291bnQucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICAgICAgdmFyIG1lID0gdGhpcztcbiAgICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgICAnZGl2JyxcbiAgICAgICAgICAgIHsgY2xhc3NOYW1lOiAna3VtYS11eGZvcm0tY291bnQnIH0sXG4gICAgICAgICAgICBtZS5wcm9wcy5sZW5ndGggKyBcIi9cIiArIG1lLnByb3BzLnRvdGFsXG4gICAgICAgICk7XG4gICAgfTtcblxuICAgIHJldHVybiBGb3JtQ291bnQ7XG59KFJlYWN0LkNvbXBvbmVudCk7XG5cbkZvcm1Db3VudC5kZWZhdWx0UHJvcHMgPSB7fTtcbkZvcm1Db3VudC5wcm9wVHlwZXMgPSB7XG4gICAgbGVuZ3RoOiBSZWFjdC5Qcm9wVHlwZXMubnVtYmVyLFxuICAgIHRvdGFsOiBSZWFjdC5Qcm9wVHlwZXMubnVtYmVyXG59O1xuXG5Gb3JtQ291bnQuZGlzcGxheU5hbWUgPSBcIkZvcm1Db3VudFwiO1xuXG52YXIgTGVmdEFkZG9uID0gZnVuY3Rpb24gKF9SZWFjdCRDb21wb25lbnQyKSB7XG4gICAgX2luaGVyaXRzKExlZnRBZGRvbiwgX1JlYWN0JENvbXBvbmVudDIpO1xuXG4gICAgZnVuY3Rpb24gTGVmdEFkZG9uKHByb3BzKSB7XG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBMZWZ0QWRkb24pO1xuXG4gICAgICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfUmVhY3QkQ29tcG9uZW50Mi5jYWxsKHRoaXMsIHByb3BzKSk7XG4gICAgfVxuXG4gICAgTGVmdEFkZG9uLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgICAgIHZhciBtZSA9IHRoaXM7XG4gICAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICAgJ2RpdicsXG4gICAgICAgICAgICB7IGNsYXNzTmFtZTogY2xhc3NuYW1lcyh7XG4gICAgICAgICAgICAgICAgICAgIFwia3VtYS11eGZvcm0tbGVmdC1pY29uXCI6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIFwia3VtYS11eGZvcm0tbGVmdC1pY29uLWZvY3VzXCI6ICEhbWUucHJvcHMuZm9jdXNcbiAgICAgICAgICAgICAgICB9KSB9LFxuICAgICAgICAgICAgbWUucHJvcHMuY2hpbGRyZW5cbiAgICAgICAgKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIExlZnRBZGRvbjtcbn0oUmVhY3QuQ29tcG9uZW50KTtcblxuTGVmdEFkZG9uLmRlZmF1bHRQcm9wcyA9IHt9O1xuTGVmdEFkZG9uLnByb3BUeXBlcyA9IHt9O1xuTGVmdEFkZG9uLmRpc3BsYXlOYW1lID0gXCJMZWZ0QWRkb25cIjtcblxudmFyIFJpZ2h0QWRkb24gPSBmdW5jdGlvbiAoX1JlYWN0JENvbXBvbmVudDMpIHtcbiAgICBfaW5oZXJpdHMoUmlnaHRBZGRvbiwgX1JlYWN0JENvbXBvbmVudDMpO1xuXG4gICAgZnVuY3Rpb24gUmlnaHRBZGRvbihwcm9wcykge1xuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUmlnaHRBZGRvbik7XG5cbiAgICAgICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9SZWFjdCRDb21wb25lbnQzLmNhbGwodGhpcywgcHJvcHMpKTtcbiAgICB9XG5cbiAgICBSaWdodEFkZG9uLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgICAgIHZhciBtZSA9IHRoaXM7XG4gICAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICAgJ2RpdicsXG4gICAgICAgICAgICB7IGNsYXNzTmFtZTogJ2t1bWEtdXhmb3JtLXJpZ2h0LWljb24gJyB9LFxuICAgICAgICAgICAgbWUucHJvcHMuY2hpbGRyZW5cbiAgICAgICAgKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIFJpZ2h0QWRkb247XG59KFJlYWN0LkNvbXBvbmVudCk7XG5cblJpZ2h0QWRkb24uZGVmYXVsdFByb3BzID0ge307XG5SaWdodEFkZG9uLnByb3BUeXBlcyA9IHt9O1xuUmlnaHRBZGRvbi5kaXNwbGF5TmFtZSA9IFwiUmlnaHRBZGRvblwiO1xuXG4vKipcbiAqIGV4dGVuZCBGb3JtRmllbGQsIHJld3JpdGUgcmVuZGVyRmllbGQgbWV0aG9kXG4gKi9cblxudmFyIElucHV0Rm9ybUZpZWxkID0gZnVuY3Rpb24gKF9Gb3JtRmllbGQpIHtcbiAgICBfaW5oZXJpdHMoSW5wdXRGb3JtRmllbGQsIF9Gb3JtRmllbGQpO1xuXG4gICAgZnVuY3Rpb24gSW5wdXRGb3JtRmllbGQocHJvcHMpIHtcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIElucHV0Rm9ybUZpZWxkKTtcblxuICAgICAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX0Zvcm1GaWVsZC5jYWxsKHRoaXMsIHByb3BzKSk7XG4gICAgfVxuXG4gICAgSW5wdXRGb3JtRmllbGQucHJvdG90eXBlLmdldFZhbHVlID0gZnVuY3Rpb24gZ2V0VmFsdWUoKSB7XG4gICAgICAgIHJldHVybiBSZWFjdERPTS5maW5kRE9NTm9kZSh0aGlzLnJlZnMucm9vdCkudmFsdWUoKTtcbiAgICB9O1xuXG4gICAgSW5wdXRGb3JtRmllbGQucHJvdG90eXBlLmhhbmRsZUNoYW5nZSA9IGZ1bmN0aW9uIGhhbmRsZUNoYW5nZShlKSB7XG4gICAgICAgIHZhciBtZSA9IHRoaXM7XG4gICAgICAgIHZhciBhdXRvVHJpbSA9IG1lLnByb3BzLmF1dG9UcmltO1xuXG4gICAgICAgIHZhciB2YWx1ZSA9IGUuY3VycmVudFRhcmdldC52YWx1ZTtcbiAgICAgICAgaWYgKGF1dG9UcmltKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IG1lLnRyaW0odmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIG1lLmhhbmRsZURhdGFDaGFuZ2UobWUuZGVGb3JtYXRWYWx1ZSh2YWx1ZSkpO1xuICAgIH07XG5cbiAgICBJbnB1dEZvcm1GaWVsZC5wcm90b3R5cGUudHJpbSA9IGZ1bmN0aW9uIHRyaW0oc3RyKSB7XG4gICAgICAgIHJldHVybiBzdHIucmVwbGFjZSgvKF5cXHMrfFxccyskKS9nLCBcIlwiKTtcbiAgICB9O1xuXG4gICAgSW5wdXRGb3JtRmllbGQucHJvdG90eXBlLmhhbmRsZUZvY3VzID0gZnVuY3Rpb24gaGFuZGxlRm9jdXMoZSkge1xuICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgIGZvY3VzOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnByb3BzLm9uRm9jdXMoZSk7XG4gICAgfTtcblxuICAgIElucHV0Rm9ybUZpZWxkLnByb3RvdHlwZS5oYW5kbGVCbHVyID0gZnVuY3Rpb24gaGFuZGxlQmx1cihlKSB7XG4gICAgICAgIHZhciBtZSA9IHRoaXM7XG4gICAgICAgIG1lLnNldFN0YXRlKHtcbiAgICAgICAgICAgIGZvY3VzOiBmYWxzZVxuICAgICAgICB9KTtcbiAgICAgICAgdmFyIHBhc3MgPSB0cnVlO1xuICAgICAgICBpZiAobWUucHJvcHMudmFsaWRhdGVPbkJsdXIpIHtcbiAgICAgICAgICAgIHBhc3MgPSBtZS5kb1ZhbGlkYXRlKCk7XG4gICAgICAgIH1cbiAgICAgICAgbWUucHJvcHMub25CbHVyKGUsIHBhc3MpO1xuICAgIH07XG5cbiAgICBJbnB1dEZvcm1GaWVsZC5wcm90b3R5cGUuaGFuZGxlS2V5RG93biA9IGZ1bmN0aW9uIGhhbmRsZUtleURvd24oZSkge1xuICAgICAgICB2YXIgbWUgPSB0aGlzO1xuICAgICAgICBtZS5wcm9wcy5vbktleURvd24oZSk7XG4gICAgfTtcblxuICAgIElucHV0Rm9ybUZpZWxkLnByb3RvdHlwZS5kZUZvcm1hdFZhbHVlID0gZnVuY3Rpb24gZGVGb3JtYXRWYWx1ZSh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfTtcblxuICAgIElucHV0Rm9ybUZpZWxkLnByb3RvdHlwZS5hZGRTcGVjaWZpY0NsYXNzID0gZnVuY3Rpb24gYWRkU3BlY2lmaWNDbGFzcygpIHtcbiAgICAgICAgdmFyIG1lID0gdGhpcztcbiAgICAgICAgaWYgKG1lLnByb3BzLmpzeHByZWZpeENscyA9PSBcImt1bWEtdXhmb3JtLWZpZWxkXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBtZS5wcm9wcy5qc3hwcmVmaXhDbHMgKyBcIiBrdW1hLWlucHV0LXV4Zm9ybS1maWVsZFwiO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG1lLnByb3BzLmpzeHByZWZpeENscztcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBJbnB1dEZvcm1GaWVsZC5wcm90b3R5cGUuZ2V0Q291bnQgPSBmdW5jdGlvbiBnZXRDb3VudCgpIHtcbiAgICAgICAgdmFyIG1lID0gdGhpcztcbiAgICAgICAgdmFyIGNoaWxkcmVuID0gbWUucHJvcHMuY2hpbGRyZW47XG4gICAgICAgIHZhciBlbGVtZW50ID0gdm9pZCAwO1xuICAgICAgICBSZWFjdC5DaGlsZHJlbi5tYXAoY2hpbGRyZW4sIGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICAgICAgaWYgKGNoaWxkICYmIHR5cGVvZiBjaGlsZC50eXBlID09ICdmdW5jdGlvbicgJiYgY2hpbGQudHlwZS5kaXNwbGF5TmFtZSA9PSAnRm9ybUNvdW50Jykge1xuICAgICAgICAgICAgICAgIGVsZW1lbnQgPSBjaGlsZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGlmICghIWVsZW1lbnQpIHtcbiAgICAgICAgICAgIHZhciB0b3RhbCA9IGVsZW1lbnQucHJvcHMudG90YWw7XG4gICAgICAgICAgICB2YXIgQ291bnQgPSBSZWFjdC5jbG9uZUVsZW1lbnQoZWxlbWVudCwge1xuICAgICAgICAgICAgICAgIGxlbmd0aDogISFtZS5zdGF0ZS52YWx1ZSA/IG1lLnN0YXRlLnZhbHVlLmxlbmd0aCA6IDAsXG4gICAgICAgICAgICAgICAga2V5OiBcImNvdW50XCJcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGVsZW1lbnQ6IENvdW50LFxuICAgICAgICAgICAgICAgIHRvdGFsOiB0b3RhbFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBJbnB1dEZvcm1GaWVsZC5wcm90b3R5cGUucmVuZGVyTGVmdEFkZG9uID0gZnVuY3Rpb24gcmVuZGVyTGVmdEFkZG9uKCkge1xuICAgICAgICB2YXIgbWUgPSB0aGlzO1xuICAgICAgICB2YXIgY2hpbGRyZW4gPSBtZS5wcm9wcy5jaGlsZHJlbjtcbiAgICAgICAgdmFyIGVsZW1lbnQgPSB2b2lkIDA7XG4gICAgICAgIFJlYWN0LkNoaWxkcmVuLm1hcChjaGlsZHJlbiwgZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgICAgICBpZiAoY2hpbGQgJiYgdHlwZW9mIGNoaWxkLnR5cGUgPT0gJ2Z1bmN0aW9uJyAmJiBjaGlsZC50eXBlLmRpc3BsYXlOYW1lID09ICdMZWZ0QWRkb24nKSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudCA9IGNoaWxkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKCEhZWxlbWVudCkge1xuICAgICAgICAgICAgcmV0dXJuIFJlYWN0LmNsb25lRWxlbWVudChlbGVtZW50LCB7XG4gICAgICAgICAgICAgICAgZm9jdXM6ICEhbWUuc3RhdGUuZm9jdXMsXG4gICAgICAgICAgICAgICAga2V5OiBcImxlZnRcIlxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgSW5wdXRGb3JtRmllbGQucHJvdG90eXBlLnJlbmRlclJpZ2h0QWRkb24gPSBmdW5jdGlvbiByZW5kZXJSaWdodEFkZG9uKCkge1xuICAgICAgICB2YXIgbWUgPSB0aGlzO1xuICAgICAgICB2YXIgY2hpbGRyZW4gPSBtZS5wcm9wcy5jaGlsZHJlbjtcbiAgICAgICAgdmFyIGVsZW1lbnQgPSB2b2lkIDA7XG4gICAgICAgIFJlYWN0LkNoaWxkcmVuLm1hcChjaGlsZHJlbiwgZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgICAgICBpZiAoY2hpbGQgJiYgdHlwZW9mIGNoaWxkLnR5cGUgPT0gJ2Z1bmN0aW9uJyAmJiBjaGlsZC50eXBlLmRpc3BsYXlOYW1lID09ICdSaWdodEFkZG9uJykge1xuICAgICAgICAgICAgICAgIGVsZW1lbnQgPSBjaGlsZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKCEhZWxlbWVudCkge1xuICAgICAgICAgICAgcmV0dXJuIFJlYWN0LmNsb25lRWxlbWVudChlbGVtZW50LCB7XG4gICAgICAgICAgICAgICAga2V5OiBcInJpZ2h0XCJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIElucHV0Rm9ybUZpZWxkLnByb3RvdHlwZS5yZW5kZXJGaWVsZCA9IGZ1bmN0aW9uIHJlbmRlckZpZWxkKCkge1xuICAgICAgICB2YXIgbWUgPSB0aGlzO1xuICAgICAgICB2YXIgYXJyID0gW107XG4gICAgICAgIHZhciBtb2RlID0gbWUucHJvcHMuanN4bW9kZSB8fCBtZS5wcm9wcy5tb2RlO1xuICAgICAgICB2YXIgY291bnQgPSBtZS5nZXRDb3VudCgpO1xuICAgICAgICB2YXIgbGVmdEFkZG9uID0gbWUucmVuZGVyTGVmdEFkZG9uKCk7XG4gICAgICAgIHZhciByaWdodEFkZG9uID0gbWUucmVuZGVyUmlnaHRBZGRvbigpO1xuICAgICAgICB2YXIgY2hpbGRyZW4gPSBtZS5wcm9wcy5jaGlsZHJlbjtcbiAgICAgICAgaWYgKG1vZGUgPT0gQ29uc3RhbnRzLk1PREUuRURJVCkge1xuICAgICAgICAgICAgdmFyIG90aGVyT3B0aW9ucyA9IHt9O1xuICAgICAgICAgICAgLy8gaWYgKCEhY291bnQpIHtcbiAgICAgICAgICAgIC8vICAgICBvdGhlck9wdGlvbnMubWF4TGVuZ3RoID0gY291bnQudG90YWwgKyBcIlwiO1xuICAgICAgICAgICAgLy8gfVxuICAgICAgICAgICAgaWYgKCEhbGVmdEFkZG9uKSB7XG4gICAgICAgICAgICAgICAgYXJyLnB1c2gobGVmdEFkZG9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFyci5wdXNoKFJlYWN0LmNyZWF0ZUVsZW1lbnQoJ2lucHV0JywgX2V4dGVuZHMoe1xuICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogY2xhc3NuYW1lcyh7XG4gICAgICAgICAgICAgICAgICAgIFwia3VtYS1pbnB1dFwiOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAna3VtYS11eGZvcm0taW5wdXQtaGFzLXJpZ2h0JzogISFjb3VudCB8fCAhIXJpZ2h0QWRkb24sXG4gICAgICAgICAgICAgICAgICAgIFwia3VtYS11eGZvcm0taW5wdXQtaGFzLWxlZnRcIjogISFsZWZ0QWRkb25cbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICByZWY6ICdyb290JyxcbiAgICAgICAgICAgICAgICBrZXk6IG1lLnByb3BzLmlucHV0VHlwZSxcbiAgICAgICAgICAgICAgICB0eXBlOiBtZS5wcm9wcy5pbnB1dFR5cGUsXG4gICAgICAgICAgICAgICAgcGxhY2Vob2xkZXI6IG1lLnByb3BzLmpzeHBsYWNlaG9sZGVyLFxuICAgICAgICAgICAgICAgIGRpc2FibGVkOiBtZS5wcm9wcy5qc3hkaXNhYmxlZCA9PSBcImRpc2FibGVkXCIgfHwgbWUucHJvcHMuanN4ZGlzYWJsZWQgPT0gdHJ1ZSA/IFwiZGlzYWJsZWRcIiA6IFwiXCIsXG4gICAgICAgICAgICAgICAgbmFtZTogbWUucHJvcHMua2V5LFxuICAgICAgICAgICAgICAgIHZhbHVlOiBtZS5zdGF0ZS5mb3JtYXRWYWx1ZSxcbiAgICAgICAgICAgICAgICBvbkZvY3VzOiBtZS5oYW5kbGVGb2N1cy5iaW5kKG1lKSxcbiAgICAgICAgICAgICAgICBvbkJsdXI6IG1lLmhhbmRsZUJsdXIuYmluZChtZSksXG4gICAgICAgICAgICAgICAgb25DaGFuZ2U6IG1lLmhhbmRsZUNoYW5nZS5iaW5kKG1lKSxcbiAgICAgICAgICAgICAgICBvbktleURvd246IG1lLmhhbmRsZUtleURvd24uYmluZChtZSlcbiAgICAgICAgICAgIH0sIG90aGVyT3B0aW9ucykpKTtcblxuICAgICAgICAgICAgaWYgKCEhcmlnaHRBZGRvbikge1xuICAgICAgICAgICAgICAgIGFyci5wdXNoKHJpZ2h0QWRkb24pO1xuICAgICAgICAgICAgfSBlbHNlIGlmICghIWNvdW50KSB7XG4gICAgICAgICAgICAgICAgYXJyLnB1c2goY291bnQuZWxlbWVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAobW9kZSA9PSBDb25zdGFudHMuTU9ERS5WSUVXKSB7XG4gICAgICAgICAgICBhcnIucHVzaChSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICAgICAgICdzcGFuJyxcbiAgICAgICAgICAgICAgICB7IGtleTogJ3RleHQnIH0sXG4gICAgICAgICAgICAgICAgbWUuc3RhdGUuZm9ybWF0VmFsdWVcbiAgICAgICAgICAgICkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhcnI7XG4gICAgfTtcblxuICAgIHJldHVybiBJbnB1dEZvcm1GaWVsZDtcbn0oRm9ybUZpZWxkKTtcblxuSW5wdXRGb3JtRmllbGQuQ291bnQgPSBGb3JtQ291bnQ7XG5JbnB1dEZvcm1GaWVsZC5MZWZ0QWRkb24gPSBMZWZ0QWRkb247XG5JbnB1dEZvcm1GaWVsZC5SaWdodEFkZG9uID0gUmlnaHRBZGRvbjtcbklucHV0Rm9ybUZpZWxkLnByb3BUeXBlcyA9IGFzc2lnbih7fSwgRm9ybUZpZWxkLnByb3BUeXBlcywge1xuICAgIG9uQmx1cjogUmVhY3QuUHJvcFR5cGVzLmZ1bmMsXG4gICAgb25Gb2N1czogUmVhY3QuUHJvcFR5cGVzLmZ1bmMsXG4gICAgb25LZXlEb3duOiBSZWFjdC5Qcm9wVHlwZXMuZnVuYyxcbiAgICB2YWxpZGF0ZU9uQmx1cjogUmVhY3QuUHJvcFR5cGVzLmJvb2wsXG4gICAgYXV0b1RyaW06IFJlYWN0LlByb3BUeXBlcy5ib29sLFxuICAgIGlucHV0VHlwZTogUmVhY3QuUHJvcFR5cGVzLnN0cmluZ1xufSk7XG5JbnB1dEZvcm1GaWVsZC5kZWZhdWx0UHJvcHMgPSBhc3NpZ24oe30sIEZvcm1GaWVsZC5kZWZhdWx0UHJvcHMsIHtcbiAgICBvbkJsdXI6IGZ1bmN0aW9uIG9uQmx1cigpIHt9LFxuICAgIG9uRm9jdXM6IGZ1bmN0aW9uIG9uRm9jdXMoKSB7fSxcbiAgICBvbktleURvd246IGZ1bmN0aW9uIG9uS2V5RG93bigpIHt9LFxuICAgIHZhbGlkYXRlT25CbHVyOiBmYWxzZSxcbiAgICBpbnB1dFR5cGU6ICd0ZXh0J1xufSk7XG5JbnB1dEZvcm1GaWVsZC5kaXNwbGF5TmFtZSA9IFwiSW5wdXRGb3JtRmllbGRcIjtcbm1vZHVsZS5leHBvcnRzID0gSW5wdXRGb3JtRmllbGQ7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vdXhjb3JlLWZvcm0vYnVpbGQvRm9ybUZpZWxkL0lucHV0Rm9ybUZpZWxkLmpzXG4gKiogbW9kdWxlIGlkID0gMzcxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogRGF0ZUZvcm1GaWVsZCBDb21wb25lbnQgZm9yIHV4Y29yZVxuICogQGF1dGhvciBldGVybmFsc2t5XG4gKlxuICogQ29weXJpZ2h0IDIwMTUtMjAxNiwgVXhjb3JlIFRlYW0sIEFsaW53LlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vRGF0ZUZvcm1GaWVsZCcpO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3V4Y29yZS1mb3JtL34vdXhjb3JlLWRhdGUtZm9ybS1maWVsZC9idWlsZC9pbmRleC5qc1xuICoqIG1vZHVsZSBpZCA9IDM3NFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcblxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKG9iaiwga2V5cykgeyB2YXIgdGFyZ2V0ID0ge307IGZvciAodmFyIGkgaW4gb2JqKSB7IGlmIChrZXlzLmluZGV4T2YoaSkgPj0gMCkgY29udGludWU7IGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgaSkpIGNvbnRpbnVlOyB0YXJnZXRbaV0gPSBvYmpbaV07IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbi8qKlxuICogRGF0ZUZvcm1GaWVsZCBDb21wb25lbnQgZm9yIHV4Y29yZVxuICogQGF1dGhvciBldGVybmFsc2t5XG4gKlxuICogQ29weXJpZ2h0IDIwMTUtMjAxNiwgVXhjb3JlIFRlYW0sIEFsaW53LlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqL1xuXG52YXIgRm9ybUZpZWxkID0gcmVxdWlyZSgndXhjb3JlLWZvcm0tZmllbGQnKTtcbnZhciBDb25zdGFudHMgPSByZXF1aXJlKCd1eGNvcmUtY29uc3QnKTtcbnZhciBjbGFzc25hbWVzID0gcmVxdWlyZSgnY2xhc3NuYW1lcycpO1xudmFyIENhbGVuZGFyID0gcmVxdWlyZSgndXhjb3JlLWNhbGVuZGFyJyk7XG52YXIgYXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xudmFyIGRlZXBjb3B5ID0gcmVxdWlyZSgnZGVlcGNvcHknKTtcbnZhciBGb3JtYXR0ZXIgPSByZXF1aXJlKCd1eGNvcmUtZm9ybWF0dGVyJyk7XG5cbnZhciBEYXRlRm9ybUZpZWxkID0gZnVuY3Rpb24gKF9Gb3JtRmllbGQpIHtcbiAgICBfaW5oZXJpdHMoRGF0ZUZvcm1GaWVsZCwgX0Zvcm1GaWVsZCk7XG5cbiAgICBmdW5jdGlvbiBEYXRlRm9ybUZpZWxkKHByb3BzKSB7XG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBEYXRlRm9ybUZpZWxkKTtcblxuICAgICAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX0Zvcm1GaWVsZC5jYWxsKHRoaXMsIHByb3BzKSk7XG4gICAgfVxuXG4gICAgRGF0ZUZvcm1GaWVsZC5wcm90b3R5cGUuaGFuZGxlQ2hhbmdlID0gZnVuY3Rpb24gaGFuZGxlQ2hhbmdlKHZhbHVlKSB7XG4gICAgICAgIHZhciBtZSA9IHRoaXM7XG4gICAgICAgIG1lLmhhbmRsZURhdGFDaGFuZ2UobmV3IERhdGUodmFsdWUpLmdldFRpbWUoKSk7XG4gICAgfTtcblxuICAgIERhdGVGb3JtRmllbGQucHJvdG90eXBlLmhhbmRsZUNhc2NhZGVDaGFuZ2UgPSBmdW5jdGlvbiBoYW5kbGVDYXNjYWRlQ2hhbmdlKGksIHZhbHVlKSB7XG4gICAgICAgIHZhciBtZSA9IHRoaXM7XG4gICAgICAgIHZhciB2YWx1ZXMgPSBkZWVwY29weShtZS5zdGF0ZS52YWx1ZSkgfHwgW107XG4gICAgICAgIHZhbHVlc1tpXSA9IG5ldyBEYXRlKHZhbHVlKS5nZXRUaW1lKCk7XG4gICAgICAgIGlmIChpID09IDAgJiYgISF2YWx1ZXNbMV0gJiYgbmV3IERhdGUodmFsdWUpLmdldFRpbWUoKSA+IG5ldyBEYXRlKHZhbHVlc1sxXSkuZ2V0VGltZSgpKSB7XG4gICAgICAgICAgICB2YWx1ZXMucG9wKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGkgPT0gMSAmJiAhIXZhbHVlc1swXSAmJiBuZXcgRGF0ZSh2YWx1ZSkuZ2V0VGltZSgpIDwgbmV3IERhdGUodmFsdWVzWzBdKS5nZXRUaW1lKCkpIHtcbiAgICAgICAgICAgIHZhbHVlc1swXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBtZS5oYW5kbGVEYXRhQ2hhbmdlKHZhbHVlcyk7XG4gICAgfTtcblxuICAgIERhdGVGb3JtRmllbGQucHJvdG90eXBlLmFkZFNwZWNpZmljQ2xhc3MgPSBmdW5jdGlvbiBhZGRTcGVjaWZpY0NsYXNzKCkge1xuICAgICAgICB2YXIgbWUgPSB0aGlzO1xuICAgICAgICBpZiAobWUucHJvcHMuanN4cHJlZml4Q2xzID09IFwia3VtYS11eGZvcm0tZmllbGRcIikge1xuICAgICAgICAgICAgdmFyIHN0ciA9IG1lLnByb3BzLmpzeHByZWZpeENscyArIFwiIGt1bWEtZGF0ZS11eGZvcm0tZmllbGRcIjtcbiAgICAgICAgICAgIGlmIChtZS5wcm9wcy5qc3h0eXBlID09IFwiY2FzY2FkZVwiKSB7XG4gICAgICAgICAgICAgICAgc3RyICs9IFwiIGt1bWEtY2FzY2FkZS1kYXRlLXV4Zm9ybS1maWVsZFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHN0cjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBtZS5wcm9wcy5qc3hwcmVmaXhDbHM7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgRGF0ZUZvcm1GaWVsZC5wcm90b3R5cGUucHJvY2Vzc1RpbWUgPSBmdW5jdGlvbiBwcm9jZXNzVGltZSh0aW1lKSB7XG4gICAgICAgIC8vIGlmIHNob3dUaW1lIGlzIHRydWUgb3IgdGltZVBpY2tlciBpcyBzZXQsIHdlIHVzZSB0aW1lIHRvIGNvbXBhcmVcbiAgICAgICAgLy8gb3RoZXJ3aXNlIHdlIHVzZSBkYXkgdG8gY29tcGFyZVxuICAgICAgICB2YXIgbWUgPSB0aGlzO1xuICAgICAgICB2YXIgX21lJHByb3BzID0gbWUucHJvcHM7XG4gICAgICAgIHZhciBzaG93VGltZSA9IF9tZSRwcm9wcy5zaG93VGltZTtcbiAgICAgICAgdmFyIHRpbWVQaWNrZXIgPSBfbWUkcHJvcHMudGltZVBpY2tlcjtcblxuICAgICAgICBpZiAoc2hvd1RpbWUgfHwgdGltZVBpY2tlcikge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBEYXRlKHRpbWUpLmdldFRpbWUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRGF0ZShGb3JtYXR0ZXIuZGF0ZSh0aW1lLCAnWVlZWS1NTS1ERCcpKS5nZXRUaW1lKCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgRGF0ZUZvcm1GaWVsZC5wcm90b3R5cGUucmVuZGVyRmllbGQgPSBmdW5jdGlvbiByZW5kZXJGaWVsZCgpIHtcbiAgICAgICAgdmFyIG1lID0gdGhpcztcbiAgICAgICAgdmFyIF9tZSRwcm9wczIgPSBtZS5wcm9wcztcbiAgICAgICAgdmFyIG9uU2VsZWN0ID0gX21lJHByb3BzMi5vblNlbGVjdDtcbiAgICAgICAgdmFyIHN0eWxlID0gX21lJHByb3BzMi5zdHlsZTtcbiAgICAgICAgdmFyIHByZWZpeENscyA9IF9tZSRwcm9wczIucHJlZml4Q2xzO1xuICAgICAgICB2YXIgdmFsdWUgPSBfbWUkcHJvcHMyLnZhbHVlO1xuICAgICAgICB2YXIganN4dHlwZSA9IF9tZSRwcm9wczIuanN4dHlwZTtcbiAgICAgICAgdmFyIGpzeGZyb20gPSBfbWUkcHJvcHMyLmpzeGZyb207XG4gICAgICAgIHZhciBqc3h0byA9IF9tZSRwcm9wczIuanN4dG87XG4gICAgICAgIHZhciBkaXNhYmxlZERhdGUgPSBfbWUkcHJvcHMyLmRpc2FibGVkRGF0ZTtcblxuICAgICAgICB2YXIgb3RoZXJzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9tZSRwcm9wczIsIFsnb25TZWxlY3QnLCAnc3R5bGUnLCAncHJlZml4Q2xzJywgJ3ZhbHVlJywgJ2pzeHR5cGUnLCAnanN4ZnJvbScsICdqc3h0bycsICdkaXNhYmxlZERhdGUnXSk7XG5cbiAgICAgICAgdmFyIGZyb20gPSAhIWpzeGZyb20gPyBtZS5wcm9jZXNzVGltZShqc3hmcm9tKSA6IDA7XG4gICAgICAgIHZhciB0byA9ICEhanN4dG8gPyBtZS5wcm9jZXNzVGltZShqc3h0bykgOiBJbmZpbml0eTtcbiAgICAgICAgdmFyIG1vZGUgPSBtZS5wcm9wcy5qc3htb2RlIHx8IG1lLnByb3BzLm1vZGU7XG4gICAgICAgIGlmIChtb2RlID09IENvbnN0YW50cy5NT0RFLkVESVQpIHtcbiAgICAgICAgICAgIGlmIChqc3h0eXBlID09IFwic2luZ2xlXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChDYWxlbmRhciwgX2V4dGVuZHMoe1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogbWUuc3RhdGUudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIG9uU2VsZWN0OiBtZS5oYW5kbGVDaGFuZ2UuYmluZChtZSksXG4gICAgICAgICAgICAgICAgICAgIGRpc2FibGVkRGF0ZTogZGlzYWJsZWREYXRlID8gZGlzYWJsZWREYXRlIDogZnVuY3Rpb24gKGN1cnJlbnQsIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiBzaG93VGltZSBpcyB0cnVlIG9yIHRpbWVQaWNrZXIgaXMgc2V0LCB3ZSB1c2UgdGltZSB0byBjb21wYXJlXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBvdGhlcndpc2Ugd2UgdXNlIGRheSB0byBjb21wYXJlXG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBtZS5wcm9jZXNzVGltZShjdXJyZW50LmdldFRpbWUoKSkgPCBmcm9tIHx8IG1lLnByb2Nlc3NUaW1lKGN1cnJlbnQuZ2V0VGltZSgpKSA+IHRvO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSwgb3RoZXJzKSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGpzeHR5cGUgPT0gXCJjYXNjYWRlXCIpIHtcbiAgICAgICAgICAgICAgICB2YXIgYXJyID0gW107XG4gICAgICAgICAgICAgICAgdmFyIG90aGVyczEgPSBhc3NpZ24oe30sIG90aGVycyk7XG4gICAgICAgICAgICAgICAgdmFyIG90aGVyczIgPSBhc3NpZ24oe30sIG90aGVycyk7XG4gICAgICAgICAgICAgICAgaWYgKG1lLnN0YXRlLnZhbHVlICYmIG1lLnN0YXRlLnZhbHVlWzBdKSB7XG4gICAgICAgICAgICAgICAgICAgIG90aGVyczEgPSBhc3NpZ24oe30sIG90aGVycywge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IG1lLnN0YXRlLnZhbHVlWzBdXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG90aGVyczEgPSBhc3NpZ24oe30sIG90aGVycywge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IG51bGxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChtZS5zdGF0ZS52YWx1ZSAmJiBtZS5zdGF0ZS52YWx1ZVsxXSkge1xuICAgICAgICAgICAgICAgICAgICBvdGhlcnMyID0gYXNzaWduKHt9LCBvdGhlcnMsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBtZS5zdGF0ZS52YWx1ZVsxXVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBvdGhlcnMyID0gYXNzaWduKHt9LCBvdGhlcnMsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBudWxsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhcnIucHVzaChSZWFjdC5jcmVhdGVFbGVtZW50KENhbGVuZGFyLCBfZXh0ZW5kcyh7XG4gICAgICAgICAgICAgICAgICAgIGtleTogJ2NhbGVuZGFyMScsXG4gICAgICAgICAgICAgICAgICAgIG9uU2VsZWN0OiBtZS5oYW5kbGVDYXNjYWRlQ2hhbmdlLmJpbmQobWUsIDApLFxuICAgICAgICAgICAgICAgICAgICBkaXNhYmxlZERhdGU6IGZ1bmN0aW9uIGRpc2FibGVkRGF0ZShjdXJyZW50LCB2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5vdyA9IG1lLnByb2Nlc3NUaW1lKGN1cnJlbnQuZ2V0VGltZSgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBub3cgPCBmcm9tIHx8IG5vdyA+IHRvO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSwgb3RoZXJzMSkpKTtcbiAgICAgICAgICAgICAgICBhcnIucHVzaChSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICAgICAgICAgICAnc3BhbicsXG4gICAgICAgICAgICAgICAgICAgIHsga2V5OiAnc3BsaXQnLCBjbGFzc05hbWU6ICdrdW1hLXV4Zm9ybS1zcGxpdCcgfSxcbiAgICAgICAgICAgICAgICAgICAgJy0nXG4gICAgICAgICAgICAgICAgKSk7XG5cbiAgICAgICAgICAgICAgICBhcnIucHVzaChSZWFjdC5jcmVhdGVFbGVtZW50KENhbGVuZGFyLCBfZXh0ZW5kcyh7XG4gICAgICAgICAgICAgICAgICAgIGtleTogJ2NhbGVuZGFyMicsXG4gICAgICAgICAgICAgICAgICAgIG9uU2VsZWN0OiBtZS5oYW5kbGVDYXNjYWRlQ2hhbmdlLmJpbmQobWUsIDEpLFxuICAgICAgICAgICAgICAgICAgICBkaXNhYmxlZERhdGU6IGZ1bmN0aW9uIGRpc2FibGVkRGF0ZShjdXJyZW50LCB2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5vdyA9IG1lLnByb2Nlc3NUaW1lKGN1cnJlbnQuZ2V0VGltZSgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmaXJzdCA9IG1lLnN0YXRlLnZhbHVlID8gbWUuc3RhdGUudmFsdWVbMF0gOiAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgZmlyc3QgPSBtZS5wcm9jZXNzVGltZShmaXJzdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbm93IDwgZnJvbSB8fCBub3cgPiB0byB8fCBub3cgPCBmaXJzdDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sIG90aGVyczIpKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFycjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChtb2RlID09IENvbnN0YW50cy5NT0RFLlZJRVcpIHtcbiAgICAgICAgICAgIHZhciBfcmV0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBkZWZhdXRGb3JtYXQgPSAnWVlZWS1NTS1ERCc7XG4gICAgICAgICAgICAgICAgaWYgKG1lLnByb3BzLnNob3dUaW1lIHx8IG1lLnByb3BzLnRpbWVQaWNrZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVmYXV0Rm9ybWF0ID0gJ1lZWVktTU0tREQgSEg6bW06c3MnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoanN4dHlwZSA9PSBcInNpbmdsZVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2OiBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdzcGFuJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICEhbWUuc3RhdGUudmFsdWUgPyBGb3JtYXR0ZXIuZGF0ZShtZS5zdGF0ZS52YWx1ZSwgbWUucHJvcHMuZm9ybWF0IHx8IGRlZmF1dEZvcm1hdCkgOiBcIlwiXG4gICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHY6IFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3NwYW4nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgISFtZS5zdGF0ZS52YWx1ZSA/IG1lLnN0YXRlLnZhbHVlLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gRm9ybWF0dGVyLmRhdGUoaXRlbSwgbWUucHJvcHMuZm9ybWF0IHx8IGRlZmF1dEZvcm1hdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkuam9pbihcIiAtIFwiKSA6IFwiXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KCk7XG5cbiAgICAgICAgICAgIGlmICgodHlwZW9mIF9yZXQgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKF9yZXQpKSA9PT0gXCJvYmplY3RcIikgcmV0dXJuIF9yZXQudjtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICByZXR1cm4gRGF0ZUZvcm1GaWVsZDtcbn0oRm9ybUZpZWxkKTtcblxuRGF0ZUZvcm1GaWVsZC5kaXNwbGF5TmFtZSA9IFwiRGF0ZUZvcm1GaWVsZFwiO1xuRGF0ZUZvcm1GaWVsZC5wcm9wVHlwZXMgPSBhc3NpZ24oRm9ybUZpZWxkLnByb3BUeXBlcywge1xuICAgIGpzeHR5cGU6IFJlYWN0LlByb3BUeXBlcy5zdHJpbmdcbn0pO1xuRGF0ZUZvcm1GaWVsZC5kZWZhdWx0UHJvcHMgPSBhc3NpZ24oRm9ybUZpZWxkLmRlZmF1bHRQcm9wcywge1xuICAgIGxvY2FsZTogJ3poLWNuJyxcbiAgICBoYXNUcmlnZ2VyOiB0cnVlLFxuICAgIGpzeHR5cGU6IFwic2luZ2xlXCJcbn0pO1xubW9kdWxlLmV4cG9ydHMgPSBEYXRlRm9ybUZpZWxkO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3V4Y29yZS1mb3JtL34vdXhjb3JlLWRhdGUtZm9ybS1maWVsZC9idWlsZC9EYXRlRm9ybUZpZWxkLmpzXG4gKiogbW9kdWxlIGlkID0gMzc1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQ2FsZW5kYXIgQ29tcG9uZW50IGZvciB1eGNvcmVcbiAqIEBhdXRob3IgXG4gKlxuICogQ29weXJpZ2h0IDIwMTQtMjAxNSwgVXhjb3JlIFRlYW0sIEFsaW53LlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vQ2FsZW5kYXInKTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi91eGNvcmUtZm9ybS9+L3V4Y29yZS1kYXRlLWZvcm0tZmllbGQvfi91eGNvcmUtY2FsZW5kYXIvYnVpbGQvaW5kZXguanNcbiAqKiBtb2R1bGUgaWQgPSAzNzZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgUmNDYWxlbmRhciA9IHJlcXVpcmUoJy4vUmNDYWxlbmRhcicpO1xudmFyIEdyZWdvcmlhbkNhbGVuZGFyID0gcmVxdWlyZSgnZ3JlZ29yaWFuLWNhbGVuZGFyJyk7XG52YXIgRGF0ZVRpbWVGb3JtYXQgPSByZXF1aXJlKCdncmVnb3JpYW4tY2FsZW5kYXItZm9ybWF0Jyk7XG52YXIgRGF0ZXBpY2tlciA9IHJlcXVpcmUoJ3JjLWNhbGVuZGFyL2xpYi9QaWNrZXInKTtcbnZhciBSY01vbnRoQ2FsZW5kYXIgPSByZXF1aXJlKCdyYy1jYWxlbmRhci9saWIvTW9udGhDYWxlbmRhcicpO1xudmFyIFJjWWVhckNhbGVuZGFyID0gcmVxdWlyZSgnLi9ZZWFyQ2FsZW5kYXInKTtcbnZhciBUaW1lUGlja2VyID0gcmVxdWlyZSgncmMtdGltZS1waWNrZXInKTtcbnZhciB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG52YXIgUmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xuXG52YXIgZGVmYXVsdFZhbHVlTG9jYWxlID0ge307XG52YXIgQ2FsZW5kYXJMb2NhbGUgPSB7fTtcbnZhciBUaW1lUGlja2VyTG9jYWxlID0ge307XG5kZWZhdWx0VmFsdWVMb2NhbGVbJ3poLWNuJ10gPSByZXF1aXJlKCdncmVnb3JpYW4tY2FsZW5kYXIvbGliL2xvY2FsZS96aF9DTicpO1xuZGVmYXVsdFZhbHVlTG9jYWxlWydlbi11cyddID0gcmVxdWlyZSgnZ3JlZ29yaWFuLWNhbGVuZGFyL2xpYi9sb2NhbGUvZW5fVVMnKTtcbkNhbGVuZGFyTG9jYWxlWyd6aC1jbiddID0gcmVxdWlyZSgncmMtY2FsZW5kYXIvbGliL2xvY2FsZS96aF9DTicpO1xuQ2FsZW5kYXJMb2NhbGVbJ2VuLXVzJ10gPSByZXF1aXJlKCdyYy1jYWxlbmRhci9saWIvbG9jYWxlL2VuX1VTJyk7XG5UaW1lUGlja2VyTG9jYWxlWyd6aC1jbiddID0gcmVxdWlyZSgncmMtdGltZS1waWNrZXIvbGliL2xvY2FsZS96aF9DTicpO1xuVGltZVBpY2tlckxvY2FsZVsnZW4tdXMnXSA9IHJlcXVpcmUoJ3JjLXRpbWUtcGlja2VyL2xpYi9sb2NhbGUvZW5fVVMnKTtcblxuZnVuY3Rpb24gZ2V0R3JlZ29yaWFuQ2FsZW5kYXJEYXRlKGRhdGUsIGxvY2FsZSkge1xuICAgIGRlZmF1bHRWYWx1ZUxvY2FsZVtsb2NhbGVdLnRpbWV6b25lT2Zmc2V0ID0gLW5ldyBEYXRlKCkuZ2V0VGltZXpvbmVPZmZzZXQoKTtcbiAgICB2YXIgdmFsdWUgPSBuZXcgR3JlZ29yaWFuQ2FsZW5kYXIoZGVmYXVsdFZhbHVlTG9jYWxlW2xvY2FsZV0pO1xuICAgIHZhbHVlLnNldFRpbWUobmV3IERhdGUoZGF0ZSkudmFsdWVPZigpKTtcbiAgICByZXR1cm4gdmFsdWU7XG59XG5cbmZ1bmN0aW9uIGdldENhbGVuZGFyQ29udGFpbmVyKCkge1xuICAgIHZhciBjID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgYy5jbGFzc05hbWUgPSAndXhjb3JlJztcbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGMpO1xuICAgIHJldHVybiBjO1xufVxuXG52YXIgQ2FsZW5kYXIgPSBmdW5jdGlvbiAoX1JlYWN0JENvbXBvbmVudCkge1xuICAgIF9pbmhlcml0cyhDYWxlbmRhciwgX1JlYWN0JENvbXBvbmVudCk7XG5cbiAgICBmdW5jdGlvbiBDYWxlbmRhcihwcm9wcykge1xuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQ2FsZW5kYXIpO1xuXG4gICAgICAgIHZhciBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9SZWFjdCRDb21wb25lbnQuY2FsbCh0aGlzLCBwcm9wcykpO1xuXG4gICAgICAgIF90aGlzLnN0YXRlID0ge307XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG5cbiAgICBDYWxlbmRhci5wcm90b3R5cGUuY29tcG9uZW50V2lsbE1vdW50ID0gZnVuY3Rpb24gY29tcG9uZW50V2lsbE1vdW50KCkge1xuICAgICAgICB2YXIgbWUgPSB0aGlzO1xuICAgICAgICBtZS5UaW1lUGlja2VyRWxlbWVudCA9IFJlYWN0LmNyZWF0ZUVsZW1lbnQoVGltZVBpY2tlciwgeyBwcmVmaXhDbHM6ICdrdW1hLXRpbWUtcGlja2VyJywgbG9jYWxlOiBUaW1lUGlja2VyTG9jYWxlW21lLnByb3BzLmxvY2FsZV0gfSk7XG4gICAgfTtcblxuICAgIENhbGVuZGFyLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICAgIHZhciBtZSA9IHRoaXM7XG4gICAgICAgIHZhciBwID0gbWUucHJvcHM7XG4gICAgICAgIHZhciBmb3JtYXR0ZXIgPSBuZXcgRGF0ZVRpbWVGb3JtYXQocC5mb3JtYXQpO1xuICAgICAgICB2YXIgY2FsZW5kYXJPcHRpb25zID0ge1xuICAgICAgICAgICAgY2xhc3NOYW1lOiBwLmNsYXNzTmFtZSxcbiAgICAgICAgICAgIHN0eWxlOiBwLnN0eWxlLFxuICAgICAgICAgICAgY29udGVudFJlbmRlcjogcC5jb250ZW50UmVuZGVyLFxuICAgICAgICAgICAgZGlzYWJsZWREYXRlOiBwLmRpc2FibGVkRGF0ZSxcbiAgICAgICAgICAgIHNob3dXZWVrTnVtYmVyOiBwLnNob3dXZWVrTnVtYmVyLFxuICAgICAgICAgICAgc2hvd1RvZGF5OiBwLnNob3dUb2RheSxcbiAgICAgICAgICAgIHRpbWVQaWNrZXI6IHAudGltZVBpY2tlciA/IHAudGltZVBpY2tlciA6IHAuc2hvd1RpbWUgPyBtZS5UaW1lUGlja2VyRWxlbWVudCA6IG51bGwsXG4gICAgICAgICAgICBzaG93RGF0ZUlucHV0OiBwLnNob3dEYXRlSW5wdXQsXG4gICAgICAgICAgICBsb2NhbGU6IENhbGVuZGFyTG9jYWxlW3AubG9jYWxlXSxcbiAgICAgICAgICAgIHByZWZpeENsczogJ2t1bWEtY2FsZW5kYXInXG4gICAgICAgIH07XG4gICAgICAgIHZhciBwaWNrZXJPcHRpb25zID0ge1xuICAgICAgICAgICAgZGlzYWJsZWQ6IHAuZGlzYWJsZWQsXG4gICAgICAgICAgICBmb3JtYXR0ZXI6IGZvcm1hdHRlcixcbiAgICAgICAgICAgIGFsaWduOiBwLmFsaWduLFxuICAgICAgICAgICAgdHJhbnNpdGlvbk5hbWU6IHAudHJhbnNpdGlvbk5hbWUsXG4gICAgICAgICAgICBhZGp1c3RPcmllbnRPbkNhbGVuZGFyT3ZlcmZsb3c6IGZhbHNlLFxuICAgICAgICAgICAgcHJlZml4Q2xzOiAna3VtYS1jYWxlbmRhci1waWNrZXInLFxuICAgICAgICAgICAgcGxhY2VtZW50OiAnYm90dG9tTGVmdCcsXG4gICAgICAgICAgICBnZXRDYWxlbmRhckNvbnRhaW5lcjogcC5nZXRQb3B1cENvbnRhaW5lciB8fCBnZXRDYWxlbmRhckNvbnRhaW5lclxuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChwLnZhbHVlKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBnZXRHcmVnb3JpYW5DYWxlbmRhckRhdGUocC52YWx1ZSwgcC5sb2NhbGUpO1xuICAgICAgICAgICAgcGlja2VyT3B0aW9ucy52YWx1ZSA9IGNhbGVuZGFyT3B0aW9ucy5kZWZhdWx0VmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBpY2tlck9wdGlvbnMudmFsdWUgPSBjYWxlbmRhck9wdGlvbnMuZGVmYXVsdFZhbHVlID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwLmRlZmF1bHRWYWx1ZSkge1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gZ2V0R3JlZ29yaWFuQ2FsZW5kYXJEYXRlKHAuZGVmYXVsdFZhbHVlLCBwLmxvY2FsZSk7XG4gICAgICAgICAgICBjYWxlbmRhck9wdGlvbnMuZGVmYXVsdFZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICBwaWNrZXJPcHRpb25zLmRlZmF1bHRWYWx1ZSA9IHZhbHVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gZ2V0R3JlZ29yaWFuQ2FsZW5kYXJEYXRlKG5ldyBEYXRlKCkuZ2V0VGltZSgpLCBwLmxvY2FsZSk7XG4gICAgICAgICAgICBjYWxlbmRhck9wdGlvbnMuZGVmYXVsdFZhbHVlID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHAuaGFzVHJpZ2dlcikge1xuICAgICAgICAgICAgcGlja2VyT3B0aW9ucy50cmlnZ2VyID0gUmVhY3QuY3JlYXRlRWxlbWVudCgnaScsIHsgY2xhc3NOYW1lOiAna3VtYS1pY29uIGt1bWEtaWNvbi1jYWxlbmRlcicgfSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgY2FsZW5kYXIgPSBSZWFjdC5jcmVhdGVFbGVtZW50KFJjQ2FsZW5kYXIsIGNhbGVuZGFyT3B0aW9ucyk7XG5cbiAgICAgICAgZnVuY3Rpb24gX29uQ2hhbmdlKHYpIHtcbiAgICAgICAgICAgIGlmICh2KSB7XG4gICAgICAgICAgICAgICAgdmFyIGRhdGUgPSB2LmdldFRpbWUoKTtcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBnZXRHcmVnb3JpYW5DYWxlbmRhckRhdGUoZGF0ZSwgcC5sb2NhbGUpO1xuICAgICAgICAgICAgICAgIHRoaXMucHJvcHMub25TZWxlY3QobmV3IERhdGUoZGF0ZSksIGZvcm1hdHRlci5mb3JtYXQodmFsdWUpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wcm9wcy5vblNlbGVjdCh2LCB2KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICAgRGF0ZXBpY2tlcixcbiAgICAgICAgICAgIF9leHRlbmRzKHtcbiAgICAgICAgICAgICAgICBjYWxlbmRhcjogY2FsZW5kYXIsXG4gICAgICAgICAgICAgICAgb25DaGFuZ2U6IF9vbkNoYW5nZS5iaW5kKG1lKVxuICAgICAgICAgICAgfSwgcGlja2VyT3B0aW9ucyksXG4gICAgICAgICAgICBmdW5jdGlvbiAoX3JlZikge1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IF9yZWYudmFsdWU7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAgICAgICAgICAgJ3NwYW4nLFxuICAgICAgICAgICAgICAgICAgICB7IGNsYXNzTmFtZTogJ2t1bWEtY2FsZW5kYXItcGlja2VyLWlucHV0JyB9LFxuICAgICAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KCdpbnB1dCcsIHsgdmFsdWU6IHZhbHVlICYmIGZvcm1hdHRlci5mb3JtYXQodmFsdWUpLCByZWFkT25seTogdHJ1ZSwgZGlzYWJsZWQ6IG1lLnByb3BzLmRpc2FibGVkLCBwbGFjZWhvbGRlcjogX3RoaXMyLnByb3BzLnBsYWNlaG9sZGVyLCBjbGFzc05hbWU6ICdrdW1hLWlucHV0JyB9KSxcbiAgICAgICAgICAgICAgICAgICAgcC5oYXNUcmlnZ2VyID8gUmVhY3QuY3JlYXRlRWxlbWVudCgnaScsIHsgY2xhc3NOYW1lOiAna3VtYS1pY29uIGt1bWEtaWNvbi1jYWxlbmRlcicgfSkgOiBudWxsXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIENhbGVuZGFyO1xufShSZWFjdC5Db21wb25lbnQpO1xuXG5DYWxlbmRhci5kaXNwbGF5TmFtZSA9ICdDYWxlbmRhcic7XG5DYWxlbmRhci5kZWZhdWx0UHJvcHMgPSB7XG4gICAgZm9ybWF0OiAneXl5eS1NTS1kZCcsXG4gICAgcGxhY2Vob2xkZXI6ICfor7fpgInmi6nml6XmnJ8nLFxuICAgIG9uU2VsZWN0OiBmdW5jdGlvbiBvblNlbGVjdCgpIHt9LFxuICAgIGxvY2FsZTogJ3poLWNuJyxcbiAgICBhbGlnbjoge1xuICAgICAgICBvZmZzZXQ6IFswLCAwXVxuICAgIH0sXG4gICAgc2hvd0RhdGVJbnB1dDogZmFsc2UsXG4gICAgaGFzVHJpZ2dlcjogdHJ1ZSxcbiAgICB0cmFuc2l0aW9uTmFtZTogJ3NsaWRlVXAnXG59O1xuQ2FsZW5kYXIucHJvcFR5cGVzID0ge1xuICAgIGZvcm1hdDogUmVhY3QuUHJvcFR5cGVzLnN0cmluZyxcbiAgICBwbGFjZWhvbGRlcjogUmVhY3QuUHJvcFR5cGVzLnN0cmluZyxcbiAgICBvblNlbGVjdDogUmVhY3QuUHJvcFR5cGVzLmZ1bmMsXG4gICAgbG9jYWxlOiBSZWFjdC5Qcm9wVHlwZXMuc3RyaW5nLFxuICAgIGhhc1RyaWdnZXI6IFJlYWN0LlByb3BUeXBlcy5ib29sLFxuICAgIGdldFBvcHVwQ29udGFpbmVyOiBSZWFjdC5Qcm9wVHlwZXMuZnVuY1xufTtcblxudmFyIE1vbnRoQ2FsZW5kYXIgPSBmdW5jdGlvbiAoX1JlYWN0JENvbXBvbmVudDIpIHtcbiAgICBfaW5oZXJpdHMoTW9udGhDYWxlbmRhciwgX1JlYWN0JENvbXBvbmVudDIpO1xuXG4gICAgZnVuY3Rpb24gTW9udGhDYWxlbmRhcihwcm9wcykge1xuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTW9udGhDYWxlbmRhcik7XG5cbiAgICAgICAgdmFyIF90aGlzMyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9SZWFjdCRDb21wb25lbnQyLmNhbGwodGhpcywgcHJvcHMpKTtcblxuICAgICAgICBfdGhpczMuc3RhdGUgPSB7fTtcbiAgICAgICAgcmV0dXJuIF90aGlzMztcbiAgICB9XG5cbiAgICBNb250aENhbGVuZGFyLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgICAgIHZhciBfdGhpczQgPSB0aGlzO1xuXG4gICAgICAgIHZhciBtZSA9IHRoaXM7XG4gICAgICAgIHZhciBwID0gbWUucHJvcHM7XG4gICAgICAgIHZhciBmb3JtYXR0ZXIgPSBuZXcgRGF0ZVRpbWVGb3JtYXQocC5mb3JtYXQpO1xuICAgICAgICB2YXIgY2FsZW5kYXJPcHRpb25zID0ge1xuICAgICAgICAgICAgY2xhc3NOYW1lOiBwLmNsYXNzTmFtZSxcbiAgICAgICAgICAgIHN0eWxlOiBwLnN0eWxlLFxuICAgICAgICAgICAgbG9jYWxlOiBDYWxlbmRhckxvY2FsZVtwLmxvY2FsZV0sXG4gICAgICAgICAgICBvcmllbnQ6IFsndG9wJywgJ2xlZnQnXSxcbiAgICAgICAgICAgIHByZWZpeENsczogJ2t1bWEtY2FsZW5kYXInXG4gICAgICAgIH07XG4gICAgICAgIHZhciBwaWNrZXJPcHRpb25zID0ge1xuICAgICAgICAgICAgZGlzYWJsZWQ6IHAuZGlzYWJsZWQsXG4gICAgICAgICAgICBhbGlnbjogcC5hbGlnbixcbiAgICAgICAgICAgIHRyYW5zaXRpb25OYW1lOiBwLnRyYW5zaXRpb25OYW1lLFxuICAgICAgICAgICAgZm9ybWF0dGVyOiBmb3JtYXR0ZXIsXG4gICAgICAgICAgICBhZGp1c3RPcmllbnRPbkNhbGVuZGFyT3ZlcmZsb3c6IGZhbHNlLFxuICAgICAgICAgICAgcHJlZml4Q2xzOiAna3VtYS1jYWxlbmRhci1waWNrZXInLFxuICAgICAgICAgICAgZ2V0Q2FsZW5kYXJDb250YWluZXI6IHAuZ2V0UG9wdXBDb250YWluZXIgfHwgZ2V0Q2FsZW5kYXJDb250YWluZXJcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAocC52YWx1ZSkge1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gZ2V0R3JlZ29yaWFuQ2FsZW5kYXJEYXRlKHAudmFsdWUsIHAubG9jYWxlKTtcbiAgICAgICAgICAgIHBpY2tlck9wdGlvbnMudmFsdWUgPSBjYWxlbmRhck9wdGlvbnMuZGVmYXVsdFZhbHVlID0gdmFsdWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwaWNrZXJPcHRpb25zLnZhbHVlID0gY2FsZW5kYXJPcHRpb25zLmRlZmF1bHRWYWx1ZSA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocC5kZWZhdWx0VmFsdWUpIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IGdldEdyZWdvcmlhbkNhbGVuZGFyRGF0ZShwLmRlZmF1bHRWYWx1ZSwgcC5sb2NhbGUpO1xuICAgICAgICAgICAgY2FsZW5kYXJPcHRpb25zLmRlZmF1bHRWYWx1ZSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjYWxlbmRhciA9IFJlYWN0LmNyZWF0ZUVsZW1lbnQoUmNNb250aENhbGVuZGFyLCBjYWxlbmRhck9wdGlvbnMpO1xuXG4gICAgICAgIGZ1bmN0aW9uIF9vbkNoYW5nZSh2KSB7XG4gICAgICAgICAgICB2YXIgZGF0ZSA9IHYuZ2V0VGltZSgpO1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gZ2V0R3JlZ29yaWFuQ2FsZW5kYXJEYXRlKGRhdGUsIHAubG9jYWxlKTtcbiAgICAgICAgICAgIHRoaXMucHJvcHMub25TZWxlY3QobmV3IERhdGUoZGF0ZSksIGZvcm1hdHRlci5mb3JtYXQodmFsdWUpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICAgRGF0ZXBpY2tlcixcbiAgICAgICAgICAgIF9leHRlbmRzKHtcbiAgICAgICAgICAgICAgICBjYWxlbmRhcjogY2FsZW5kYXIsXG4gICAgICAgICAgICAgICAgb25DaGFuZ2U6IF9vbkNoYW5nZS5iaW5kKG1lKVxuICAgICAgICAgICAgfSwgcGlja2VyT3B0aW9ucyksXG4gICAgICAgICAgICBmdW5jdGlvbiAoX3JlZjIpIHtcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBfcmVmMi52YWx1ZTtcblxuICAgICAgICAgICAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICAgICAgICAgICAnc3BhbicsXG4gICAgICAgICAgICAgICAgICAgIHsgY2xhc3NOYW1lOiAna3VtYS1jYWxlbmRhci1waWNrZXItaW5wdXQnIH0sXG4gICAgICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoJ2lucHV0JywgeyB2YWx1ZTogdmFsdWUgJiYgZm9ybWF0dGVyLmZvcm1hdCh2YWx1ZSksIHJlYWRPbmx5OiB0cnVlLCBkaXNhYmxlZDogbWUucHJvcHMuZGlzYWJsZWQsIHBsYWNlaG9sZGVyOiBfdGhpczQucHJvcHMucGxhY2Vob2xkZXIsIGNsYXNzTmFtZTogJ2t1bWEtaW5wdXQnIH0pLFxuICAgICAgICAgICAgICAgICAgICBwLmhhc1RyaWdnZXIgPyBSZWFjdC5jcmVhdGVFbGVtZW50KCdpJywgeyBjbGFzc05hbWU6ICdrdW1hLWljb24ga3VtYS1pY29uLWNhbGVuZGVyJyB9KSA6IG51bGxcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICApO1xuICAgIH07XG5cbiAgICByZXR1cm4gTW9udGhDYWxlbmRhcjtcbn0oUmVhY3QuQ29tcG9uZW50KTtcblxuTW9udGhDYWxlbmRhci5kaXNwbGF5TmFtZSA9ICdNb250aENhbGVuZGFyJztcbk1vbnRoQ2FsZW5kYXIuZGVmYXVsdFByb3BzID0ge1xuICAgIGZvcm1hdDogJ3l5eXktTU0nLFxuICAgIHBsYWNlaG9sZGVyOiAn6K+36YCJ5oup5pyI5Lu9JyxcbiAgICBvblNlbGVjdDogZnVuY3Rpb24gb25TZWxlY3QoKSB7fSxcbiAgICBsb2NhbGU6ICd6aC1jbicsXG4gICAgdHJhbnNpdGlvbk5hbWU6ICdzbGlkZVVwJyxcbiAgICBhbGlnbjoge1xuICAgICAgICBvZmZzZXQ6IFswLCAwXVxuICAgIH0sXG4gICAgc2hvd0RhdGVJbnB1dDogZmFsc2UsXG4gICAgaGFzVHJpZ2dlcjogdHJ1ZVxufTtcbk1vbnRoQ2FsZW5kYXIucHJvcFR5cGVzID0ge1xuICAgIGZvcm1hdDogUmVhY3QuUHJvcFR5cGVzLnN0cmluZyxcbiAgICBwbGFjZWhvbGRlcjogUmVhY3QuUHJvcFR5cGVzLnN0cmluZyxcbiAgICBvblNlbGVjdDogUmVhY3QuUHJvcFR5cGVzLmZ1bmMsXG4gICAgbG9jYWxlOiBSZWFjdC5Qcm9wVHlwZXMuc3RyaW5nLFxuICAgIGdldFBvcHVwQ29udGFpbmVyOiBSZWFjdC5Qcm9wVHlwZXMuZnVuY1xufTtcblxudmFyIFllYXJDYWxlbmRhciA9IGZ1bmN0aW9uIChfUmVhY3QkQ29tcG9uZW50Mykge1xuICAgIF9pbmhlcml0cyhZZWFyQ2FsZW5kYXIsIF9SZWFjdCRDb21wb25lbnQzKTtcblxuICAgIGZ1bmN0aW9uIFllYXJDYWxlbmRhcihwcm9wcykge1xuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgWWVhckNhbGVuZGFyKTtcblxuICAgICAgICB2YXIgX3RoaXM1ID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX1JlYWN0JENvbXBvbmVudDMuY2FsbCh0aGlzLCBwcm9wcykpO1xuXG4gICAgICAgIF90aGlzNS5zdGF0ZSA9IHt9O1xuICAgICAgICByZXR1cm4gX3RoaXM1O1xuICAgIH1cblxuICAgIFllYXJDYWxlbmRhci5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgICAgICB2YXIgX3RoaXM2ID0gdGhpcztcblxuICAgICAgICB2YXIgbWUgPSB0aGlzO1xuICAgICAgICB2YXIgcCA9IG1lLnByb3BzO1xuICAgICAgICB2YXIgZm9ybWF0dGVyID0gbmV3IERhdGVUaW1lRm9ybWF0KHAuZm9ybWF0KTtcbiAgICAgICAgdmFyIGNhbGVuZGFyT3B0aW9ucyA9IHtcbiAgICAgICAgICAgIGNsYXNzTmFtZTogcC5jbGFzc05hbWUsXG4gICAgICAgICAgICBzdHlsZTogcC5zdHlsZSxcbiAgICAgICAgICAgIGxvY2FsZTogQ2FsZW5kYXJMb2NhbGVbcC5sb2NhbGVdLFxuICAgICAgICAgICAgb3JpZW50OiBbJ3RvcCcsICdsZWZ0J10sXG4gICAgICAgICAgICBwcmVmaXhDbHM6ICdrdW1hLWNhbGVuZGFyJ1xuICAgICAgICB9O1xuICAgICAgICB2YXIgcGlja2VyT3B0aW9ucyA9IHtcbiAgICAgICAgICAgIGRpc2FibGVkOiBwLmRpc2FibGVkLFxuICAgICAgICAgICAgYWxpZ246IHAuYWxpZ24sXG4gICAgICAgICAgICBmb3JtYXR0ZXI6IGZvcm1hdHRlcixcbiAgICAgICAgICAgIHRyYW5zaXRpb25OYW1lOiBwLnRyYW5zaXRpb25OYW1lLFxuICAgICAgICAgICAgYWRqdXN0T3JpZW50T25DYWxlbmRhck92ZXJmbG93OiBmYWxzZSxcbiAgICAgICAgICAgIHByZWZpeENsczogJ2t1bWEtY2FsZW5kYXItcGlja2VyJyxcbiAgICAgICAgICAgIGdldENhbGVuZGFyQ29udGFpbmVyOiBwLmdldFBvcHVwQ29udGFpbmVyIHx8IGdldENhbGVuZGFyQ29udGFpbmVyXG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKHAudmFsdWUpIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IGdldEdyZWdvcmlhbkNhbGVuZGFyRGF0ZShwLnZhbHVlLCBwLmxvY2FsZSk7XG4gICAgICAgICAgICBwaWNrZXJPcHRpb25zLnZhbHVlID0gY2FsZW5kYXJPcHRpb25zLmRlZmF1bHRWYWx1ZSA9IHZhbHVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGlja2VyT3B0aW9ucy52YWx1ZSA9IGNhbGVuZGFyT3B0aW9ucy5kZWZhdWx0VmFsdWUgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHAuZGVmYXVsdFZhbHVlKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBnZXRHcmVnb3JpYW5DYWxlbmRhckRhdGUocC5kZWZhdWx0VmFsdWUsIHAubG9jYWxlKTtcbiAgICAgICAgICAgIGNhbGVuZGFyT3B0aW9ucy5kZWZhdWx0VmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY2FsZW5kYXIgPSBSZWFjdC5jcmVhdGVFbGVtZW50KFJjWWVhckNhbGVuZGFyLCBjYWxlbmRhck9wdGlvbnMpO1xuXG4gICAgICAgIGZ1bmN0aW9uIF9vbkNoYW5nZSh2KSB7XG4gICAgICAgICAgICB2YXIgZGF0ZSA9IHYuZ2V0VGltZSgpO1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gZ2V0R3JlZ29yaWFuQ2FsZW5kYXJEYXRlKGRhdGUsIHAubG9jYWxlKTtcbiAgICAgICAgICAgIHRoaXMucHJvcHMub25TZWxlY3QobmV3IERhdGUoZGF0ZSksIGZvcm1hdHRlci5mb3JtYXQodmFsdWUpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICAgRGF0ZXBpY2tlcixcbiAgICAgICAgICAgIF9leHRlbmRzKHtcbiAgICAgICAgICAgICAgICBjYWxlbmRhcjogY2FsZW5kYXIsXG4gICAgICAgICAgICAgICAgb25DaGFuZ2U6IF9vbkNoYW5nZS5iaW5kKG1lKVxuICAgICAgICAgICAgfSwgcGlja2VyT3B0aW9ucyksXG4gICAgICAgICAgICBmdW5jdGlvbiAoX3JlZjMpIHtcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBfcmVmMy52YWx1ZTtcblxuICAgICAgICAgICAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICAgICAgICAgICAnc3BhbicsXG4gICAgICAgICAgICAgICAgICAgIHsgY2xhc3NOYW1lOiAna3VtYS1jYWxlbmRhci1waWNrZXItaW5wdXQnIH0sXG4gICAgICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoJ2lucHV0JywgeyB2YWx1ZTogdmFsdWUgJiYgZm9ybWF0dGVyLmZvcm1hdCh2YWx1ZSksIHJlYWRPbmx5OiB0cnVlLCBkaXNhYmxlZDogbWUucHJvcHMuZGlzYWJsZWQsIHBsYWNlaG9sZGVyOiBfdGhpczYucHJvcHMucGxhY2Vob2xkZXIsIGNsYXNzTmFtZTogJ2t1bWEtaW5wdXQnIH0pLFxuICAgICAgICAgICAgICAgICAgICBwLmhhc1RyaWdnZXIgPyBSZWFjdC5jcmVhdGVFbGVtZW50KCdpJywgeyBjbGFzc05hbWU6ICdrdW1hLWljb24ga3VtYS1pY29uLWNhbGVuZGVyJyB9KSA6IG51bGxcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICApO1xuICAgIH07XG5cbiAgICByZXR1cm4gWWVhckNhbGVuZGFyO1xufShSZWFjdC5Db21wb25lbnQpO1xuXG5ZZWFyQ2FsZW5kYXIuZGlzcGxheU5hbWUgPSAnWWVhckNhbGVuZGFyJztcblllYXJDYWxlbmRhci5kZWZhdWx0UHJvcHMgPSB7XG4gICAgZm9ybWF0OiAneXl5eScsXG4gICAgcGxhY2Vob2xkZXI6ICfor7fpgInmi6nlubTku70nLFxuICAgIG9uU2VsZWN0OiBmdW5jdGlvbiBvblNlbGVjdCgpIHt9LFxuICAgIGxvY2FsZTogJ3poLWNuJyxcbiAgICB0cmFuc2l0aW9uTmFtZTogJ3NsaWRlVXAnLFxuICAgIGFsaWduOiB7XG4gICAgICAgIG9mZnNldDogWzAsIDBdXG4gICAgfSxcbiAgICBzaG93RGF0ZUlucHV0OiBmYWxzZSxcbiAgICBoYXNUcmlnZ2VyOiB0cnVlXG59O1xuWWVhckNhbGVuZGFyLnByb3BUeXBlcyA9IHtcbiAgICBmb3JtYXQ6IFJlYWN0LlByb3BUeXBlcy5zdHJpbmcsXG4gICAgcGxhY2Vob2xkZXI6IFJlYWN0LlByb3BUeXBlcy5zdHJpbmcsXG4gICAgb25TZWxlY3Q6IFJlYWN0LlByb3BUeXBlcy5mdW5jLFxuICAgIGxvY2FsZTogUmVhY3QuUHJvcFR5cGVzLnN0cmluZyxcbiAgICBnZXRQb3B1cENvbnRhaW5lcjogUmVhY3QuUHJvcFR5cGVzLmZ1bmNcbn07XG5cbkNhbGVuZGFyLk1vbnRoQ2FsZW5kYXIgPSBNb250aENhbGVuZGFyO1xuQ2FsZW5kYXIuWWVhckNhbGVuZGFyID0gWWVhckNhbGVuZGFyO1xuQ2FsZW5kYXIuQ2FsZW5kYXJQYW5lbCA9IFJjQ2FsZW5kYXI7XG5DYWxlbmRhci51dGlsID0gdXRpbDtcblxubW9kdWxlLmV4cG9ydHMgPSBDYWxlbmRhcjtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi91eGNvcmUtZm9ybS9+L3V4Y29yZS1kYXRlLWZvcm0tZmllbGQvfi91eGNvcmUtY2FsZW5kYXIvYnVpbGQvQ2FsZW5kYXIuanNcbiAqKiBtb2R1bGUgaWQgPSAzNzdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9yZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5cbnZhciBfcmVhY3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmVhY3QpO1xuXG52YXIgX2dyZWdvcmlhbkNhbGVuZGFyID0gcmVxdWlyZSgnZ3JlZ29yaWFuLWNhbGVuZGFyJyk7XG5cbnZhciBfZ3JlZ29yaWFuQ2FsZW5kYXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZ3JlZ29yaWFuQ2FsZW5kYXIpO1xuXG52YXIgX3JjVXRpbCA9IHJlcXVpcmUoJ3JjLXV0aWwnKTtcblxudmFyIF9EYXRlVGFibGUgPSByZXF1aXJlKCcuL2RhdGUvRGF0ZVRhYmxlJyk7XG5cbnZhciBfRGF0ZVRhYmxlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0RhdGVUYWJsZSk7XG5cbnZhciBfQ2FsZW5kYXJIZWFkZXIgPSByZXF1aXJlKCdyYy1jYWxlbmRhci9saWIvY2FsZW5kYXIvQ2FsZW5kYXJIZWFkZXInKTtcblxudmFyIF9DYWxlbmRhckhlYWRlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9DYWxlbmRhckhlYWRlcik7XG5cbnZhciBfQ2FsZW5kYXJGb290ZXIgPSByZXF1aXJlKCdyYy1jYWxlbmRhci9saWIvY2FsZW5kYXIvQ2FsZW5kYXJGb290ZXInKTtcblxudmFyIF9DYWxlbmRhckZvb3RlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9DYWxlbmRhckZvb3Rlcik7XG5cbnZhciBfQ2FsZW5kYXJNaXhpbiA9IHJlcXVpcmUoJ3JjLWNhbGVuZGFyL2xpYi9taXhpbi9DYWxlbmRhck1peGluJyk7XG5cbnZhciBfQ2FsZW5kYXJNaXhpbjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9DYWxlbmRhck1peGluKTtcblxudmFyIF9Db21tb25NaXhpbiA9IHJlcXVpcmUoJ3JjLWNhbGVuZGFyL2xpYi9taXhpbi9Db21tb25NaXhpbicpO1xuXG52YXIgX0NvbW1vbk1peGluMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0NvbW1vbk1peGluKTtcblxudmFyIF9EYXRlSW5wdXQgPSByZXF1aXJlKCdyYy1jYWxlbmRhci9saWIvZGF0ZS9EYXRlSW5wdXQnKTtcblxudmFyIF9EYXRlSW5wdXQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfRGF0ZUlucHV0KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgXCJkZWZhdWx0XCI6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fSAvLyBjdXN0b21pemVkIHJjLWNhbGVuZGFyIGh0dHBzOi8vZ2l0aHViLmNvbS9yZWFjdC1jb21wb25lbnQvY2FsZW5kYXIvYmxvYi9tYXN0ZXIvc3JjL0NhbGVuZGFyLmpzeFxuXG5mdW5jdGlvbiBnb1N0YXJ0TW9udGgoKSB7XG4gIHZhciBuZXh0ID0gdGhpcy5zdGF0ZS52YWx1ZS5jbG9uZSgpO1xuICBuZXh0LnNldERheU9mTW9udGgoMSk7XG4gIHRoaXMuc2V0VmFsdWUobmV4dCk7XG59XG5cbmZ1bmN0aW9uIGdvRW5kTW9udGgoKSB7XG4gIHZhciBuZXh0ID0gdGhpcy5zdGF0ZS52YWx1ZS5jbG9uZSgpO1xuICBuZXh0LnNldERheU9mTW9udGgobmV4dC5nZXRBY3R1YWxNYXhpbXVtKF9ncmVnb3JpYW5DYWxlbmRhcjJbXCJkZWZhdWx0XCJdLk1PTlRIKSk7XG4gIHRoaXMuc2V0VmFsdWUobmV4dCk7XG59XG5cbmZ1bmN0aW9uIGdvTW9udGgoZGlyZWN0aW9uKSB7XG4gIHZhciBuZXh0ID0gdGhpcy5zdGF0ZS52YWx1ZS5jbG9uZSgpO1xuICBuZXh0LmFkZE1vbnRoKGRpcmVjdGlvbik7XG4gIHRoaXMuc2V0VmFsdWUobmV4dCk7XG59XG5cbmZ1bmN0aW9uIGdvWWVhcihkaXJlY3Rpb24pIHtcbiAgdmFyIG5leHQgPSB0aGlzLnN0YXRlLnZhbHVlLmNsb25lKCk7XG4gIG5leHQuYWRkWWVhcihkaXJlY3Rpb24pO1xuICB0aGlzLnNldFZhbHVlKG5leHQpO1xufVxuXG5mdW5jdGlvbiBnb1dlZWsoZGlyZWN0aW9uKSB7XG4gIHZhciBuZXh0ID0gdGhpcy5zdGF0ZS52YWx1ZS5jbG9uZSgpO1xuICBuZXh0LmFkZFdlZWtPZlllYXIoZGlyZWN0aW9uKTtcbiAgdGhpcy5zZXRWYWx1ZShuZXh0KTtcbn1cblxuZnVuY3Rpb24gZ29EYXkoZGlyZWN0aW9uKSB7XG4gIHZhciBuZXh0ID0gdGhpcy5zdGF0ZS52YWx1ZS5jbG9uZSgpO1xuICBuZXh0LmFkZERheU9mTW9udGgoZGlyZWN0aW9uKTtcbiAgdGhpcy5zZXRWYWx1ZShuZXh0KTtcbn1cblxudmFyIENhbGVuZGFyID0gX3JlYWN0MltcImRlZmF1bHRcIl0uY3JlYXRlQ2xhc3Moe1xuICBkaXNwbGF5TmFtZTogJ0NhbGVuZGFyJyxcblxuICBwcm9wVHlwZXM6IHtcbiAgICBkaXNhYmxlZERhdGU6IF9yZWFjdC5Qcm9wVHlwZXMuZnVuYyxcbiAgICBkaXNhYmxlZFRpbWU6IF9yZWFjdC5Qcm9wVHlwZXMuYW55LFxuICAgIHZhbHVlOiBfcmVhY3QuUHJvcFR5cGVzLm9iamVjdCxcbiAgICBzZWxlY3RlZFZhbHVlOiBfcmVhY3QuUHJvcFR5cGVzLm9iamVjdCxcbiAgICBkZWZhdWx0VmFsdWU6IF9yZWFjdC5Qcm9wVHlwZXMub2JqZWN0LFxuICAgIGNsYXNzTmFtZTogX3JlYWN0LlByb3BUeXBlcy5zdHJpbmcsXG4gICAgbG9jYWxlOiBfcmVhY3QuUHJvcFR5cGVzLm9iamVjdCxcbiAgICBzaG93V2Vla051bWJlcjogX3JlYWN0LlByb3BUeXBlcy5ib29sLFxuICAgIHN0eWxlOiBfcmVhY3QuUHJvcFR5cGVzLm9iamVjdCxcbiAgICBzaG93VG9kYXk6IF9yZWFjdC5Qcm9wVHlwZXMuYm9vbCxcbiAgICBzaG93RGF0ZUlucHV0OiBfcmVhY3QuUHJvcFR5cGVzLmJvb2wsXG4gICAgdmlzaWJsZTogX3JlYWN0LlByb3BUeXBlcy5ib29sLFxuICAgIG9uU2VsZWN0OiBfcmVhY3QuUHJvcFR5cGVzLmZ1bmMsXG4gICAgb25PazogX3JlYWN0LlByb3BUeXBlcy5mdW5jLFxuICAgIHNob3dPazogX3JlYWN0LlByb3BUeXBlcy5ib29sLFxuICAgIHByZWZpeENsczogX3JlYWN0LlByb3BUeXBlcy5zdHJpbmcsXG4gICAgb25LZXlEb3duOiBfcmVhY3QuUHJvcFR5cGVzLmZ1bmMsXG4gICAgdGltZVBpY2tlcjogX3JlYWN0LlByb3BUeXBlcy5lbGVtZW50LFxuICAgIGRhdGVJbnB1dFBsYWNlaG9sZGVyOiBfcmVhY3QuUHJvcFR5cGVzLmFueSxcbiAgICBvbkNsZWFyOiBfcmVhY3QuUHJvcFR5cGVzLmZ1bmMsXG4gICAgb25DaGFuZ2U6IF9yZWFjdC5Qcm9wVHlwZXMuZnVuY1xuICB9LFxuXG4gIG1peGluczogW19Db21tb25NaXhpbjJbXCJkZWZhdWx0XCJdLCBfQ2FsZW5kYXJNaXhpbjJbXCJkZWZhdWx0XCJdXSxcblxuICBnZXREZWZhdWx0UHJvcHM6IGZ1bmN0aW9uIGdldERlZmF1bHRQcm9wcygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc2hvd1RvZGF5OiB0cnVlLFxuICAgICAgc2hvd0RhdGVJbnB1dDogdHJ1ZSxcbiAgICAgIHRpbWVQaWNrZXI6IG51bGwsXG4gICAgICBvbk9rOiBub29wXG4gICAgfTtcbiAgfSxcbiAgZ2V0SW5pdGlhbFN0YXRlOiBmdW5jdGlvbiBnZXRJbml0aWFsU3RhdGUoKSB7XG4gICAgLy8gYmluZCBtZXRob2RzXG4gICAgdGhpcy5uZXh0TW9udGggPSBnb01vbnRoLmJpbmQodGhpcywgMSk7XG4gICAgdGhpcy5wcmV2aW91c01vbnRoID0gZ29Nb250aC5iaW5kKHRoaXMsIC0xKTtcbiAgICB0aGlzLm5leHRZZWFyID0gZ29ZZWFyLmJpbmQodGhpcywgMSk7XG4gICAgdGhpcy5wcmV2aW91c1llYXIgPSBnb1llYXIuYmluZCh0aGlzLCAtMSk7XG4gICAgcmV0dXJuIHt9O1xuICB9LFxuICBvbktleURvd246IGZ1bmN0aW9uIG9uS2V5RG93bihldmVudCkge1xuICAgIGlmIChldmVudC50YXJnZXQubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ2lucHV0Jykge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgdmFyIGtleUNvZGUgPSBldmVudC5rZXlDb2RlO1xuICAgIC8vIG1hY1xuICAgIHZhciBjdHJsS2V5ID0gZXZlbnQuY3RybEtleSB8fCBldmVudC5tZXRhS2V5O1xuICAgIHN3aXRjaCAoa2V5Q29kZSkge1xuICAgICAgY2FzZSBfcmNVdGlsLktleUNvZGUuRE9XTjpcbiAgICAgICAgZ29XZWVrLmNhbGwodGhpcywgMSk7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHJldHVybiAxO1xuICAgICAgY2FzZSBfcmNVdGlsLktleUNvZGUuVVA6XG4gICAgICAgIGdvV2Vlay5jYWxsKHRoaXMsIC0xKTtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgICBjYXNlIF9yY1V0aWwuS2V5Q29kZS5MRUZUOlxuICAgICAgICBpZiAoY3RybEtleSkge1xuICAgICAgICAgIHRoaXMucHJldmlvdXNZZWFyKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZ29EYXkuY2FsbCh0aGlzLCAtMSk7XG4gICAgICAgIH1cbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgICBjYXNlIF9yY1V0aWwuS2V5Q29kZS5SSUdIVDpcbiAgICAgICAgaWYgKGN0cmxLZXkpIHtcbiAgICAgICAgICB0aGlzLm5leHRZZWFyKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZ29EYXkuY2FsbCh0aGlzLCAxKTtcbiAgICAgICAgfVxuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICByZXR1cm4gMTtcbiAgICAgIGNhc2UgX3JjVXRpbC5LZXlDb2RlLkhPTUU6XG4gICAgICAgIGdvU3RhcnRNb250aC5jYWxsKHRoaXMpO1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICByZXR1cm4gMTtcbiAgICAgIGNhc2UgX3JjVXRpbC5LZXlDb2RlLkVORDpcbiAgICAgICAgZ29FbmRNb250aC5jYWxsKHRoaXMpO1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICByZXR1cm4gMTtcbiAgICAgIGNhc2UgX3JjVXRpbC5LZXlDb2RlLlBBR0VfRE9XTjpcbiAgICAgICAgdGhpcy5uZXh0TW9udGgoKTtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgICBjYXNlIF9yY1V0aWwuS2V5Q29kZS5QQUdFX1VQOlxuICAgICAgICB0aGlzLnByZXZpb3VzTW9udGgoKTtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgICBjYXNlIF9yY1V0aWwuS2V5Q29kZS5FTlRFUjpcbiAgICAgICAgdGhpcy5vblNlbGVjdCh0aGlzLnN0YXRlLnZhbHVlKTtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aGlzLnByb3BzLm9uS2V5RG93bihldmVudCk7XG4gICAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgfSxcbiAgb25DbGVhcjogZnVuY3Rpb24gb25DbGVhcigpIHtcbiAgICB0aGlzLm9uU2VsZWN0KG51bGwpO1xuICAgIHRoaXMucHJvcHMub25DbGVhcigpO1xuICB9LFxuICBvbk9rOiBmdW5jdGlvbiBvbk9rKCkge1xuICAgIHZhciBzZWxlY3RlZFZhbHVlID0gdGhpcy5zdGF0ZS5zZWxlY3RlZFZhbHVlO1xuXG4gICAgaWYgKHRoaXMuaXNBbGxvd2VkRGF0ZShzZWxlY3RlZFZhbHVlKSkge1xuICAgICAgdGhpcy5wcm9wcy5vbk9rKHNlbGVjdGVkVmFsdWUpO1xuICAgIH1cbiAgfSxcbiAgb25EYXRlSW5wdXRDaGFuZ2U6IGZ1bmN0aW9uIG9uRGF0ZUlucHV0Q2hhbmdlKHZhbHVlKSB7XG4gICAgdGhpcy5vblNlbGVjdCh2YWx1ZSwge1xuICAgICAgc291cmNlOiAnZGF0ZUlucHV0J1xuICAgIH0pO1xuICB9LFxuICBvbkRhdGVUYWJsZVNlbGVjdDogZnVuY3Rpb24gb25EYXRlVGFibGVTZWxlY3QodmFsdWUpIHtcbiAgICB0aGlzLm9uU2VsZWN0KHZhbHVlKTtcbiAgfSxcbiAgY2hvb3NlVG9kYXk6IGZ1bmN0aW9uIGNob29zZVRvZGF5KCkge1xuICAgIHZhciB0b2RheSA9IHRoaXMuc3RhdGUudmFsdWUuY2xvbmUoKTtcbiAgICB0b2RheS5zZXRUaW1lKERhdGUubm93KCkpO1xuICAgIHRoaXMub25TZWxlY3QodG9kYXkpO1xuICB9LFxuICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICB2YXIgcHJvcHMgPSB0aGlzLnByb3BzO1xuICAgIHZhciBsb2NhbGUgPSBwcm9wcy5sb2NhbGU7XG4gICAgdmFyIHByZWZpeENscyA9IHByb3BzLnByZWZpeENscztcbiAgICB2YXIgZGlzYWJsZWREYXRlID0gcHJvcHMuZGlzYWJsZWREYXRlO1xuICAgIHZhciBkYXRlSW5wdXRQbGFjZWhvbGRlciA9IHByb3BzLmRhdGVJbnB1dFBsYWNlaG9sZGVyO1xuICAgIHZhciB0aW1lUGlja2VyID0gcHJvcHMudGltZVBpY2tlcjtcbiAgICB2YXIgZGlzYWJsZWRUaW1lID0gcHJvcHMuZGlzYWJsZWRUaW1lO1xuXG4gICAgdmFyIHN0YXRlID0gdGhpcy5zdGF0ZTtcbiAgICB2YXIgdmFsdWUgPSBzdGF0ZS52YWx1ZTtcbiAgICB2YXIgc2VsZWN0ZWRWYWx1ZSA9IHN0YXRlLnNlbGVjdGVkVmFsdWU7XG5cbiAgICB2YXIgZGF0ZUlucHV0RWxlbWVudCA9IHByb3BzLnNob3dEYXRlSW5wdXQgPyBfcmVhY3QyW1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KF9EYXRlSW5wdXQyW1wiZGVmYXVsdFwiXSwge1xuICAgICAgZm9ybWF0dGVyOiB0aGlzLmdldEZvcm1hdHRlcigpLFxuICAgICAga2V5OiAnZGF0ZS1pbnB1dCcsXG4gICAgICB0aW1lUGlja2VyOiB0aW1lUGlja2VyLFxuICAgICAgZ3JlZ29yaWFuQ2FsZW5kYXJMb2NhbGU6IHZhbHVlLmxvY2FsZSxcbiAgICAgIGxvY2FsZTogbG9jYWxlLFxuICAgICAgcGxhY2Vob2xkZXI6IGRhdGVJbnB1dFBsYWNlaG9sZGVyLFxuICAgICAgc2hvd0NsZWFyOiB0cnVlLFxuICAgICAgZGlzYWJsZWRUaW1lOiBkaXNhYmxlZFRpbWUsXG4gICAgICBkaXNhYmxlZERhdGU6IGRpc2FibGVkRGF0ZSxcbiAgICAgIG9uQ2xlYXI6IHRoaXMub25DbGVhcixcbiAgICAgIHByZWZpeENsczogcHJlZml4Q2xzLFxuICAgICAgc2VsZWN0ZWRWYWx1ZTogc2VsZWN0ZWRWYWx1ZSxcbiAgICAgIG9uQ2hhbmdlOiB0aGlzLm9uRGF0ZUlucHV0Q2hhbmdlXG4gICAgfSkgOiBudWxsO1xuICAgIHZhciBjaGlsZHJlbiA9IFtkYXRlSW5wdXRFbGVtZW50LCBfcmVhY3QyW1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFxuICAgICAgJ2RpdicsXG4gICAgICB7XG4gICAgICAgIGtleTogJ2RhdGUtcGFuZWwnLFxuICAgICAgICBjbGFzc05hbWU6IHByZWZpeENscyArICctZGF0ZS1wYW5lbCdcbiAgICAgIH0sXG4gICAgICBfcmVhY3QyW1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KF9DYWxlbmRhckhlYWRlcjJbXCJkZWZhdWx0XCJdLCB7XG4gICAgICAgIGxvY2FsZTogbG9jYWxlLFxuICAgICAgICBvblZhbHVlQ2hhbmdlOiB0aGlzLnNldFZhbHVlLFxuICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgIHByZWZpeENsczogcHJlZml4Q2xzXG4gICAgICB9KSxcbiAgICAgIF9yZWFjdDJbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICdkaXYnLFxuICAgICAgICB7IGNsYXNzTmFtZTogcHJlZml4Q2xzICsgJy1jYWxlbmRhci1ib2R5JyB9LFxuICAgICAgICBfcmVhY3QyW1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KF9EYXRlVGFibGUyW1wiZGVmYXVsdFwiXSwge1xuICAgICAgICAgIGxvY2FsZTogbG9jYWxlLFxuICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICBzZWxlY3RlZFZhbHVlOiBzZWxlY3RlZFZhbHVlLFxuICAgICAgICAgIHByZWZpeENsczogcHJlZml4Q2xzLFxuICAgICAgICAgIGRhdGVSZW5kZXI6IHByb3BzLmRhdGVSZW5kZXIsXG4gICAgICAgICAgY29udGVudFJlbmRlcjogcHJvcHMuY29udGVudFJlbmRlcixcbiAgICAgICAgICBvblNlbGVjdDogdGhpcy5vbkRhdGVUYWJsZVNlbGVjdCxcbiAgICAgICAgICBkaXNhYmxlZERhdGU6IGRpc2FibGVkRGF0ZSxcbiAgICAgICAgICBzaG93V2Vla051bWJlcjogcHJvcHMuc2hvd1dlZWtOdW1iZXJcbiAgICAgICAgfSlcbiAgICAgICksXG4gICAgICBfcmVhY3QyW1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KF9DYWxlbmRhckZvb3RlcjJbXCJkZWZhdWx0XCJdLCB7XG4gICAgICAgIHNob3dPazogcHJvcHMuc2hvd09rLFxuICAgICAgICBsb2NhbGU6IGxvY2FsZSxcbiAgICAgICAgcHJlZml4Q2xzOiBwcmVmaXhDbHMsXG4gICAgICAgIHNob3dUb2RheTogcHJvcHMuc2hvd1RvZGF5LFxuICAgICAgICBkaXNhYmxlZFRpbWU6IGRpc2FibGVkVGltZSxcbiAgICAgICAgZ3JlZ29yaWFuQ2FsZW5kYXJMb2NhbGU6IHZhbHVlLmxvY2FsZSxcbiAgICAgICAgc2hvd0RhdGVJbnB1dDogcHJvcHMuc2hvd0RhdGVJbnB1dCxcbiAgICAgICAgdGltZVBpY2tlcjogdGltZVBpY2tlcixcbiAgICAgICAgc2VsZWN0ZWRWYWx1ZTogc2VsZWN0ZWRWYWx1ZSxcbiAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICBkaXNhYmxlZERhdGU6IGRpc2FibGVkRGF0ZSxcbiAgICAgICAgb25PazogdGhpcy5vbk9rLFxuICAgICAgICBvblNlbGVjdDogdGhpcy5vblNlbGVjdCxcbiAgICAgICAgb25Ub2RheTogdGhpcy5jaG9vc2VUb2RheVxuICAgICAgfSlcbiAgICApXTtcblxuICAgIHJldHVybiB0aGlzLnJlbmRlclJvb3Qoe1xuICAgICAgY2hpbGRyZW46IGNoaWxkcmVuLFxuICAgICAgY2xhc3NOYW1lOiBwcm9wcy5zaG93V2Vla051bWJlciA/IHByZWZpeENscyArICctd2Vlay1udW1iZXInIDogJydcbiAgICB9KTtcbiAgfVxufSk7XG5cbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gQ2FsZW5kYXI7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi91eGNvcmUtZm9ybS9+L3V4Y29yZS1kYXRlLWZvcm0tZmllbGQvfi91eGNvcmUtY2FsZW5kYXIvYnVpbGQvUmNDYWxlbmRhci5qc1xuICoqIG1vZHVsZSBpZCA9IDM3OFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLypcbiAqIEdyZWdvcmlhbkNhbGVuZGFyIGNsYXNzXG4gKiBAaWdub3JlXG4gKiBAYXV0aG9yIHlpbWluZ2hlQGdtYWlsLmNvbVxuICovXG4ndXNlIHN0cmljdCc7XG5cbnZhciB0b0ludCA9IHBhcnNlSW50O1xudmFyIFV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xudmFyIGRlZmF1bHRMb2NhbGUgPSByZXF1aXJlKCcuL2xvY2FsZS9lbl9VUycpO1xudmFyIENvbnN0ID0gcmVxdWlyZSgnLi9jb25zdCcpO1xuXG4vKlxuICogR3JlZ29yaWFuQ2FsZW5kYXIgY2xhc3MuXG4gKlxuICogLSBubyBhcmd1bWVudHM6XG4gKiAgIENvbnN0cnVjdHMgYSBkZWZhdWx0IEdyZWdvcmlhbkNhbGVuZGFyIHVzaW5nIHRoZSBjdXJyZW50IHRpbWVcbiAqICAgaW4gdGhlIGRlZmF1bHQgdGltZSB6b25lIHdpdGggdGhlIGRlZmF1bHQgbG9jYWxlLlxuICogLSBvbmUgYXJndW1lbnQgbG9jYWxlOlxuICogICBDb25zdHJ1Y3RzIGEgR3JlZ29yaWFuQ2FsZW5kYXJcbiAqICAgYmFzZWQgb24gdGhlIGN1cnJlbnQgdGltZSBpbiB0aGUgZGVmYXVsdCB0aW1lIHpvbmUgd2l0aCB0aGUgZ2l2ZW4gbG9jYWxlLlxuICpcbiAqIEBjbGFzcyBEYXRlLkdyZWdvcmlhblxuICovXG5mdW5jdGlvbiBHcmVnb3JpYW5DYWxlbmRhcihsb2MpIHtcbiAgdmFyIGxvY2FsZSA9IGxvYyB8fCBkZWZhdWx0TG9jYWxlO1xuXG4gIHRoaXMubG9jYWxlID0gbG9jYWxlO1xuXG4gIHRoaXMuZmllbGRzID0gW107XG5cbiAgLypcbiAgICogVGhlIGN1cnJlbnRseSBzZXQgdGltZSBmb3IgdGhpcyBkYXRlLlxuICAgKiBAcHJvdGVjdGVkXG4gICAqIEB0eXBlIE51bWJlcnx1bmRlZmluZWRcbiAgICovXG4gIHRoaXMudGltZSA9IHVuZGVmaW5lZDtcbiAgLypcbiAgICogVGhlIHRpbWV6b25lT2Zmc2V0IGluIG1pbnV0ZXMgdXNlZCBieSB0aGlzIGRhdGUuXG4gICAqIEB0eXBlIE51bWJlclxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuXG4gIHRoaXMudGltZXpvbmVPZmZzZXQgPSBsb2NhbGUudGltZXpvbmVPZmZzZXQ7XG5cbiAgLypcbiAgICogVGhlIGZpcnN0IGRheSBvZiB0aGUgd2Vla1xuICAgKiBAdHlwZSBOdW1iZXJcbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgdGhpcy5maXJzdERheU9mV2VlayA9IGxvY2FsZS5maXJzdERheU9mV2VlaztcblxuICAvKlxuICAgKiBUaGUgbnVtYmVyIG9mIGRheXMgcmVxdWlyZWQgZm9yIHRoZSBmaXJzdCB3ZWVrIGluIGEgbW9udGggb3IgeWVhcixcbiAgICogd2l0aCBwb3NzaWJsZSB2YWx1ZXMgZnJvbSAxIHRvIDcuXG4gICAqIEBAcHJvdGVjdGVkXG4gICAqIEB0eXBlIE51bWJlclxuICAgKi9cbiAgdGhpcy5taW5pbWFsRGF5c0luRmlyc3RXZWVrID0gbG9jYWxlLm1pbmltYWxEYXlzSW5GaXJzdFdlZWs7XG5cbiAgdGhpcy5maWVsZHNDb21wdXRlZCA9IGZhbHNlO1xufVxuXG5VdGlscy5taXgoR3JlZ29yaWFuQ2FsZW5kYXIsIENvbnN0KTtcblxuVXRpbHMubWl4KEdyZWdvcmlhbkNhbGVuZGFyLCB7XG4gIFV0aWxzOiBVdGlscyxcblxuICBkZWZhdWx0TG9jYWxlOiBkZWZhdWx0TG9jYWxlLFxuXG4gIC8qXG4gICAqIERldGVybWluZXMgaWYgdGhlIGdpdmVuIHllYXIgaXMgYSBsZWFwIHllYXIuXG4gICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4geWVhciBpcyBhIGxlYXAgeWVhci4gVG8gc3BlY2lmeSBCQyB5ZWFyIG51bWJlcnMsXG4gICAqIDEgLSB5ZWFyIG51bWJlciBtdXN0IGJlIGdpdmVuLiBGb3IgZXhhbXBsZSwgeWVhciBCQyA0IGlzIHNwZWNpZmllZCBhcyAtMy5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHllYXIgdGhlIGdpdmVuIHllYXIuXG4gICAqIEByZXR1cm5zIHtCb29sZWFufSB0cnVlIGlmIHRoZSBnaXZlbiB5ZWFyIGlzIGEgbGVhcCB5ZWFyOyBmYWxzZSBvdGhlcndpc2UuXG4gICAqIEBzdGF0aWNcbiAgICogQG1ldGhvZFxuICAgKi9cbiAgaXNMZWFwWWVhcjogVXRpbHMuaXNMZWFwWWVhcixcblxuICAvKlxuICAgKiBFbnVtIGluZGljYXRpbmcgeWVhciBmaWVsZCBvZiBkYXRlXG4gICAqIEB0eXBlIE51bWJlclxuICAgKi9cbiAgWUVBUjogMSxcbiAgLypcbiAgICogRW51bSBpbmRpY2F0aW5nIG1vbnRoIGZpZWxkIG9mIGRhdGVcbiAgICogQHR5cGUgTnVtYmVyXG4gICAqL1xuICBNT05USDogMixcbiAgLypcbiAgICogRW51bSBpbmRpY2F0aW5nIHRoZSBkYXkgb2YgdGhlIG1vbnRoXG4gICAqIEB0eXBlIE51bWJlclxuICAgKi9cbiAgREFZX09GX01PTlRIOiAzLFxuICAvKlxuICAgKiBFbnVtIGluZGljYXRpbmcgdGhlIGhvdXIgKDI0KS5cbiAgICogQHR5cGUgTnVtYmVyXG4gICAqL1xuICBIT1VSX09GX0RBWTogNCxcbiAgLypcbiAgICogRW51bSBpbmRpY2F0aW5nIHRoZSBtaW51dGUgb2YgdGhlIGRheVxuICAgKiBAdHlwZSBOdW1iZXJcbiAgICovXG4gIE1JTlVURVM6IDUsXG4gIC8qXG4gICAqIEVudW0gaW5kaWNhdGluZyB0aGUgc2Vjb25kIG9mIHRoZSBkYXlcbiAgICogQHR5cGUgTnVtYmVyXG4gICAqL1xuICBTRUNPTkRTOiA2LFxuICAvKlxuICAgKiBFbnVtIGluZGljYXRpbmcgdGhlIG1pbGxpc2Vjb25kIG9mIHRoZSBkYXlcbiAgICogQHR5cGUgTnVtYmVyXG4gICAqL1xuICBNSUxMSVNFQ09ORFM6IDcsXG4gIC8qXG4gICAqIEVudW0gaW5kaWNhdGluZyB0aGUgd2VlayBudW1iZXIgd2l0aGluIHRoZSBjdXJyZW50IHllYXJcbiAgICogQHR5cGUgTnVtYmVyXG4gICAqL1xuICBXRUVLX09GX1lFQVI6IDgsXG4gIC8qXG4gICAqIEVudW0gaW5kaWNhdGluZyB0aGUgd2VlayBudW1iZXIgd2l0aGluIHRoZSBjdXJyZW50IG1vbnRoXG4gICAqIEB0eXBlIE51bWJlclxuICAgKi9cbiAgV0VFS19PRl9NT05USDogOSxcblxuICAvKlxuICAgKiBFbnVtIGluZGljYXRpbmcgdGhlIGRheSBvZiB0aGUgZGF5IG51bWJlciB3aXRoaW4gdGhlIGN1cnJlbnQgeWVhclxuICAgKiBAdHlwZSBOdW1iZXJcbiAgICovXG4gIERBWV9PRl9ZRUFSOiAxMCxcbiAgLypcbiAgICogRW51bSBpbmRpY2F0aW5nIHRoZSBkYXkgb2YgdGhlIHdlZWtcbiAgICogQHR5cGUgTnVtYmVyXG4gICAqL1xuICBEQVlfT0ZfV0VFSzogMTEsXG4gIC8qXG4gICAqIEVudW0gaW5kaWNhdGluZyB0aGUgZGF5IG9mIHRoZSBvcmRpbmFsIG51bWJlciBvZiB0aGUgZGF5IG9mIHRoZSB3ZWVrXG4gICAqIEB0eXBlIE51bWJlclxuICAgKi9cbiAgREFZX09GX1dFRUtfSU5fTU9OVEg6IDEyLFxuXG4gIC8qXG4gICAqIEVudW0gaW5kaWNhdGluZyBhbVxuICAgKiBAdHlwZSBOdW1iZXJcbiAgICovXG4gIEFNOiAwLFxuICAvKlxuICAgKiBFbnVtIGluZGljYXRpbmcgcG1cbiAgICogQHR5cGUgTnVtYmVyXG4gICAqL1xuICBQTTogMVxufSk7XG5cbnZhciBGSUVMRFMgPSBbJycsICdZZWFyJywgJ01vbnRoJywgJ0RheU9mTW9udGgnLCAnSG91ck9mRGF5JywgJ01pbnV0ZXMnLCAnU2Vjb25kcycsICdNaWxsaXNlY29uZHMnLCAnV2Vla09mWWVhcicsICdXZWVrT2ZNb250aCcsICdEYXlPZlllYXInLCAnRGF5T2ZXZWVrJywgJ0RheU9mV2Vla0luTW9udGgnXTtcblxudmFyIFlFQVIgPSBHcmVnb3JpYW5DYWxlbmRhci5ZRUFSO1xudmFyIE1PTlRIID0gR3JlZ29yaWFuQ2FsZW5kYXIuTU9OVEg7XG52YXIgREFZX09GX01PTlRIID0gR3JlZ29yaWFuQ2FsZW5kYXIuREFZX09GX01PTlRIO1xudmFyIEhPVVJfT0ZfREFZID0gR3JlZ29yaWFuQ2FsZW5kYXIuSE9VUl9PRl9EQVk7XG52YXIgTUlOVVRFID0gR3JlZ29yaWFuQ2FsZW5kYXIuTUlOVVRFUztcbnZhciBTRUNPTkRTID0gR3JlZ29yaWFuQ2FsZW5kYXIuU0VDT05EUztcblxudmFyIE1JTExJU0VDT05EUyA9IEdyZWdvcmlhbkNhbGVuZGFyLk1JTExJU0VDT05EUztcbnZhciBEQVlfT0ZfV0VFS19JTl9NT05USCA9IEdyZWdvcmlhbkNhbGVuZGFyLkRBWV9PRl9XRUVLX0lOX01PTlRIO1xudmFyIERBWV9PRl9ZRUFSID0gR3JlZ29yaWFuQ2FsZW5kYXIuREFZX09GX1lFQVI7XG52YXIgREFZX09GX1dFRUsgPSBHcmVnb3JpYW5DYWxlbmRhci5EQVlfT0ZfV0VFSztcblxudmFyIFdFRUtfT0ZfTU9OVEggPSBHcmVnb3JpYW5DYWxlbmRhci5XRUVLX09GX01PTlRIO1xudmFyIFdFRUtfT0ZfWUVBUiA9IEdyZWdvcmlhbkNhbGVuZGFyLldFRUtfT0ZfWUVBUjtcblxudmFyIE1PTlRIX0xFTkdUSCA9IFszMSwgMjgsIDMxLCAzMCwgMzEsIDMwLCAzMSwgMzEsIDMwLCAzMSwgMzAsIDMxXTsgLy8gMC1iYXNlZFxudmFyIExFQVBfTU9OVEhfTEVOR1RIID0gWzMxLCAyOSwgMzEsIDMwLCAzMSwgMzAsIDMxLCAzMSwgMzAsIDMxLCAzMCwgMzFdOyAvLyAwLWJhc2VkXG5cbnZhciBPTkVfU0VDT05EID0gMTAwMDtcbnZhciBPTkVfTUlOVVRFID0gNjAgKiBPTkVfU0VDT05EO1xudmFyIE9ORV9IT1VSID0gNjAgKiBPTkVfTUlOVVRFO1xudmFyIE9ORV9EQVkgPSAyNCAqIE9ORV9IT1VSO1xudmFyIE9ORV9XRUVLID0gT05FX0RBWSAqIDc7XG5cbnZhciBFUE9DSF9PRkZTRVQgPSA3MTkxNjM7IC8vIEZpeGVkIGRhdGUgb2YgSmFudWFyeSAxLCAxOTcwIChHcmVnb3JpYW4pXG5cbnZhciBtb2QgPSBVdGlscy5tb2Q7XG52YXIgX2lzTGVhcFllYXIgPSBVdGlscy5pc0xlYXBZZWFyO1xudmFyIGZsb29yRGl2aWRlID0gTWF0aC5mbG9vcjtcblxudmFyIE1JTl9WQUxVRVMgPSBbdW5kZWZpbmVkLCAxLCAvLyBZRUFSXG5HcmVnb3JpYW5DYWxlbmRhci5KQU5VQVJZLCAvLyBNT05USFxuMSwgLy8gREFZX09GX01PTlRIXG4wLCAvLyBIT1VSX09GX0RBWVxuMCwgLy8gTUlOVVRFXG4wLCAvLyBTRUNPTkRTXG4wLCAvLyBNSUxMSVNFQ09ORFNcblxuMSwgLy8gV0VFS19PRl9ZRUFSXG51bmRlZmluZWQsIC8vIFdFRUtfT0ZfTU9OVEhcblxuMSwgLy8gREFZX09GX1lFQVJcbkdyZWdvcmlhbkNhbGVuZGFyLlNVTkRBWSwgLy8gREFZX09GX1dFRUtcbjFdO1xuXG4vLyBEQVlfT0ZfV0VFS19JTl9NT05USFxudmFyIE1BWF9WQUxVRVMgPSBbdW5kZWZpbmVkLCAyOTIyNzg5OTQsIC8vIFlFQVJcbkdyZWdvcmlhbkNhbGVuZGFyLkRFQ0VNQkVSLCAvLyBNT05USFxudW5kZWZpbmVkLCAvLyBEQVlfT0ZfTU9OVEhcbjIzLCAvLyBIT1VSX09GX0RBWVxuNTksIC8vIE1JTlVURVxuNTksIC8vIFNFQ09ORFNcbjk5OSwgLy8gTUlMTElTRUNPTkRTXG51bmRlZmluZWQsIC8vIFdFRUtfT0ZfWUVBUlxudW5kZWZpbmVkLCAvLyBXRUVLX09GX01PTlRIXG51bmRlZmluZWQsIC8vIERBWV9PRl9ZRUFSXG5HcmVnb3JpYW5DYWxlbmRhci5TQVRVUkRBWSwgLy8gREFZX09GX1dFRUtcbnVuZGVmaW5lZF07XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0gcHJpdmF0ZSBzdGFydFxuXG4vLyBEQVlfT0ZfV0VFS19JTl9NT05USFxuZnVuY3Rpb24gZ2V0TW9udGhMZW5ndGgoeWVhciwgbW9udGgpIHtcbiAgcmV0dXJuIF9pc0xlYXBZZWFyKHllYXIpID8gTEVBUF9NT05USF9MRU5HVEhbbW9udGhdIDogTU9OVEhfTEVOR1RIW21vbnRoXTtcbn1cblxuZnVuY3Rpb24gZ2V0WWVhckxlbmd0aCh5ZWFyKSB7XG4gIHJldHVybiBfaXNMZWFwWWVhcih5ZWFyKSA/IDM2NiA6IDM2NTtcbn1cblxuZnVuY3Rpb24gYWRqdXN0RGF5T2ZNb250aChzZWxmKSB7XG4gIHZhciBmaWVsZHMgPSBzZWxmLmZpZWxkcztcbiAgdmFyIHllYXIgPSBmaWVsZHNbWUVBUl07XG4gIHZhciBtb250aCA9IGZpZWxkc1tNT05USF07XG4gIHZhciBtb250aExlbiA9IGdldE1vbnRoTGVuZ3RoKHllYXIsIG1vbnRoKTtcbiAgdmFyIGRheU9mTW9udGggPSBmaWVsZHNbREFZX09GX01PTlRIXTtcbiAgaWYgKGRheU9mTW9udGggPiBtb250aExlbikge1xuICAgIHNlbGYuc2V0KERBWV9PRl9NT05USCwgbW9udGhMZW4pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldERheU9mV2Vla0RhdGVPbk9yQmVmb3JlKGZpeGVkRGF0ZSwgZGF5T2ZXZWVrKSB7XG4gIC8vIDEuMS4xIGlzIG1vbmRheVxuICAvLyBvbmUgd2VlayBoYXMgNyBkYXlzXG4gIHJldHVybiBmaXhlZERhdGUgLSBtb2QoZml4ZWREYXRlIC0gZGF5T2ZXZWVrLCA3KTtcbn1cblxuZnVuY3Rpb24gZ2V0V2Vla051bWJlcihzZWxmLCBmaXhlZERheTEsIGZpeGVkRGF0ZSkge1xuICB2YXIgZml4ZWREYXkxc3QgPSBnZXREYXlPZldlZWtEYXRlT25PckJlZm9yZShmaXhlZERheTEgKyA2LCBzZWxmLmZpcnN0RGF5T2ZXZWVrKTtcbiAgdmFyIG5EYXlzID0gZml4ZWREYXkxc3QgLSBmaXhlZERheTE7XG4gIGlmIChuRGF5cyA+PSBzZWxmLm1pbmltYWxEYXlzSW5GaXJzdFdlZWspIHtcbiAgICBmaXhlZERheTFzdCAtPSA3O1xuICB9XG4gIHZhciBub3JtYWxpemVkRGF5T2ZQZXJpb2QgPSBmaXhlZERhdGUgLSBmaXhlZERheTFzdDtcbiAgcmV0dXJuIGZsb29yRGl2aWRlKG5vcm1hbGl6ZWREYXlPZlBlcmlvZCAvIDcpICsgMTtcbn1cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLSBwcml2YXRlIGVuZFxuXG5HcmVnb3JpYW5DYWxlbmRhci5wcm90b3R5cGUgPSB7XG4gIGNvbnN0cnVjdG9yOiBHcmVnb3JpYW5DYWxlbmRhcixcblxuICBpc0dyZWdvcmlhbkNhbGVuZGFyOiAxLFxuXG4gIC8qXG4gICAqIERldGVybWluZXMgaWYgY3VycmVudCB5ZWFyIGlzIGEgbGVhcCB5ZWFyLlxuICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIHllYXIgaXMgYSBsZWFwIHllYXIuIFRvIHNwZWNpZnkgQkMgeWVhciBudW1iZXJzLFxuICAgKiAxIC0geWVhciBudW1iZXIgbXVzdCBiZSBnaXZlbi4gRm9yIGV4YW1wbGUsIHllYXIgQkMgNCBpcyBzcGVjaWZpZWQgYXMgLTMuXG4gICAqIEByZXR1cm5zIHtCb29sZWFufSB0cnVlIGlmIHRoZSBnaXZlbiB5ZWFyIGlzIGEgbGVhcCB5ZWFyOyBmYWxzZSBvdGhlcndpc2UuXG4gICAqIEBtZXRob2RcbiAgICogQG1lbWJlciBEYXRlLkdyZWdvcmlhblxuICAgKi9cbiAgaXNMZWFwWWVhcjogZnVuY3Rpb24gaXNMZWFwWWVhcigpIHtcbiAgICByZXR1cm4gX2lzTGVhcFllYXIodGhpcy5nZXRZZWFyKCkpO1xuICB9LFxuXG4gIC8qXG4gICAqIFJldHVybiBsb2NhbCBpbmZvIGZvciBjdXJyZW50IGRhdGUgaW5zdGFuY2VcbiAgICogQHJldHVybnMge09iamVjdH1cbiAgICovXG4gIGdldExvY2FsZTogZnVuY3Rpb24gZ2V0TG9jYWxlKCkge1xuICAgIHJldHVybiB0aGlzLmxvY2FsZTtcbiAgfSxcblxuICAvKlxuICAgKiBSZXR1cm5zIHRoZSBtaW5pbXVtIHZhbHVlIGZvclxuICAgKiB0aGUgZ2l2ZW4gY2FsZW5kYXIgZmllbGQgb2YgdGhpcyBHcmVnb3JpYW5DYWxlbmRhciBpbnN0YW5jZS5cbiAgICogVGhlIG1pbmltdW0gdmFsdWUgaXMgZGVmaW5lZCBhcyB0aGUgc21hbGxlc3QgdmFsdWVcbiAgICogcmV0dXJuZWQgYnkgdGhlIGdldCBtZXRob2QgZm9yIGFueSBwb3NzaWJsZSB0aW1lIHZhbHVlLFxuICAgKiB0YWtpbmcgaW50byBjb25zaWRlcmF0aW9uIHRoZSBjdXJyZW50IHZhbHVlcyBvZiB0aGUgZ2V0Rmlyc3REYXlPZldlZWssXG4gICAqIGdldE1pbmltYWxEYXlzSW5GaXJzdFdlZWsuXG4gICAqIEBwYXJhbSBmaWVsZCB0aGUgY2FsZW5kYXIgZmllbGQuXG4gICAqIEByZXR1cm5zIHtOdW1iZXJ9IHRoZSBtaW5pbXVtIHZhbHVlIGZvciB0aGUgZ2l2ZW4gY2FsZW5kYXIgZmllbGQuXG4gICAqL1xuICBnZXRBY3R1YWxNaW5pbXVtOiBmdW5jdGlvbiBnZXRBY3R1YWxNaW5pbXVtKGZpZWxkKSB7XG4gICAgaWYgKE1JTl9WQUxVRVNbZmllbGRdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBNSU5fVkFMVUVTW2ZpZWxkXTtcbiAgICB9XG4gICAgaWYgKGZpZWxkID09PSBXRUVLX09GX01PTlRIKSB7XG4gICAgICB2YXIgY2FsID0gdGhpcy5jbG9uZSgpO1xuICAgICAgY2FsLmNsZWFyKCk7XG4gICAgICBjYWwuc2V0KHRoaXMuZmllbGRzW1lFQVJdLCB0aGlzLmZpZWxkc1tNT05USF0sIDEpO1xuICAgICAgcmV0dXJuIGNhbC5nZXQoV0VFS19PRl9NT05USCk7XG4gICAgfVxuXG4gICAgdGhyb3cgbmV3IEVycm9yKCdtaW5pbXVtIHZhbHVlIG5vdCBkZWZpbmVkIScpO1xuICB9LFxuXG4gIC8qXG4gICAqIFJldHVybnMgdGhlIG1heGltdW0gdmFsdWUgZm9yIHRoZSBnaXZlbiBjYWxlbmRhciBmaWVsZFxuICAgKiBvZiB0aGlzIEdyZWdvcmlhbkNhbGVuZGFyIGluc3RhbmNlLlxuICAgKiBUaGUgbWF4aW11bSB2YWx1ZSBpcyBkZWZpbmVkIGFzIHRoZSBsYXJnZXN0IHZhbHVlIHJldHVybmVkXG4gICAqIGJ5IHRoZSBnZXQgbWV0aG9kIGZvciBhbnkgcG9zc2libGUgdGltZSB2YWx1ZSwgdGFraW5nIGludG8gY29uc2lkZXJhdGlvblxuICAgKiB0aGUgY3VycmVudCB2YWx1ZXMgb2YgdGhlIGdldEZpcnN0RGF5T2ZXZWVrLCBnZXRNaW5pbWFsRGF5c0luRmlyc3RXZWVrIG1ldGhvZHMuXG4gICAqIEBwYXJhbSBmaWVsZCB0aGUgY2FsZW5kYXIgZmllbGQuXG4gICAqIEByZXR1cm5zIHtOdW1iZXJ9IHRoZSBtYXhpbXVtIHZhbHVlIGZvciB0aGUgZ2l2ZW4gY2FsZW5kYXIgZmllbGQuXG4gICAqL1xuICBnZXRBY3R1YWxNYXhpbXVtOiBmdW5jdGlvbiBnZXRBY3R1YWxNYXhpbXVtKGZpZWxkKSB7XG4gICAgaWYgKE1BWF9WQUxVRVNbZmllbGRdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBNQVhfVkFMVUVTW2ZpZWxkXTtcbiAgICB9XG4gICAgdmFyIHZhbHVlID0gdW5kZWZpbmVkO1xuICAgIHZhciBmaWVsZHMgPSB0aGlzLmZpZWxkcztcbiAgICBzd2l0Y2ggKGZpZWxkKSB7XG4gICAgICBjYXNlIERBWV9PRl9NT05USDpcbiAgICAgICAgdmFsdWUgPSBnZXRNb250aExlbmd0aChmaWVsZHNbWUVBUl0sIGZpZWxkc1tNT05USF0pO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBXRUVLX09GX1lFQVI6XG4gICAgICAgIHZhciBlbmRPZlllYXIgPSB0aGlzLmNsb25lKCk7XG4gICAgICAgIGVuZE9mWWVhci5jbGVhcigpO1xuICAgICAgICBlbmRPZlllYXIuc2V0KGZpZWxkc1tZRUFSXSwgR3JlZ29yaWFuQ2FsZW5kYXIuREVDRU1CRVIsIDMxKTtcbiAgICAgICAgdmFsdWUgPSBlbmRPZlllYXIuZ2V0KFdFRUtfT0ZfWUVBUik7XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gMSkge1xuICAgICAgICAgIHZhbHVlID0gNTI7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgV0VFS19PRl9NT05USDpcbiAgICAgICAgdmFyIGVuZE9mTW9udGggPSB0aGlzLmNsb25lKCk7XG4gICAgICAgIGVuZE9mTW9udGguY2xlYXIoKTtcbiAgICAgICAgZW5kT2ZNb250aC5zZXQoZmllbGRzW1lFQVJdLCBmaWVsZHNbTU9OVEhdLCBnZXRNb250aExlbmd0aChmaWVsZHNbWUVBUl0sIGZpZWxkc1tNT05USF0pKTtcbiAgICAgICAgdmFsdWUgPSBlbmRPZk1vbnRoLmdldChXRUVLX09GX01PTlRIKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgREFZX09GX1lFQVI6XG4gICAgICAgIHZhbHVlID0gZ2V0WWVhckxlbmd0aChmaWVsZHNbWUVBUl0pO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBEQVlfT0ZfV0VFS19JTl9NT05USDpcbiAgICAgICAgdmFsdWUgPSB0b0ludCgoZ2V0TW9udGhMZW5ndGgoZmllbGRzW1lFQVJdLCBmaWVsZHNbTU9OVEhdKSAtIDEpIC8gNykgKyAxO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdtYXhpbXVtIHZhbHVlIG5vdCBkZWZpbmVkIScpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG4gIH0sXG5cbiAgLypcbiAgICogRGV0ZXJtaW5lcyBpZiB0aGUgZ2l2ZW4gY2FsZW5kYXIgZmllbGQgaGFzIGEgdmFsdWUgc2V0LFxuICAgKiBpbmNsdWRpbmcgY2FzZXMgdGhhdCB0aGUgdmFsdWUgaGFzIGJlZW4gc2V0IGJ5IGludGVybmFsIGZpZWxkcyBjYWxjdWxhdGlvbnNcbiAgICogdHJpZ2dlcmVkIGJ5IGEgZ2V0IG1ldGhvZCBjYWxsLlxuICAgKiBAcGFyYW0gZmllbGQgdGhlIGNhbGVuZGFyIGZpZWxkIHRvIGJlIGNsZWFyZWQuXG4gICAqIEByZXR1cm5zIHtib29sZWFufSB0cnVlIGlmIHRoZSBnaXZlbiBjYWxlbmRhciBmaWVsZCBoYXMgYSB2YWx1ZSBzZXQ7IGZhbHNlIG90aGVyd2lzZS5cbiAgICovXG4gIGlzU2V0OiBmdW5jdGlvbiBpc1NldChmaWVsZCkge1xuICAgIHJldHVybiB0aGlzLmZpZWxkc1tmaWVsZF0gIT09IHVuZGVmaW5lZDtcbiAgfSxcblxuICAvKlxuICAgKiBDb252ZXJ0cyB0aGUgdGltZSB2YWx1ZSAobWlsbGlzZWNvbmQgb2Zmc2V0IGZyb20gdGhlIEVwb2NoKVxuICAgKiB0byBjYWxlbmRhciBmaWVsZCB2YWx1ZXMuXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIGNvbXB1dGVGaWVsZHM6IGZ1bmN0aW9uIGNvbXB1dGVGaWVsZHMoKSB7XG4gICAgdmFyIHRpbWUgPSB0aGlzLnRpbWU7XG4gICAgdmFyIHRpbWV6b25lT2Zmc2V0ID0gdGhpcy50aW1lem9uZU9mZnNldCAqIE9ORV9NSU5VVEU7XG4gICAgdmFyIGZpeGVkRGF0ZSA9IHRvSW50KHRpbWV6b25lT2Zmc2V0IC8gT05FX0RBWSk7XG4gICAgdmFyIHRpbWVPZkRheSA9IHRpbWV6b25lT2Zmc2V0ICUgT05FX0RBWTtcbiAgICBmaXhlZERhdGUgKz0gdG9JbnQodGltZSAvIE9ORV9EQVkpO1xuICAgIHRpbWVPZkRheSArPSB0aW1lICUgT05FX0RBWTtcbiAgICBpZiAodGltZU9mRGF5ID49IE9ORV9EQVkpIHtcbiAgICAgIHRpbWVPZkRheSAtPSBPTkVfREFZO1xuICAgICAgZml4ZWREYXRlKys7XG4gICAgfSBlbHNlIHtcbiAgICAgIHdoaWxlICh0aW1lT2ZEYXkgPCAwKSB7XG4gICAgICAgIHRpbWVPZkRheSArPSBPTkVfREFZO1xuICAgICAgICBmaXhlZERhdGUtLTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmaXhlZERhdGUgKz0gRVBPQ0hfT0ZGU0VUO1xuXG4gICAgdmFyIGRhdGUgPSBVdGlscy5nZXRHcmVnb3JpYW5EYXRlRnJvbUZpeGVkRGF0ZShmaXhlZERhdGUpO1xuXG4gICAgdmFyIHllYXIgPSBkYXRlLnllYXI7XG5cbiAgICB2YXIgZmllbGRzID0gdGhpcy5maWVsZHM7XG4gICAgZmllbGRzW1lFQVJdID0geWVhcjtcbiAgICBmaWVsZHNbTU9OVEhdID0gZGF0ZS5tb250aDtcbiAgICBmaWVsZHNbREFZX09GX01PTlRIXSA9IGRhdGUuZGF5T2ZNb250aDtcbiAgICBmaWVsZHNbREFZX09GX1dFRUtdID0gZGF0ZS5kYXlPZldlZWs7XG5cbiAgICBpZiAodGltZU9mRGF5ICE9PSAwKSB7XG4gICAgICBmaWVsZHNbSE9VUl9PRl9EQVldID0gdG9JbnQodGltZU9mRGF5IC8gT05FX0hPVVIpO1xuICAgICAgdmFyIHIgPSB0aW1lT2ZEYXkgJSBPTkVfSE9VUjtcbiAgICAgIGZpZWxkc1tNSU5VVEVdID0gdG9JbnQociAvIE9ORV9NSU5VVEUpO1xuICAgICAgciAlPSBPTkVfTUlOVVRFO1xuICAgICAgZmllbGRzW1NFQ09ORFNdID0gdG9JbnQociAvIE9ORV9TRUNPTkQpO1xuICAgICAgZmllbGRzW01JTExJU0VDT05EU10gPSByICUgT05FX1NFQ09ORDtcbiAgICB9IGVsc2Uge1xuICAgICAgZmllbGRzW0hPVVJfT0ZfREFZXSA9IGZpZWxkc1tNSU5VVEVdID0gZmllbGRzW1NFQ09ORFNdID0gZmllbGRzW01JTExJU0VDT05EU10gPSAwO1xuICAgIH1cblxuICAgIHZhciBmaXhlZERhdGVKYW4xID0gVXRpbHMuZ2V0Rml4ZWREYXRlKHllYXIsIEdyZWdvcmlhbkNhbGVuZGFyLkpBTlVBUlksIDEpO1xuICAgIHZhciBkYXlPZlllYXIgPSBmaXhlZERhdGUgLSBmaXhlZERhdGVKYW4xICsgMTtcbiAgICB2YXIgZml4RGF0ZU1vbnRoMSA9IGZpeGVkRGF0ZSAtIGRhdGUuZGF5T2ZNb250aCArIDE7XG5cbiAgICBmaWVsZHNbREFZX09GX1lFQVJdID0gZGF5T2ZZZWFyO1xuICAgIGZpZWxkc1tEQVlfT0ZfV0VFS19JTl9NT05USF0gPSB0b0ludCgoZGF0ZS5kYXlPZk1vbnRoIC0gMSkgLyA3KSArIDE7XG5cbiAgICB2YXIgd2Vla09mWWVhciA9IGdldFdlZWtOdW1iZXIodGhpcywgZml4ZWREYXRlSmFuMSwgZml4ZWREYXRlKTtcblxuICAgIC8vIOacrOWRqOayoeaciei2s+Wkn+eahOaXtumXtOWcqOW9k+WJjeW5tFxuICAgIGlmICh3ZWVrT2ZZZWFyID09PSAwKSB7XG4gICAgICAvLyBJZiB0aGUgZGF0ZSBiZWxvbmdzIHRvIHRoZSBsYXN0IHdlZWsgb2YgdGhlXG4gICAgICAvLyBwcmV2aW91cyB5ZWFyLCB1c2UgdGhlIHdlZWsgbnVtYmVyIG9mIFwiMTIvMzFcIiBvZlxuICAgICAgLy8gdGhlIFwicHJldmlvdXNcIiB5ZWFyLlxuICAgICAgdmFyIGZpeGVkRGVjMzEgPSBmaXhlZERhdGVKYW4xIC0gMTtcbiAgICAgIHZhciBwcmV2SmFuMSA9IGZpeGVkRGF0ZUphbjEgLSBnZXRZZWFyTGVuZ3RoKHllYXIgLSAxKTtcbiAgICAgIHdlZWtPZlllYXIgPSBnZXRXZWVrTnVtYmVyKHRoaXMsIHByZXZKYW4xLCBmaXhlZERlYzMxKTtcbiAgICB9IGVsc2VcbiAgICAgIC8vIOacrOWRqOaYr+W5tOacq+acgOWQjuS4gOWRqO+8jOWPr+iDveaciei2s+Wkn+eahOaXtumXtOWcqOaWsOeahOS4gOW5tFxuICAgICAgaWYgKHdlZWtPZlllYXIgPj0gNTIpIHtcbiAgICAgICAgdmFyIG5leHRKYW4xID0gZml4ZWREYXRlSmFuMSArIGdldFllYXJMZW5ndGgoeWVhcik7XG4gICAgICAgIHZhciBuZXh0SmFuMXN0ID0gZ2V0RGF5T2ZXZWVrRGF0ZU9uT3JCZWZvcmUobmV4dEphbjEgKyA2LCB0aGlzLmZpcnN0RGF5T2ZXZWVrKTtcbiAgICAgICAgdmFyIG5EYXlzID0gbmV4dEphbjFzdCAtIG5leHRKYW4xO1xuICAgICAgICAvLyDmnKzlkajmnInotrPlpJ/lpKnmlbDlnKjmlrDnmoTkuIDlubRcbiAgICAgICAgaWYgKG5EYXlzID49IHRoaXMubWluaW1hbERheXNJbkZpcnN0V2VlayAmJlxuICAgICAgICAvLyDlvZPlpKnnoa7lrp7lnKjmnKzlkajvvIx3ZWVrT2ZZZWFyID09PSA1MyDml7bmmK/kuI3pnIDopoHov5nkuKrliKTmlq1cbiAgICAgICAgZml4ZWREYXRlID49IG5leHRKYW4xc3QgLSA3KSB7XG4gICAgICAgICAgd2Vla09mWWVhciA9IDE7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgIGZpZWxkc1tXRUVLX09GX1lFQVJdID0gd2Vla09mWWVhcjtcbiAgICBmaWVsZHNbV0VFS19PRl9NT05USF0gPSBnZXRXZWVrTnVtYmVyKHRoaXMsIGZpeERhdGVNb250aDEsIGZpeGVkRGF0ZSk7XG5cbiAgICB0aGlzLmZpZWxkc0NvbXB1dGVkID0gdHJ1ZTtcbiAgfSxcblxuICAvKlxuICAgKiBDb252ZXJ0cyBjYWxlbmRhciBmaWVsZCB2YWx1ZXMgdG8gdGhlIHRpbWUgdmFsdWVcbiAgICogKG1pbGxpc2Vjb25kIG9mZnNldCBmcm9tIHRoZSBFcG9jaCkuXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIGNvbXB1dGVUaW1lOiBmdW5jdGlvbiBjb21wdXRlVGltZSgpIHtcbiAgICB2YXIgeWVhciA9IHVuZGVmaW5lZDtcbiAgICB2YXIgZmllbGRzID0gdGhpcy5maWVsZHM7XG4gICAgaWYgKHRoaXMuaXNTZXQoWUVBUikpIHtcbiAgICAgIHllYXIgPSBmaWVsZHNbWUVBUl07XG4gICAgfSBlbHNlIHtcbiAgICAgIHllYXIgPSBuZXcgRGF0ZSgpLmdldEZ1bGxZZWFyKCk7XG4gICAgfVxuICAgIHZhciB0aW1lT2ZEYXkgPSAwO1xuICAgIGlmICh0aGlzLmlzU2V0KEhPVVJfT0ZfREFZKSkge1xuICAgICAgdGltZU9mRGF5ICs9IGZpZWxkc1tIT1VSX09GX0RBWV07XG4gICAgfVxuICAgIHRpbWVPZkRheSAqPSA2MDtcbiAgICB0aW1lT2ZEYXkgKz0gZmllbGRzW01JTlVURV0gfHwgMDtcbiAgICB0aW1lT2ZEYXkgKj0gNjA7XG4gICAgdGltZU9mRGF5ICs9IGZpZWxkc1tTRUNPTkRTXSB8fCAwO1xuICAgIHRpbWVPZkRheSAqPSAxMDAwO1xuICAgIHRpbWVPZkRheSArPSBmaWVsZHNbTUlMTElTRUNPTkRTXSB8fCAwO1xuICAgIHZhciBmaXhlZERhdGUgPSAwO1xuICAgIGZpZWxkc1tZRUFSXSA9IHllYXI7XG4gICAgZml4ZWREYXRlID0gZml4ZWREYXRlICsgdGhpcy5nZXRGaXhlZERhdGUoKTtcbiAgICAvLyBtaWxsaXMgcmVwcmVzZW50cyBsb2NhbCB3YWxsLWNsb2NrIHRpbWUgaW4gbWlsbGlzZWNvbmRzLlxuICAgIHZhciBtaWxsaXMgPSAoZml4ZWREYXRlIC0gRVBPQ0hfT0ZGU0VUKSAqIE9ORV9EQVkgKyB0aW1lT2ZEYXk7XG4gICAgbWlsbGlzIC09IHRoaXMudGltZXpvbmVPZmZzZXQgKiBPTkVfTUlOVVRFO1xuICAgIHRoaXMudGltZSA9IG1pbGxpcztcbiAgICB0aGlzLmNvbXB1dGVGaWVsZHMoKTtcbiAgfSxcblxuICAvKlxuICAgKiBGaWxscyBpbiBhbnkgdW5zZXQgZmllbGRzIGluIHRoZSBjYWxlbmRhciBmaWVsZHMuIEZpcnN0LFxuICAgKiB0aGUgY29tcHV0ZVRpbWUoKSBtZXRob2QgaXMgY2FsbGVkIGlmIHRoZSB0aW1lIHZhbHVlIChtaWxsaXNlY29uZCBvZmZzZXQgZnJvbSB0aGUgRXBvY2gpXG4gICAqIGhhcyBub3QgYmVlbiBjYWxjdWxhdGVkIGZyb20gY2FsZW5kYXIgZmllbGQgdmFsdWVzLlxuICAgKiBUaGVuLCB0aGUgY29tcHV0ZUZpZWxkcygpIG1ldGhvZCBpcyBjYWxsZWQgdG8gY2FsY3VsYXRlIGFsbCBjYWxlbmRhciBmaWVsZCB2YWx1ZXMuXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIGNvbXBsZXRlOiBmdW5jdGlvbiBjb21wbGV0ZSgpIHtcbiAgICBpZiAodGhpcy50aW1lID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuY29tcHV0ZVRpbWUoKTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLmZpZWxkc0NvbXB1dGVkKSB7XG4gICAgICB0aGlzLmNvbXB1dGVGaWVsZHMoKTtcbiAgICB9XG4gIH0sXG5cbiAgZ2V0Rml4ZWREYXRlOiBmdW5jdGlvbiBnZXRGaXhlZERhdGUoKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgdmFyIGZpZWxkcyA9IHNlbGYuZmllbGRzO1xuXG4gICAgdmFyIGZpcnN0RGF5T2ZXZWVrQ2ZnID0gc2VsZi5maXJzdERheU9mV2VlaztcblxuICAgIHZhciB5ZWFyID0gZmllbGRzW1lFQVJdO1xuXG4gICAgdmFyIG1vbnRoID0gR3JlZ29yaWFuQ2FsZW5kYXIuSkFOVUFSWTtcblxuICAgIGlmIChzZWxmLmlzU2V0KE1PTlRIKSkge1xuICAgICAgbW9udGggPSBmaWVsZHNbTU9OVEhdO1xuICAgICAgaWYgKG1vbnRoID4gR3JlZ29yaWFuQ2FsZW5kYXIuREVDRU1CRVIpIHtcbiAgICAgICAgeWVhciArPSB0b0ludChtb250aCAvIDEyKTtcbiAgICAgICAgbW9udGggJT0gMTI7XG4gICAgICB9IGVsc2UgaWYgKG1vbnRoIDwgR3JlZ29yaWFuQ2FsZW5kYXIuSkFOVUFSWSkge1xuICAgICAgICB5ZWFyICs9IGZsb29yRGl2aWRlKG1vbnRoIC8gMTIpO1xuICAgICAgICBtb250aCA9IG1vZChtb250aCwgMTIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEdldCB0aGUgZml4ZWQgZGF0ZSBzaW5jZSBKYW4gMSwgMSAoR3JlZ29yaWFuKS4gV2UgYXJlIG9uXG4gICAgLy8gdGhlIGZpcnN0IGRheSBvZiBlaXRoZXIgYG1vbnRoJyBvciBKYW51YXJ5IGluICd5ZWFyJy5cbiAgICB2YXIgZml4ZWREYXRlID0gVXRpbHMuZ2V0Rml4ZWREYXRlKHllYXIsIG1vbnRoLCAxKTtcbiAgICB2YXIgZmlyc3REYXlPZldlZWsgPSB1bmRlZmluZWQ7XG4gICAgdmFyIGRheU9mV2VlayA9IHNlbGYuZmlyc3REYXlPZldlZWs7XG5cbiAgICBpZiAoc2VsZi5pc1NldChEQVlfT0ZfV0VFSykpIHtcbiAgICAgIGRheU9mV2VlayA9IGZpZWxkc1tEQVlfT0ZfV0VFS107XG4gICAgfVxuXG4gICAgaWYgKHNlbGYuaXNTZXQoTU9OVEgpKSB7XG4gICAgICBpZiAoc2VsZi5pc1NldChEQVlfT0ZfTU9OVEgpKSB7XG4gICAgICAgIGZpeGVkRGF0ZSArPSBmaWVsZHNbREFZX09GX01PTlRIXSAtIDE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoc2VsZi5pc1NldChXRUVLX09GX01PTlRIKSkge1xuICAgICAgICAgIGZpcnN0RGF5T2ZXZWVrID0gZ2V0RGF5T2ZXZWVrRGF0ZU9uT3JCZWZvcmUoZml4ZWREYXRlICsgNiwgZmlyc3REYXlPZldlZWtDZmcpO1xuXG4gICAgICAgICAgLy8gSWYgd2UgaGF2ZSBlbm91Z2ggZGF5cyBpbiB0aGUgZmlyc3Qgd2VlaywgdGhlblxuICAgICAgICAgIC8vIG1vdmUgdG8gdGhlIHByZXZpb3VzIHdlZWsuXG4gICAgICAgICAgaWYgKGZpcnN0RGF5T2ZXZWVrIC0gZml4ZWREYXRlID49IHNlbGYubWluaW1hbERheXNJbkZpcnN0V2Vlaykge1xuICAgICAgICAgICAgZmlyc3REYXlPZldlZWsgLT0gNztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoZGF5T2ZXZWVrICE9PSBmaXJzdERheU9mV2Vla0NmZykge1xuICAgICAgICAgICAgZmlyc3REYXlPZldlZWsgPSBnZXREYXlPZldlZWtEYXRlT25PckJlZm9yZShmaXJzdERheU9mV2VlayArIDYsIGRheU9mV2Vlayk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZml4ZWREYXRlID0gZmlyc3REYXlPZldlZWsgKyA3ICogKGZpZWxkc1tXRUVLX09GX01PTlRIXSAtIDEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBkb3dpbSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICBpZiAoc2VsZi5pc1NldChEQVlfT0ZfV0VFS19JTl9NT05USCkpIHtcbiAgICAgICAgICAgIGRvd2ltID0gZmllbGRzW0RBWV9PRl9XRUVLX0lOX01PTlRIXTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZG93aW0gPSAxO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgbGFzdERhdGUgPSA3ICogZG93aW07XG4gICAgICAgICAgaWYgKGRvd2ltIDwgMCkge1xuICAgICAgICAgICAgbGFzdERhdGUgPSBnZXRNb250aExlbmd0aCh5ZWFyLCBtb250aCkgKyA3ICogKGRvd2ltICsgMSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZpeGVkRGF0ZSA9IGdldERheU9mV2Vla0RhdGVPbk9yQmVmb3JlKGZpeGVkRGF0ZSArIGxhc3REYXRlIC0gMSwgZGF5T2ZXZWVrKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBXZSBhcmUgb24gdGhlIGZpcnN0IGRheSBvZiB0aGUgeWVhci5cbiAgICAgIGlmIChzZWxmLmlzU2V0KERBWV9PRl9ZRUFSKSkge1xuICAgICAgICBmaXhlZERhdGUgKz0gZmllbGRzW0RBWV9PRl9ZRUFSXSAtIDE7XG4gICAgICB9IGVsc2UgaWYgKHNlbGYuaXNTZXQoV0VFS19PRl9ZRUFSKSkge1xuICAgICAgICBmaXJzdERheU9mV2VlayA9IGdldERheU9mV2Vla0RhdGVPbk9yQmVmb3JlKGZpeGVkRGF0ZSArIDYsIGZpcnN0RGF5T2ZXZWVrQ2ZnKTtcbiAgICAgICAgLy8gSWYgd2UgaGF2ZSBlbm91Z2ggZGF5cyBpbiB0aGUgZmlyc3Qgd2VlaywgdGhlbiBtb3ZlXG4gICAgICAgIC8vIHRvIHRoZSBwcmV2aW91cyB3ZWVrLlxuICAgICAgICBpZiAoZmlyc3REYXlPZldlZWsgLSBmaXhlZERhdGUgPj0gc2VsZi5taW5pbWFsRGF5c0luRmlyc3RXZWVrKSB7XG4gICAgICAgICAgZmlyc3REYXlPZldlZWsgLT0gNztcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF5T2ZXZWVrICE9PSBmaXJzdERheU9mV2Vla0NmZykge1xuICAgICAgICAgIGZpcnN0RGF5T2ZXZWVrID0gZ2V0RGF5T2ZXZWVrRGF0ZU9uT3JCZWZvcmUoZmlyc3REYXlPZldlZWsgKyA2LCBkYXlPZldlZWspO1xuICAgICAgICB9XG4gICAgICAgIGZpeGVkRGF0ZSA9IGZpcnN0RGF5T2ZXZWVrICsgNyAqIChmaWVsZHNbV0VFS19PRl9ZRUFSXSAtIDEpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmaXhlZERhdGU7XG4gIH0sXG5cbiAgLypcbiAgICogUmV0dXJucyB0aGlzIENhbGVuZGFyJ3MgdGltZSB2YWx1ZSBpbiBtaWxsaXNlY29uZHNcbiAgICogQG1lbWJlciBEYXRlLkdyZWdvcmlhblxuICAgKiBAcmV0dXJucyB7TnVtYmVyfSB0aGUgY3VycmVudCB0aW1lIGFzIFVUQyBtaWxsaXNlY29uZHMgZnJvbSB0aGUgZXBvY2guXG4gICAqL1xuICBnZXRUaW1lOiBmdW5jdGlvbiBnZXRUaW1lKCkge1xuICAgIGlmICh0aGlzLnRpbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5jb21wdXRlVGltZSgpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy50aW1lO1xuICB9LFxuXG4gIC8qXG4gICAqIFNldHMgdGhpcyBDYWxlbmRhcidzIGN1cnJlbnQgdGltZSBmcm9tIHRoZSBnaXZlbiBsb25nIHZhbHVlLlxuICAgKiBAcGFyYW0gdGltZSB0aGUgbmV3IHRpbWUgaW4gVVRDIG1pbGxpc2Vjb25kcyBmcm9tIHRoZSBlcG9jaC5cbiAgICovXG4gIHNldFRpbWU6IGZ1bmN0aW9uIHNldFRpbWUodGltZSkge1xuICAgIHRoaXMudGltZSA9IHRpbWU7XG4gICAgdGhpcy5maWVsZHNDb21wdXRlZCA9IGZhbHNlO1xuICAgIHRoaXMuY29tcGxldGUoKTtcbiAgfSxcblxuICAvKlxuICAgKiBSZXR1cm5zIHRoZSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gY2FsZW5kYXIgZmllbGQuXG4gICAqIEBwYXJhbSBmaWVsZCB0aGUgZ2l2ZW4gY2FsZW5kYXIgZmllbGQuXG4gICAqIEByZXR1cm5zIHtOdW1iZXJ9IHRoZSB2YWx1ZSBmb3IgdGhlIGdpdmVuIGNhbGVuZGFyIGZpZWxkLlxuICAgKi9cbiAgZ2V0OiBmdW5jdGlvbiBnZXQoZmllbGQpIHtcbiAgICB0aGlzLmNvbXBsZXRlKCk7XG4gICAgcmV0dXJuIHRoaXMuZmllbGRzW2ZpZWxkXTtcbiAgfSxcblxuICAvKlxuICAgKiBSZXR1cm5zIHRoZSB5ZWFyIG9mIHRoZSBnaXZlbiBjYWxlbmRhciBmaWVsZC5cbiAgICogQG1ldGhvZCBnZXRZZWFyXG4gICAqIEByZXR1cm5zIHtOdW1iZXJ9IHRoZSB5ZWFyIGZvciB0aGUgZ2l2ZW4gY2FsZW5kYXIgZmllbGQuXG4gICAqL1xuXG4gIC8qXG4gICAqIFJldHVybnMgdGhlIG1vbnRoIG9mIHRoZSBnaXZlbiBjYWxlbmRhciBmaWVsZC5cbiAgICogQG1ldGhvZCBnZXRNb250aFxuICAgKiBAcmV0dXJucyB7TnVtYmVyfSB0aGUgbW9udGggZm9yIHRoZSBnaXZlbiBjYWxlbmRhciBmaWVsZC5cbiAgICovXG5cbiAgLypcbiAgICogUmV0dXJucyB0aGUgZGF5IG9mIG1vbnRoIG9mIHRoZSBnaXZlbiBjYWxlbmRhciBmaWVsZC5cbiAgICogQG1ldGhvZCBnZXREYXlPZk1vbnRoXG4gICAqIEByZXR1cm5zIHtOdW1iZXJ9IHRoZSBkYXkgb2YgbW9udGggZm9yIHRoZSBnaXZlbiBjYWxlbmRhciBmaWVsZC5cbiAgICovXG5cbiAgLypcbiAgICogUmV0dXJucyB0aGUgaG91ciBvZiBkYXkgb2YgdGhlIGdpdmVuIGNhbGVuZGFyIGZpZWxkLlxuICAgKiBAbWV0aG9kIGdldEhvdXJPZkRheVxuICAgKiBAcmV0dXJucyB7TnVtYmVyfSB0aGUgaG91ciBvZiBkYXkgZm9yIHRoZSBnaXZlbiBjYWxlbmRhciBmaWVsZC5cbiAgICovXG5cbiAgLypcbiAgICogUmV0dXJucyB0aGUgbWludXRlIG9mIHRoZSBnaXZlbiBjYWxlbmRhciBmaWVsZC5cbiAgICogQG1ldGhvZCBnZXRNaW51dGVcbiAgICogQHJldHVybnMge051bWJlcn0gdGhlIG1pbnV0ZSBmb3IgdGhlIGdpdmVuIGNhbGVuZGFyIGZpZWxkLlxuICAgKi9cblxuICAvKlxuICAgKiBSZXR1cm5zIHRoZSBzZWNvbmQgb2YgdGhlIGdpdmVuIGNhbGVuZGFyIGZpZWxkLlxuICAgKiBAbWV0aG9kIGdldFNlY29uZFxuICAgKiBAcmV0dXJucyB7TnVtYmVyfSB0aGUgc2Vjb25kIGZvciB0aGUgZ2l2ZW4gY2FsZW5kYXIgZmllbGQuXG4gICAqL1xuXG4gIC8qXG4gICAqIFJldHVybnMgdGhlIG1pbGxpc2Vjb25kIG9mIHRoZSBnaXZlbiBjYWxlbmRhciBmaWVsZC5cbiAgICogQG1ldGhvZCBnZXRNaWxsaVNlY29uZFxuICAgKiBAcmV0dXJucyB7TnVtYmVyfSB0aGUgbWlsbGlzZWNvbmQgZm9yIHRoZSBnaXZlbiBjYWxlbmRhciBmaWVsZC5cbiAgICovXG5cbiAgLypcbiAgICogUmV0dXJucyB0aGUgd2VlayBvZiB5ZWFyIG9mIHRoZSBnaXZlbiBjYWxlbmRhciBmaWVsZC5cbiAgICogQG1ldGhvZCBnZXRXZWVrT2ZZZWFyXG4gICAqIEByZXR1cm5zIHtOdW1iZXJ9IHRoZSB3ZWVrIG9mIHllYXIgZm9yIHRoZSBnaXZlbiBjYWxlbmRhciBmaWVsZC5cbiAgICovXG5cbiAgLypcbiAgICogUmV0dXJucyB0aGUgd2VlayBvZiBtb250aCBvZiB0aGUgZ2l2ZW4gY2FsZW5kYXIgZmllbGQuXG4gICAqIEBtZXRob2QgZ2V0V2Vla09mTW9udGhcbiAgICogQHJldHVybnMge051bWJlcn0gdGhlIHdlZWsgb2YgbW9udGggZm9yIHRoZSBnaXZlbiBjYWxlbmRhciBmaWVsZC5cbiAgICovXG5cbiAgLypcbiAgICogUmV0dXJucyB0aGUgZGF5IG9mIHllYXIgb2YgdGhlIGdpdmVuIGNhbGVuZGFyIGZpZWxkLlxuICAgKiBAbWV0aG9kIGdldERheU9mWWVhclxuICAgKiBAcmV0dXJucyB7TnVtYmVyfSB0aGUgZGF5IG9mIHllYXIgZm9yIHRoZSBnaXZlbiBjYWxlbmRhciBmaWVsZC5cbiAgICovXG5cbiAgLypcbiAgICogUmV0dXJucyB0aGUgZGF5IG9mIHdlZWsgb2YgdGhlIGdpdmVuIGNhbGVuZGFyIGZpZWxkLlxuICAgKiBAbWV0aG9kIGdldERheU9mV2Vla1xuICAgKiBAcmV0dXJucyB7TnVtYmVyfSB0aGUgZGF5IG9mIHdlZWsgZm9yIHRoZSBnaXZlbiBjYWxlbmRhciBmaWVsZC5cbiAgICovXG5cbiAgLypcbiAgICogUmV0dXJucyB0aGUgZGF5IG9mIHdlZWsgaW4gbW9udGggb2YgdGhlIGdpdmVuIGNhbGVuZGFyIGZpZWxkLlxuICAgKiBAbWV0aG9kIGdldERheU9mV2Vla0luTW9udGhcbiAgICogQHJldHVybnMge051bWJlcn0gdGhlIGRheSBvZiB3ZWVrIGluIG1vbnRoIGZvciB0aGUgZ2l2ZW4gY2FsZW5kYXIgZmllbGQuXG4gICAqL1xuXG4gIC8qXG4gICAqIFNldHMgdGhlIGdpdmVuIGNhbGVuZGFyIGZpZWxkIHRvIHRoZSBnaXZlbiB2YWx1ZS5cbiAgICogQHBhcmFtIGZpZWxkIHRoZSBnaXZlbiBjYWxlbmRhciBmaWVsZC5cbiAgICogQHBhcmFtIHYgdGhlIHZhbHVlIHRvIGJlIHNldCBmb3IgdGhlIGdpdmVuIGNhbGVuZGFyIGZpZWxkLlxuICAgKi9cbiAgc2V0OiBmdW5jdGlvbiBzZXQoZmllbGQsIHYpIHtcbiAgICB2YXIgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICBpZiAobGVuID09PSAyKSB7XG4gICAgICB0aGlzLmZpZWxkc1tmaWVsZF0gPSB2O1xuICAgIH0gZWxzZSBpZiAobGVuIDwgTUlMTElTRUNPTkRTICsgMSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICB0aGlzLmZpZWxkc1tZRUFSICsgaV0gPSBhcmd1bWVudHNbaV07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignaWxsZWdhbCBhcmd1bWVudHMgZm9yIEdyZWdvcmlhbkNhbGVuZGFyIHNldCcpO1xuICAgIH1cbiAgICB0aGlzLnRpbWUgPSB1bmRlZmluZWQ7XG4gIH0sXG5cbiAgLypcbiAgICogU2V0IHRoZSB5ZWFyIG9mIHRoZSBnaXZlbiBjYWxlbmRhciBmaWVsZC5cbiAgICogQG1ldGhvZCBzZXRZZWFyXG4gICAqL1xuXG4gIC8qXG4gICAqIFNldCB0aGUgbW9udGggb2YgdGhlIGdpdmVuIGNhbGVuZGFyIGZpZWxkLlxuICAgKiBAbWV0aG9kIHNldE1vbnRoXG4gICAqL1xuXG4gIC8qXG4gICAqIFNldCB0aGUgZGF5IG9mIG1vbnRoIG9mIHRoZSBnaXZlbiBjYWxlbmRhciBmaWVsZC5cbiAgICogQG1ldGhvZCBzZXREYXlPZk1vbnRoXG4gICAqL1xuXG4gIC8qXG4gICAqIFNldCB0aGUgaG91ciBvZiBkYXkgb2YgdGhlIGdpdmVuIGNhbGVuZGFyIGZpZWxkLlxuICAgKiBAbWV0aG9kIHNldEhvdXJPZkRheVxuICAgKi9cblxuICAvKlxuICAgKiBTZXQgdGhlIG1pbnV0ZSBvZiB0aGUgZ2l2ZW4gY2FsZW5kYXIgZmllbGQuXG4gICAqIEBtZXRob2Qgc2V0TWludXRlXG4gICAqL1xuXG4gIC8qXG4gICAqIFNldCB0aGUgc2Vjb25kIG9mIHRoZSBnaXZlbiBjYWxlbmRhciBmaWVsZC5cbiAgICogQG1ldGhvZCBzZXRTZWNvbmRcbiAgICovXG5cbiAgLypcbiAgICogU2V0IHRoZSBtaWxsaXNlY29uZCBvZiB0aGUgZ2l2ZW4gY2FsZW5kYXIgZmllbGQuXG4gICAqIEBtZXRob2Qgc2V0TWlsbGlTZWNvbmRcbiAgICovXG5cbiAgLypcbiAgICogU2V0IHRoZSB3ZWVrIG9mIHllYXIgb2YgdGhlIGdpdmVuIGNhbGVuZGFyIGZpZWxkLlxuICAgKiBAbWV0aG9kIHNldFdlZWtPZlllYXJcbiAgICovXG5cbiAgLypcbiAgICogU2V0IHRoZSB3ZWVrIG9mIG1vbnRoIG9mIHRoZSBnaXZlbiBjYWxlbmRhciBmaWVsZC5cbiAgICogQG1ldGhvZCBzZXRXZWVrT2ZNb250aFxuICAgKi9cblxuICAvKlxuICAgKiBTZXQgdGhlIGRheSBvZiB5ZWFyIG9mIHRoZSBnaXZlbiBjYWxlbmRhciBmaWVsZC5cbiAgICogQG1ldGhvZCBzZXREYXlPZlllYXJcbiAgICovXG5cbiAgLypcbiAgICogU2V0IHRoZSBkYXkgb2Ygd2VlayBvZiB0aGUgZ2l2ZW4gY2FsZW5kYXIgZmllbGQuXG4gICAqIEBtZXRob2Qgc2V0RGF5T2ZXZWVrXG4gICAqL1xuXG4gIC8qXG4gICAqIFNldCB0aGUgZGF5IG9mIHdlZWsgaW4gbW9udGggb2YgdGhlIGdpdmVuIGNhbGVuZGFyIGZpZWxkLlxuICAgKiBAbWV0aG9kIHNldERheU9mV2Vla0luTW9udGhcbiAgICovXG5cbiAgLypcbiAgICogYWRkIGZvciBzcGVjaWZpZWQgZmllbGQgYmFzZWQgb24gdHdvIHJ1bGVzOlxuICAgKlxuICAgKiAgLSBBZGQgcnVsZSAxLiBUaGUgdmFsdWUgb2YgZmllbGQgYWZ0ZXIgdGhlIGNhbGwgbWludXMgdGhlIHZhbHVlIG9mIGZpZWxkIGJlZm9yZSB0aGVcbiAgICogIGNhbGwgaXMgYW1vdW50LCBtb2R1bG8gYW55IG92ZXJmbG93IHRoYXQgaGFzIG9jY3VycmVkIGluIGZpZWxkXG4gICAqICBPdmVyZmxvdyBvY2N1cnMgd2hlbiBhIGZpZWxkIHZhbHVlIGV4Y2VlZHMgaXRzIHJhbmdlIGFuZCxcbiAgICogIGFzIGEgcmVzdWx0LCB0aGUgbmV4dCBsYXJnZXIgZmllbGQgaXMgaW5jcmVtZW50ZWQgb3JcbiAgICogIGRlY3JlbWVudGVkIGFuZCB0aGUgZmllbGQgdmFsdWUgaXMgYWRqdXN0ZWQgYmFjayBpbnRvIGl0cyByYW5nZS5cbiAgICpcbiAgICogIC0gQWRkIHJ1bGUgMi4gSWYgYSBzbWFsbGVyIGZpZWxkIGlzIGV4cGVjdGVkIHRvIGJlIGludmFyaWFudCxcbiAgICogIGJ1dCBpdCBpcyBpbXBvc3NpYmxlIGZvciBpdCB0byBiZSBlcXVhbCB0byBpdHNcbiAgICogIHByaW9yIHZhbHVlIGJlY2F1c2Ugb2YgY2hhbmdlcyBpbiBpdHMgbWluaW11bSBvciBtYXhpbXVtIGFmdGVyXG4gICAqICBmaWVsZCBpcyBjaGFuZ2VkLCB0aGVuIGl0cyB2YWx1ZSBpcyBhZGp1c3RlZCB0byBiZSBhcyBjbG9zZVxuICAgKiAgYXMgcG9zc2libGUgdG8gaXRzIGV4cGVjdGVkIHZhbHVlLiBBIHNtYWxsZXIgZmllbGQgcmVwcmVzZW50cyBhXG4gICAqICBzbWFsbGVyIHVuaXQgb2YgdGltZS4gSE9VUl9PRl9EQVkgaXMgYSBzbWFsbGVyIGZpZWxkIHRoYW5cbiAgICogIERBWV9PRl9NT05USC4gTm8gYWRqdXN0bWVudCBpcyBtYWRlIHRvIHNtYWxsZXIgZmllbGRzXG4gICAqICB0aGF0IGFyZSBub3QgZXhwZWN0ZWQgdG8gYmUgaW52YXJpYW50LiBUaGUgY2FsZW5kYXIgc3lzdGVtXG4gICAqICBkZXRlcm1pbmVzIHdoYXQgZmllbGRzIGFyZSBleHBlY3RlZCB0byBiZSBpbnZhcmlhbnQuXG4gICAqXG4gICAqXG4gICAqICAgICAgQGV4YW1wbGVcbiAgICogICAgICB1c2UoJ2RhdGUvZ3JlZ29yaWFuJyxmdW5jdGlvbihTLCBHcmVnb3JpYW5DYWxlbmRhcil7XG4gICAqICAgICAgICAgIGNvbnN0IGQgPSBuZXcgR3JlZ29yaWFuQ2FsZW5kYXIoKTtcbiAgICogICAgICAgICAgZC5zZXQoMjAxMiwgR3JlZ29yaWFuQ2FsZW5kYXIuSkFOVUFSWSwgMzEpO1xuICAgKiAgICAgICAgICBkLmFkZChHcmVnb3JpYW4uTU9OVEgsMSk7XG4gICAqICAgICAgICAgIC8vIDIwMTItMi0yOVxuICAgKiAgICAgICAgICBkb2N1bWVudC53cml0ZWxuKCc8cD4nK2QuZ2V0WWVhcigpKyctJytkLmdldE1vbnRoKCkrJy0nK2QuZ2V0RGF5T2ZXZWVrKCkpXG4gICAqICAgICAgICAgIGQuYWRkKEdyZWdvcmlhbi5NT05USCwxMik7XG4gICAqICAgICAgICAgIC8vIDIwMTMtMi0yOFxuICAgKiAgICAgICAgICBkb2N1bWVudC53cml0ZWxuKCc8cD4nK2QuZ2V0WWVhcigpKyctJytkLmdldE1vbnRoKCkrJy0nK2QuZ2V0RGF5T2ZXZWVrKCkpXG4gICAqICAgICAgfSk7XG4gICAqXG4gICAqIEBwYXJhbSBmaWVsZCB0aGUgY2FsZW5kYXIgZmllbGQuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBhbW91bnQgaGUgYW1vdW50IG9mIGRhdGUgb3IgdGltZSB0byBiZSBhZGRlZCB0byB0aGUgZmllbGQuXG4gICAqL1xuICBhZGQ6IGZ1bmN0aW9uIGFkZChmaWVsZCwgYSkge1xuICAgIGlmICghYSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgYW1vdW50ID0gYTtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGZpZWxkcyA9IHNlbGYuZmllbGRzO1xuICAgIC8vIGNvbXB1dGVyIGFuZCByZXRyaWV2ZSBvcmlnaW5hbCB2YWx1ZVxuICAgIHZhciB2YWx1ZSA9IHNlbGYuZ2V0KGZpZWxkKTtcbiAgICBpZiAoZmllbGQgPT09IFlFQVIpIHtcbiAgICAgIHZhbHVlICs9IGFtb3VudDtcbiAgICAgIHNlbGYuc2V0KFlFQVIsIHZhbHVlKTtcbiAgICAgIGFkanVzdERheU9mTW9udGgoc2VsZik7XG4gICAgfSBlbHNlIGlmIChmaWVsZCA9PT0gTU9OVEgpIHtcbiAgICAgIHZhbHVlICs9IGFtb3VudDtcbiAgICAgIHZhciB5ZWFyQW1vdW50ID0gZmxvb3JEaXZpZGUodmFsdWUgLyAxMik7XG4gICAgICB2YWx1ZSA9IG1vZCh2YWx1ZSwgMTIpO1xuICAgICAgaWYgKHllYXJBbW91bnQpIHtcbiAgICAgICAgc2VsZi5zZXQoWUVBUiwgZmllbGRzW1lFQVJdICsgeWVhckFtb3VudCk7XG4gICAgICB9XG4gICAgICBzZWxmLnNldChNT05USCwgdmFsdWUpO1xuICAgICAgYWRqdXN0RGF5T2ZNb250aChzZWxmKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3dpdGNoIChmaWVsZCkge1xuICAgICAgICBjYXNlIEhPVVJfT0ZfREFZOlxuICAgICAgICAgIGFtb3VudCAqPSBPTkVfSE9VUjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBNSU5VVEU6XG4gICAgICAgICAgYW1vdW50ICo9IE9ORV9NSU5VVEU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgU0VDT05EUzpcbiAgICAgICAgICBhbW91bnQgKj0gT05FX1NFQ09ORDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBNSUxMSVNFQ09ORFM6XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgV0VFS19PRl9NT05USDpcbiAgICAgICAgY2FzZSBXRUVLX09GX1lFQVI6XG4gICAgICAgIGNhc2UgREFZX09GX1dFRUtfSU5fTU9OVEg6XG4gICAgICAgICAgYW1vdW50ICo9IE9ORV9XRUVLO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIERBWV9PRl9XRUVLOlxuICAgICAgICBjYXNlIERBWV9PRl9ZRUFSOlxuICAgICAgICBjYXNlIERBWV9PRl9NT05USDpcbiAgICAgICAgICBhbW91bnQgKj0gT05FX0RBWTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2lsbGVnYWwgZmllbGQgZm9yIGFkZCcpO1xuICAgICAgfVxuICAgICAgc2VsZi5zZXRUaW1lKHNlbGYudGltZSArIGFtb3VudCk7XG4gICAgfVxuICB9LFxuXG4gIC8qXG4gICAqIGFkZCB0aGUgeWVhciBvZiB0aGUgZ2l2ZW4gY2FsZW5kYXIgZmllbGQuXG4gICAqIEBtZXRob2QgYWRkWWVhclxuICAgKiBAcGFyYW0ge051bWJlcn0gYW1vdW50IHRoZSBzaWduZWQgYW1vdW50IHRvIGFkZCB0byBmaWVsZC5cbiAgICovXG5cbiAgLypcbiAgICogYWRkIHRoZSBtb250aCBvZiB0aGUgZ2l2ZW4gY2FsZW5kYXIgZmllbGQuXG4gICAqIEBtZXRob2QgYWRkTW9udGhcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGFtb3VudCB0aGUgc2lnbmVkIGFtb3VudCB0byBhZGQgdG8gZmllbGQuXG4gICAqL1xuXG4gIC8qXG4gICAqIGFkZCB0aGUgZGF5IG9mIG1vbnRoIG9mIHRoZSBnaXZlbiBjYWxlbmRhciBmaWVsZC5cbiAgICogQG1ldGhvZCBhZGREYXlPZk1vbnRoXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBhbW91bnQgdGhlIHNpZ25lZCBhbW91bnQgdG8gYWRkIHRvIGZpZWxkLlxuICAgKi9cblxuICAvKlxuICAgKiBhZGQgdGhlIGhvdXIgb2YgZGF5IG9mIHRoZSBnaXZlbiBjYWxlbmRhciBmaWVsZC5cbiAgICogQG1ldGhvZCBhZGRIb3VyT2ZEYXlcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGFtb3VudCB0aGUgc2lnbmVkIGFtb3VudCB0byBhZGQgdG8gZmllbGQuXG4gICAqL1xuXG4gIC8qXG4gICAqIGFkZCB0aGUgbWludXRlIG9mIHRoZSBnaXZlbiBjYWxlbmRhciBmaWVsZC5cbiAgICogQG1ldGhvZCBhZGRNaW51dGVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGFtb3VudCB0aGUgc2lnbmVkIGFtb3VudCB0byBhZGQgdG8gZmllbGQuXG4gICAqL1xuXG4gIC8qXG4gICAqIGFkZCB0aGUgc2Vjb25kIG9mIHRoZSBnaXZlbiBjYWxlbmRhciBmaWVsZC5cbiAgICogQG1ldGhvZCBhZGRTZWNvbmRcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGFtb3VudCB0aGUgc2lnbmVkIGFtb3VudCB0byBhZGQgdG8gZmllbGQuXG4gICAqL1xuXG4gIC8qXG4gICAqIGFkZCB0aGUgbWlsbGlzZWNvbmQgb2YgdGhlIGdpdmVuIGNhbGVuZGFyIGZpZWxkLlxuICAgKiBAbWV0aG9kIGFkZE1pbGxpU2Vjb25kXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBhbW91bnQgdGhlIHNpZ25lZCBhbW91bnQgdG8gYWRkIHRvIGZpZWxkLlxuICAgKi9cblxuICAvKlxuICAgKiBhZGQgdGhlIHdlZWsgb2YgeWVhciBvZiB0aGUgZ2l2ZW4gY2FsZW5kYXIgZmllbGQuXG4gICAqIEBtZXRob2QgYWRkV2Vla09mWWVhclxuICAgKiBAcGFyYW0ge051bWJlcn0gYW1vdW50IHRoZSBzaWduZWQgYW1vdW50IHRvIGFkZCB0byBmaWVsZC5cbiAgICovXG5cbiAgLypcbiAgICogYWRkIHRoZSB3ZWVrIG9mIG1vbnRoIG9mIHRoZSBnaXZlbiBjYWxlbmRhciBmaWVsZC5cbiAgICogQG1ldGhvZCBhZGRXZWVrT2ZNb250aFxuICAgKiBAcGFyYW0ge051bWJlcn0gYW1vdW50IHRoZSBzaWduZWQgYW1vdW50IHRvIGFkZCB0byBmaWVsZC5cbiAgICovXG5cbiAgLypcbiAgICogYWRkIHRoZSBkYXkgb2YgeWVhciBvZiB0aGUgZ2l2ZW4gY2FsZW5kYXIgZmllbGQuXG4gICAqIEBtZXRob2QgYWRkRGF5T2ZZZWFyXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBhbW91bnQgdGhlIHNpZ25lZCBhbW91bnQgdG8gYWRkIHRvIGZpZWxkLlxuICAgKi9cblxuICAvKlxuICAgKiBhZGQgdGhlIGRheSBvZiB3ZWVrIG9mIHRoZSBnaXZlbiBjYWxlbmRhciBmaWVsZC5cbiAgICogQG1ldGhvZCBhZGREYXlPZldlZWtcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGFtb3VudCB0aGUgc2lnbmVkIGFtb3VudCB0byBhZGQgdG8gZmllbGQuXG4gICAqL1xuXG4gIC8qXG4gICAqIGFkZCB0aGUgZGF5IG9mIHdlZWsgaW4gbW9udGggb2YgdGhlIGdpdmVuIGNhbGVuZGFyIGZpZWxkLlxuICAgKiBAbWV0aG9kIGFkZERheU9mV2Vla0luTW9udGhcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGFtb3VudCB0aGUgc2lnbmVkIGFtb3VudCB0byBhZGQgdG8gZmllbGQuXG4gICAqL1xuXG4gIC8qXG4gICAqIEdldCByb2xsZWQgdmFsdWUgZm9yIHRoZSBmaWVsZFxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBnZXRSb2xsZWRWYWx1ZTogZnVuY3Rpb24gZ2V0Um9sbGVkVmFsdWUodmFsdWUsIGEsIG1pbiwgbWF4KSB7XG4gICAgdmFyIGFtb3VudCA9IGE7XG4gICAgdmFyIGRpZmYgPSB2YWx1ZSAtIG1pbjtcbiAgICB2YXIgcmFuZ2UgPSBtYXggLSBtaW4gKyAxO1xuICAgIGFtb3VudCAlPSByYW5nZTtcbiAgICByZXR1cm4gbWluICsgKGRpZmYgKyBhbW91bnQgKyByYW5nZSkgJSByYW5nZTtcbiAgfSxcblxuICAvKlxuICAgKiBBZGRzIGEgc2lnbmVkIGFtb3VudCB0byB0aGUgc3BlY2lmaWVkIGNhbGVuZGFyIGZpZWxkIHdpdGhvdXQgY2hhbmdpbmcgbGFyZ2VyIGZpZWxkcy5cbiAgICogQSBuZWdhdGl2ZSByb2xsIGFtb3VudCBtZWFucyB0byBzdWJ0cmFjdCBmcm9tIGZpZWxkIHdpdGhvdXQgY2hhbmdpbmdcbiAgICogbGFyZ2VyIGZpZWxkcy4gSWYgdGhlIHNwZWNpZmllZCBhbW91bnQgaXMgMCwgdGhpcyBtZXRob2QgcGVyZm9ybXMgbm90aGluZy5cbiAgICpcbiAgICpcbiAgICpcbiAgICogICAgICBAZXhhbXBsZVxuICAgKiAgICAgIGNvbnN0IGQgPSBuZXcgR3JlZ29yaWFuQ2FsZW5kYXIoKTtcbiAgICogICAgICBkLnNldCgxOTk5LCBHcmVnb3JpYW5DYWxlbmRhci5BVUdVU1QsIDMxKTtcbiAgICogICAgICAvLyAxOTk5LTQtMzBcbiAgICogICAgICAvLyBUdWVzZGF5IEp1bmUgMSwgMTk5OVxuICAgKiAgICAgIGQuc2V0KDE5OTksIEdyZWdvcmlhbkNhbGVuZGFyLkpVTkUsIDEpO1xuICAgKiAgICAgIGQuYWRkKEdyZWdvcmlhbi5XRUVLX09GX01PTlRILC0xKTsgLy8gPT09IGQuYWRkKEdyZWdvcmlhbi5XRUVLX09GX01PTlRILFxuICAgKiAgICAgIGQuZ2V0KEdyZWdvcmlhbi5XRUVLX09GX01PTlRIKSk7XG4gICAqICAgICAgLy8gMTk5OS0wNi0yOVxuICAgKlxuICAgKlxuICAgKiBAcGFyYW0gZmllbGQgdGhlIGNhbGVuZGFyIGZpZWxkLlxuICAgKiBAcGFyYW0ge051bWJlcn0gYW1vdW50IHRoZSBzaWduZWQgYW1vdW50IHRvIGFkZCB0byBmaWVsZC5cbiAgICovXG4gIHJvbGw6IGZ1bmN0aW9uIHJvbGwoZmllbGQsIGFtb3VudCkge1xuICAgIGlmICghYW1vdW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAvLyBjb21wdXRlciBhbmQgcmV0cmlldmUgb3JpZ2luYWwgdmFsdWVcbiAgICB2YXIgdmFsdWUgPSBzZWxmLmdldChmaWVsZCk7XG4gICAgdmFyIG1pbiA9IHNlbGYuZ2V0QWN0dWFsTWluaW11bShmaWVsZCk7XG4gICAgdmFyIG1heCA9IHNlbGYuZ2V0QWN0dWFsTWF4aW11bShmaWVsZCk7XG4gICAgdmFsdWUgPSBzZWxmLmdldFJvbGxlZFZhbHVlKHZhbHVlLCBhbW91bnQsIG1pbiwgbWF4KTtcblxuICAgIHNlbGYuc2V0KGZpZWxkLCB2YWx1ZSk7XG5cbiAgICAvLyBjb25zaWRlciBjb21wdXRlIHRpbWUgcHJpb3JpdHlcbiAgICBzd2l0Y2ggKGZpZWxkKSB7XG4gICAgICBjYXNlIE1PTlRIOlxuICAgICAgICBhZGp1c3REYXlPZk1vbnRoKHNlbGYpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIC8vIG90aGVyIGZpZWxkcyBhcmUgc2V0IGFscmVhZHkgd2hlbiBnZXRcbiAgICAgICAgc2VsZi51cGRhdGVGaWVsZHNCeVNldChmaWVsZCk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfSxcblxuICAvKlxuICAgKiBrZWVwIGZpZWxkIHN0YWJsZS5cbiAgICpcbiAgICogMjAxNS0wOS0yOSBzZXRNb250aCAyIHZzIHJvbGxTZXRNb250aCAyXG4gICAqXG4gICAqL1xuICByb2xsU2V0OiBmdW5jdGlvbiByb2xsU2V0KGZpZWxkLCB2KSB7XG4gICAgdGhpcy5zZXQoZmllbGQsIHYpO1xuICAgIHN3aXRjaCAoZmllbGQpIHtcbiAgICAgIGNhc2UgTU9OVEg6XG4gICAgICAgIGFkanVzdERheU9mTW9udGgodGhpcyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgLy8gb3RoZXIgZmllbGRzIGFyZSBzZXQgYWxyZWFkeSB3aGVuIGdldFxuICAgICAgICB0aGlzLnVwZGF0ZUZpZWxkc0J5U2V0KGZpZWxkKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9LFxuXG4gIC8qXG4gICAqIHJvbGwgdGhlIHllYXIgb2YgdGhlIGdpdmVuIGNhbGVuZGFyIGZpZWxkLlxuICAgKiBAbWV0aG9kIHJvbGxZZWFyXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBhbW91bnQgdGhlIHNpZ25lZCBhbW91bnQgdG8gYWRkIHRvIGZpZWxkLlxuICAgKi9cblxuICAvKlxuICAgKiByb2xsIHRoZSBtb250aCBvZiB0aGUgZ2l2ZW4gY2FsZW5kYXIgZmllbGQuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBhbW91bnQgdGhlIHNpZ25lZCBhbW91bnQgdG8gYWRkIHRvIGZpZWxkLlxuICAgKiBAbWV0aG9kIHJvbGxNb250aFxuICAgKi9cblxuICAvKlxuICAgKiByb2xsIHRoZSBkYXkgb2YgbW9udGggb2YgdGhlIGdpdmVuIGNhbGVuZGFyIGZpZWxkLlxuICAgKiBAbWV0aG9kIHJvbGxEYXlPZk1vbnRoXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBhbW91bnQgdGhlIHNpZ25lZCBhbW91bnQgdG8gYWRkIHRvIGZpZWxkLlxuICAgKi9cblxuICAvKlxuICAgKiByb2xsIHRoZSBob3VyIG9mIGRheSBvZiB0aGUgZ2l2ZW4gY2FsZW5kYXIgZmllbGQuXG4gICAqIEBtZXRob2Qgcm9sbEhvdXJPZkRheVxuICAgKiBAcGFyYW0ge051bWJlcn0gYW1vdW50IHRoZSBzaWduZWQgYW1vdW50IHRvIGFkZCB0byBmaWVsZC5cbiAgICovXG5cbiAgLypcbiAgICogcm9sbCB0aGUgbWludXRlIG9mIHRoZSBnaXZlbiBjYWxlbmRhciBmaWVsZC5cbiAgICogQG1ldGhvZCByb2xsTWludXRlXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBhbW91bnQgdGhlIHNpZ25lZCBhbW91bnQgdG8gYWRkIHRvIGZpZWxkLlxuICAgKi9cblxuICAvKlxuICAgKiByb2xsIHRoZSBzZWNvbmQgb2YgdGhlIGdpdmVuIGNhbGVuZGFyIGZpZWxkLlxuICAgKiBAbWV0aG9kIHJvbGxTZWNvbmRcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGFtb3VudCB0aGUgc2lnbmVkIGFtb3VudCB0byBhZGQgdG8gZmllbGQuXG4gICAqL1xuXG4gIC8qXG4gICAqIHJvbGwgdGhlIG1pbGxpc2Vjb25kIG9mIHRoZSBnaXZlbiBjYWxlbmRhciBmaWVsZC5cbiAgICogQG1ldGhvZCByb2xsTWlsbGlTZWNvbmRcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGFtb3VudCB0aGUgc2lnbmVkIGFtb3VudCB0byBhZGQgdG8gZmllbGQuXG4gICAqL1xuXG4gIC8qXG4gICAqIHJvbGwgdGhlIHdlZWsgb2YgeWVhciBvZiB0aGUgZ2l2ZW4gY2FsZW5kYXIgZmllbGQuXG4gICAqIEBtZXRob2Qgcm9sbFdlZWtPZlllYXJcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGFtb3VudCB0aGUgc2lnbmVkIGFtb3VudCB0byBhZGQgdG8gZmllbGQuXG4gICAqL1xuXG4gIC8qXG4gICAqIHJvbGwgdGhlIHdlZWsgb2YgbW9udGggb2YgdGhlIGdpdmVuIGNhbGVuZGFyIGZpZWxkLlxuICAgKiBAbWV0aG9kIHJvbGxXZWVrT2ZNb250aFxuICAgKiBAcGFyYW0ge051bWJlcn0gYW1vdW50IHRoZSBzaWduZWQgYW1vdW50IHRvIGFkZCB0byBmaWVsZC5cbiAgICovXG5cbiAgLypcbiAgICogcm9sbCB0aGUgZGF5IG9mIHllYXIgb2YgdGhlIGdpdmVuIGNhbGVuZGFyIGZpZWxkLlxuICAgKiBAbWV0aG9kIHJvbGxEYXlPZlllYXJcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGFtb3VudCB0aGUgc2lnbmVkIGFtb3VudCB0byBhZGQgdG8gZmllbGQuXG4gICAqL1xuXG4gIC8qXG4gICAqIHJvbGwgdGhlIGRheSBvZiB3ZWVrIG9mIHRoZSBnaXZlbiBjYWxlbmRhciBmaWVsZC5cbiAgICogQG1ldGhvZCByb2xsRGF5T2ZXZWVrXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBhbW91bnQgdGhlIHNpZ25lZCBhbW91bnQgdG8gYWRkIHRvIGZpZWxkLlxuICAgKi9cblxuICAvKlxuICAgKiByZW1vdmUgb3RoZXIgcHJpb3JpdHkgZmllbGRzIHdoZW4gY2FsbCBnZXRGaXhlZERhdGVcbiAgICogcHJlY29uZGl0aW9uOiBvdGhlciBmaWVsZHMgYXJlIGFsbCBzZXQgb3IgY29tcHV0ZWRcbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgdXBkYXRlRmllbGRzQnlTZXQ6IGZ1bmN0aW9uIHVwZGF0ZUZpZWxkc0J5U2V0KGZpZWxkKSB7XG4gICAgdmFyIGZpZWxkcyA9IHRoaXMuZmllbGRzO1xuICAgIHN3aXRjaCAoZmllbGQpIHtcbiAgICAgIGNhc2UgV0VFS19PRl9NT05USDpcbiAgICAgICAgZmllbGRzW0RBWV9PRl9NT05USF0gPSB1bmRlZmluZWQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBEQVlfT0ZfWUVBUjpcbiAgICAgICAgZmllbGRzW01PTlRIXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIERBWV9PRl9XRUVLOlxuICAgICAgICBmaWVsZHNbREFZX09GX01PTlRIXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFdFRUtfT0ZfWUVBUjpcbiAgICAgICAgZmllbGRzW0RBWV9PRl9ZRUFSXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgZmllbGRzW01PTlRIXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBicmVhaztcbiAgICB9XG4gIH0sXG5cbiAgLypcbiAgICogZ2V0IGN1cnJlbnQgZGF0ZSBpbnN0YW5jZSdzIHRpbWV6b25lIG9mZnNldFxuICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgKi9cbiAgZ2V0VGltZXpvbmVPZmZzZXQ6IGZ1bmN0aW9uIGdldFRpbWV6b25lT2Zmc2V0KCkge1xuICAgIHJldHVybiB0aGlzLnRpbWV6b25lT2Zmc2V0O1xuICB9LFxuXG4gIC8qXG4gICAqIHNldCBjdXJyZW50IGRhdGUgaW5zdGFuY2UncyB0aW1lem9uZSBvZmZzZXRcbiAgICovXG4gIHNldFRpbWV6b25lT2Zmc2V0OiBmdW5jdGlvbiBzZXRUaW1lem9uZU9mZnNldCh0aW1lem9uZU9mZnNldCkge1xuICAgIGlmICh0aGlzLnRpbWV6b25lT2Zmc2V0ICE9PSB0aW1lem9uZU9mZnNldCkge1xuICAgICAgdGhpcy5maWVsZHNDb21wdXRlZCA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMudGltZXpvbmVPZmZzZXQgPSB0aW1lem9uZU9mZnNldDtcbiAgICB9XG4gIH0sXG5cbiAgLypcbiAgICogc2V0IGZpcnN0IGRheSBvZiB3ZWVrIGZvciBjdXJyZW50IGRhdGUgaW5zdGFuY2VcbiAgICovXG4gIHNldEZpcnN0RGF5T2ZXZWVrOiBmdW5jdGlvbiBzZXRGaXJzdERheU9mV2VlayhmaXJzdERheU9mV2Vlaykge1xuICAgIGlmICh0aGlzLmZpcnN0RGF5T2ZXZWVrICE9PSBmaXJzdERheU9mV2Vlaykge1xuICAgICAgdGhpcy5maXJzdERheU9mV2VlayA9IGZpcnN0RGF5T2ZXZWVrO1xuICAgICAgdGhpcy5maWVsZHNDb21wdXRlZCA9IGZhbHNlO1xuICAgIH1cbiAgfSxcblxuICAvKlxuICAgKiBHZXRzIHdoYXQgdGhlIGZpcnN0IGRheSBvZiB0aGUgd2VlayBpczsgZS5nLiwgU1VOREFZIGluIHRoZSBVLlMuLCBNT05EQVkgaW4gRnJhbmNlLlxuICAgKiBAcmV0dXJucyB7TnVtYmVyfSB0aGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrLlxuICAgKi9cbiAgZ2V0Rmlyc3REYXlPZldlZWs6IGZ1bmN0aW9uIGdldEZpcnN0RGF5T2ZXZWVrKCkge1xuICAgIHJldHVybiB0aGlzLmZpcnN0RGF5T2ZXZWVrO1xuICB9LFxuXG4gIC8qXG4gICAqIFNldHMgd2hhdCB0aGUgbWluaW1hbCBkYXlzIHJlcXVpcmVkIGluIHRoZSBmaXJzdCB3ZWVrIG9mIHRoZSB5ZWFyIGFyZTsgRm9yIGV4YW1wbGUsXG4gICAqIGlmIHRoZSBmaXJzdCB3ZWVrIGlzIGRlZmluZWQgYXMgb25lIHRoYXQgY29udGFpbnMgdGhlIGZpcnN0IGRheSBvZiB0aGUgZmlyc3QgbW9udGggb2YgYSB5ZWFyLFxuICAgKiBjYWxsIHRoaXMgbWV0aG9kIHdpdGggdmFsdWUgMS5cbiAgICogSWYgaXQgbXVzdCBiZSBhIGZ1bGwgd2VlaywgdXNlIHZhbHVlIDcuXG4gICAqIEBwYXJhbSBtaW5pbWFsRGF5c0luRmlyc3RXZWVrIHRoZSBnaXZlbiBtaW5pbWFsIGRheXMgcmVxdWlyZWQgaW4gdGhlIGZpcnN0IHdlZWsgb2YgdGhlIHllYXIuXG4gICAqL1xuICBzZXRNaW5pbWFsRGF5c0luRmlyc3RXZWVrOiBmdW5jdGlvbiBzZXRNaW5pbWFsRGF5c0luRmlyc3RXZWVrKG1pbmltYWxEYXlzSW5GaXJzdFdlZWspIHtcbiAgICBpZiAodGhpcy5taW5pbWFsRGF5c0luRmlyc3RXZWVrICE9PSBtaW5pbWFsRGF5c0luRmlyc3RXZWVrKSB7XG4gICAgICB0aGlzLm1pbmltYWxEYXlzSW5GaXJzdFdlZWsgPSBtaW5pbWFsRGF5c0luRmlyc3RXZWVrO1xuICAgICAgdGhpcy5maWVsZHNDb21wdXRlZCA9IGZhbHNlO1xuICAgIH1cbiAgfSxcblxuICAvKlxuICAgKiBHZXRzIHdoYXQgdGhlIG1pbmltYWwgZGF5cyByZXF1aXJlZCBpbiB0aGUgZmlyc3Qgd2VlayBvZiB0aGUgeWVhciBhcmU7IGUuZy4sXG4gICAqIGlmIHRoZSBmaXJzdCB3ZWVrIGlzIGRlZmluZWQgYXMgb25lIHRoYXQgY29udGFpbnMgdGhlIGZpcnN0IGRheSBvZiB0aGUgZmlyc3QgbW9udGggb2YgYSB5ZWFyLFxuICAgKiB0aGlzIG1ldGhvZCByZXR1cm5zIDEuXG4gICAqIElmIHRoZSBtaW5pbWFsIGRheXMgcmVxdWlyZWQgbXVzdCBiZSBhIGZ1bGwgd2VlaywgdGhpcyBtZXRob2QgcmV0dXJucyA3LlxuICAgKiBAcmV0dXJucyB7TnVtYmVyfSB0aGUgbWluaW1hbCBkYXlzIHJlcXVpcmVkIGluIHRoZSBmaXJzdCB3ZWVrIG9mIHRoZSB5ZWFyLlxuICAgKi9cbiAgZ2V0TWluaW1hbERheXNJbkZpcnN0V2VlazogZnVuY3Rpb24gZ2V0TWluaW1hbERheXNJbkZpcnN0V2VlaygpIHtcbiAgICByZXR1cm4gdGhpcy5taW5pbWFsRGF5c0luRmlyc3RXZWVrO1xuICB9LFxuXG4gIC8qXG4gICAqIFJldHVybnMgdGhlIG51bWJlciBvZiB3ZWVrcyBpbiB0aGUgd2VlayB5ZWFyXG4gICAqIHJlcHJlc2VudGVkIGJ5IHRoaXMgR3JlZ29yaWFuQ2FsZW5kYXIuXG4gICAqXG4gICAqIEZvciBleGFtcGxlLCBpZiB0aGlzIEdyZWdvcmlhbkNhbGVuZGFyJ3MgZGF0ZSBpc1xuICAgKiBEZWNlbWJlciAzMSwgMjAwOCB3aXRoIHRoZSBJU09cbiAgICogODYwMSBjb21wYXRpYmxlIHNldHRpbmcsIHRoaXMgbWV0aG9kIHdpbGwgcmV0dXJuIDUzIGZvciB0aGVcbiAgICogcGVyaW9kOiBEZWNlbWJlciAyOSwgMjAwOCB0byBKYW51YXJ5IDMsIDIwMTBcbiAgICogd2hpbGUgZ2V0QWN0dWFsTWF4aW11bShXRUVLX09GX1lFQVIpIHdpbGwgcmV0dXJuXG4gICAqIDUyIGZvciB0aGUgcGVyaW9kOiBEZWNlbWJlciAzMSwgMjAwNyB0byBEZWNlbWJlciAyOCwgMjAwOC5cbiAgICpcbiAgICogQHJldHVybiB7TnVtYmVyfSB0aGUgbnVtYmVyIG9mIHdlZWtzIGluIHRoZSB3ZWVrIHllYXIuXG4gICAqL1xuICBnZXRXZWVrc0luV2Vla1llYXI6IGZ1bmN0aW9uIGdldFdlZWtzSW5XZWVrWWVhcigpIHtcbiAgICB2YXIgd2Vla1llYXIgPSB0aGlzLmdldFdlZWtZZWFyKCk7XG4gICAgaWYgKHdlZWtZZWFyID09PSB0aGlzLmdldChZRUFSKSkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0QWN0dWFsTWF4aW11bShXRUVLX09GX1lFQVIpO1xuICAgIH1cbiAgICAvLyBVc2UgdGhlIDJuZCB3ZWVrIGZvciBjYWxjdWxhdGluZyB0aGUgbWF4IG9mIFdFRUtfT0ZfWUVBUlxuICAgIHZhciBnYyA9IHRoaXMuY2xvbmUoKTtcbiAgICBnYy5jbGVhcigpO1xuICAgIGdjLnNldFdlZWtEYXRlKHdlZWtZZWFyLCAyLCB0aGlzLmdldChEQVlfT0ZfV0VFSykpO1xuICAgIHJldHVybiBnYy5nZXRBY3R1YWxNYXhpbXVtKFdFRUtfT0ZfWUVBUik7XG4gIH0sXG5cbiAgLypcbiAgICogUmV0dXJucyB0aGUgd2VlayB5ZWFyIHJlcHJlc2VudGVkIGJ5IHRoaXMgR3JlZ29yaWFuQ2FsZW5kYXIuXG4gICAqIFRoZSBkYXRlcyBpbiB0aGUgd2Vla3MgYmV0d2VlbiAxIGFuZCB0aGVcbiAgICogbWF4aW11bSB3ZWVrIG51bWJlciBvZiB0aGUgd2VlayB5ZWFyIGhhdmUgdGhlIHNhbWUgd2VlayB5ZWFyIHZhbHVlXG4gICAqIHRoYXQgbWF5IGJlIG9uZSB5ZWFyIGJlZm9yZSBvciBhZnRlciB0aGUgY2FsZW5kYXIgeWVhciB2YWx1ZS5cbiAgICpcbiAgICogQHJldHVybiB7TnVtYmVyfSB0aGUgd2VlayB5ZWFyIHJlcHJlc2VudGVkIGJ5IHRoaXMgR3JlZ29yaWFuQ2FsZW5kYXIuXG4gICAqL1xuICBnZXRXZWVrWWVhcjogZnVuY3Rpb24gZ2V0V2Vla1llYXIoKSB7XG4gICAgdmFyIHllYXIgPSB0aGlzLmdldChZRUFSKTsgLy8gaW1wbGljaXRseSAgY29tcGxldGVcbiAgICB2YXIgd2Vla09mWWVhciA9IHRoaXMuZ2V0KFdFRUtfT0ZfWUVBUik7XG4gICAgdmFyIG1vbnRoID0gdGhpcy5nZXQoTU9OVEgpO1xuICAgIGlmIChtb250aCA9PT0gR3JlZ29yaWFuQ2FsZW5kYXIuSkFOVUFSWSkge1xuICAgICAgaWYgKHdlZWtPZlllYXIgPj0gNTIpIHtcbiAgICAgICAgLS15ZWFyO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobW9udGggPT09IEdyZWdvcmlhbkNhbGVuZGFyLkRFQ0VNQkVSKSB7XG4gICAgICBpZiAod2Vla09mWWVhciA9PT0gMSkge1xuICAgICAgICArK3llYXI7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB5ZWFyO1xuICB9LFxuICAvKlxuICAgKiBTZXRzIHRoaXMgR3JlZ29yaWFuQ2FsZW5kYXIgdG8gdGhlIGRhdGUgZ2l2ZW4gYnkgdGhlIGRhdGUgc3BlY2lmaWVycyAtIHdlZWtZZWFyLFxuICAgKiB3ZWVrT2ZZZWFyLCBhbmQgZGF5T2ZXZWVrLiB3ZWVrT2ZZZWFyIGZvbGxvd3MgdGhlIFdFRUtfT0ZfWUVBUiBudW1iZXJpbmcuXG4gICAqIFRoZSBkYXlPZldlZWsgdmFsdWUgbXVzdCBiZSBvbmUgb2YgdGhlIERBWV9PRl9XRUVLIHZhbHVlczogU1VOREFZIHRvIFNBVFVSREFZLlxuICAgKlxuICAgKiBAcGFyYW0gd2Vla1llYXIgICAgdGhlIHdlZWsgeWVhclxuICAgKiBAcGFyYW0gd2Vla09mWWVhciAgdGhlIHdlZWsgbnVtYmVyIGJhc2VkIG9uIHdlZWtZZWFyXG4gICAqIEBwYXJhbSBkYXlPZldlZWsgICB0aGUgZGF5IG9mIHdlZWsgdmFsdWVcbiAgICovXG4gIHNldFdlZWtEYXRlOiBmdW5jdGlvbiBzZXRXZWVrRGF0ZSh3ZWVrWWVhciwgd2Vla09mWWVhciwgZGF5T2ZXZWVrKSB7XG4gICAgaWYgKGRheU9mV2VlayA8IEdyZWdvcmlhbkNhbGVuZGFyLlNVTkRBWSB8fCBkYXlPZldlZWsgPiBHcmVnb3JpYW5DYWxlbmRhci5TQVRVUkRBWSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGRheU9mV2VlazogJyArIGRheU9mV2Vlayk7XG4gICAgfVxuICAgIHZhciBmaWVsZHMgPSB0aGlzLmZpZWxkcztcbiAgICAvLyBUbyBhdm9pZCBjaGFuZ2luZyB0aGUgdGltZSBvZiBkYXkgZmllbGRzIGJ5IGRhdGVcbiAgICAvLyBjYWxjdWxhdGlvbnMsIHVzZSBhIGNsb25lIHdpdGggdGhlIEdNVCB0aW1lIHpvbmUuXG4gICAgdmFyIGdjID0gdGhpcy5jbG9uZSgpO1xuICAgIGdjLmNsZWFyKCk7XG4gICAgZ2Muc2V0VGltZXpvbmVPZmZzZXQoMCk7XG4gICAgZ2Muc2V0KFlFQVIsIHdlZWtZZWFyKTtcbiAgICBnYy5zZXQoV0VFS19PRl9ZRUFSLCAxKTtcbiAgICBnYy5zZXQoREFZX09GX1dFRUssIHRoaXMuZ2V0Rmlyc3REYXlPZldlZWsoKSk7XG4gICAgdmFyIGRheXMgPSBkYXlPZldlZWsgLSB0aGlzLmdldEZpcnN0RGF5T2ZXZWVrKCk7XG4gICAgaWYgKGRheXMgPCAwKSB7XG4gICAgICBkYXlzICs9IDc7XG4gICAgfVxuICAgIGRheXMgKz0gNyAqICh3ZWVrT2ZZZWFyIC0gMSk7XG4gICAgaWYgKGRheXMgIT09IDApIHtcbiAgICAgIGdjLmFkZChEQVlfT0ZfWUVBUiwgZGF5cyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGdjLmNvbXBsZXRlKCk7XG4gICAgfVxuICAgIGZpZWxkc1tZRUFSXSA9IGdjLmdldChZRUFSKTtcbiAgICBmaWVsZHNbTU9OVEhdID0gZ2MuZ2V0KE1PTlRIKTtcbiAgICBmaWVsZHNbREFZX09GX01PTlRIXSA9IGdjLmdldChEQVlfT0ZfTU9OVEgpO1xuICAgIHRoaXMuY29tcGxldGUoKTtcbiAgfSxcbiAgLypcbiAgICogQ3JlYXRlcyBhbmQgcmV0dXJucyBhIGNvcHkgb2YgdGhpcyBvYmplY3QuXG4gICAqIEByZXR1cm5zIHtEYXRlLkdyZWdvcmlhbn1cbiAgICovXG4gIGNsb25lOiBmdW5jdGlvbiBjbG9uZSgpIHtcbiAgICBpZiAodGhpcy50aW1lID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuY29tcHV0ZVRpbWUoKTtcbiAgICB9XG4gICAgdmFyIGNhbCA9IG5ldyBHcmVnb3JpYW5DYWxlbmRhcih0aGlzLmxvY2FsZSk7XG4gICAgY2FsLnNldFRpbWV6b25lT2Zmc2V0KGNhbC5nZXRUaW1lem9uZU9mZnNldCgpKTtcbiAgICBjYWwuc2V0Rmlyc3REYXlPZldlZWsoY2FsLmdldEZpcnN0RGF5T2ZXZWVrKCkpO1xuICAgIGNhbC5zZXRNaW5pbWFsRGF5c0luRmlyc3RXZWVrKGNhbC5nZXRNaW5pbWFsRGF5c0luRmlyc3RXZWVrKCkpO1xuICAgIGNhbC5zZXRUaW1lKHRoaXMudGltZSk7XG4gICAgcmV0dXJuIGNhbDtcbiAgfSxcblxuICAvKlxuICAgKiBDb21wYXJlcyB0aGlzIEdyZWdvcmlhbkNhbGVuZGFyIHRvIHRoZSBzcGVjaWZpZWQgT2JqZWN0LlxuICAgKiBUaGUgcmVzdWx0IGlzIHRydWUgaWYgYW5kIG9ubHkgaWYgdGhlIGFyZ3VtZW50IGlzIGEgR3JlZ29yaWFuQ2FsZW5kYXIgb2JqZWN0XG4gICAqIHRoYXQgcmVwcmVzZW50cyB0aGUgc2FtZSB0aW1lIHZhbHVlIChtaWxsaXNlY29uZCBvZmZzZXQgZnJvbSB0aGUgRXBvY2gpXG4gICAqIHVuZGVyIHRoZSBzYW1lIENhbGVuZGFyIHBhcmFtZXRlcnMgYW5kIEdyZWdvcmlhbiBjaGFuZ2UgZGF0ZSBhcyB0aGlzIG9iamVjdC5cbiAgICogQHBhcmFtIHtEYXRlLkdyZWdvcmlhbn0gb2JqIHRoZSBvYmplY3QgdG8gY29tcGFyZSB3aXRoLlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSBpZiB0aGlzIG9iamVjdCBpcyBlcXVhbCB0byBvYmo7IGZhbHNlIG90aGVyd2lzZS5cbiAgICovXG4gIGVxdWFsczogZnVuY3Rpb24gZXF1YWxzKG9iaikge1xuICAgIHJldHVybiB0aGlzLmdldFRpbWUoKSA9PT0gb2JqLmdldFRpbWUoKSAmJiB0aGlzLmZpcnN0RGF5T2ZXZWVrID09PSBvYmouZmlyc3REYXlPZldlZWsgJiYgdGhpcy50aW1lem9uZU9mZnNldCA9PT0gb2JqLnRpbWV6b25lT2Zmc2V0ICYmIHRoaXMubWluaW1hbERheXNJbkZpcnN0V2VlayA9PT0gb2JqLm1pbmltYWxEYXlzSW5GaXJzdFdlZWs7XG4gIH0sXG5cbiAgY29tcGFyZVRvRGF5OiBmdW5jdGlvbiBjb21wYXJlVG9EYXkoZDIpIHtcbiAgICB2YXIgZDFZZWFyID0gdGhpcy5nZXRZZWFyKCk7XG4gICAgdmFyIGQyWWVhciA9IGQyLmdldFllYXIoKTtcbiAgICB2YXIgZDFNb250aCA9IHRoaXMuZ2V0TW9udGgoKTtcbiAgICB2YXIgZDJNb250aCA9IGQyLmdldE1vbnRoKCk7XG4gICAgdmFyIGQxRGF5ID0gdGhpcy5nZXREYXlPZk1vbnRoKCk7XG4gICAgdmFyIGQyRGF5ID0gZDIuZ2V0RGF5T2ZNb250aCgpO1xuICAgIGlmIChkMVllYXIgIT09IGQyWWVhcikge1xuICAgICAgcmV0dXJuIGQxWWVhciAtIGQyWWVhcjtcbiAgICB9XG4gICAgaWYgKGQxTW9udGggIT09IGQyTW9udGgpIHtcbiAgICAgIHJldHVybiBkMU1vbnRoIC0gZDJNb250aDtcbiAgICB9XG4gICAgcmV0dXJuIGQxRGF5IC0gZDJEYXk7XG4gIH0sXG5cbiAgLypcbiAgICogU2V0cyBhbGwgdGhlIGNhbGVuZGFyIGZpZWxkIHZhbHVlcyBvciBzcGVjaWZpZWQgZmllbGQgYW5kIHRoZSB0aW1lIHZhbHVlXG4gICAqIChtaWxsaXNlY29uZCBvZmZzZXQgZnJvbSB0aGUgRXBvY2gpIG9mIHRoaXMgQ2FsZW5kYXIgdW5kZWZpbmVkLlxuICAgKiBUaGlzIG1lYW5zIHRoYXQgaXNTZXQoKSB3aWxsIHJldHVybiBmYWxzZSBmb3IgYWxsIHRoZSBjYWxlbmRhciBmaWVsZHMsXG4gICAqIGFuZCB0aGUgZGF0ZSBhbmQgdGltZSBjYWxjdWxhdGlvbnMgd2lsbCB0cmVhdCB0aGUgZmllbGRzIGFzIGlmIHRoZXkgaGFkIG5ldmVyIGJlZW4gc2V0LlxuICAgKiBAcGFyYW0gW2ZpZWxkXSB0aGUgY2FsZW5kYXIgZmllbGQgdG8gYmUgY2xlYXJlZC5cbiAgICovXG4gIGNsZWFyOiBmdW5jdGlvbiBjbGVhcihmaWVsZCkge1xuICAgIGlmIChmaWVsZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLmZpZWxkID0gW107XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZmllbGRzW2ZpZWxkXSA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgdGhpcy50aW1lID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuZmllbGRzQ29tcHV0ZWQgPSBmYWxzZTtcbiAgfSxcblxuICB0b1N0cmluZzogZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgLy8gZm9yIGRlYnVnXG4gICAgdmFyIHYgPSB0aGlzO1xuICAgIHJldHVybiAnW0dyZWdvcmlhbkNhbGVuZGFyXTogJyArIHYuZ2V0WWVhcigpICsgJy8nICsgdi5nZXRNb250aCgpICsgJy8nICsgdi5nZXREYXlPZk1vbnRoKCkgKyAnICcgKyB2LmdldEhvdXJPZkRheSgpICsgJzonICsgdi5nZXRNaW51dGVzKCkgKyAnOicgKyB2LmdldFNlY29uZHMoKTtcbiAgfVxufTtcblxudmFyIEdyZWdvcmlhbkNhbGVuZGFyUHJvdG8gPSBHcmVnb3JpYW5DYWxlbmRhci5wcm90b3R5cGU7XG5cblV0aWxzLmVhY2goRklFTERTLCBmdW5jdGlvbiAoZiwgaW5kZXgpIHtcbiAgaWYgKGYpIHtcbiAgICBHcmVnb3JpYW5DYWxlbmRhclByb3RvWydnZXQnICsgZl0gPSBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXQoaW5kZXgpO1xuICAgIH07XG5cbiAgICBHcmVnb3JpYW5DYWxlbmRhclByb3RvWydpc1NldCcgKyBmXSA9IGZ1bmN0aW9uIGlzU2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuaXNTZXQoaW5kZXgpO1xuICAgIH07XG5cbiAgICBHcmVnb3JpYW5DYWxlbmRhclByb3RvWydzZXQnICsgZl0gPSBmdW5jdGlvbiBzZXQodikge1xuICAgICAgcmV0dXJuIHRoaXMuc2V0KGluZGV4LCB2KTtcbiAgICB9O1xuXG4gICAgR3JlZ29yaWFuQ2FsZW5kYXJQcm90b1snYWRkJyArIGZdID0gZnVuY3Rpb24gYWRkKHYpIHtcbiAgICAgIHJldHVybiB0aGlzLmFkZChpbmRleCwgdik7XG4gICAgfTtcblxuICAgIEdyZWdvcmlhbkNhbGVuZGFyUHJvdG9bJ3JvbGwnICsgZl0gPSBmdW5jdGlvbiByb2xsKHYpIHtcbiAgICAgIHJldHVybiB0aGlzLnJvbGwoaW5kZXgsIHYpO1xuICAgIH07XG5cbiAgICBHcmVnb3JpYW5DYWxlbmRhclByb3RvWydyb2xsU2V0JyArIGZdID0gZnVuY3Rpb24gcm9sbFNldCh2KSB7XG4gICAgICByZXR1cm4gdGhpcy5yb2xsU2V0KGluZGV4LCB2KTtcbiAgICB9O1xuICB9XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBHcmVnb3JpYW5DYWxlbmRhcjtcbi8qXG4gaHR0cDovL2RvY3Mub3JhY2xlLmNvbS9qYXZhc2UvNy9kb2NzL2FwaS9qYXZhL3V0aWwvR3JlZ29yaWFuQ2FsZW5kYXIuaHRtbFxuXG4gVE9ET1xuIC0gZGF5IHNhdmluZyB0aW1lXG4gLSBpMThuXG4gLSBqdWxpYW4gY2FsZW5kYXJcbiAqL1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3V4Y29yZS1mb3JtL34vdXhjb3JlLWRhdGUtZm9ybS1maWVsZC9+L3V4Y29yZS1jYWxlbmRhci9+L2dyZWdvcmlhbi1jYWxlbmRhci9saWIvZ3JlZ29yaWFuLWNhbGVuZGFyLmpzXG4gKiogbW9kdWxlIGlkID0gMzc5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKlxuICogdXRpbHMgZm9yIGdyZWdvcmlhbiBkYXRlXG4gKiBAaWdub3JlXG4gKiBAYXV0aG9yIHlpbWluZ2hlQGdtYWlsLmNvbVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIENvbnN0ID0gcmVxdWlyZSgnLi9jb25zdCcpO1xudmFyIGZsb29yID0gTWF0aC5mbG9vcjtcbnZhciBBQ0NVTVVMQVRFRF9EQVlTX0lOX01PTlRIXG4vLyAgIDEvMSAyLzEgMy8xIDQvMSA1LzEgNi8xIDcvMSA4LzEgOS8xIDEwLzEgMTEvMSAxMi8xXG49IFswLCAzMSwgNTksIDkwLCAxMjAsIDE1MSwgMTgxLCAyMTIsIDI0MywgMjczLCAzMDQsIDMzNF07XG5cbnZhciBBQ0NVTVVMQVRFRF9EQVlTX0lOX01PTlRIX0xFQVBcbi8vICAgMS8xIDIvMSAgIDMvMSAgIDQvMSAgIDUvMSAgIDYvMSAgIDcvMSAgIDgvMSAgIDkvMVxuLy8gMTAvMSAgIDExLzEgICAxMi8xXG49IFswLCAzMSwgNTkgKyAxLCA5MCArIDEsIDEyMCArIDEsIDE1MSArIDEsIDE4MSArIDEsIDIxMiArIDEsIDI0MyArIDEsIDI3MyArIDEsIDMwNCArIDEsIDMzNCArIDFdO1xuXG52YXIgREFZU19PRl9ZRUFSID0gMzY1O1xudmFyIERBWVNfT0ZfNFlFQVIgPSAzNjUgKiA0ICsgMTtcbnZhciBEQVlTX09GXzEwMFlFQVIgPSBEQVlTX09GXzRZRUFSICogMjUgLSAxO1xudmFyIERBWVNfT0ZfNDAwWUVBUiA9IERBWVNfT0ZfMTAwWUVBUiAqIDQgKyAxO1xudmFyIF9leHBvcnRzID0ge307XG5cbmZ1bmN0aW9uIGdldERheU9mWWVhcih5ZWFyLCBtb250aCwgZGF5T2ZNb250aCkge1xuICByZXR1cm4gZGF5T2ZNb250aCArIChfZXhwb3J0cy5pc0xlYXBZZWFyKHllYXIpID8gQUNDVU1VTEFURURfREFZU19JTl9NT05USF9MRUFQW21vbnRoXSA6IEFDQ1VNVUxBVEVEX0RBWVNfSU5fTU9OVEhbbW9udGhdKTtcbn1cblxuZnVuY3Rpb24gZ2V0RGF5T2ZXZWVrRnJvbUZpeGVkRGF0ZShmaXhlZERhdGUpIHtcbiAgLy8gVGhlIGZpeGVkIGRheSAxIChKYW51YXJ5IDEsIDEgR3JlZ29yaWFuKSBpcyBNb25kYXkuXG4gIGlmIChmaXhlZERhdGUgPj0gMCkge1xuICAgIHJldHVybiBmaXhlZERhdGUgJSA3O1xuICB9XG4gIHJldHVybiBfZXhwb3J0cy5tb2QoZml4ZWREYXRlLCA3KTtcbn1cblxuZnVuY3Rpb24gZ2V0R3JlZ29yaWFuWWVhckZyb21GaXhlZERhdGUoZml4ZWREYXRlKSB7XG4gIHZhciBkMCA9IHVuZGVmaW5lZDtcbiAgdmFyIGQxID0gdW5kZWZpbmVkO1xuICB2YXIgZDIgPSB1bmRlZmluZWQ7XG4gIHZhciBkMyA9IHVuZGVmaW5lZDtcbiAgdmFyIG40MDAgPSB1bmRlZmluZWQ7XG4gIHZhciBuMTAwID0gdW5kZWZpbmVkO1xuICB2YXIgbjQgPSB1bmRlZmluZWQ7XG4gIHZhciBuMSA9IHVuZGVmaW5lZDtcbiAgdmFyIHllYXIgPSB1bmRlZmluZWQ7XG4gIGQwID0gZml4ZWREYXRlIC0gMTtcblxuICBuNDAwID0gZmxvb3IoZDAgLyBEQVlTX09GXzQwMFlFQVIpO1xuICBkMSA9IF9leHBvcnRzLm1vZChkMCwgREFZU19PRl80MDBZRUFSKTtcbiAgbjEwMCA9IGZsb29yKGQxIC8gREFZU19PRl8xMDBZRUFSKTtcbiAgZDIgPSBfZXhwb3J0cy5tb2QoZDEsIERBWVNfT0ZfMTAwWUVBUik7XG4gIG40ID0gZmxvb3IoZDIgLyBEQVlTX09GXzRZRUFSKTtcbiAgZDMgPSBfZXhwb3J0cy5tb2QoZDIsIERBWVNfT0ZfNFlFQVIpO1xuICBuMSA9IGZsb29yKGQzIC8gREFZU19PRl9ZRUFSKTtcblxuICB5ZWFyID0gNDAwICogbjQwMCArIDEwMCAqIG4xMDAgKyA0ICogbjQgKyBuMTtcblxuICAvLyA/XG4gIGlmICghKG4xMDAgPT09IDQgfHwgbjEgPT09IDQpKSB7XG4gICAgKyt5ZWFyO1xuICB9XG5cbiAgcmV0dXJuIHllYXI7XG59XG5cbl9leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSB7XG4gIGVhY2g6IGZ1bmN0aW9uIGVhY2goYXJyLCBmbikge1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBhcnIubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGlmIChmbihhcnJbaV0sIGksIGFycikgPT09IGZhbHNlKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICBtaXg6IGZ1bmN0aW9uIG1peCh0LCBzKSB7XG4gICAgZm9yICh2YXIgcCBpbiBzKSB7XG4gICAgICBpZiAocy5oYXNPd25Qcm9wZXJ0eShwKSkge1xuICAgICAgICB0W3BdID0gc1twXTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgaXNMZWFwWWVhcjogZnVuY3Rpb24gaXNMZWFwWWVhcih5ZWFyKSB7XG4gICAgaWYgKCh5ZWFyICYgMykgIT09IDApIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHllYXIgJSAxMDAgIT09IDAgfHwgeWVhciAlIDQwMCA9PT0gMDtcbiAgfSxcblxuICBtb2Q6IGZ1bmN0aW9uIG1vZCh4LCB5KSB7XG4gICAgLy8g6LSf5pWw5pe25LiN5piv6ZWc5YOP5YWz57O7XG4gICAgcmV0dXJuIHggLSB5ICogZmxvb3IoeCAvIHkpO1xuICB9LFxuXG4gIC8vIG1vbnRoOiAwIGJhc2VkXG4gIGdldEZpeGVkRGF0ZTogZnVuY3Rpb24gZ2V0Rml4ZWREYXRlKHllYXIsIG1vbnRoLCBkYXlPZk1vbnRoKSB7XG4gICAgdmFyIHByZXZZZWFyID0geWVhciAtIDE7XG4gICAgLy8g6ICD6JmR5YWs5YWD5YmNXG4gICAgcmV0dXJuIERBWVNfT0ZfWUVBUiAqIHByZXZZZWFyICsgZmxvb3IocHJldlllYXIgLyA0KSAtIGZsb29yKHByZXZZZWFyIC8gMTAwKSArIGZsb29yKHByZXZZZWFyIC8gNDAwKSArIGdldERheU9mWWVhcih5ZWFyLCBtb250aCwgZGF5T2ZNb250aCk7XG4gIH0sXG5cbiAgZ2V0R3JlZ29yaWFuRGF0ZUZyb21GaXhlZERhdGU6IGZ1bmN0aW9uIGdldEdyZWdvcmlhbkRhdGVGcm9tRml4ZWREYXRlKGZpeGVkRGF0ZSkge1xuICAgIHZhciB5ZWFyID0gZ2V0R3JlZ29yaWFuWWVhckZyb21GaXhlZERhdGUoZml4ZWREYXRlKTtcbiAgICB2YXIgamFuMSA9IF9leHBvcnRzLmdldEZpeGVkRGF0ZSh5ZWFyLCBDb25zdC5KQU5VQVJZLCAxKTtcbiAgICB2YXIgaXNMZWFwID0gX2V4cG9ydHMuaXNMZWFwWWVhcih5ZWFyKTtcbiAgICB2YXIgQUNDVU1VTEFURURfREFZUyA9IGlzTGVhcCA/IEFDQ1VNVUxBVEVEX0RBWVNfSU5fTU9OVEhfTEVBUCA6IEFDQ1VNVUxBVEVEX0RBWVNfSU5fTU9OVEg7XG4gICAgdmFyIGRheXNEaWZmID0gZml4ZWREYXRlIC0gamFuMTtcbiAgICB2YXIgbW9udGggPSB1bmRlZmluZWQ7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IEFDQ1VNVUxBVEVEX0RBWVMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChBQ0NVTVVMQVRFRF9EQVlTW2ldIDw9IGRheXNEaWZmKSB7XG4gICAgICAgIG1vbnRoID0gaTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBkYXlPZk1vbnRoID0gZml4ZWREYXRlIC0gamFuMSAtIEFDQ1VNVUxBVEVEX0RBWVNbbW9udGhdICsgMTtcbiAgICB2YXIgZGF5T2ZXZWVrID0gZ2V0RGF5T2ZXZWVrRnJvbUZpeGVkRGF0ZShmaXhlZERhdGUpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIHllYXI6IHllYXIsXG4gICAgICBtb250aDogbW9udGgsXG4gICAgICBkYXlPZk1vbnRoOiBkYXlPZk1vbnRoLFxuICAgICAgZGF5T2ZXZWVrOiBkYXlPZldlZWssXG4gICAgICBpc0xlYXA6IGlzTGVhcFxuICAgIH07XG4gIH1cbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vdXhjb3JlLWZvcm0vfi91eGNvcmUtZGF0ZS1mb3JtLWZpZWxkL34vdXhjb3JlLWNhbGVuZGFyL34vZ3JlZ29yaWFuLWNhbGVuZGFyL2xpYi91dGlscy5qc1xuICoqIG1vZHVsZSBpZCA9IDM4MFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLypcbiAqIEBpZ25vcmVcbiAqIGNvbnN0IGZvciBncmVnb3JpYW4gZGF0ZVxuICogQGF1dGhvciB5aW1pbmdoZUBnbWFpbC5jb21cbiAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIC8qXG4gICAqIEVudW0gaW5kaWNhdGluZyBzdW5kYXlcbiAgICogQHR5cGUgTnVtYmVyXG4gICAqIEBtZW1iZXIgRGF0ZS5HcmVnb3JpYW5cbiAgICovXG4gIFNVTkRBWTogMCxcbiAgLypcbiAgICogRW51bSBpbmRpY2F0aW5nIG1vbmRheVxuICAgKiBAdHlwZSBOdW1iZXJcbiAgICogQG1lbWJlciBEYXRlLkdyZWdvcmlhblxuICAgKi9cbiAgTU9OREFZOiAxLFxuICAvKlxuICAgKiBFbnVtIGluZGljYXRpbmcgdHVlc2RheVxuICAgKiBAdHlwZSBOdW1iZXJcbiAgICogQG1lbWJlciBEYXRlLkdyZWdvcmlhblxuICAgKi9cbiAgVFVFU0RBWTogMixcbiAgLypcbiAgICogRW51bSBpbmRpY2F0aW5nIHdlZG5lc2RheVxuICAgKiBAdHlwZSBOdW1iZXJcbiAgICogQG1lbWJlciBEYXRlLkdyZWdvcmlhblxuICAgKi9cbiAgV0VETkVTREFZOiAzLFxuICAvKlxuICAgKiBFbnVtIGluZGljYXRpbmcgdGh1cnNkYXlcbiAgICogQHR5cGUgTnVtYmVyXG4gICAqIEBtZW1iZXIgRGF0ZS5HcmVnb3JpYW5cbiAgICovXG4gIFRIVVJTREFZOiA0LFxuICAvKlxuICAgKiBFbnVtIGluZGljYXRpbmcgZnJpZGF5XG4gICAqIEB0eXBlIE51bWJlclxuICAgKiBAbWVtYmVyIERhdGUuR3JlZ29yaWFuXG4gICAqL1xuICBGUklEQVk6IDUsXG4gIC8qXG4gICAqIEVudW0gaW5kaWNhdGluZyBzYXR1cmRheVxuICAgKiBAdHlwZSBOdW1iZXJcbiAgICogQG1lbWJlciBEYXRlLkdyZWdvcmlhblxuICAgKi9cbiAgU0FUVVJEQVk6IDYsXG4gIC8qXG4gICAqIEVudW0gaW5kaWNhdGluZyBqYW51YXJ5XG4gICAqIEB0eXBlIE51bWJlclxuICAgKiBAbWVtYmVyIERhdGUuR3JlZ29yaWFuXG4gICAqL1xuICBKQU5VQVJZOiAwLFxuICAvKlxuICAgKiBFbnVtIGluZGljYXRpbmcgZmVicnVhcnlcbiAgICogQHR5cGUgTnVtYmVyXG4gICAqIEBtZW1iZXIgRGF0ZS5HcmVnb3JpYW5cbiAgICovXG4gIEZFQlJVQVJZOiAxLFxuICAvKlxuICAgKiBFbnVtIGluZGljYXRpbmcgbWFyY2hcbiAgICogQHR5cGUgTnVtYmVyXG4gICAqIEBtZW1iZXIgRGF0ZS5HcmVnb3JpYW5cbiAgICovXG4gIE1BUkNIOiAyLFxuICAvKlxuICAgKiBFbnVtIGluZGljYXRpbmcgYXByaWxcbiAgICogQHR5cGUgTnVtYmVyXG4gICAqIEBtZW1iZXIgRGF0ZS5HcmVnb3JpYW5cbiAgICovXG4gIEFQUklMOiAzLFxuICAvKlxuICAgKiBFbnVtIGluZGljYXRpbmcgbWF5XG4gICAqIEB0eXBlIE51bWJlclxuICAgKiBAbWVtYmVyIERhdGUuR3JlZ29yaWFuXG4gICAqL1xuICBNQVk6IDQsXG4gIC8qXG4gICAqIEVudW0gaW5kaWNhdGluZyBqdW5lXG4gICAqIEB0eXBlIE51bWJlclxuICAgKiBAbWVtYmVyIERhdGUuR3JlZ29yaWFuXG4gICAqL1xuICBKVU5FOiA1LFxuICAvKlxuICAgKiBFbnVtIGluZGljYXRpbmcganVseVxuICAgKiBAdHlwZSBOdW1iZXJcbiAgICogQG1lbWJlciBEYXRlLkdyZWdvcmlhblxuICAgKi9cbiAgSlVMWTogNixcbiAgLypcbiAgICogRW51bSBpbmRpY2F0aW5nIGF1Z3VzdFxuICAgKiBAdHlwZSBOdW1iZXJcbiAgICogQG1lbWJlciBEYXRlLkdyZWdvcmlhblxuICAgKi9cbiAgQVVHVVNUOiA3LFxuICAvKlxuICAgKiBFbnVtIGluZGljYXRpbmcgc2VwdGVtYmVyXG4gICAqIEB0eXBlIE51bWJlclxuICAgKiBAbWVtYmVyIERhdGUuR3JlZ29yaWFuXG4gICAqL1xuICBTRVBURU1CRVI6IDgsXG4gIC8qXG4gICAqIEVudW0gaW5kaWNhdGluZyBvY3RvYmVyXG4gICAqIEB0eXBlIE51bWJlclxuICAgKiBAbWVtYmVyIERhdGUuR3JlZ29yaWFuXG4gICAqL1xuICBPQ1RPQkVSOiA5LFxuICAvKlxuICAgKiBFbnVtIGluZGljYXRpbmcgbm92ZW1iZXJcbiAgICogQHR5cGUgTnVtYmVyXG4gICAqIEBtZW1iZXIgRGF0ZS5HcmVnb3JpYW5cbiAgICovXG4gIE5PVkVNQkVSOiAxMCxcbiAgLypcbiAgICogRW51bSBpbmRpY2F0aW5nIGRlY2VtYmVyXG4gICAqIEB0eXBlIE51bWJlclxuICAgKiBAbWVtYmVyIERhdGUuR3JlZ29yaWFuXG4gICAqL1xuICBERUNFTUJFUjogMTFcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vdXhjb3JlLWZvcm0vfi91eGNvcmUtZGF0ZS1mb3JtLWZpZWxkL34vdXhjb3JlLWNhbGVuZGFyL34vZ3JlZ29yaWFuLWNhbGVuZGFyL2xpYi9jb25zdC5qc1xuICoqIG1vZHVsZSBpZCA9IDM4MVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLypcbiAqIGVuLXVzIGxvY2FsZVxuICogQGlnbm9yZVxuICogQGF1dGhvciB5aW1pbmdoZUBnbWFpbC5jb21cbiAqL1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAvLyBpbiBtaW51dGVzXG4gIHRpbWV6b25lT2Zmc2V0OiAtOCAqIDYwLFxuICBmaXJzdERheU9mV2VlazogMCxcbiAgbWluaW1hbERheXNJbkZpcnN0V2VlazogMVxufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi91eGNvcmUtZm9ybS9+L3V4Y29yZS1kYXRlLWZvcm0tZmllbGQvfi91eGNvcmUtY2FsZW5kYXIvfi9ncmVnb3JpYW4tY2FsZW5kYXIvbGliL2xvY2FsZS9lbl9VUy5qc1xuICoqIG1vZHVsZSBpZCA9IDM4MlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX3JlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxudmFyIF9yZWFjdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yZWFjdCk7XG5cbnZhciBfRGF0ZVRIZWFkID0gcmVxdWlyZSgnLi9EYXRlVEhlYWQnKTtcblxudmFyIF9EYXRlVEhlYWQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfRGF0ZVRIZWFkKTtcblxudmFyIF9EYXRlVEJvZHkgPSByZXF1aXJlKCcuL0RhdGVUQm9keScpO1xuXG52YXIgX0RhdGVUQm9keTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9EYXRlVEJvZHkpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBcImRlZmF1bHRcIjogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfSAvLyBjdXN0b21pemVkIHJjLWNhbGVuZGFyIGh0dHBzOi8vZ2l0aHViLmNvbS9yZWFjdC1jb21wb25lbnQvY2FsZW5kYXIvYmxvYi9tYXN0ZXIvXG5cbnZhciBEYXRlVGFibGUgPSBmdW5jdGlvbiAoX1JlYWN0JENvbXBvbmVudCkge1xuICBfaW5oZXJpdHMoRGF0ZVRhYmxlLCBfUmVhY3QkQ29tcG9uZW50KTtcblxuICBmdW5jdGlvbiBEYXRlVGFibGUoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIERhdGVUYWJsZSk7XG5cbiAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX1JlYWN0JENvbXBvbmVudC5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgfVxuXG4gIERhdGVUYWJsZS5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgIHZhciBwcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgdmFyIHByZWZpeENscyA9IHByb3BzLnByZWZpeENscztcbiAgICByZXR1cm4gX3JlYWN0MltcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChcbiAgICAgICd0YWJsZScsXG4gICAgICB7IGNsYXNzTmFtZTogcHJlZml4Q2xzICsgJy10YWJsZScsIGNlbGxTcGFjaW5nOiAnMCcsIHJvbGU6ICdncmlkJyB9LFxuICAgICAgX3JlYWN0MltcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChfRGF0ZVRIZWFkMltcImRlZmF1bHRcIl0sIHByb3BzKSxcbiAgICAgIF9yZWFjdDJbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoX0RhdGVUQm9keTJbXCJkZWZhdWx0XCJdLCBwcm9wcylcbiAgICApO1xuICB9O1xuXG4gIHJldHVybiBEYXRlVGFibGU7XG59KF9yZWFjdDJbXCJkZWZhdWx0XCJdLkNvbXBvbmVudCk7XG5cbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gRGF0ZVRhYmxlO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vdXhjb3JlLWZvcm0vfi91eGNvcmUtZGF0ZS1mb3JtLWZpZWxkL34vdXhjb3JlLWNhbGVuZGFyL2J1aWxkL2RhdGUvRGF0ZVRhYmxlLmpzXG4gKiogbW9kdWxlIGlkID0gNDAzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfcmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xuXG52YXIgX3JlYWN0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JlYWN0KTtcblxudmFyIF9EYXRlQ29uc3RhbnRzID0gcmVxdWlyZSgnLi9EYXRlQ29uc3RhbnRzJyk7XG5cbnZhciBfRGF0ZUNvbnN0YW50czIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9EYXRlQ29uc3RhbnRzKTtcblxudmFyIF9jbGFzc25hbWVzMiA9IHJlcXVpcmUoJ2NsYXNzbmFtZXMnKTtcblxudmFyIF9jbGFzc25hbWVzMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NsYXNzbmFtZXMyKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgXCJkZWZhdWx0XCI6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIERhdGVUSGVhZCA9IGZ1bmN0aW9uIChfUmVhY3QkQ29tcG9uZW50KSB7XG4gIF9pbmhlcml0cyhEYXRlVEhlYWQsIF9SZWFjdCRDb21wb25lbnQpO1xuXG4gIGZ1bmN0aW9uIERhdGVUSGVhZCgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRGF0ZVRIZWFkKTtcblxuICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfUmVhY3QkQ29tcG9uZW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICB9XG5cbiAgRGF0ZVRIZWFkLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgdmFyIHByb3BzID0gdGhpcy5wcm9wcztcbiAgICB2YXIgdmFsdWUgPSBwcm9wcy52YWx1ZTtcbiAgICB2YXIgbG9jYWxlID0gcHJvcHMubG9jYWxlO1xuICAgIHZhciBwcmVmaXhDbHMgPSBwcm9wcy5wcmVmaXhDbHM7XG4gICAgdmFyIHZlcnlTaG9ydFdlZWtkYXlzID0gW107XG4gICAgdmFyIHdlZWtEYXlzID0gW107XG4gICAgdmFyIGZpcnN0RGF5T2ZXZWVrID0gdmFsdWUuZ2V0Rmlyc3REYXlPZldlZWsoKTtcbiAgICB2YXIgc2hvd1dlZWtOdW1iZXJFbCA9IHVuZGVmaW5lZDtcblxuICAgIGZvciAodmFyIGRhdGVDb2xJbmRleCA9IDA7IGRhdGVDb2xJbmRleCA8IF9EYXRlQ29uc3RhbnRzMltcImRlZmF1bHRcIl0uREFURV9DT0xfQ09VTlQ7IGRhdGVDb2xJbmRleCsrKSB7XG4gICAgICB2YXIgaW5kZXggPSAoZmlyc3REYXlPZldlZWsgKyBkYXRlQ29sSW5kZXgpICUgX0RhdGVDb25zdGFudHMyW1wiZGVmYXVsdFwiXS5EQVRFX0NPTF9DT1VOVDtcbiAgICAgIHZlcnlTaG9ydFdlZWtkYXlzW2RhdGVDb2xJbmRleF0gPSBsb2NhbGUuZm9ybWF0LnZlcnlTaG9ydFdlZWtkYXlzW2luZGV4XTtcbiAgICAgIHdlZWtEYXlzW2RhdGVDb2xJbmRleF0gPSBsb2NhbGUuZm9ybWF0LndlZWtkYXlzW2luZGV4XTtcbiAgICB9XG5cbiAgICBpZiAocHJvcHMuc2hvd1dlZWtOdW1iZXIpIHtcbiAgICAgIHNob3dXZWVrTnVtYmVyRWwgPSBfcmVhY3QyW1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFxuICAgICAgICAndGgnLFxuICAgICAgICB7XG4gICAgICAgICAgcm9sZTogJ2NvbHVtbmhlYWRlcicsXG4gICAgICAgICAgY2xhc3NOYW1lOiBwcmVmaXhDbHMgKyAnLWNvbHVtbi1oZWFkZXIgJyArIHByZWZpeENscyArICctd2Vlay1udW1iZXItaGVhZGVyJ1xuICAgICAgICB9LFxuICAgICAgICBfcmVhY3QyW1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICdzcGFuJyxcbiAgICAgICAgICB7IGNsYXNzTmFtZTogcHJlZml4Q2xzICsgJy1jb2x1bW4taGVhZGVyLWlubmVyJyB9LFxuICAgICAgICAgICd4J1xuICAgICAgICApXG4gICAgICApO1xuICAgIH1cbiAgICB2YXIgd2Vla0RheXNFbHMgPSB3ZWVrRGF5cy5tYXAoZnVuY3Rpb24gKGRheSwgeGluZGV4KSB7XG4gICAgICB2YXIgX2NsYXNzbmFtZXM7XG5cbiAgICAgIHZhciBzcGFuQ2xzID0gKDAsIF9jbGFzc25hbWVzM1tcImRlZmF1bHRcIl0pKChfY2xhc3NuYW1lcyA9IHt9LCBfY2xhc3NuYW1lc1twcmVmaXhDbHMgKyAnLWNvbHVtbi1oZWFkZXItaW5uZXInXSA9IHRydWUsIF9jbGFzc25hbWVzLndlZWtlbmQgPSB4aW5kZXggPT09IDAgfHwgeGluZGV4ID09PSA2LCBfY2xhc3NuYW1lcykpO1xuICAgICAgcmV0dXJuIF9yZWFjdDJbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICd0aCcsXG4gICAgICAgIHtcbiAgICAgICAgICBrZXk6IHhpbmRleCxcbiAgICAgICAgICByb2xlOiAnY29sdW1uaGVhZGVyJyxcbiAgICAgICAgICB0aXRsZTogZGF5LFxuICAgICAgICAgIGNsYXNzTmFtZTogcHJlZml4Q2xzICsgJy1jb2x1bW4taGVhZGVyJ1xuICAgICAgICB9LFxuICAgICAgICBfcmVhY3QyW1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICdzcGFuJyxcbiAgICAgICAgICB7IGNsYXNzTmFtZTogc3BhbkNscyB9LFxuICAgICAgICAgIHZlcnlTaG9ydFdlZWtkYXlzW3hpbmRleF1cbiAgICAgICAgKVxuICAgICAgKTtcbiAgICB9KTtcbiAgICByZXR1cm4gX3JlYWN0MltcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChcbiAgICAgICd0aGVhZCcsXG4gICAgICBudWxsLFxuICAgICAgX3JlYWN0MltcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChcbiAgICAgICAgJ3RyJyxcbiAgICAgICAgeyByb2xlOiAncm93JyB9LFxuICAgICAgICBzaG93V2Vla051bWJlckVsLFxuICAgICAgICB3ZWVrRGF5c0Vsc1xuICAgICAgKVxuICAgICk7XG4gIH07XG5cbiAgcmV0dXJuIERhdGVUSGVhZDtcbn0oX3JlYWN0MltcImRlZmF1bHRcIl0uQ29tcG9uZW50KTtcblxuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBEYXRlVEhlYWQ7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi91eGNvcmUtZm9ybS9+L3V4Y29yZS1kYXRlLWZvcm0tZmllbGQvfi91eGNvcmUtY2FsZW5kYXIvYnVpbGQvZGF0ZS9EYXRlVEhlYWQuanNcbiAqKiBtb2R1bGUgaWQgPSA0MDRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSB7XG4gIERBVEVfUk9XX0NPVU5UOiA2LFxuICBEQVRFX0NPTF9DT1VOVDogN1xufTtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3V4Y29yZS1mb3JtL34vdXhjb3JlLWRhdGUtZm9ybS1maWVsZC9+L3V4Y29yZS1jYWxlbmRhci9idWlsZC9kYXRlL0RhdGVDb25zdGFudHMuanNcbiAqKiBtb2R1bGUgaWQgPSA0MDVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9yZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5cbnZhciBfcmVhY3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmVhY3QpO1xuXG52YXIgX0RhdGVDb25zdGFudHMgPSByZXF1aXJlKCdyYy1jYWxlbmRhci9saWIvZGF0ZS9EYXRlQ29uc3RhbnRzJyk7XG5cbnZhciBfRGF0ZUNvbnN0YW50czIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9EYXRlQ29uc3RhbnRzKTtcblxudmFyIF91dGlsID0gcmVxdWlyZSgncmMtY2FsZW5kYXIvbGliL3V0aWwvJyk7XG5cbnZhciBfY2xhc3NuYW1lczIgPSByZXF1aXJlKCdjbGFzc25hbWVzJyk7XG5cbnZhciBfY2xhc3NuYW1lczMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jbGFzc25hbWVzMik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IFwiZGVmYXVsdFwiOiBvYmogfTsgfVxuXG4vLyBjdXN0b21pemVkIHJjLWNhbGVuZGFyIGh0dHBzOi8vZ2l0aHViLmNvbS9yZWFjdC1jb21wb25lbnQvY2FsZW5kYXIvYmxvYi9tYXN0ZXIvXG5cbmZ1bmN0aW9uIGlzU2FtZURheShvbmUsIHR3bykge1xuICByZXR1cm4gb25lICYmIHR3byAmJiBvbmUuY29tcGFyZVRvRGF5KHR3bykgPT09IDA7XG59XG5cbmZ1bmN0aW9uIGJlZm9yZUN1cnJlbnRNb250aFllYXIoY3VycmVudCwgdG9kYXkpIHtcbiAgaWYgKGN1cnJlbnQuZ2V0WWVhcigpIDwgdG9kYXkuZ2V0WWVhcigpKSB7XG4gICAgcmV0dXJuIDE7XG4gIH1cbiAgcmV0dXJuIGN1cnJlbnQuZ2V0WWVhcigpID09PSB0b2RheS5nZXRZZWFyKCkgJiYgY3VycmVudC5nZXRNb250aCgpIDwgdG9kYXkuZ2V0TW9udGgoKTtcbn1cblxuZnVuY3Rpb24gYWZ0ZXJDdXJyZW50TW9udGhZZWFyKGN1cnJlbnQsIHRvZGF5KSB7XG4gIGlmIChjdXJyZW50LmdldFllYXIoKSA+IHRvZGF5LmdldFllYXIoKSkge1xuICAgIHJldHVybiAxO1xuICB9XG4gIHJldHVybiBjdXJyZW50LmdldFllYXIoKSA9PT0gdG9kYXkuZ2V0WWVhcigpICYmIGN1cnJlbnQuZ2V0TW9udGgoKSA+IHRvZGF5LmdldE1vbnRoKCk7XG59XG5cbmZ1bmN0aW9uIGdldElkRnJvbURhdGUoZGF0ZSkge1xuICByZXR1cm4gJ3JjLWNhbGVuZGFyLScgKyBkYXRlLmdldFllYXIoKSArICctJyArIGRhdGUuZ2V0TW9udGgoKSArICctJyArIGRhdGUuZ2V0RGF5T2ZNb250aCgpO1xufVxuXG5mdW5jdGlvbiBub29wKCkge31cblxuZnVuY3Rpb24gaGFuZGxlRGF5Q2xpY2soY3VycmVudCkge1xuICB0aGlzLnByb3BzLm9uU2VsZWN0KGN1cnJlbnQpO1xufVxuXG5mdW5jdGlvbiBoYW5kbGVDZWxsTW91c2VFbnRlcihjdXJyZW50KSB7XG4gIHRoaXMucHJvcHMub25EYXlIb3ZlcihjdXJyZW50KTtcbn1cblxudmFyIERhdGVUQm9keSA9IF9yZWFjdDJbXCJkZWZhdWx0XCJdLmNyZWF0ZUNsYXNzKHtcbiAgZGlzcGxheU5hbWU6ICdEYXRlVEJvZHknLFxuXG4gIHByb3BUeXBlczoge1xuICAgIGNvbnRlbnRSZW5kZXI6IF9yZWFjdC5Qcm9wVHlwZXMuZnVuYyxcbiAgICBkYXRlUmVuZGVyOiBfcmVhY3QuUHJvcFR5cGVzLmZ1bmMsXG4gICAgZGlzYWJsZWREYXRlOiBfcmVhY3QuUHJvcFR5cGVzLmZ1bmMsXG4gICAgcHJlZml4Q2xzOiBfcmVhY3QuUHJvcFR5cGVzLnN0cmluZyxcbiAgICBzZWxlY3RlZFZhbHVlOiBfcmVhY3QuUHJvcFR5cGVzLm9iamVjdCxcbiAgICB2YWx1ZTogX3JlYWN0LlByb3BUeXBlcy5vYmplY3QsXG4gICAgc2hvd1dlZWtOdW1iZXI6IF9yZWFjdC5Qcm9wVHlwZXMuYm9vbFxuICB9LFxuXG4gIGdldERlZmF1bHRQcm9wczogZnVuY3Rpb24gZ2V0RGVmYXVsdFByb3BzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBvbkRheUhvdmVyOiBub29wXG4gICAgfTtcbiAgfSxcbiAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgdmFyIHByb3BzID0gdGhpcy5wcm9wcztcbiAgICB2YXIgY29udGVudFJlbmRlciA9IHByb3BzLmNvbnRlbnRSZW5kZXI7XG4gICAgdmFyIHByZWZpeENscyA9IHByb3BzLnByZWZpeENscztcbiAgICB2YXIgc2VsZWN0ZWRWYWx1ZSA9IHByb3BzLnNlbGVjdGVkVmFsdWU7XG4gICAgdmFyIHZhbHVlID0gcHJvcHMudmFsdWU7XG4gICAgdmFyIHNob3dXZWVrTnVtYmVyID0gcHJvcHMuc2hvd1dlZWtOdW1iZXI7XG4gICAgdmFyIGRhdGVSZW5kZXIgPSBwcm9wcy5kYXRlUmVuZGVyO1xuICAgIHZhciBkaXNhYmxlZERhdGUgPSBwcm9wcy5kaXNhYmxlZERhdGU7XG5cbiAgICB2YXIgaUluZGV4ID0gdW5kZWZpbmVkO1xuICAgIHZhciBqSW5kZXggPSB1bmRlZmluZWQ7XG4gICAgdmFyIGN1cnJlbnQgPSB1bmRlZmluZWQ7XG4gICAgdmFyIGRhdGVUYWJsZSA9IFtdO1xuICAgIHZhciB0b2RheSA9IHZhbHVlLmNsb25lKCk7XG4gICAgdmFyIGNlbGxDbGFzcyA9IHByZWZpeENscyArICctY2VsbCc7XG4gICAgdmFyIHdlZWtOdW1iZXJDZWxsQ2xhc3MgPSBwcmVmaXhDbHMgKyAnLXdlZWstbnVtYmVyLWNlbGwnO1xuICAgIHZhciBkYXRlQ2xhc3MgPSBwcmVmaXhDbHMgKyAnLWRhdGUnO1xuICAgIHZhciB0b2RheUNsYXNzID0gcHJlZml4Q2xzICsgJy10b2RheSc7XG4gICAgdmFyIHNlbGVjdGVkQ2xhc3MgPSBwcmVmaXhDbHMgKyAnLXNlbGVjdGVkLWRheSc7XG4gICAgdmFyIGluUmFuZ2VDbGFzcyA9IHByZWZpeENscyArICctaW4tcmFuZ2UtY2VsbCc7XG4gICAgdmFyIGxhc3RNb250aERheUNsYXNzID0gcHJlZml4Q2xzICsgJy1sYXN0LW1vbnRoLWNlbGwnO1xuICAgIHZhciBuZXh0TW9udGhEYXlDbGFzcyA9IHByZWZpeENscyArICctbmV4dC1tb250aC1idG4tZGF5JztcbiAgICB2YXIgZGlzYWJsZWRDbGFzcyA9IHByZWZpeENscyArICctZGlzYWJsZWQtY2VsbCc7XG4gICAgdmFyIGZpcnN0RGlzYWJsZUNsYXNzID0gcHJlZml4Q2xzICsgJy1kaXNhYmxlZC1jZWxsLWZpcnN0LW9mLXJvdyc7XG4gICAgdmFyIGxhc3REaXNhYmxlQ2xhc3MgPSBwcmVmaXhDbHMgKyAnLWRpc2FibGVkLWNlbGwtbGFzdC1vZi1yb3cnO1xuICAgIHRvZGF5LnNldFRpbWUoRGF0ZS5ub3coKSk7XG4gICAgdmFyIG1vbnRoMSA9IHZhbHVlLmNsb25lKCk7XG4gICAgbW9udGgxLnNldCh2YWx1ZS5nZXRZZWFyKCksIHZhbHVlLmdldE1vbnRoKCksIDEpO1xuICAgIHZhciBkYXkgPSBtb250aDEuZ2V0RGF5T2ZXZWVrKCk7XG4gICAgdmFyIGxhc3RNb250aERpZmZEYXkgPSAoZGF5ICsgNyAtIHZhbHVlLmdldEZpcnN0RGF5T2ZXZWVrKCkpICUgNztcbiAgICAvLyBjYWxjdWxhdGUgbGFzdCBtb250aFxuICAgIHZhciBsYXN0TW9udGgxID0gbW9udGgxLmNsb25lKCk7XG4gICAgbGFzdE1vbnRoMS5hZGREYXlPZk1vbnRoKDAgLSBsYXN0TW9udGhEaWZmRGF5KTtcbiAgICB2YXIgcGFzc2VkID0gMDtcbiAgICBmb3IgKGlJbmRleCA9IDA7IGlJbmRleCA8IF9EYXRlQ29uc3RhbnRzMltcImRlZmF1bHRcIl0uREFURV9ST1dfQ09VTlQ7IGlJbmRleCsrKSB7XG4gICAgICBmb3IgKGpJbmRleCA9IDA7IGpJbmRleCA8IF9EYXRlQ29uc3RhbnRzMltcImRlZmF1bHRcIl0uREFURV9DT0xfQ09VTlQ7IGpJbmRleCsrKSB7XG4gICAgICAgIGN1cnJlbnQgPSBsYXN0TW9udGgxO1xuICAgICAgICBpZiAocGFzc2VkKSB7XG4gICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQuY2xvbmUoKTtcbiAgICAgICAgICBjdXJyZW50LmFkZERheU9mTW9udGgocGFzc2VkKTtcbiAgICAgICAgfVxuICAgICAgICBkYXRlVGFibGUucHVzaChjdXJyZW50KTtcbiAgICAgICAgcGFzc2VkKys7XG4gICAgICB9XG4gICAgfVxuICAgIHZhciB0YWJsZUh0bWwgPSBbXTtcbiAgICBwYXNzZWQgPSAwO1xuICAgIGZvciAoaUluZGV4ID0gMDsgaUluZGV4IDwgX0RhdGVDb25zdGFudHMyW1wiZGVmYXVsdFwiXS5EQVRFX1JPV19DT1VOVDsgaUluZGV4KyspIHtcbiAgICAgIHZhciB3ZWVrTnVtYmVyQ2VsbCA9IHVuZGVmaW5lZDtcbiAgICAgIHZhciBkYXRlQ2VsbHMgPSBbXTtcbiAgICAgIGlmIChzaG93V2Vla051bWJlcikge1xuICAgICAgICB3ZWVrTnVtYmVyQ2VsbCA9IF9yZWFjdDJbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgJ3RkJyxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBrZXk6IGRhdGVUYWJsZVtwYXNzZWRdLmdldFdlZWtPZlllYXIoKSxcbiAgICAgICAgICAgIHJvbGU6ICdncmlkY2VsbCcsXG4gICAgICAgICAgICBjbGFzc05hbWU6IHdlZWtOdW1iZXJDZWxsQ2xhc3NcbiAgICAgICAgICB9LFxuICAgICAgICAgIGRhdGVUYWJsZVtwYXNzZWRdLmdldFdlZWtPZlllYXIoKVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgZm9yIChqSW5kZXggPSAwOyBqSW5kZXggPCBfRGF0ZUNvbnN0YW50czJbXCJkZWZhdWx0XCJdLkRBVEVfQ09MX0NPVU5UOyBqSW5kZXgrKykge1xuICAgICAgICB2YXIgbmV4dCA9IG51bGw7XG4gICAgICAgIHZhciBsYXN0ID0gbnVsbDtcbiAgICAgICAgY3VycmVudCA9IGRhdGVUYWJsZVtwYXNzZWRdO1xuICAgICAgICBpZiAoakluZGV4IDwgX0RhdGVDb25zdGFudHMyW1wiZGVmYXVsdFwiXS5EQVRFX0NPTF9DT1VOVCAtIDEpIHtcbiAgICAgICAgICBuZXh0ID0gZGF0ZVRhYmxlW3Bhc3NlZCArIDFdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChqSW5kZXggPiAwKSB7XG4gICAgICAgICAgbGFzdCA9IGRhdGVUYWJsZVtwYXNzZWQgLSAxXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY2xzID0gY2VsbENsYXNzO1xuICAgICAgICB2YXIgZGlzYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgdmFyIHNlbGVjdGVkID0gZmFsc2U7XG5cbiAgICAgICAgaWYgKGlzU2FtZURheShjdXJyZW50LCB0b2RheSkpIHtcbiAgICAgICAgICBjbHMgKz0gJyAnICsgdG9kYXlDbGFzcztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBpc0JlZm9yZUN1cnJlbnRNb250aFllYXIgPSBiZWZvcmVDdXJyZW50TW9udGhZZWFyKGN1cnJlbnQsIHZhbHVlKTtcbiAgICAgICAgdmFyIGlzQWZ0ZXJDdXJyZW50TW9udGhZZWFyID0gYWZ0ZXJDdXJyZW50TW9udGhZZWFyKGN1cnJlbnQsIHZhbHVlKTtcblxuICAgICAgICBpZiAoc2VsZWN0ZWRWYWx1ZSAmJiBBcnJheS5pc0FycmF5KHNlbGVjdGVkVmFsdWUpKSB7XG4gICAgICAgICAgaWYgKCFpc0JlZm9yZUN1cnJlbnRNb250aFllYXIgJiYgIWlzQWZ0ZXJDdXJyZW50TW9udGhZZWFyKSB7XG4gICAgICAgICAgICB2YXIgc3RhcnRWYWx1ZSA9IHNlbGVjdGVkVmFsdWVbMF07XG4gICAgICAgICAgICB2YXIgZW5kVmFsdWUgPSBzZWxlY3RlZFZhbHVlWzFdO1xuICAgICAgICAgICAgaWYgKHN0YXJ0VmFsdWUpIHtcbiAgICAgICAgICAgICAgaWYgKGlzU2FtZURheShjdXJyZW50LCBzdGFydFZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHNlbGVjdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHN0YXJ0VmFsdWUgJiYgZW5kVmFsdWUpIHtcbiAgICAgICAgICAgICAgaWYgKGlzU2FtZURheShjdXJyZW50LCBlbmRWYWx1ZSkgJiYgIXNlbGVjdGVkVmFsdWUuaG92ZXJpbmcpIHtcbiAgICAgICAgICAgICAgICBzZWxlY3RlZCA9IHRydWU7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoY3VycmVudC5jb21wYXJlVG9EYXkoc3RhcnRWYWx1ZSkgPiAwICYmIGN1cnJlbnQuY29tcGFyZVRvRGF5KGVuZFZhbHVlKSA8IDApIHtcbiAgICAgICAgICAgICAgICBjbHMgKz0gJyAnICsgaW5SYW5nZUNsYXNzO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGlzU2FtZURheShjdXJyZW50LCBzZWxlY3RlZFZhbHVlKSkge1xuICAgICAgICAgIHNlbGVjdGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNCZWZvcmVDdXJyZW50TW9udGhZZWFyKSB7XG4gICAgICAgICAgY2xzICs9ICcgJyArIGxhc3RNb250aERheUNsYXNzO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0FmdGVyQ3VycmVudE1vbnRoWWVhcikge1xuICAgICAgICAgIGNscyArPSAnICcgKyBuZXh0TW9udGhEYXlDbGFzcztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkaXNhYmxlZERhdGUpIHtcbiAgICAgICAgICBpZiAoZGlzYWJsZWREYXRlKGN1cnJlbnQsIHZhbHVlKSkge1xuICAgICAgICAgICAgZGlzYWJsZWQgPSB0cnVlO1xuXG4gICAgICAgICAgICBpZiAoIWxhc3QgfHwgIWRpc2FibGVkRGF0ZShsYXN0LCB2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgY2xzICs9ICcgJyArIGZpcnN0RGlzYWJsZUNsYXNzO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIW5leHQgfHwgIWRpc2FibGVkRGF0ZShuZXh0LCB2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgY2xzICs9ICcgJyArIGxhc3REaXNhYmxlQ2xhc3M7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNlbGVjdGVkKSB7XG4gICAgICAgICAgY2xzICs9ICcgJyArIHNlbGVjdGVkQ2xhc3M7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZGlzYWJsZWQpIHtcbiAgICAgICAgICBjbHMgKz0gJyAnICsgZGlzYWJsZWRDbGFzcztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBkYXRlSHRtbCA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKGRhdGVSZW5kZXIpIHtcbiAgICAgICAgICBkYXRlSHRtbCA9IGRhdGVSZW5kZXIoY3VycmVudCwgdmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBfY2xhc3NuYW1lcztcblxuICAgICAgICAgIHZhciBjb250ZW50ID0gY29udGVudFJlbmRlciA/IGNvbnRlbnRSZW5kZXIoY3VycmVudCwgdmFsdWUpIDogY3VycmVudC5nZXREYXlPZk1vbnRoKCk7XG4gICAgICAgICAgdmFyIGRheU9mV2VlayA9IGN1cnJlbnQuZ2V0RGF5T2ZXZWVrKCk7XG4gICAgICAgICAgZGF0ZUh0bWwgPSBfcmVhY3QyW1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICAgJ2RpdicsXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGtleTogZ2V0SWRGcm9tRGF0ZShjdXJyZW50KSxcbiAgICAgICAgICAgICAgY2xhc3NOYW1lOiAoMCwgX2NsYXNzbmFtZXMzW1wiZGVmYXVsdFwiXSkoKF9jbGFzc25hbWVzID0ge30sIF9jbGFzc25hbWVzW2RhdGVDbGFzc10gPSB0cnVlLCBfY2xhc3NuYW1lcy53ZWVrZW5kID0gZGF5T2ZXZWVrID09IDAgfHwgZGF5T2ZXZWVrID09IDYsIF9jbGFzc25hbWVzKSksXG4gICAgICAgICAgICAgICdhcmlhLXNlbGVjdGVkJzogc2VsZWN0ZWQsXG4gICAgICAgICAgICAgICdhcmlhLWRpc2FibGVkJzogZGlzYWJsZWRcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjb250ZW50XG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGRhdGVDZWxscy5wdXNoKF9yZWFjdDJbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgJ3RkJyxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBrZXk6IHBhc3NlZCxcbiAgICAgICAgICAgIG9uQ2xpY2s6IGRpc2FibGVkID8gbm9vcCA6IGhhbmRsZURheUNsaWNrLmJpbmQodGhpcywgY3VycmVudCksXG4gICAgICAgICAgICBvbk1vdXNlRW50ZXI6IGRpc2FibGVkID8gbm9vcCA6IGhhbmRsZUNlbGxNb3VzZUVudGVyLmJpbmQodGhpcywgY3VycmVudCksXG4gICAgICAgICAgICByb2xlOiAnZ3JpZGNlbGwnLFxuICAgICAgICAgICAgdGl0bGU6ICgwLCBfdXRpbC5nZXRUaXRsZVN0cmluZykoY3VycmVudCksIGNsYXNzTmFtZTogY2xzXG4gICAgICAgICAgfSxcbiAgICAgICAgICBkYXRlSHRtbFxuICAgICAgICApKTtcblxuICAgICAgICBwYXNzZWQrKztcbiAgICAgIH1cbiAgICAgIHRhYmxlSHRtbC5wdXNoKF9yZWFjdDJbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICd0cicsXG4gICAgICAgIHtcbiAgICAgICAgICBrZXk6IGlJbmRleCxcbiAgICAgICAgICByb2xlOiAncm93J1xuICAgICAgICB9LFxuICAgICAgICB3ZWVrTnVtYmVyQ2VsbCxcbiAgICAgICAgZGF0ZUNlbGxzXG4gICAgICApKTtcbiAgICB9XG4gICAgcmV0dXJuIF9yZWFjdDJbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXG4gICAgICAndGJvZHknLFxuICAgICAgeyBjbGFzc05hbWU6IHByZWZpeENscyArICd0Ym9keScgfSxcbiAgICAgIHRhYmxlSHRtbFxuICAgICk7XG4gIH1cbn0pO1xuXG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IERhdGVUQm9keTtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3V4Y29yZS1mb3JtL34vdXhjb3JlLWRhdGUtZm9ybS1maWVsZC9+L3V4Y29yZS1jYWxlbmRhci9idWlsZC9kYXRlL0RhdGVUQm9keS5qc1xuICoqIG1vZHVsZSBpZCA9IDQwNlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IHtcbiAgREFURV9ST1dfQ09VTlQ6IDYsXG4gIERBVEVfQ09MX0NPVU5UOiA3XG59O1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vdXhjb3JlLWZvcm0vfi91eGNvcmUtZGF0ZS1mb3JtLWZpZWxkL34vdXhjb3JlLWNhbGVuZGFyL34vcmMtY2FsZW5kYXIvbGliL2RhdGUvRGF0ZUNvbnN0YW50cy5qc1xuICoqIG1vZHVsZSBpZCA9IDQwN1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG5leHBvcnRzLmdldFRvZGF5VGltZSA9IGdldFRvZGF5VGltZTtcbmV4cG9ydHMuZ2V0VGl0bGVTdHJpbmcgPSBnZXRUaXRsZVN0cmluZztcbmV4cG9ydHMuZ2V0VG9kYXlUaW1lU3RyID0gZ2V0VG9kYXlUaW1lU3RyO1xuZXhwb3J0cy5nZXRGb3JtYXR0ZXIgPSBnZXRGb3JtYXR0ZXI7XG5leHBvcnRzLnN5bmNUaW1lID0gc3luY1RpbWU7XG5leHBvcnRzLmdldFRpbWVDb25maWcgPSBnZXRUaW1lQ29uZmlnO1xuZXhwb3J0cy5pc1RpbWVWYWxpZEJ5Q29uZmlnID0gaXNUaW1lVmFsaWRCeUNvbmZpZztcbmV4cG9ydHMuaXNUaW1lVmFsaWQgPSBpc1RpbWVWYWxpZDtcbmV4cG9ydHMuaXNBbGxvd2VkRGF0ZSA9IGlzQWxsb3dlZERhdGU7XG5cbnZhciBfZ3JlZ29yaWFuQ2FsZW5kYXJGb3JtYXQgPSByZXF1aXJlKCdncmVnb3JpYW4tY2FsZW5kYXItZm9ybWF0Jyk7XG5cbnZhciBfZ3JlZ29yaWFuQ2FsZW5kYXJGb3JtYXQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZ3JlZ29yaWFuQ2FsZW5kYXJGb3JtYXQpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBcImRlZmF1bHRcIjogb2JqIH07IH1cblxudmFyIGRlZmF1bHREaXNhYmxlZFRpbWUgPSB7XG4gIGRpc2FibGVkSG91cnM6IGZ1bmN0aW9uIGRpc2FibGVkSG91cnMoKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9LFxuICBkaXNhYmxlZE1pbnV0ZXM6IGZ1bmN0aW9uIGRpc2FibGVkTWludXRlcygpIHtcbiAgICByZXR1cm4gW107XG4gIH0sXG4gIGRpc2FibGVkU2Vjb25kczogZnVuY3Rpb24gZGlzYWJsZWRTZWNvbmRzKCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxufTtcblxuZnVuY3Rpb24gZ2V0VG9kYXlUaW1lKHZhbHVlKSB7XG4gIHZhciB0b2RheSA9IHZhbHVlLmNsb25lKCk7XG4gIHRvZGF5LnNldFRpbWUoRGF0ZS5ub3coKSk7XG4gIHJldHVybiB0b2RheTtcbn1cblxuZnVuY3Rpb24gZ2V0VGl0bGVTdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlLmdldFllYXIoKSArICctJyArICh2YWx1ZS5nZXRNb250aCgpICsgMSkgKyAnLScgKyB2YWx1ZS5nZXREYXlPZk1vbnRoKCk7XG59XG5cbmZ1bmN0aW9uIGdldFRvZGF5VGltZVN0cih2YWx1ZSkge1xuICB2YXIgdG9kYXkgPSBnZXRUb2RheVRpbWUodmFsdWUpO1xuICByZXR1cm4gZ2V0VGl0bGVTdHJpbmcodG9kYXkpO1xufVxuXG5mdW5jdGlvbiBnZXRGb3JtYXR0ZXIoZm9ybWF0LCBsb2NhbGUpIHtcbiAgaWYgKHR5cGVvZiBmb3JtYXQgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIG5ldyBfZ3JlZ29yaWFuQ2FsZW5kYXJGb3JtYXQyW1wiZGVmYXVsdFwiXShmb3JtYXQsIGxvY2FsZS5mb3JtYXQpO1xuICB9XG4gIHJldHVybiBmb3JtYXQ7XG59XG5cbmZ1bmN0aW9uIHN5bmNUaW1lKGZyb20sIHRvKSB7XG4gIHRvLnNldEhvdXJPZkRheShmcm9tLmdldEhvdXJPZkRheSgpKTtcbiAgdG8uc2V0TWludXRlcyhmcm9tLmdldE1pbnV0ZXMoKSk7XG4gIHRvLnNldFNlY29uZHMoZnJvbS5nZXRTZWNvbmRzKCkpO1xufVxuXG5mdW5jdGlvbiBnZXRUaW1lQ29uZmlnKHZhbHVlLCBkaXNhYmxlZFRpbWUpIHtcbiAgdmFyIGRpc2FibGVkVGltZUNvbmZpZyA9IGRpc2FibGVkVGltZSA/IGRpc2FibGVkVGltZSh2YWx1ZSkgOiB7fTtcbiAgZGlzYWJsZWRUaW1lQ29uZmlnID0gX2V4dGVuZHMoe30sIGRlZmF1bHREaXNhYmxlZFRpbWUsIGRpc2FibGVkVGltZUNvbmZpZyk7XG4gIHJldHVybiBkaXNhYmxlZFRpbWVDb25maWc7XG59XG5cbmZ1bmN0aW9uIGlzVGltZVZhbGlkQnlDb25maWcodmFsdWUsIGRpc2FibGVkVGltZUNvbmZpZykge1xuICB2YXIgaW52YWxpZFRpbWUgPSBmYWxzZTtcbiAgaWYgKHZhbHVlKSB7XG4gICAgdmFyIGhvdXIgPSB2YWx1ZS5nZXRIb3VyT2ZEYXkoKTtcbiAgICB2YXIgbWludXRlcyA9IHZhbHVlLmdldE1pbnV0ZXMoKTtcbiAgICB2YXIgc2Vjb25kcyA9IHZhbHVlLmdldFNlY29uZHMoKTtcbiAgICB2YXIgZGlzYWJsZWRIb3VycyA9IGRpc2FibGVkVGltZUNvbmZpZy5kaXNhYmxlZEhvdXJzKCk7XG4gICAgaWYgKGRpc2FibGVkSG91cnMuaW5kZXhPZihob3VyKSA9PT0gLTEpIHtcbiAgICAgIHZhciBkaXNhYmxlZE1pbnV0ZXMgPSBkaXNhYmxlZFRpbWVDb25maWcuZGlzYWJsZWRNaW51dGVzKGhvdXIpO1xuICAgICAgaWYgKGRpc2FibGVkTWludXRlcy5pbmRleE9mKG1pbnV0ZXMpID09PSAtMSkge1xuICAgICAgICB2YXIgZGlzYWJsZWRTZWNvbmRzID0gZGlzYWJsZWRUaW1lQ29uZmlnLmRpc2FibGVkU2Vjb25kcyhob3VyLCBtaW51dGVzKTtcbiAgICAgICAgaW52YWxpZFRpbWUgPSBkaXNhYmxlZFNlY29uZHMuaW5kZXhPZihzZWNvbmRzKSAhPT0gLTE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbnZhbGlkVGltZSA9IHRydWU7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGludmFsaWRUaW1lID0gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuICFpbnZhbGlkVGltZTtcbn1cblxuZnVuY3Rpb24gaXNUaW1lVmFsaWQodmFsdWUsIGRpc2FibGVkVGltZSkge1xuICB2YXIgZGlzYWJsZWRUaW1lQ29uZmlnID0gZ2V0VGltZUNvbmZpZyh2YWx1ZSwgZGlzYWJsZWRUaW1lKTtcbiAgcmV0dXJuIGlzVGltZVZhbGlkQnlDb25maWcodmFsdWUsIGRpc2FibGVkVGltZUNvbmZpZyk7XG59XG5cbmZ1bmN0aW9uIGlzQWxsb3dlZERhdGUodmFsdWUsIGRpc2FibGVkRGF0ZSwgZGlzYWJsZWRUaW1lKSB7XG4gIGlmIChkaXNhYmxlZERhdGUpIHtcbiAgICBpZiAoZGlzYWJsZWREYXRlKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICBpZiAoZGlzYWJsZWRUaW1lKSB7XG4gICAgaWYgKCFpc1RpbWVWYWxpZCh2YWx1ZSwgZGlzYWJsZWRUaW1lKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi91eGNvcmUtZm9ybS9+L3V4Y29yZS1kYXRlLWZvcm0tZmllbGQvfi91eGNvcmUtY2FsZW5kYXIvfi9yYy1jYWxlbmRhci9saWIvdXRpbC9pbmRleC5qc1xuICoqIG1vZHVsZSBpZCA9IDQwOFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBAaWdub3JlXG4gKiBEYXRlVGltZUZvcm1hdCBmb3JcbiAqIEluc3BpcmVkIGJ5IERhdGVUaW1lRm9ybWF0IGZyb20gSkRLLlxuICogQGF1dGhvciB5aW1pbmdoZUBnbWFpbC5jb21cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBHcmVnb3JpYW5DYWxlbmRhciA9IHJlcXVpcmUoJ2dyZWdvcmlhbi1jYWxlbmRhcicpO1xudmFyIGVuVXNMb2NhbGUgPSByZXF1aXJlKCcuL2xvY2FsZS9lbl9VUycpO1xudmFyIE1BWF9WQUxVRSA9IE51bWJlci5NQVhfVkFMVUU7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ3dhcm5pbmcnKTtcblxuLyoqXG4gKiBkYXRlIG9yIHRpbWUgc3R5bGUgZW51bVxuICogQGVudW0ge051bWJlcn0gRGF0ZS5Gb3JtYXR0ZXIuU3R5bGVcbiAqL1xudmFyIERhdGVUaW1lU3R5bGUgPSB7XG4gIC8qKlxuICAgKiBmdWxsIHN0eWxlXG4gICAqL1xuICBGVUxMOiAwLFxuICAvKipcbiAgICogbG9uZyBzdHlsZVxuICAgKi9cbiAgTE9ORzogMSxcbiAgLyoqXG4gICAqIG1lZGl1bSBzdHlsZVxuICAgKi9cbiAgTUVESVVNOiAyLFxuICAvKipcbiAgICogc2hvcnQgc3R5bGVcbiAgICovXG4gIFNIT1JUOiAzXG59O1xuXG4vKlxuIExldHRlciAgICBEYXRlIG9yIFRpbWUgQ29tcG9uZW50ICAgIFByZXNlbnRhdGlvbiAgICBFeGFtcGxlc1xuIEcgICAgRXJhIGRlc2lnbmF0b3IgICAgVGV4dCAgICBBRFxuIHkgICAgWWVhciAgICBZZWFyICAgIDE5OTY7IDk2XG4gWSAgICBXZWVrWWVhciAgICBXZWVrWWVhciAgICAxOTk2OyA5NlxuIE0gICAgTW9udGggaW4geWVhciAgICBNb250aCAgICBKdWx5OyBKdWw7IDA3XG4gdyAgICBXZWVrIGluIHllYXIgICAgTnVtYmVyICAgIDI3XG4gVyAgICBXZWVrIGluIG1vbnRoICAgIE51bWJlciAgICAyXG4gRCAgICBEYXkgaW4geWVhciAgICBOdW1iZXIgICAgMTg5XG4gZCAgICBEYXkgaW4gbW9udGggICAgTnVtYmVyICAgIDEwXG4gRiAgICBEYXkgb2Ygd2VlayBpbiBtb250aCAgICBOdW1iZXIgICAgMlxuIEUgICAgRGF5IGluIHdlZWsgICAgVGV4dCAgICBUdWVzZGF5OyBUdWVcbiBhICAgIEFtL3BtIG1hcmtlciAgICBUZXh0ICAgIFBNXG4gSCAgICBIb3VyIGluIGRheSAoMC0yMykgICAgTnVtYmVyICAgIDBcbiBrICAgIEhvdXIgaW4gZGF5ICgxLTI0KSAgICBOdW1iZXIgICAgMjRcbiBLICAgIEhvdXIgaW4gYW0vcG0gKDAtMTEpICAgIE51bWJlciAgICAwXG4gaCAgICBIb3VyIGluIGFtL3BtICgxLTEyKSAgICBOdW1iZXIgICAgMTJcbiBtICAgIE1pbnV0ZSBpbiBob3VyICAgIE51bWJlciAgICAzMFxuIHMgICAgU2Vjb25kIGluIG1pbnV0ZSAgICBOdW1iZXIgICAgNTVcbiBTICAgIE1pbGxpc2Vjb25kICAgIE51bWJlciAgICA5NzhcbiB4IHogICAgVGltZSB6b25lICAgIEdlbmVyYWwgdGltZSB6b25lICAgIFBhY2lmaWMgU3RhbmRhcmQgVGltZTsgUFNUOyBHTVQtMDg6MDBcbiBaICAgIFRpbWUgem9uZSAgICBSRkMgODIyIHRpbWUgem9uZSAgICAtMDgwMFxuICovXG5cbnZhciBwYXR0ZXJuQ2hhcnMgPSBuZXcgQXJyYXkoR3JlZ29yaWFuQ2FsZW5kYXIuREFZX09GX1dFRUtfSU5fTU9OVEggKyAyKS5qb2luKCcxJyk7XG52YXIgRVJBID0gMDtcbnZhciBjYWxlbmRhckluZGV4TWFwID0ge307XG5cbnBhdHRlcm5DaGFycyA9IHBhdHRlcm5DaGFycy5zcGxpdCgnJyk7XG5wYXR0ZXJuQ2hhcnNbRVJBXSA9ICdHJztcbnBhdHRlcm5DaGFyc1tHcmVnb3JpYW5DYWxlbmRhci5ZRUFSXSA9ICd5JztcbnBhdHRlcm5DaGFyc1tHcmVnb3JpYW5DYWxlbmRhci5NT05USF0gPSAnTSc7XG5wYXR0ZXJuQ2hhcnNbR3JlZ29yaWFuQ2FsZW5kYXIuREFZX09GX01PTlRIXSA9ICdkJztcbnBhdHRlcm5DaGFyc1tHcmVnb3JpYW5DYWxlbmRhci5IT1VSX09GX0RBWV0gPSAnSCc7XG5wYXR0ZXJuQ2hhcnNbR3JlZ29yaWFuQ2FsZW5kYXIuTUlOVVRFU10gPSAnbSc7XG5wYXR0ZXJuQ2hhcnNbR3JlZ29yaWFuQ2FsZW5kYXIuU0VDT05EU10gPSAncyc7XG5wYXR0ZXJuQ2hhcnNbR3JlZ29yaWFuQ2FsZW5kYXIuTUlMTElTRUNPTkRTXSA9ICdTJztcbnBhdHRlcm5DaGFyc1tHcmVnb3JpYW5DYWxlbmRhci5XRUVLX09GX1lFQVJdID0gJ3cnO1xucGF0dGVybkNoYXJzW0dyZWdvcmlhbkNhbGVuZGFyLldFRUtfT0ZfTU9OVEhdID0gJ1cnO1xucGF0dGVybkNoYXJzW0dyZWdvcmlhbkNhbGVuZGFyLkRBWV9PRl9ZRUFSXSA9ICdEJztcbnBhdHRlcm5DaGFyc1tHcmVnb3JpYW5DYWxlbmRhci5EQVlfT0ZfV0VFS19JTl9NT05USF0gPSAnRic7XG5wYXR0ZXJuQ2hhcnMucHVzaCgnWScpO1xuXG5wYXR0ZXJuQ2hhcnMuZm9yRWFjaChmdW5jdGlvbiAodiwga2V5KSB7XG4gIHZhciBrID0ga2V5O1xuICBpZiAodiA9PT0gJ1knKSB7XG4gICAgayA9IEdyZWdvcmlhbkNhbGVuZGFyLllFQVI7XG4gIH1cbiAgaWYgKHYpIHtcbiAgICBjYWxlbmRhckluZGV4TWFwW3ZdID0gaztcbiAgfVxufSk7XG5cbmZ1bmN0aW9uIG1peCh0LCBzKSB7XG4gIGZvciAodmFyIHAgaW4gcykge1xuICAgIGlmIChzLmhhc093blByb3BlcnR5KHApKSB7XG4gICAgICB0W3BdID0gc1twXTtcbiAgICB9XG4gIH1cbn1cblxudmFyIFNVQlNUSVRVVEVfUkVHID0gL1xcXFw/XFx7KFtee31dKylcXH0vZztcbnZhciBFTVBUWSA9ICcnO1xuXG5mdW5jdGlvbiBzdWJzdGl0dXRlKHN0ciwgbywgcmVnZXhwKSB7XG4gIGlmICh0eXBlb2Ygc3RyICE9PSAnc3RyaW5nJyB8fCAhbykge1xuICAgIHJldHVybiBzdHI7XG4gIH1cblxuICByZXR1cm4gc3RyLnJlcGxhY2UocmVnZXhwIHx8IFNVQlNUSVRVVEVfUkVHLCBmdW5jdGlvbiAobWF0Y2gsIG5hbWUpIHtcbiAgICBpZiAobWF0Y2guY2hhckF0KDApID09PSAnXFxcXCcpIHtcbiAgICAgIHJldHVybiBtYXRjaC5zbGljZSgxKTtcbiAgICB9XG4gICAgcmV0dXJuIG9bbmFtZV0gPT09IHVuZGVmaW5lZCA/IEVNUFRZIDogb1tuYW1lXTtcbiAgfSk7XG59XG5cbnBhdHRlcm5DaGFycyA9IHBhdHRlcm5DaGFycy5qb2luKCcnKSArICdhaGtLWkUnO1xuXG5mdW5jdGlvbiBlbmNvZGUobGFzdEZpZWxkLCBjb3VudCwgY29tcGlsZWRQYXR0ZXJuKSB7XG4gIGNvbXBpbGVkUGF0dGVybi5wdXNoKHtcbiAgICBmaWVsZDogbGFzdEZpZWxkLFxuICAgIGNvdW50OiBjb3VudFxuICB9KTtcbn1cblxuZnVuY3Rpb24gY29tcGlsZShwYXR0ZXJuKSB7XG4gIHZhciBsZW5ndGggPSBwYXR0ZXJuLmxlbmd0aDtcbiAgdmFyIGluUXVvdGUgPSBmYWxzZTtcbiAgdmFyIGNvbXBpbGVkUGF0dGVybiA9IFtdO1xuICB2YXIgdG1wQnVmZmVyID0gbnVsbDtcbiAgdmFyIGNvdW50ID0gMDtcbiAgdmFyIGxhc3RGaWVsZCA9IC0xO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgYyA9IHBhdHRlcm4uY2hhckF0KGkpO1xuXG4gICAgaWYgKGMgPT09ICdcXCcnKSB7XG4gICAgICAvLyAnJyBpcyB0cmVhdGVkIGFzIGEgc2luZ2xlIHF1b3RlIHJlZ2FyZGxlc3Mgb2YgYmVpbmdcbiAgICAgIC8vIGluIGEgcXVvdGVkIHNlY3Rpb24uXG4gICAgICBpZiAoaSArIDEgPCBsZW5ndGgpIHtcbiAgICAgICAgYyA9IHBhdHRlcm4uY2hhckF0KGkgKyAxKTtcbiAgICAgICAgaWYgKGMgPT09ICdcXCcnKSB7XG4gICAgICAgICAgaSsrO1xuICAgICAgICAgIGlmIChjb3VudCAhPT0gMCkge1xuICAgICAgICAgICAgZW5jb2RlKGxhc3RGaWVsZCwgY291bnQsIGNvbXBpbGVkUGF0dGVybik7XG4gICAgICAgICAgICBsYXN0RmllbGQgPSAtMTtcbiAgICAgICAgICAgIGNvdW50ID0gMDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGluUXVvdGUpIHtcbiAgICAgICAgICAgIHRtcEJ1ZmZlciArPSBjO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCFpblF1b3RlKSB7XG4gICAgICAgIGlmIChjb3VudCAhPT0gMCkge1xuICAgICAgICAgIGVuY29kZShsYXN0RmllbGQsIGNvdW50LCBjb21waWxlZFBhdHRlcm4pO1xuICAgICAgICAgIGxhc3RGaWVsZCA9IC0xO1xuICAgICAgICAgIGNvdW50ID0gMDtcbiAgICAgICAgfVxuICAgICAgICB0bXBCdWZmZXIgPSAnJztcbiAgICAgICAgaW5RdW90ZSA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb21waWxlZFBhdHRlcm4ucHVzaCh7XG4gICAgICAgICAgdGV4dDogdG1wQnVmZmVyXG4gICAgICAgIH0pO1xuICAgICAgICBpblF1b3RlID0gZmFsc2U7XG4gICAgICB9XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKGluUXVvdGUpIHtcbiAgICAgIHRtcEJ1ZmZlciArPSBjO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmICghKGMgPj0gJ2EnICYmIGMgPD0gJ3onIHx8IGMgPj0gJ0EnICYmIGMgPD0gJ1onKSkge1xuICAgICAgaWYgKGNvdW50ICE9PSAwKSB7XG4gICAgICAgIGVuY29kZShsYXN0RmllbGQsIGNvdW50LCBjb21waWxlZFBhdHRlcm4pO1xuICAgICAgICBsYXN0RmllbGQgPSAtMTtcbiAgICAgICAgY291bnQgPSAwO1xuICAgICAgfVxuICAgICAgY29tcGlsZWRQYXR0ZXJuLnB1c2goe1xuICAgICAgICB0ZXh0OiBjXG4gICAgICB9KTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmIChwYXR0ZXJuQ2hhcnMuaW5kZXhPZihjKSA9PT0gLTEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSWxsZWdhbCBwYXR0ZXJuIGNoYXJhY3RlciBcIicgKyBjICsgJ1wiJyk7XG4gICAgfVxuXG4gICAgaWYgKGxhc3RGaWVsZCA9PT0gLTEgfHwgbGFzdEZpZWxkID09PSBjKSB7XG4gICAgICBsYXN0RmllbGQgPSBjO1xuICAgICAgY291bnQrKztcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBlbmNvZGUobGFzdEZpZWxkLCBjb3VudCwgY29tcGlsZWRQYXR0ZXJuKTtcbiAgICBsYXN0RmllbGQgPSBjO1xuICAgIGNvdW50ID0gMTtcbiAgfVxuXG4gIGlmIChpblF1b3RlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdVbnRlcm1pbmF0ZWQgcXVvdGUnKTtcbiAgfVxuXG4gIGlmIChjb3VudCAhPT0gMCkge1xuICAgIGVuY29kZShsYXN0RmllbGQsIGNvdW50LCBjb21waWxlZFBhdHRlcm4pO1xuICB9XG5cbiAgcmV0dXJuIGNvbXBpbGVkUGF0dGVybjtcbn1cblxudmFyIHplcm9EaWdpdCA9ICcwJztcblxuLy8gVE9ETyB6ZXJvRGlnaXQgbG9jYWxpemF0aW9uPz9cbmZ1bmN0aW9uIHplcm9QYWRkaW5nTnVtYmVyKF94LCBfeDIsIF94MywgX3g0KSB7XG4gIHZhciBfYWdhaW4gPSB0cnVlO1xuXG4gIF9mdW5jdGlvbjogd2hpbGUgKF9hZ2Fpbikge1xuICAgIHZhciB2YWx1ZSA9IF94LFxuICAgICAgICBtaW5EaWdpdHMgPSBfeDIsXG4gICAgICAgIG1heERpZ2l0c18gPSBfeDMsXG4gICAgICAgIGIgPSBfeDQ7XG4gICAgX2FnYWluID0gZmFsc2U7XG5cbiAgICAvLyBPcHRpbWl6YXRpb24gZm9yIDEsIDIgYW5kIDQgZGlnaXQgbnVtYmVycy4gVGhpcyBzaG91bGRcbiAgICAvLyBjb3ZlciBtb3N0IGNhc2VzIG9mIGZvcm1hdHRpbmcgZGF0ZS90aW1lIHJlbGF0ZWQgaXRlbXMuXG4gICAgLy8gTm90ZTogVGhpcyBvcHRpbWl6YXRpb24gY29kZSBhc3N1bWVzIHRoYXQgbWF4RGlnaXRzIGlzXG4gICAgLy8gZWl0aGVyIDIgb3IgSW50ZWdlci5NQVhfVkFMVUUgKG1heEludENvdW50IGluIGZvcm1hdCgpKS5cbiAgICB2YXIgYnVmZmVyID0gYiB8fCBbXTtcbiAgICB2YXIgbWF4RGlnaXRzID0gbWF4RGlnaXRzXyB8fCBNQVhfVkFMVUU7XG4gICAgaWYgKHZhbHVlID49IDApIHtcbiAgICAgIGlmICh2YWx1ZSA8IDEwMCAmJiBtaW5EaWdpdHMgPj0gMSAmJiBtaW5EaWdpdHMgPD0gMikge1xuICAgICAgICBpZiAodmFsdWUgPCAxMCAmJiBtaW5EaWdpdHMgPT09IDIpIHtcbiAgICAgICAgICBidWZmZXIucHVzaCh6ZXJvRGlnaXQpO1xuICAgICAgICB9XG4gICAgICAgIGJ1ZmZlci5wdXNoKHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIGJ1ZmZlci5qb2luKCcnKTtcbiAgICAgIH0gZWxzZSBpZiAodmFsdWUgPj0gMTAwMCAmJiB2YWx1ZSA8IDEwMDAwKSB7XG4gICAgICAgIGlmIChtaW5EaWdpdHMgPT09IDQpIHtcbiAgICAgICAgICBidWZmZXIucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgcmV0dXJuIGJ1ZmZlci5qb2luKCcnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWluRGlnaXRzID09PSAyICYmIG1heERpZ2l0cyA9PT0gMikge1xuICAgICAgICAgIF94ID0gdmFsdWUgJSAxMDA7XG4gICAgICAgICAgX3gyID0gMjtcbiAgICAgICAgICBfeDMgPSAyO1xuICAgICAgICAgIF94NCA9IGJ1ZmZlcjtcbiAgICAgICAgICBfYWdhaW4gPSB0cnVlO1xuICAgICAgICAgIGJ1ZmZlciA9IG1heERpZ2l0cyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICBjb250aW51ZSBfZnVuY3Rpb247XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgYnVmZmVyLnB1c2godmFsdWUgKyAnJyk7XG4gICAgcmV0dXJuIGJ1ZmZlci5qb2luKCcnKTtcbiAgfVxufVxuXG4vKipcbiAqXG4gKiBkYXRlIHRpbWUgZm9ybWF0dGVyIGZvciBHcmVnb3JpYW5DYWxlbmRhclxuICpcbiAqICAgICAgQGV4YW1wbGVcbiAqXG4gKiAgICAgICAgICBjb25zdCBjYWxlbmRhciA9IG5ldyBHcmVnb3JpYW5DYWxlbmRhcigyMDEzLDksMjQpO1xuICogICAgICAgICAgLy8gJyB0byBlc2NhcGVcbiAqICAgICAgICAgIGNvbnN0IGZvcm1hdHRlciA9IG5ldyBHcmVnb3JpYW5DYWxlbmRhckZvcm1hdChcIid0b2RheSBpcycgJyd5eXl5L01NL2RkIGEnJ1wiKTtcbiAqICAgICAgICAgIGRvY3VtZW50LndyaXRlKGZvcm1hdHRlci5mb3JtYXQoY2FsZW5kYXIpKTtcbiAqXG4gKiBAY2xhc3MgR3JlZ29yaWFuQ2FsZW5kYXJGb3JtYXRcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXR0ZXJuIHBhdHRlciBzdHJpbmcgb2YgZGF0ZSBmb3JtYXR0ZXJcbiAqXG4gKiA8dGFibGUgYm9yZGVyPVwiMVwiPlxuICogPHRoZWFkIHZhbGlnbj1cImJvdHRvbVwiPlxuICogPHRyPjx0aCBjbGFzcz1cImhlYWRcIj5MZXR0ZXI8L3RoPlxuICogPHRoIGNsYXNzPVwiaGVhZFwiPkRhdGUgb3IgVGltZSBDb21wb25lbnQ8L3RoPlxuICogPHRoIGNsYXNzPVwiaGVhZFwiPlByZXNlbnRhdGlvbjwvdGg+XG4gKiA8dGggY2xhc3M9XCJoZWFkXCI+RXhhbXBsZXM8L3RoPlxuICogPC90cj5cbiAqIDwvdGhlYWQ+XG4gKiA8dGJvZHkgdmFsaWduPVwidG9wXCI+XG4gKiA8dHI+PHRkPkc8L3RkPlxuICogPHRkPkVyYSBkZXNpZ25hdG9yPC90ZD5cbiAqIDx0ZD5UZXh0PC90ZD5cbiAqIDx0ZD5BRDwvdGQ+XG4gKiA8L3RyPlxuICogPHRyPjx0ZD55PC90ZD5cbiAqIDx0ZD5ZZWFyPC90ZD5cbiAqIDx0ZD5ZZWFyPC90ZD5cbiAqIDx0ZD4xOTk2OyA5NjwvdGQ+XG4gKiA8L3RyPlxuICogPHRyPjx0ZD5NPC90ZD5cbiAqIDx0ZD5Nb250aCBpbiB5ZWFyPC90ZD5cbiAqIDx0ZD5Nb250aDwvdGQ+XG4gKiA8dGQ+SnVseTsgSnVsOyAwNzwvdGQ+XG4gKiA8L3RyPlxuICogPHRyPjx0ZD53PC90ZD5cbiAqIDx0ZD5XZWVrIGluIHllYXI8L3RkPlxuICogPHRkPk51bWJlcjwvdGQ+XG4gKiA8dGQ+Mjc8L3RkPlxuICogPC90cj5cbiAqIDx0cj48dGQ+VzwvdGQ+XG4gKiA8dGQ+V2VlayBpbiBtb250aDwvdGQ+XG4gKiA8dGQ+TnVtYmVyPC90ZD5cbiAqIDx0ZD4yPC90ZD5cbiAqIDwvdHI+XG4gKiA8dHI+PHRkPkQ8L3RkPlxuICogPHRkPkRheSBpbiB5ZWFyPC90ZD5cbiAqIDx0ZD5OdW1iZXI8L3RkPlxuICogPHRkPjE4OTwvdGQ+XG4gKiA8L3RyPlxuICogPHRyPjx0ZD5kPC90ZD5cbiAqIDx0ZD5EYXkgaW4gbW9udGg8L3RkPlxuICogPHRkPk51bWJlcjwvdGQ+XG4gKiA8dGQ+MTA8L3RkPlxuICogPC90cj5cbiAqIDx0cj48dGQ+RjwvdGQ+XG4gKiA8dGQ+RGF5IG9mIHdlZWsgaW4gbW9udGg8L3RkPlxuICogPHRkPk51bWJlcjwvdGQ+XG4gKiA8dGQ+MjwvdGQ+XG4gKiA8L3RyPlxuICogPHRyPjx0ZD5FPC90ZD5cbiAqIDx0ZD5EYXkgaW4gd2VlazwvdGQ+XG4gKiA8dGQ+VGV4dDwvdGQ+XG4gKiA8dGQ+VHVlc2RheTsgVHVlPC90ZD5cbiAqIDwvdHI+XG4gKiA8dHI+PHRkPmE8L3RkPlxuICogPHRkPkFtL3BtIG1hcmtlcjwvdGQ+XG4gKiA8dGQ+VGV4dDwvdGQ+XG4gKiA8dGQ+UE08L3RkPlxuICogPC90cj5cbiAqIDx0cj48dGQ+SDwvdGQ+XG4gKiAgICAgICA8dGQ+SG91ciBpbiBkYXkgKDAtMjMpPC90ZD5cbiAqIDx0ZD5OdW1iZXI8L3RkPlxuICogPHRkPjA8L3RkPlxuICogPC90cj5cbiAqIDx0cj48dGQ+azwvdGQ+XG4gKiAgICAgICA8dGQ+SG91ciBpbiBkYXkgKDEtMjQpPC90ZD5cbiAqIDx0ZD5OdW1iZXI8L3RkPlxuICogPHRkPjI0PC90ZD5cbiAqIDwvdHI+XG4gKiA8dHI+PHRkPks8L3RkPlxuICogPHRkPkhvdXIgaW4gYW0vcG0gKDAtMTEpPC90ZD5cbiAqIDx0ZD5OdW1iZXI8L3RkPlxuICogPHRkPjA8L3RkPlxuICogPC90cj5cbiAqIDx0cj48dGQ+aDwvdGQ+XG4gKiA8dGQ+SG91ciBpbiBhbS9wbSAoMS0xMik8L3RkPlxuICogPHRkPk51bWJlcjwvdGQ+XG4gKiA8dGQ+MTI8L3RkPlxuICogPC90cj5cbiAqIDx0cj48dGQ+bTwvdGQ+XG4gKiA8dGQ+TWludXRlIGluIGhvdXI8L3RkPlxuICogPHRkPk51bWJlcjwvdGQ+XG4gKiA8dGQ+MzA8L3RkPlxuICogPC90cj5cbiAqIDx0cj48dGQ+czwvdGQ+XG4gKiA8dGQ+U2Vjb25kIGluIG1pbnV0ZTwvdGQ+XG4gKiA8dGQ+TnVtYmVyPC90ZD5cbiAqIDx0ZD41NTwvdGQ+XG4gKiA8L3RyPlxuICogPHRyPjx0ZD5TPC90ZD5cbiAqIDx0ZD5NaWxsaXNlY29uZDwvdGQ+XG4gKiA8dGQ+TnVtYmVyPC90ZD5cbiAqIDx0ZD45Nzg8L3RkPlxuICogPC90cj5cbiAqIDx0cj48dGQ+eC96PC90ZD5cbiAqIDx0ZD5UaW1lIHpvbmU8L3RkPlxuICogPHRkPkdlbmVyYWwgdGltZSB6b25lPC90ZD5cbiAqIDx0ZD5QYWNpZmljIFN0YW5kYXJkIFRpbWU7IFBTVDsgR01ULTA4OjAwPC90ZD5cbiAqIDwvdHI+XG4gKiA8dHI+PHRkPlo8L3RkPlxuICogPHRkPlRpbWUgem9uZTwvdGQ+XG4gKiA8dGQ+UkZDIDgyMiB0aW1lIHpvbmU8L3RkPlxuICogPHRkPi0wODAwPC90ZD5cbiAqIDwvdHI+XG4gKiA8L3Rib2R5PlxuICogPC90YWJsZT5cblxuICogQHBhcmFtIHtPYmplY3R9IGxvY2FsZSBmb3JtYXQgbG9jYWxlXG4gKi9cbmZ1bmN0aW9uIERhdGVUaW1lRm9ybWF0KHBhdHRlcm4sIGxvY2FsZSkge1xuICB0aGlzLmxvY2FsZSA9IGxvY2FsZSB8fCBlblVzTG9jYWxlO1xuICB0aGlzLm9yaWdpbmFsUGF0dGVybiA9IHBhdHRlcm47XG4gIHRoaXMucGF0dGVybiA9IGNvbXBpbGUocGF0dGVybik7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdEZpZWxkKGZpZWxkLCBjb3VudCwgbG9jYWxlLCBjYWxlbmRhcikge1xuICB2YXIgY3VycmVudCA9IHVuZGVmaW5lZDtcbiAgdmFyIHZhbHVlID0gdW5kZWZpbmVkO1xuICBzd2l0Y2ggKGZpZWxkKSB7XG4gICAgY2FzZSAnRyc6XG4gICAgICB2YWx1ZSA9IGNhbGVuZGFyLmdldFllYXIoKSA+IDAgPyAxIDogMDtcbiAgICAgIGN1cnJlbnQgPSBsb2NhbGUuZXJhc1t2YWx1ZV07XG4gICAgICBicmVhaztcbiAgICBjYXNlICdZJzpcbiAgICAgIHZhbHVlID0gY2FsZW5kYXIuZ2V0V2Vla1llYXIoKTtcbiAgICAgIGlmICh2YWx1ZSA8PSAwKSB7XG4gICAgICAgIHZhbHVlID0gMSAtIHZhbHVlO1xuICAgICAgfVxuICAgICAgY3VycmVudCA9IHplcm9QYWRkaW5nTnVtYmVyKHZhbHVlLCAyLCBjb3VudCAhPT0gMiA/IE1BWF9WQUxVRSA6IDIpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAneSc6XG4gICAgICB2YWx1ZSA9IGNhbGVuZGFyLmdldFllYXIoKTtcbiAgICAgIGlmICh2YWx1ZSA8PSAwKSB7XG4gICAgICAgIHZhbHVlID0gMSAtIHZhbHVlO1xuICAgICAgfVxuICAgICAgY3VycmVudCA9IHplcm9QYWRkaW5nTnVtYmVyKHZhbHVlLCAyLCBjb3VudCAhPT0gMiA/IE1BWF9WQUxVRSA6IDIpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnTSc6XG4gICAgICB2YWx1ZSA9IGNhbGVuZGFyLmdldE1vbnRoKCk7XG4gICAgICBpZiAoY291bnQgPj0gNCkge1xuICAgICAgICBjdXJyZW50ID0gbG9jYWxlLm1vbnRoc1t2YWx1ZV07XG4gICAgICB9IGVsc2UgaWYgKGNvdW50ID09PSAzKSB7XG4gICAgICAgIGN1cnJlbnQgPSBsb2NhbGUuc2hvcnRNb250aHNbdmFsdWVdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY3VycmVudCA9IHplcm9QYWRkaW5nTnVtYmVyKHZhbHVlICsgMSwgY291bnQpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnayc6XG4gICAgICBjdXJyZW50ID0gemVyb1BhZGRpbmdOdW1iZXIoY2FsZW5kYXIuZ2V0SG91ck9mRGF5KCkgfHwgMjQsIGNvdW50KTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ0UnOlxuICAgICAgdmFsdWUgPSBjYWxlbmRhci5nZXREYXlPZldlZWsoKTtcbiAgICAgIGN1cnJlbnQgPSBjb3VudCA+PSA0ID8gbG9jYWxlLndlZWtkYXlzW3ZhbHVlXSA6IGxvY2FsZS5zaG9ydFdlZWtkYXlzW3ZhbHVlXTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2EnOlxuICAgICAgY3VycmVudCA9IGxvY2FsZS5hbXBtc1tjYWxlbmRhci5nZXRIb3VyT2ZEYXkoKSA+PSAxMiA/IDEgOiAwXTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2gnOlxuICAgICAgY3VycmVudCA9IHplcm9QYWRkaW5nTnVtYmVyKGNhbGVuZGFyLmdldEhvdXJPZkRheSgpICUgMTIgfHwgMTIsIGNvdW50KTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ0snOlxuICAgICAgY3VycmVudCA9IHplcm9QYWRkaW5nTnVtYmVyKGNhbGVuZGFyLmdldEhvdXJPZkRheSgpICUgMTIsIGNvdW50KTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ1onOlxuICAgICAgdmFyIG9mZnNldCA9IGNhbGVuZGFyLmdldFRpbWV6b25lT2Zmc2V0KCk7XG4gICAgICB2YXIgcGFydHMgPSBbb2Zmc2V0IDwgMCA/ICctJyA6ICcrJ107XG4gICAgICBvZmZzZXQgPSBNYXRoLmFicyhvZmZzZXQpO1xuICAgICAgcGFydHMucHVzaCh6ZXJvUGFkZGluZ051bWJlcihNYXRoLmZsb29yKG9mZnNldCAvIDYwKSAlIDEwMCwgMiksIHplcm9QYWRkaW5nTnVtYmVyKG9mZnNldCAlIDYwLCAyKSk7XG4gICAgICBjdXJyZW50ID0gcGFydHMuam9pbignJyk7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgLy8gY2FzZSAnZCc6XG4gICAgICAvLyBjYXNlICdIJzpcbiAgICAgIC8vIGNhc2UgJ20nOlxuICAgICAgLy8gY2FzZSAncyc6XG4gICAgICAvLyBjYXNlICdTJzpcbiAgICAgIC8vIGNhc2UgJ0QnOlxuICAgICAgLy8gY2FzZSAnRic6XG4gICAgICAvLyBjYXNlICd3JzpcbiAgICAgIC8vIGNhc2UgJ1cnOlxuICAgICAgdmFyIGluZGV4ID0gY2FsZW5kYXJJbmRleE1hcFtmaWVsZF07XG4gICAgICB2YWx1ZSA9IGNhbGVuZGFyLmdldChpbmRleCk7XG4gICAgICBjdXJyZW50ID0gemVyb1BhZGRpbmdOdW1iZXIodmFsdWUsIGNvdW50KTtcbiAgfVxuICByZXR1cm4gY3VycmVudDtcbn1cblxuZnVuY3Rpb24gbWF0Y2hQYXJ0U3RyaW5nKGRhdGVTdHIsIHN0YXJ0SW5kZXgsIG1hdGNoLCBtTGVuKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbUxlbjsgaSsrKSB7XG4gICAgaWYgKGRhdGVTdHIuY2hhckF0KHN0YXJ0SW5kZXggKyBpKSAhPT0gbWF0Y2guY2hhckF0KGkpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBtYXRjaEZpZWxkKGRhdGVTdHIsIHN0YXJ0SW5kZXgsIG1hdGNoZXMpIHtcbiAgdmFyIG1hdGNoZWRMZW4gPSAtMTtcbiAgdmFyIGluZGV4ID0gLTE7XG4gIHZhciBpID0gdW5kZWZpbmVkO1xuICB2YXIgbGVuID0gbWF0Y2hlcy5sZW5ndGg7XG4gIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIHZhciBtID0gbWF0Y2hlc1tpXTtcbiAgICB2YXIgbUxlbiA9IG0ubGVuZ3RoO1xuICAgIGlmIChtTGVuID4gbWF0Y2hlZExlbiAmJiBtYXRjaFBhcnRTdHJpbmcoZGF0ZVN0ciwgc3RhcnRJbmRleCwgbSwgbUxlbikpIHtcbiAgICAgIG1hdGNoZWRMZW4gPSBtTGVuO1xuICAgICAgaW5kZXggPSBpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gaW5kZXggPj0gMCA/IHtcbiAgICB2YWx1ZTogaW5kZXgsXG4gICAgc3RhcnRJbmRleDogc3RhcnRJbmRleCArIG1hdGNoZWRMZW5cbiAgfSA6IG51bGw7XG59XG5cbmZ1bmN0aW9uIGdldExlYWRpbmdOdW1iZXJMZW4oc3RyKSB7XG4gIHZhciBpID0gdW5kZWZpbmVkO1xuICB2YXIgYyA9IHVuZGVmaW5lZDtcbiAgdmFyIGxlbiA9IHN0ci5sZW5ndGg7XG4gIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIGMgPSBzdHIuY2hhckF0KGkpO1xuICAgIGlmIChjIDwgJzAnIHx8IGMgPiAnOScpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gaTtcbn1cblxuZnVuY3Rpb24gbWF0Y2hOdW1iZXIoZGF0ZVN0ciwgc3RhcnRJbmRleCwgY291bnQsIG9iZXlDb3VudCkge1xuICB2YXIgc3RyID0gZGF0ZVN0cjtcbiAgdmFyIG4gPSB1bmRlZmluZWQ7XG4gIGlmIChvYmV5Q291bnQpIHtcbiAgICBpZiAoZGF0ZVN0ci5sZW5ndGggPCBzdGFydEluZGV4ICsgY291bnQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBzdHIgPSBkYXRlU3RyLnNsaWNlKHN0YXJ0SW5kZXgsIHN0YXJ0SW5kZXggKyBjb3VudCk7XG4gICAgaWYgKCFzdHIubWF0Y2goL15cXGQrJC8pKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0dyZWdvcmlhbkNhbGVuZGFyRm9ybWF0IHBhcnNlIGVycm9yLCBkYXRlU3RyOiAnICsgZGF0ZVN0ciArICcsIHBhdHRlcjogJyArIHRoaXMub3JpZ2luYWxQYXR0ZXJuKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgc3RyID0gc3RyLnNsaWNlKHN0YXJ0SW5kZXgpO1xuICB9XG4gIG4gPSBwYXJzZUludChzdHIsIDEwKTtcbiAgaWYgKGlzTmFOKG4pKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdHcmVnb3JpYW5DYWxlbmRhckZvcm1hdCBwYXJzZSBlcnJvciwgZGF0ZVN0cjogJyArIGRhdGVTdHIgKyAnLCBwYXR0ZXI6ICcgKyB0aGlzLm9yaWdpbmFsUGF0dGVybik7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB2YWx1ZTogbixcbiAgICBzdGFydEluZGV4OiBzdGFydEluZGV4ICsgZ2V0TGVhZGluZ051bWJlckxlbihzdHIpXG4gIH07XG59XG5cbmZ1bmN0aW9uIHBhcnNlRmllbGQoY2FsZW5kYXIsIGRhdGVTdHIsIHN0YXJ0SW5kZXhfLCBmaWVsZCwgY291bnQsIG9iZXlDb3VudCwgdG1wKSB7XG4gIHZhciBtYXRjaCA9IHVuZGVmaW5lZDtcbiAgdmFyIHllYXIgPSB1bmRlZmluZWQ7XG4gIHZhciBob3VyID0gdW5kZWZpbmVkO1xuICB2YXIgc3RhcnRJbmRleCA9IHN0YXJ0SW5kZXhfO1xuICBpZiAoZGF0ZVN0ci5sZW5ndGggPD0gc3RhcnRJbmRleCkge1xuICAgIHJldHVybiBzdGFydEluZGV4O1xuICB9XG4gIHZhciBsb2NhbGUgPSB0aGlzLmxvY2FsZTtcbiAgc3dpdGNoIChmaWVsZCkge1xuICAgIGNhc2UgJ0cnOlxuICAgICAgbWF0Y2ggPSBtYXRjaEZpZWxkKGRhdGVTdHIsIHN0YXJ0SW5kZXgsIGxvY2FsZS5lcmFzKTtcbiAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICBpZiAoY2FsZW5kYXIuaXNTZXRZZWFyKCkpIHtcbiAgICAgICAgICBpZiAobWF0Y2gudmFsdWUgPT09IDApIHtcbiAgICAgICAgICAgIHllYXIgPSBjYWxlbmRhci5nZXRZZWFyKCk7XG4gICAgICAgICAgICBjYWxlbmRhci5zZXRZZWFyKDEgLSB5ZWFyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdG1wLmVyYSA9IG1hdGNoLnZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlICd5JzpcbiAgICAgIG1hdGNoID0gbWF0Y2hOdW1iZXIuY2FsbCh0aGlzLCBkYXRlU3RyLCBzdGFydEluZGV4LCBjb3VudCwgb2JleUNvdW50KTtcbiAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICB5ZWFyID0gbWF0Y2gudmFsdWU7XG4gICAgICAgIGlmICgnZXJhJyBpbiB0bXApIHtcbiAgICAgICAgICBpZiAodG1wLmVyYSA9PT0gMCkge1xuICAgICAgICAgICAgeWVhciA9IDEgLSB5ZWFyO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYWxlbmRhci5zZXRZZWFyKHllYXIpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnTSc6XG4gICAgICB2YXIgbW9udGggPSB1bmRlZmluZWQ7XG4gICAgICBpZiAoY291bnQgPj0gMykge1xuICAgICAgICBtYXRjaCA9IG1hdGNoRmllbGQoZGF0ZVN0ciwgc3RhcnRJbmRleCwgbG9jYWxlW2NvdW50ID09PSAzID8gJ3Nob3J0TW9udGhzJyA6ICdtb250aHMnXSk7XG4gICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgIG1vbnRoID0gbWF0Y2gudmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1hdGNoID0gbWF0Y2hOdW1iZXIuY2FsbCh0aGlzLCBkYXRlU3RyLCBzdGFydEluZGV4LCBjb3VudCwgb2JleUNvdW50KTtcbiAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgbW9udGggPSBtYXRjaC52YWx1ZSAtIDE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICBjYWxlbmRhci5zZXRNb250aChtb250aCk7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlICdrJzpcbiAgICAgIG1hdGNoID0gbWF0Y2hOdW1iZXIuY2FsbCh0aGlzLCBkYXRlU3RyLCBzdGFydEluZGV4LCBjb3VudCwgb2JleUNvdW50KTtcbiAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICBjYWxlbmRhci5zZXRIb3VyT2ZEYXkobWF0Y2gudmFsdWUgJSAyNCk7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlICdFJzpcbiAgICAgIG1hdGNoID0gbWF0Y2hGaWVsZChkYXRlU3RyLCBzdGFydEluZGV4LCBsb2NhbGVbY291bnQgPiAzID8gJ3dlZWtkYXlzJyA6ICdzaG9ydFdlZWtkYXlzJ10pO1xuICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgIGNhbGVuZGFyLnNldERheU9mV2VlayhtYXRjaC52YWx1ZSk7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlICdhJzpcbiAgICAgIG1hdGNoID0gbWF0Y2hGaWVsZChkYXRlU3RyLCBzdGFydEluZGV4LCBsb2NhbGUuYW1wbXMpO1xuICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgIGlmIChjYWxlbmRhci5pc1NldEhvdXJPZkRheSgpKSB7XG4gICAgICAgICAgaWYgKG1hdGNoLnZhbHVlKSB7XG4gICAgICAgICAgICBob3VyID0gY2FsZW5kYXIuZ2V0SG91ck9mRGF5KCk7XG4gICAgICAgICAgICBpZiAoaG91ciA8IDEyKSB7XG4gICAgICAgICAgICAgIGNhbGVuZGFyLnNldEhvdXJPZkRheSgoaG91ciArIDEyKSAlIDI0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdG1wLmFtcG0gPSBtYXRjaC52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnaCc6XG4gICAgICBtYXRjaCA9IG1hdGNoTnVtYmVyLmNhbGwodGhpcywgZGF0ZVN0ciwgc3RhcnRJbmRleCwgY291bnQsIG9iZXlDb3VudCk7XG4gICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgaG91ciA9IG1hdGNoLnZhbHVlICU9IDEyO1xuICAgICAgICBpZiAodG1wLmFtcG0pIHtcbiAgICAgICAgICBob3VyICs9IDEyO1xuICAgICAgICB9XG4gICAgICAgIGNhbGVuZGFyLnNldEhvdXJPZkRheShob3VyKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ0snOlxuICAgICAgbWF0Y2ggPSBtYXRjaE51bWJlci5jYWxsKHRoaXMsIGRhdGVTdHIsIHN0YXJ0SW5kZXgsIGNvdW50LCBvYmV5Q291bnQpO1xuICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgIGhvdXIgPSBtYXRjaC52YWx1ZTtcbiAgICAgICAgaWYgKHRtcC5hbXBtKSB7XG4gICAgICAgICAgaG91ciArPSAxMjtcbiAgICAgICAgfVxuICAgICAgICBjYWxlbmRhci5zZXRIb3VyT2ZEYXkoaG91cik7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlICdaJzpcbiAgICAgIC8vIGxldCBzaWduID0gMTtcbiAgICAgIHZhciB6b25lQ2hhciA9IGRhdGVTdHIuY2hhckF0KHN0YXJ0SW5kZXgpO1xuICAgICAgaWYgKHpvbmVDaGFyID09PSAnLScpIHtcbiAgICAgICAgLy8gc2lnbiA9IC0xO1xuICAgICAgICBzdGFydEluZGV4Kys7XG4gICAgICB9IGVsc2UgaWYgKHpvbmVDaGFyID09PSAnKycpIHtcbiAgICAgICAgc3RhcnRJbmRleCsrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBtYXRjaCA9IG1hdGNoTnVtYmVyLmNhbGwodGhpcywgZGF0ZVN0ciwgc3RhcnRJbmRleCwgMiwgdHJ1ZSk7XG4gICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgdmFyIHpvbmVPZmZzZXQgPSBtYXRjaC52YWx1ZSAqIDYwO1xuICAgICAgICBzdGFydEluZGV4ID0gbWF0Y2guc3RhcnRJbmRleDtcbiAgICAgICAgbWF0Y2ggPSBtYXRjaE51bWJlci5jYWxsKHRoaXMsIGRhdGVTdHIsIHN0YXJ0SW5kZXgsIDIsIHRydWUpO1xuICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICB6b25lT2Zmc2V0ICs9IG1hdGNoLnZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGNhbGVuZGFyLnNldFRpbWV6b25lT2Zmc2V0KHpvbmVPZmZzZXQpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIC8vIGNhc2UgJ2QnOlxuICAgICAgLy8gY2FzZSAnSCc6XG4gICAgICAvLyBjYXNlICdtJzpcbiAgICAgIC8vIGNhc2UgJ3MnOlxuICAgICAgLy8gY2FzZSAnUyc6XG4gICAgICAvLyBjYXNlICdEJzpcbiAgICAgIC8vIGNhc2UgJ0YnOlxuICAgICAgLy8gY2FzZSAndyc6XG4gICAgICAvLyBjYXNlICdXJ1xuICAgICAgbWF0Y2ggPSBtYXRjaE51bWJlci5jYWxsKHRoaXMsIGRhdGVTdHIsIHN0YXJ0SW5kZXgsIGNvdW50LCBvYmV5Q291bnQpO1xuICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgIHZhciBpbmRleCA9IGNhbGVuZGFySW5kZXhNYXBbZmllbGRdO1xuICAgICAgICBjYWxlbmRhci5zZXQoaW5kZXgsIG1hdGNoLnZhbHVlKTtcbiAgICAgIH1cbiAgfVxuICBpZiAobWF0Y2gpIHtcbiAgICBzdGFydEluZGV4ID0gbWF0Y2guc3RhcnRJbmRleDtcbiAgfVxuICByZXR1cm4gc3RhcnRJbmRleDtcbn1cblxubWl4KERhdGVUaW1lRm9ybWF0LnByb3RvdHlwZSwge1xuICAvKlxuICAgKiBmb3JtYXQgYSBHcmVnb3JpYW5EYXRlIGluc3RhbmNlIGFjY29yZGluZyB0byBzcGVjaWZpZWQgcGF0dGVyblxuICAgKiBAcGFyYW0ge0dyZWdvcmlhbkNhbGVuZGFyfSBjYWxlbmRhciBHcmVnb3JpYW5EYXRlIGluc3RhbmNlXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IGZvcm1hdHRlZCBzdHJpbmcgb2YgR3JlZ29yaWFuRGF0ZSBpbnN0YW5jZVxuICAgKi9cbiAgZm9ybWF0OiBmdW5jdGlvbiBmb3JtYXQoY2FsZW5kYXIpIHtcbiAgICBpZiAoIWNhbGVuZGFyLmlzR3JlZ29yaWFuQ2FsZW5kYXIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignY2FsZW5kYXIgbXVzdCBiZSB0eXBlIG9mIEdyZWdvcmlhbkNhbGVuZGFyJyk7XG4gICAgfVxuICAgIHZhciBpID0gdW5kZWZpbmVkO1xuICAgIHZhciByZXQgPSBbXTtcbiAgICB2YXIgcGF0dGVybiA9IHRoaXMucGF0dGVybjtcbiAgICB2YXIgbGVuID0gcGF0dGVybi5sZW5ndGg7XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICB2YXIgY29tcCA9IHBhdHRlcm5baV07XG4gICAgICBpZiAoY29tcC50ZXh0KSB7XG4gICAgICAgIHJldC5wdXNoKGNvbXAudGV4dCk7XG4gICAgICB9IGVsc2UgaWYgKCdmaWVsZCcgaW4gY29tcCkge1xuICAgICAgICByZXQucHVzaChmb3JtYXRGaWVsZChjb21wLmZpZWxkLCBjb21wLmNvdW50LCB0aGlzLmxvY2FsZSwgY2FsZW5kYXIpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJldC5qb2luKCcnKTtcbiAgfSxcblxuICAvKlxuICAgKiBwYXJzZSBhIGZvcm1hdHRlZCBzdHJpbmcgb2YgR3JlZ29yaWFuRGF0ZSBpbnN0YW5jZSBhY2NvcmRpbmcgdG8gc3BlY2lmaWVkIHBhdHRlcm5cbiAgICogQHBhcmFtIHtTdHJpbmd9IGRhdGVTdHIgZm9ybWF0dGVkIHN0cmluZyBvZiBHcmVnb3JpYW5EYXRlXG4gICAqIEByZXR1cm5zIHtHcmVnb3JpYW5DYWxlbmRhcn1cbiAgICovXG4gIHBhcnNlOiBmdW5jdGlvbiBwYXJzZShkYXRlU3RyLCBvcHRpb25fKSB7XG4gICAgdmFyIG9wdGlvbiA9IG9wdGlvbl8gfHwge307XG4gICAgdmFyIGNhbGVuZGFyTG9jYWxlID0gb3B0aW9uLmxvY2FsZTtcbiAgICB2YXIgY2FsZW5kYXIgPSBuZXcgR3JlZ29yaWFuQ2FsZW5kYXIoY2FsZW5kYXJMb2NhbGUpO1xuICAgIHZhciBpID0gdW5kZWZpbmVkO1xuICAgIHZhciBqID0gdW5kZWZpbmVkO1xuICAgIHZhciB0bXAgPSB7fTtcbiAgICB2YXIgb2JleUNvdW50ID0gb3B0aW9uLm9iZXlDb3VudCB8fCBmYWxzZTtcbiAgICB2YXIgZGF0ZVN0ckxlbiA9IGRhdGVTdHIubGVuZ3RoO1xuICAgIHZhciBlcnJvckluZGV4ID0gLTE7XG4gICAgdmFyIHN0YXJ0SW5kZXggPSAwO1xuICAgIHZhciBvbGRTdGFydEluZGV4ID0gMDtcbiAgICB2YXIgcGF0dGVybiA9IHRoaXMucGF0dGVybjtcbiAgICB2YXIgbGVuID0gcGF0dGVybi5sZW5ndGg7XG4gICAgLyogZXNsaW50IG5vLWxhYmVsczogMCBuby1lbXB0eS1sYWJlbDowICovXG4gICAgbG9vcFBhdHRlcm46IHtcbiAgICAgIGZvciAoaSA9IDA7IGVycm9ySW5kZXggPCAwICYmIGkgPCBsZW47IGkrKykge1xuICAgICAgICB2YXIgY29tcCA9IHBhdHRlcm5baV07XG4gICAgICAgIHZhciB0ZXh0ID0gdW5kZWZpbmVkO1xuICAgICAgICB2YXIgdGV4dExlbiA9IHVuZGVmaW5lZDtcbiAgICAgICAgb2xkU3RhcnRJbmRleCA9IHN0YXJ0SW5kZXg7XG4gICAgICAgIHRleHQgPSBjb21wLnRleHQ7XG4gICAgICAgIGlmICh0ZXh0KSB7XG4gICAgICAgICAgdGV4dExlbiA9IHRleHQubGVuZ3RoO1xuICAgICAgICAgIGlmICh0ZXh0TGVuICsgc3RhcnRJbmRleCA+IGRhdGVTdHJMZW4pIHtcbiAgICAgICAgICAgIGVycm9ySW5kZXggPSBzdGFydEluZGV4O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgdGV4dExlbjsgaisrKSB7XG4gICAgICAgICAgICAgIGlmICh0ZXh0LmNoYXJBdChqKSAhPT0gZGF0ZVN0ci5jaGFyQXQoaiArIHN0YXJ0SW5kZXgpKSB7XG4gICAgICAgICAgICAgICAgZXJyb3JJbmRleCA9IHN0YXJ0SW5kZXg7XG4gICAgICAgICAgICAgICAgYnJlYWsgbG9vcFBhdHRlcm47XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0YXJ0SW5kZXggKz0gdGV4dExlbjtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoJ2ZpZWxkJyBpbiBjb21wKSB7XG4gICAgICAgICAgaWYgKCFvcHRpb24ub2JleUNvdW50KSB7XG4gICAgICAgICAgICB2YXIgbmV4dENvbXAgPSBwYXR0ZXJuW2kgKyAxXTtcbiAgICAgICAgICAgIG9iZXlDb3VudCA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKG5leHRDb21wKSB7XG4gICAgICAgICAgICAgIGlmICgnZmllbGQnIGluIG5leHRDb21wKSB7XG4gICAgICAgICAgICAgICAgb2JleUNvdW50ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgYyA9IG5leHRDb21wLnRleHQuY2hhckF0KDApO1xuICAgICAgICAgICAgICAgIGlmIChjID49ICcwJyAmJiBjIDw9ICc5Jykge1xuICAgICAgICAgICAgICAgICAgb2JleUNvdW50ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgc3RhcnRJbmRleCA9IHBhcnNlRmllbGQuY2FsbCh0aGlzLCBjYWxlbmRhciwgZGF0ZVN0ciwgc3RhcnRJbmRleCwgY29tcC5maWVsZCwgY29tcC5jb3VudCwgb2JleUNvdW50LCB0bXApO1xuICAgICAgICAgIGlmIChzdGFydEluZGV4ID09PSBvbGRTdGFydEluZGV4KSB7XG4gICAgICAgICAgICBlcnJvckluZGV4ID0gc3RhcnRJbmRleDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZXJyb3JJbmRleCA+PSAwKSB7XG4gICAgICB3YXJuaW5nKGZhbHNlLCAnZXJyb3Igd2hlbiBwYXJzaW5nIGRhdGU6ICcgKyBkYXRlU3RyICsgJywgcG9zaXRpb246ICcgKyBkYXRlU3RyLnNsaWNlKDAsIGVycm9ySW5kZXgpICsgJ14nKTtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHJldHVybiBjYWxlbmRhcjtcbiAgfVxufSk7XG5cbm1peChEYXRlVGltZUZvcm1hdCwge1xuICBTdHlsZTogRGF0ZVRpbWVTdHlsZSxcblxuICAvKlxuICAgKiBnZXQgYSBmb3JtYXR0ZXIgaW5zdGFuY2Ugb2Ygc2hvcnQgc3R5bGUgcGF0dGVybi5cbiAgICogZW4tdXM6IE0vZC95eSBoOm1tIGFcbiAgICogemgtY246IHl5LU0tZCBhaDptbVxuICAgKiBAcGFyYW0ge09iamVjdH0gbG9jYWxlIGxvY2FsZSBvYmplY3RcbiAgICogQHJldHVybnMge0dyZWdvcmlhbkNhbGVuZGFyfVxuICAgKiBAc3RhdGljXG4gICAqL1xuICBnZXRJbnN0YW5jZTogZnVuY3Rpb24gZ2V0SW5zdGFuY2UobG9jYWxlKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0RGF0ZVRpbWVJbnN0YW5jZShEYXRlVGltZVN0eWxlLlNIT1JULCBEYXRlVGltZVN0eWxlLlNIT1JULCBsb2NhbGUpO1xuICB9LFxuXG4gIC8qXG4gICAqIGdldCBhIGZvcm1hdHRlciBpbnN0YW5jZSBvZiBzcGVjaWZpZWQgZGF0ZSBzdHlsZS5cbiAgICogQHBhcmFtIHtEYXRlLkZvcm1hdHRlci5TdHlsZX0gZGF0ZVN0eWxlIGRhdGUgZm9ybWF0IHN0eWxlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBsb2NhbGVcbiAgICogQHJldHVybnMge0dyZWdvcmlhbkNhbGVuZGFyfVxuICAgKiBAc3RhdGljXG4gICAqL1xuICBnZXREYXRlSW5zdGFuY2U6IGZ1bmN0aW9uIGdldERhdGVJbnN0YW5jZShkYXRlU3R5bGUsIGxvY2FsZSkge1xuICAgIHJldHVybiB0aGlzLmdldERhdGVUaW1lSW5zdGFuY2UoZGF0ZVN0eWxlLCB1bmRlZmluZWQsIGxvY2FsZSk7XG4gIH0sXG5cbiAgLypcbiAgICogZ2V0IGEgZm9ybWF0dGVyIGluc3RhbmNlIG9mIHNwZWNpZmllZCBkYXRlIHN0eWxlIGFuZCB0aW1lIHN0eWxlLlxuICAgKiBAcGFyYW0ge0RhdGUuRm9ybWF0dGVyLlN0eWxlfSBkYXRlU3R5bGUgZGF0ZSBmb3JtYXQgc3R5bGVcbiAgICogQHBhcmFtIHtEYXRlLkZvcm1hdHRlci5TdHlsZX0gdGltZVN0eWxlIHRpbWUgZm9ybWF0IHN0eWxlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBsb2NhbGVcbiAgICogQHJldHVybnMge0dyZWdvcmlhbkNhbGVuZGFyfVxuICAgKiBAc3RhdGljXG4gICAqL1xuICBnZXREYXRlVGltZUluc3RhbmNlOiBmdW5jdGlvbiBnZXREYXRlVGltZUluc3RhbmNlKGRhdGVTdHlsZSwgdGltZVN0eWxlLCBsb2NhbGVfKSB7XG4gICAgdmFyIGxvY2FsZSA9IGxvY2FsZV8gfHwgZW5Vc0xvY2FsZTtcbiAgICB2YXIgZGF0ZVBhdHRlcm4gPSAnJztcbiAgICBpZiAoZGF0ZVN0eWxlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGRhdGVQYXR0ZXJuID0gbG9jYWxlLmRhdGVQYXR0ZXJuc1tkYXRlU3R5bGVdO1xuICAgIH1cbiAgICB2YXIgdGltZVBhdHRlcm4gPSAnJztcbiAgICBpZiAodGltZVN0eWxlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRpbWVQYXR0ZXJuID0gbG9jYWxlLnRpbWVQYXR0ZXJuc1t0aW1lU3R5bGVdO1xuICAgIH1cbiAgICB2YXIgcGF0dGVybiA9IGRhdGVQYXR0ZXJuO1xuICAgIGlmICh0aW1lUGF0dGVybikge1xuICAgICAgaWYgKGRhdGVQYXR0ZXJuKSB7XG4gICAgICAgIHBhdHRlcm4gPSBzdWJzdGl0dXRlKGxvY2FsZS5kYXRlVGltZVBhdHRlcm4sIHtcbiAgICAgICAgICBkYXRlOiBkYXRlUGF0dGVybixcbiAgICAgICAgICB0aW1lOiB0aW1lUGF0dGVyblxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhdHRlcm4gPSB0aW1lUGF0dGVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5ldyBEYXRlVGltZUZvcm1hdChwYXR0ZXJuLCBsb2NhbGUpO1xuICB9LFxuXG4gIC8qXG4gICAqIGdldCBhIGZvcm1hdHRlciBpbnN0YW5jZSBvZiBzcGVjaWZpZWQgdGltZSBzdHlsZS5cbiAgICogQHBhcmFtIHtEYXRlLkZvcm1hdHRlci5TdHlsZX0gdGltZVN0eWxlIHRpbWUgZm9ybWF0IHN0eWxlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBsb2NhbGVcbiAgICogQHJldHVybnMge0dyZWdvcmlhbkNhbGVuZGFyfVxuICAgKiBAc3RhdGljXG4gICAqL1xuICBnZXRUaW1lSW5zdGFuY2U6IGZ1bmN0aW9uIGdldFRpbWVJbnN0YW5jZSh0aW1lU3R5bGUsIGxvY2FsZSkge1xuICAgIHJldHVybiB0aGlzLmdldERhdGVUaW1lSW5zdGFuY2UodW5kZWZpbmVkLCB0aW1lU3R5bGUsIGxvY2FsZSk7XG4gIH1cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IERhdGVUaW1lRm9ybWF0O1xuXG5EYXRlVGltZUZvcm1hdC52ZXJzaW9uID0gJ0BWRVJTSU9OQCc7XG5cbi8vIGdjX2Zvcm1hdEAxNjMuY29tXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vdXhjb3JlLWZvcm0vfi91eGNvcmUtZGF0ZS1mb3JtLWZpZWxkL34vdXhjb3JlLWNhbGVuZGFyL34vZ3JlZ29yaWFuLWNhbGVuZGFyLWZvcm1hdC9saWIvZ3JlZ29yaWFuLWNhbGVuZGFyLWZvcm1hdC5qc1xuICoqIG1vZHVsZSBpZCA9IDQwOVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZXJhczogWydCQycsICdBRCddLFxuICBtb250aHM6IFsnSmFudWFyeScsICdGZWJydWFyeScsICdNYXJjaCcsICdBcHJpbCcsICdNYXknLCAnSnVuZScsICdKdWx5JywgJ0F1Z3VzdCcsICdTZXB0ZW1iZXInLCAnT2N0b2JlcicsICdOb3ZlbWJlcicsICdEZWNlbWJlciddLFxuICBzaG9ydE1vbnRoczogWydKYW4nLCAnRmViJywgJ01hcicsICdBcHInLCAnTWF5JywgJ0p1bicsICdKdWwnLCAnQXVnJywgJ1NlcCcsICdPY3QnLCAnTm92JywgJ0RlYyddLFxuICB3ZWVrZGF5czogWydTdW5kYXknLCAnTW9uZGF5JywgJ1R1ZXNkYXknLCAnV2VkbmVzZGF5JywgJ1RodXJzZGF5JywgJ0ZyaWRheScsICdTYXR1cmRheSddLFxuICBzaG9ydFdlZWtkYXlzOiBbJ1N1bicsICdNb24nLCAnVHVlJywgJ1dlZCcsICdUaHUnLCAnRnJpJywgJ1NhdCddLFxuICB2ZXJ5U2hvcnRXZWVrZGF5czogWydTdScsICdNbycsICdUdScsICdXZScsICdUaCcsICdGcicsICdTYSddLFxuICBhbXBtczogWydBTScsICdQTSddLFxuICBkYXRlUGF0dGVybnM6IFsnRUVFRSwgTU1NTSBkLCB5eXl5JywgJ01NTU0gZCwgeXl5eScsICdNTU0gZCwgeXl5eScsICdNL2QveXknXSxcbiAgdGltZVBhdHRlcm5zOiBbJ2g6bW06c3MgYSBcXCdHTVRcXCdaJywgJ2g6bW06c3MgYScsICdoOm1tOnNzIGEnLCAnaDptbSBhJ10sXG4gIGRhdGVUaW1lUGF0dGVybjogJ3tkYXRlfSB7dGltZX0nXG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3V4Y29yZS1mb3JtL34vdXhjb3JlLWRhdGUtZm9ybS1maWVsZC9+L3V4Y29yZS1jYWxlbmRhci9+L2dyZWdvcmlhbi1jYWxlbmRhci1mb3JtYXQvbGliL2xvY2FsZS9lbl9VUy5qc1xuICoqIG1vZHVsZSBpZCA9IDQxMFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNC0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIFNpbWlsYXIgdG8gaW52YXJpYW50IGJ1dCBvbmx5IGxvZ3MgYSB3YXJuaW5nIGlmIHRoZSBjb25kaXRpb24gaXMgbm90IG1ldC5cbiAqIFRoaXMgY2FuIGJlIHVzZWQgdG8gbG9nIGlzc3VlcyBpbiBkZXZlbG9wbWVudCBlbnZpcm9ubWVudHMgaW4gY3JpdGljYWxcbiAqIHBhdGhzLiBSZW1vdmluZyB0aGUgbG9nZ2luZyBjb2RlIGZvciBwcm9kdWN0aW9uIGVudmlyb25tZW50cyB3aWxsIGtlZXAgdGhlXG4gKiBzYW1lIGxvZ2ljIGFuZCBmb2xsb3cgdGhlIHNhbWUgY29kZSBwYXRocy5cbiAqL1xuXG52YXIgd2FybmluZyA9IGZ1bmN0aW9uKCkge307XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHdhcm5pbmcgPSBmdW5jdGlvbihjb25kaXRpb24sIGZvcm1hdCwgYXJncykge1xuICAgIHZhciBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIGFyZ3MgPSBuZXcgQXJyYXkobGVuID4gMiA/IGxlbiAtIDIgOiAwKTtcbiAgICBmb3IgKHZhciBrZXkgPSAyOyBrZXkgPCBsZW47IGtleSsrKSB7XG4gICAgICBhcmdzW2tleSAtIDJdID0gYXJndW1lbnRzW2tleV07XG4gICAgfVxuICAgIGlmIChmb3JtYXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnYHdhcm5pbmcoY29uZGl0aW9uLCBmb3JtYXQsIC4uLmFyZ3MpYCByZXF1aXJlcyBhIHdhcm5pbmcgJyArXG4gICAgICAgICdtZXNzYWdlIGFyZ3VtZW50J1xuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAoZm9ybWF0Lmxlbmd0aCA8IDEwIHx8ICgvXltzXFxXXSokLykudGVzdChmb3JtYXQpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdUaGUgd2FybmluZyBmb3JtYXQgc2hvdWxkIGJlIGFibGUgdG8gdW5pcXVlbHkgaWRlbnRpZnkgdGhpcyAnICtcbiAgICAgICAgJ3dhcm5pbmcuIFBsZWFzZSwgdXNlIGEgbW9yZSBkZXNjcmlwdGl2ZSBmb3JtYXQgdGhhbjogJyArIGZvcm1hdFxuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAoIWNvbmRpdGlvbikge1xuICAgICAgdmFyIGFyZ0luZGV4ID0gMDtcbiAgICAgIHZhciBtZXNzYWdlID0gJ1dhcm5pbmc6ICcgK1xuICAgICAgICBmb3JtYXQucmVwbGFjZSgvJXMvZywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIGFyZ3NbYXJnSW5kZXgrK107XG4gICAgICAgIH0pO1xuICAgICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBjb25zb2xlLmVycm9yKG1lc3NhZ2UpO1xuICAgICAgfVxuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gVGhpcyBlcnJvciB3YXMgdGhyb3duIGFzIGEgY29udmVuaWVuY2Ugc28gdGhhdCB5b3UgY2FuIHVzZSB0aGlzIHN0YWNrXG4gICAgICAgIC8vIHRvIGZpbmQgdGhlIGNhbGxzaXRlIHRoYXQgY2F1c2VkIHRoaXMgd2FybmluZyB0byBmaXJlLlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgICB9IGNhdGNoKHgpIHt9XG4gICAgfVxuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHdhcm5pbmc7XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi91eGNvcmUtZm9ybS9+L3V4Y29yZS1kYXRlLWZvcm0tZmllbGQvfi91eGNvcmUtY2FsZW5kYXIvfi9ncmVnb3JpYW4tY2FsZW5kYXItZm9ybWF0L34vd2FybmluZy9icm93c2VyLmpzXG4gKiogbW9kdWxlIGlkID0gNDExXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfcmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xuXG52YXIgX3JlYWN0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JlYWN0KTtcblxudmFyIF9Nb250aFBhbmVsID0gcmVxdWlyZSgnLi4vbW9udGgvTW9udGhQYW5lbCcpO1xuXG52YXIgX01vbnRoUGFuZWwyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfTW9udGhQYW5lbCk7XG5cbnZhciBfaW5kZXggPSByZXF1aXJlKCcuLi91dGlsL2luZGV4Jyk7XG5cbnZhciBfWWVhclBhbmVsID0gcmVxdWlyZSgnLi4veWVhci9ZZWFyUGFuZWwnKTtcblxudmFyIF9ZZWFyUGFuZWwyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfWWVhclBhbmVsKTtcblxudmFyIF9yY1V0aWwgPSByZXF1aXJlKCdyYy11dGlsJyk7XG5cbnZhciBfcmNVdGlsMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JjVXRpbCk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IFwiZGVmYXVsdFwiOiBvYmogfTsgfVxuXG52YXIgdG9GcmFnbWVudCA9IF9yY1V0aWwyW1wiZGVmYXVsdFwiXS5DaGlsZHJlbi5tYXBTZWxmO1xuXG5mdW5jdGlvbiBnb01vbnRoKGRpcmVjdGlvbikge1xuICB2YXIgbmV4dCA9IHRoaXMucHJvcHMudmFsdWUuY2xvbmUoKTtcbiAgbmV4dC5hZGRNb250aChkaXJlY3Rpb24pO1xuICB0aGlzLnByb3BzLm9uVmFsdWVDaGFuZ2UobmV4dCk7XG59XG5cbmZ1bmN0aW9uIGdvWWVhcihkaXJlY3Rpb24pIHtcbiAgdmFyIG5leHQgPSB0aGlzLnByb3BzLnZhbHVlLmNsb25lKCk7XG4gIG5leHQuYWRkWWVhcihkaXJlY3Rpb24pO1xuICB0aGlzLnByb3BzLm9uVmFsdWVDaGFuZ2UobmV4dCk7XG59XG5cbnZhciBDYWxlbmRhckhlYWRlciA9IF9yZWFjdDJbXCJkZWZhdWx0XCJdLmNyZWF0ZUNsYXNzKHtcbiAgZGlzcGxheU5hbWU6ICdDYWxlbmRhckhlYWRlcicsXG5cbiAgcHJvcFR5cGVzOiB7XG4gICAgZW5hYmxlUHJldjogX3JlYWN0LlByb3BUeXBlcy5hbnksXG4gICAgZW5hYmxlTmV4dDogX3JlYWN0LlByb3BUeXBlcy5hbnksXG4gICAgcHJlZml4Q2xzOiBfcmVhY3QuUHJvcFR5cGVzLnN0cmluZyxcbiAgICBsb2NhbGU6IF9yZWFjdC5Qcm9wVHlwZXMub2JqZWN0LFxuICAgIHZhbHVlOiBfcmVhY3QuUHJvcFR5cGVzLm9iamVjdCxcbiAgICBvblZhbHVlQ2hhbmdlOiBfcmVhY3QuUHJvcFR5cGVzLmZ1bmNcbiAgfSxcblxuICBnZXREZWZhdWx0UHJvcHM6IGZ1bmN0aW9uIGdldERlZmF1bHRQcm9wcygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZW5hYmxlTmV4dDogMSxcbiAgICAgIGVuYWJsZVByZXY6IDFcbiAgICB9O1xuICB9LFxuICBnZXRJbml0aWFsU3RhdGU6IGZ1bmN0aW9uIGdldEluaXRpYWxTdGF0ZSgpIHtcbiAgICB2YXIgcHJvcHMgPSB0aGlzLnByb3BzO1xuICAgIHRoaXMueWVhckZvcm1hdHRlciA9ICgwLCBfaW5kZXguZ2V0Rm9ybWF0dGVyKShwcm9wcy5sb2NhbGUueWVhckZvcm1hdCwgcHJvcHMubG9jYWxlKTtcbiAgICB0aGlzLm1vbnRoRm9ybWF0dGVyID0gKDAsIF9pbmRleC5nZXRGb3JtYXR0ZXIpKHByb3BzLmxvY2FsZS5tb250aEZvcm1hdCwgcHJvcHMubG9jYWxlKTtcbiAgICB0aGlzLm5leHRNb250aCA9IGdvTW9udGguYmluZCh0aGlzLCAxKTtcbiAgICB0aGlzLnByZXZpb3VzTW9udGggPSBnb01vbnRoLmJpbmQodGhpcywgLTEpO1xuICAgIHRoaXMubmV4dFllYXIgPSBnb1llYXIuYmluZCh0aGlzLCAxKTtcbiAgICB0aGlzLnByZXZpb3VzWWVhciA9IGdvWWVhci5iaW5kKHRoaXMsIC0xKTtcbiAgICByZXR1cm4ge307XG4gIH0sXG4gIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHM6IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMobmV4dFByb3BzKSB7XG4gICAgdmFyIGxvY2FsZSA9IHRoaXMucHJvcHMubG9jYWxlO1xuICAgIHZhciBuZXh0TG9jYWxlID0gbmV4dFByb3BzLmxvY2FsZTtcblxuICAgIGlmIChuZXh0TG9jYWxlICE9PSBsb2NhbGUpIHtcbiAgICAgIHRoaXMueWVhckZvcm1hdHRlciA9ICgwLCBfaW5kZXguZ2V0Rm9ybWF0dGVyKShuZXh0TG9jYWxlLnllYXJGb3JtYXQsIG5leHRMb2NhbGUpO1xuICAgICAgdGhpcy5tb250aEZvcm1hdHRlciA9ICgwLCBfaW5kZXguZ2V0Rm9ybWF0dGVyKShuZXh0TG9jYWxlLm1vbnRoRm9ybWF0LCBuZXh0TG9jYWxlKTtcbiAgICB9XG4gIH0sXG4gIG9uU2VsZWN0OiBmdW5jdGlvbiBvblNlbGVjdCh2YWx1ZSkge1xuICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgc2hvd01vbnRoUGFuZWw6IDAsXG4gICAgICBzaG93WWVhclBhbmVsOiAwXG4gICAgfSk7XG4gICAgdGhpcy5wcm9wcy5vblZhbHVlQ2hhbmdlKHZhbHVlKTtcbiAgfSxcbiAgZ2V0TW9udGhZZWFyRWxlbWVudDogZnVuY3Rpb24gZ2V0TW9udGhZZWFyRWxlbWVudCgpIHtcbiAgICB2YXIgcHJvcHMgPSB0aGlzLnByb3BzO1xuICAgIHZhciBwcmVmaXhDbHMgPSBwcm9wcy5wcmVmaXhDbHM7XG4gICAgdmFyIGxvY2FsZSA9IHByb3BzLmxvY2FsZTtcbiAgICB2YXIgdmFsdWUgPSB0aGlzLnByb3BzLnZhbHVlO1xuICAgIHZhciBtb250aEJlZm9yZVllYXIgPSBsb2NhbGUubW9udGhCZWZvcmVZZWFyO1xuICAgIHZhciBzZWxlY3RDbGFzc05hbWUgPSBwcmVmaXhDbHMgKyAnLScgKyAobW9udGhCZWZvcmVZZWFyID8gJ215LXNlbGVjdCcgOiAneW0tc2VsZWN0Jyk7XG4gICAgdmFyIHllYXIgPSBfcmVhY3QyW1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFxuICAgICAgJ2EnLFxuICAgICAge1xuICAgICAgICBjbGFzc05hbWU6IHByZWZpeENscyArICcteWVhci1zZWxlY3QnLFxuICAgICAgICByb2xlOiAnYnV0dG9uJyxcbiAgICAgICAgb25DbGljazogdGhpcy5zaG93WWVhclBhbmVsLFxuICAgICAgICB0aXRsZTogbG9jYWxlLm1vbnRoU2VsZWN0XG4gICAgICB9LFxuICAgICAgdGhpcy55ZWFyRm9ybWF0dGVyLmZvcm1hdCh2YWx1ZSlcbiAgICApO1xuICAgIHZhciBtb250aCA9IF9yZWFjdDJbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXG4gICAgICAnYScsXG4gICAgICB7XG4gICAgICAgIGNsYXNzTmFtZTogcHJlZml4Q2xzICsgJy1tb250aC1zZWxlY3QnLFxuICAgICAgICByb2xlOiAnYnV0dG9uJyxcbiAgICAgICAgb25DbGljazogdGhpcy5zaG93TW9udGhQYW5lbCxcbiAgICAgICAgdGl0bGU6IGxvY2FsZS5tb250aFNlbGVjdFxuICAgICAgfSxcbiAgICAgIHRoaXMubW9udGhGb3JtYXR0ZXIuZm9ybWF0KHZhbHVlKVxuICAgICk7XG4gICAgdmFyIG15ID0gW107XG4gICAgaWYgKG1vbnRoQmVmb3JlWWVhcikge1xuICAgICAgbXkgPSBbbW9udGgsIHllYXJdO1xuICAgIH0gZWxzZSB7XG4gICAgICBteSA9IFt5ZWFyLCBtb250aF07XG4gICAgfVxuICAgIHJldHVybiBfcmVhY3QyW1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFxuICAgICAgJ3NwYW4nLFxuICAgICAgeyBjbGFzc05hbWU6IHNlbGVjdENsYXNzTmFtZSB9LFxuICAgICAgdG9GcmFnbWVudChteSlcbiAgICApO1xuICB9LFxuICBzaG93SWY6IGZ1bmN0aW9uIHNob3dJZihjb25kaXRpb24sIGVsKSB7XG4gICAgcmV0dXJuIGNvbmRpdGlvbiA/IGVsIDogbnVsbDtcbiAgfSxcbiAgc2hvd01vbnRoUGFuZWw6IGZ1bmN0aW9uIHNob3dNb250aFBhbmVsKCkge1xuICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgc2hvd01vbnRoUGFuZWw6IDEsXG4gICAgICBzaG93WWVhclBhbmVsOiAwXG4gICAgfSk7XG4gIH0sXG4gIHNob3dZZWFyUGFuZWw6IGZ1bmN0aW9uIHNob3dZZWFyUGFuZWwoKSB7XG4gICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICBzaG93TW9udGhQYW5lbDogMCxcbiAgICAgIHNob3dZZWFyUGFuZWw6IDFcbiAgICB9KTtcbiAgfSxcbiAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgdmFyIHByb3BzID0gdGhpcy5wcm9wcztcbiAgICB2YXIgZW5hYmxlTmV4dCA9IHByb3BzLmVuYWJsZU5leHQ7XG4gICAgdmFyIGVuYWJsZVByZXYgPSBwcm9wcy5lbmFibGVQcmV2O1xuICAgIHZhciBwcmVmaXhDbHMgPSBwcm9wcy5wcmVmaXhDbHM7XG4gICAgdmFyIGxvY2FsZSA9IHByb3BzLmxvY2FsZTtcbiAgICB2YXIgdmFsdWUgPSBwcm9wcy52YWx1ZTtcblxuICAgIHZhciBzdGF0ZSA9IHRoaXMuc3RhdGU7XG4gICAgdmFyIFBhbmVsQ2xhc3MgPSBudWxsO1xuICAgIGlmIChzdGF0ZS5zaG93TW9udGhQYW5lbCkge1xuICAgICAgUGFuZWxDbGFzcyA9IF9Nb250aFBhbmVsMltcImRlZmF1bHRcIl07XG4gICAgfSBlbHNlIGlmIChzdGF0ZS5zaG93WWVhclBhbmVsKSB7XG4gICAgICBQYW5lbENsYXNzID0gX1llYXJQYW5lbDJbXCJkZWZhdWx0XCJdO1xuICAgIH1cbiAgICB2YXIgcGFuZWwgPSB1bmRlZmluZWQ7XG4gICAgaWYgKFBhbmVsQ2xhc3MpIHtcbiAgICAgIHBhbmVsID0gX3JlYWN0MltcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChQYW5lbENsYXNzLCB7XG4gICAgICAgIGxvY2FsZTogbG9jYWxlLFxuICAgICAgICBkZWZhdWx0VmFsdWU6IHZhbHVlLFxuICAgICAgICByb290UHJlZml4Q2xzOiBwcmVmaXhDbHMsXG4gICAgICAgIG9uU2VsZWN0OiB0aGlzLm9uU2VsZWN0XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIF9yZWFjdDJbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXG4gICAgICAnZGl2JyxcbiAgICAgIHsgY2xhc3NOYW1lOiBwcmVmaXhDbHMgKyAnLWhlYWRlcicgfSxcbiAgICAgIF9yZWFjdDJbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICdkaXYnLFxuICAgICAgICB7IHN0eWxlOiB7IHBvc2l0aW9uOiAncmVsYXRpdmUnIH0gfSxcbiAgICAgICAgdGhpcy5zaG93SWYoZW5hYmxlUHJldiwgX3JlYWN0MltcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAnYScsXG4gICAgICAgICAge1xuICAgICAgICAgICAgY2xhc3NOYW1lOiBwcmVmaXhDbHMgKyAnLXByZXYteWVhci1idG4nLFxuICAgICAgICAgICAgcm9sZTogJ2J1dHRvbicsXG4gICAgICAgICAgICBvbkNsaWNrOiB0aGlzLnByZXZpb3VzWWVhcixcbiAgICAgICAgICAgIHRpdGxlOiBsb2NhbGUucHJldmlvdXNZZWFyXG4gICAgICAgICAgfSxcbiAgICAgICAgICAnwqsnXG4gICAgICAgICkpLFxuICAgICAgICB0aGlzLnNob3dJZihlbmFibGVQcmV2LCBfcmVhY3QyW1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICdhJyxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBjbGFzc05hbWU6IHByZWZpeENscyArICctcHJldi1tb250aC1idG4nLFxuICAgICAgICAgICAgcm9sZTogJ2J1dHRvbicsXG4gICAgICAgICAgICBvbkNsaWNrOiB0aGlzLnByZXZpb3VzTW9udGgsXG4gICAgICAgICAgICB0aXRsZTogbG9jYWxlLnByZXZpb3VzTW9udGhcbiAgICAgICAgICB9LFxuICAgICAgICAgICfigLknXG4gICAgICAgICkpLFxuICAgICAgICB0aGlzLmdldE1vbnRoWWVhckVsZW1lbnQoKSxcbiAgICAgICAgdGhpcy5zaG93SWYoZW5hYmxlTmV4dCwgX3JlYWN0MltcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAnYScsXG4gICAgICAgICAge1xuICAgICAgICAgICAgY2xhc3NOYW1lOiBwcmVmaXhDbHMgKyAnLW5leHQtbW9udGgtYnRuJyxcbiAgICAgICAgICAgIG9uQ2xpY2s6IHRoaXMubmV4dE1vbnRoLFxuICAgICAgICAgICAgdGl0bGU6IGxvY2FsZS5uZXh0TW9udGhcbiAgICAgICAgICB9LFxuICAgICAgICAgICfigLonXG4gICAgICAgICkpLFxuICAgICAgICB0aGlzLnNob3dJZihlbmFibGVOZXh0LCBfcmVhY3QyW1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICdhJyxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBjbGFzc05hbWU6IHByZWZpeENscyArICctbmV4dC15ZWFyLWJ0bicsXG4gICAgICAgICAgICBvbkNsaWNrOiB0aGlzLm5leHRZZWFyLFxuICAgICAgICAgICAgdGl0bGU6IGxvY2FsZS5uZXh0WWVhclxuICAgICAgICAgIH0sXG4gICAgICAgICAgJ8K7J1xuICAgICAgICApKVxuICAgICAgKSxcbiAgICAgIHBhbmVsXG4gICAgKTtcbiAgfVxufSk7XG5cbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gQ2FsZW5kYXJIZWFkZXI7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi91eGNvcmUtZm9ybS9+L3V4Y29yZS1kYXRlLWZvcm0tZmllbGQvfi91eGNvcmUtY2FsZW5kYXIvfi9yYy1jYWxlbmRhci9saWIvY2FsZW5kYXIvQ2FsZW5kYXJIZWFkZXIuanNcbiAqKiBtb2R1bGUgaWQgPSA0MTJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9yZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5cbnZhciBfcmVhY3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmVhY3QpO1xuXG52YXIgX1llYXJQYW5lbCA9IHJlcXVpcmUoJy4uL3llYXIvWWVhclBhbmVsJyk7XG5cbnZhciBfWWVhclBhbmVsMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1llYXJQYW5lbCk7XG5cbnZhciBfTW9udGhUYWJsZSA9IHJlcXVpcmUoJy4vTW9udGhUYWJsZScpO1xuXG52YXIgX01vbnRoVGFibGUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfTW9udGhUYWJsZSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IFwiZGVmYXVsdFwiOiBvYmogfTsgfVxuXG5mdW5jdGlvbiBnb1llYXIoZGlyZWN0aW9uKSB7XG4gIHZhciBuZXh0ID0gdGhpcy5zdGF0ZS52YWx1ZS5jbG9uZSgpO1xuICBuZXh0LmFkZFllYXIoZGlyZWN0aW9uKTtcbiAgdGhpcy5zZXRBbmRDaGFuZ2VWYWx1ZShuZXh0KTtcbn1cblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnZhciBNb250aFBhbmVsID0gX3JlYWN0MltcImRlZmF1bHRcIl0uY3JlYXRlQ2xhc3Moe1xuICBkaXNwbGF5TmFtZTogJ01vbnRoUGFuZWwnLFxuXG4gIHByb3BUeXBlczoge1xuICAgIG9uQ2hhbmdlOiBfcmVhY3QuUHJvcFR5cGVzLmZ1bmMsXG4gICAgZGlzYWJsZWREYXRlOiBfcmVhY3QuUHJvcFR5cGVzLmZ1bmMsXG4gICAgb25TZWxlY3Q6IF9yZWFjdC5Qcm9wVHlwZXMuZnVuY1xuICB9LFxuXG4gIGdldERlZmF1bHRQcm9wczogZnVuY3Rpb24gZ2V0RGVmYXVsdFByb3BzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBvbkNoYW5nZTogbm9vcCxcbiAgICAgIG9uU2VsZWN0OiBub29wXG4gICAgfTtcbiAgfSxcbiAgZ2V0SW5pdGlhbFN0YXRlOiBmdW5jdGlvbiBnZXRJbml0aWFsU3RhdGUoKSB7XG4gICAgdmFyIHByb3BzID0gdGhpcy5wcm9wcztcbiAgICAvLyBiaW5kIG1ldGhvZHNcbiAgICB0aGlzLm5leHRZZWFyID0gZ29ZZWFyLmJpbmQodGhpcywgMSk7XG4gICAgdGhpcy5wcmV2aW91c1llYXIgPSBnb1llYXIuYmluZCh0aGlzLCAtMSk7XG4gICAgdGhpcy5wcmVmaXhDbHMgPSBwcm9wcy5yb290UHJlZml4Q2xzICsgJy1tb250aC1wYW5lbCc7XG4gICAgcmV0dXJuIHtcbiAgICAgIHZhbHVlOiBwcm9wcy52YWx1ZSB8fCBwcm9wcy5kZWZhdWx0VmFsdWVcbiAgICB9O1xuICB9LFxuICBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzOiBmdW5jdGlvbiBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKG5leHRQcm9wcykge1xuICAgIGlmICgndmFsdWUnIGluIG5leHRQcm9wcykge1xuICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgIHZhbHVlOiBuZXh0UHJvcHMudmFsdWVcbiAgICAgIH0pO1xuICAgIH1cbiAgfSxcbiAgb25ZZWFyUGFuZWxTZWxlY3Q6IGZ1bmN0aW9uIG9uWWVhclBhbmVsU2VsZWN0KGN1cnJlbnQpIHtcbiAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgIHNob3dZZWFyUGFuZWw6IDBcbiAgICB9KTtcbiAgICB0aGlzLnNldEFuZENoYW5nZVZhbHVlKGN1cnJlbnQpO1xuICB9LFxuICBzZXRBbmRDaGFuZ2VWYWx1ZTogZnVuY3Rpb24gc2V0QW5kQ2hhbmdlVmFsdWUodmFsdWUpIHtcbiAgICB0aGlzLnNldFZhbHVlKHZhbHVlKTtcbiAgICB0aGlzLnByb3BzLm9uQ2hhbmdlKHZhbHVlKTtcbiAgfSxcbiAgc2V0QW5kU2VsZWN0VmFsdWU6IGZ1bmN0aW9uIHNldEFuZFNlbGVjdFZhbHVlKHZhbHVlKSB7XG4gICAgdGhpcy5zZXRWYWx1ZSh2YWx1ZSk7XG4gICAgdGhpcy5wcm9wcy5vblNlbGVjdCh2YWx1ZSk7XG4gIH0sXG4gIHNldFZhbHVlOiBmdW5jdGlvbiBzZXRWYWx1ZSh2YWx1ZSkge1xuICAgIGlmICghKCd2YWx1ZScgaW4gdGhpcy5wcm9wcykpIHtcbiAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgIH0pO1xuICAgIH1cbiAgfSxcbiAgc2hvd1llYXJQYW5lbDogZnVuY3Rpb24gc2hvd1llYXJQYW5lbCgpIHtcbiAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgIHNob3dZZWFyUGFuZWw6IDFcbiAgICB9KTtcbiAgfSxcbiAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgdmFyIHByb3BzID0gdGhpcy5wcm9wcztcbiAgICB2YXIgdmFsdWUgPSB0aGlzLnN0YXRlLnZhbHVlO1xuICAgIHZhciBsb2NhbGUgPSBwcm9wcy5sb2NhbGU7XG4gICAgdmFyIHllYXIgPSB2YWx1ZS5nZXRZZWFyKCk7XG4gICAgdmFyIHByZWZpeENscyA9IHRoaXMucHJlZml4Q2xzO1xuICAgIHZhciB5ZWFyUGFuZWwgPSB1bmRlZmluZWQ7XG4gICAgaWYgKHRoaXMuc3RhdGUuc2hvd1llYXJQYW5lbCkge1xuICAgICAgeWVhclBhbmVsID0gX3JlYWN0MltcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChfWWVhclBhbmVsMltcImRlZmF1bHRcIl0sIHtcbiAgICAgICAgbG9jYWxlOiBsb2NhbGUsXG4gICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgcm9vdFByZWZpeENsczogcHJvcHMucm9vdFByZWZpeENscyxcbiAgICAgICAgb25TZWxlY3Q6IHRoaXMub25ZZWFyUGFuZWxTZWxlY3RcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gX3JlYWN0MltcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChcbiAgICAgICdkaXYnLFxuICAgICAgeyBjbGFzc05hbWU6IHByZWZpeENscywgc3R5bGU6IHByb3BzLnN0eWxlIH0sXG4gICAgICBfcmVhY3QyW1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFxuICAgICAgICAnZGl2JyxcbiAgICAgICAgbnVsbCxcbiAgICAgICAgX3JlYWN0MltcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAnZGl2JyxcbiAgICAgICAgICB7IGNsYXNzTmFtZTogcHJlZml4Q2xzICsgJy1oZWFkZXInIH0sXG4gICAgICAgICAgX3JlYWN0MltcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAgICdhJyxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgY2xhc3NOYW1lOiBwcmVmaXhDbHMgKyAnLXByZXYteWVhci1idG4nLFxuICAgICAgICAgICAgICByb2xlOiAnYnV0dG9uJyxcbiAgICAgICAgICAgICAgb25DbGljazogdGhpcy5wcmV2aW91c1llYXIsXG4gICAgICAgICAgICAgIHRpdGxlOiBsb2NhbGUucHJldmlvdXNZZWFyXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ8KrJ1xuICAgICAgICAgICksXG4gICAgICAgICAgX3JlYWN0MltcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAgICdhJyxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgY2xhc3NOYW1lOiBwcmVmaXhDbHMgKyAnLXllYXItc2VsZWN0JyxcbiAgICAgICAgICAgICAgcm9sZTogJ2J1dHRvbicsXG4gICAgICAgICAgICAgIG9uQ2xpY2s6IHRoaXMuc2hvd1llYXJQYW5lbCxcbiAgICAgICAgICAgICAgdGl0bGU6IGxvY2FsZS55ZWFyU2VsZWN0XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX3JlYWN0MltcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAgICAgJ3NwYW4nLFxuICAgICAgICAgICAgICB7IGNsYXNzTmFtZTogcHJlZml4Q2xzICsgJy15ZWFyLXNlbGVjdC1jb250ZW50JyB9LFxuICAgICAgICAgICAgICB5ZWFyXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgX3JlYWN0MltcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAgICAgJ3NwYW4nLFxuICAgICAgICAgICAgICB7IGNsYXNzTmFtZTogcHJlZml4Q2xzICsgJy15ZWFyLXNlbGVjdC1hcnJvdycgfSxcbiAgICAgICAgICAgICAgJ3gnXG4gICAgICAgICAgICApXG4gICAgICAgICAgKSxcbiAgICAgICAgICBfcmVhY3QyW1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICAgJ2EnLFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBjbGFzc05hbWU6IHByZWZpeENscyArICctbmV4dC15ZWFyLWJ0bicsXG4gICAgICAgICAgICAgIHJvbGU6ICdidXR0b24nLFxuICAgICAgICAgICAgICBvbkNsaWNrOiB0aGlzLm5leHRZZWFyLFxuICAgICAgICAgICAgICB0aXRsZTogbG9jYWxlLm5leHRZZWFyXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ8K7J1xuICAgICAgICAgIClcbiAgICAgICAgKSxcbiAgICAgICAgX3JlYWN0MltcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAnZGl2JyxcbiAgICAgICAgICB7IGNsYXNzTmFtZTogcHJlZml4Q2xzICsgJy1ib2R5JyB9LFxuICAgICAgICAgIF9yZWFjdDJbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoX01vbnRoVGFibGUyW1wiZGVmYXVsdFwiXSwge1xuICAgICAgICAgICAgZGlzYWJsZWREYXRlOiBwcm9wcy5kaXNhYmxlZERhdGUsXG4gICAgICAgICAgICBvblNlbGVjdDogdGhpcy5zZXRBbmRTZWxlY3RWYWx1ZSxcbiAgICAgICAgICAgIGxvY2FsZTogbG9jYWxlLFxuICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgcHJlZml4Q2xzOiBwcmVmaXhDbHNcbiAgICAgICAgICB9KVxuICAgICAgICApXG4gICAgICApLFxuICAgICAgeWVhclBhbmVsXG4gICAgKTtcbiAgfVxufSk7XG5cbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gTW9udGhQYW5lbDtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3V4Y29yZS1mb3JtL34vdXhjb3JlLWRhdGUtZm9ybS1maWVsZC9+L3V4Y29yZS1jYWxlbmRhci9+L3JjLWNhbGVuZGFyL2xpYi9tb250aC9Nb250aFBhbmVsLmpzXG4gKiogbW9kdWxlIGlkID0gNDEzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfcmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xuXG52YXIgX3JlYWN0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JlYWN0KTtcblxudmFyIF9jbGFzc25hbWVzID0gcmVxdWlyZSgnY2xhc3NuYW1lcycpO1xuXG52YXIgX2NsYXNzbmFtZXMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY2xhc3NuYW1lcyk7XG5cbnZhciBfRGVjYWRlUGFuZWwgPSByZXF1aXJlKCcuLi9kZWNhZGUvRGVjYWRlUGFuZWwnKTtcblxudmFyIF9EZWNhZGVQYW5lbDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9EZWNhZGVQYW5lbCk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IFwiZGVmYXVsdFwiOiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfZGVmYXVsdHMob2JqLCBkZWZhdWx0cykgeyB2YXIga2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGRlZmF1bHRzKTsgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7IHZhciBrZXkgPSBrZXlzW2ldOyB2YXIgdmFsdWUgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGRlZmF1bHRzLCBrZXkpOyBpZiAodmFsdWUgJiYgdmFsdWUuY29uZmlndXJhYmxlICYmIG9ialtrZXldID09PSB1bmRlZmluZWQpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSk7IH0gfSByZXR1cm4gb2JqOyB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IF9kZWZhdWx0cyhzdWJDbGFzcywgc3VwZXJDbGFzcyk7IH1cblxudmFyIFJPVyA9IDQ7XG52YXIgQ09MID0gMztcblxuZnVuY3Rpb24gZ29ZZWFyKGRpcmVjdGlvbikge1xuICB2YXIgdmFsdWUgPSB0aGlzLnN0YXRlLnZhbHVlLmNsb25lKCk7XG4gIHZhbHVlLmFkZFllYXIoZGlyZWN0aW9uKTtcbiAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgdmFsdWU6IHZhbHVlXG4gIH0pO1xufVxuXG5mdW5jdGlvbiBjaG9vc2VZZWFyKHllYXIpIHtcbiAgdmFyIHZhbHVlID0gdGhpcy5zdGF0ZS52YWx1ZS5jbG9uZSgpO1xuICB2YWx1ZS5zZXRZZWFyKHllYXIpO1xuICB2YWx1ZS5yb2xsU2V0TW9udGgodGhpcy5zdGF0ZS52YWx1ZS5nZXRNb250aCgpKTtcbiAgdGhpcy5wcm9wcy5vblNlbGVjdCh2YWx1ZSk7XG59XG5cbnZhciBZZWFyUGFuZWwgPSBmdW5jdGlvbiAoX1JlYWN0JENvbXBvbmVudCkge1xuICBfaW5oZXJpdHMoWWVhclBhbmVsLCBfUmVhY3QkQ29tcG9uZW50KTtcblxuICBmdW5jdGlvbiBZZWFyUGFuZWwocHJvcHMpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgWWVhclBhbmVsKTtcblxuICAgIHZhciBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9SZWFjdCRDb21wb25lbnQuY2FsbCh0aGlzLCBwcm9wcykpO1xuXG4gICAgX3RoaXMucHJlZml4Q2xzID0gcHJvcHMucm9vdFByZWZpeENscyArICcteWVhci1wYW5lbCc7XG4gICAgX3RoaXMuc3RhdGUgPSB7XG4gICAgICB2YWx1ZTogcHJvcHMudmFsdWUgfHwgcHJvcHMuZGVmYXVsdFZhbHVlXG4gICAgfTtcbiAgICBfdGhpcy5uZXh0RGVjYWRlID0gZ29ZZWFyLmJpbmQoX3RoaXMsIDEwKTtcbiAgICBfdGhpcy5wcmV2aW91c0RlY2FkZSA9IGdvWWVhci5iaW5kKF90aGlzLCAtMTApO1xuICAgIFsnc2hvd0RlY2FkZVBhbmVsJywgJ29uRGVjYWRlUGFuZWxTZWxlY3QnXS5mb3JFYWNoKGZ1bmN0aW9uIChtZXRob2QpIHtcbiAgICAgIF90aGlzW21ldGhvZF0gPSBfdGhpc1ttZXRob2RdLmJpbmQoX3RoaXMpO1xuICAgIH0pO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIFllYXJQYW5lbC5wcm90b3R5cGUub25EZWNhZGVQYW5lbFNlbGVjdCA9IGZ1bmN0aW9uIG9uRGVjYWRlUGFuZWxTZWxlY3QoY3VycmVudCkge1xuICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgdmFsdWU6IGN1cnJlbnQsXG4gICAgICBzaG93RGVjYWRlUGFuZWw6IDBcbiAgICB9KTtcbiAgfTtcblxuICBZZWFyUGFuZWwucHJvdG90eXBlLmdldFllYXJzID0gZnVuY3Rpb24gZ2V0WWVhcnMoKSB7XG4gICAgdmFyIHZhbHVlID0gdGhpcy5zdGF0ZS52YWx1ZTtcbiAgICB2YXIgY3VycmVudFllYXIgPSB2YWx1ZS5nZXRZZWFyKCk7XG4gICAgdmFyIHN0YXJ0WWVhciA9IHBhcnNlSW50KGN1cnJlbnRZZWFyIC8gMTAsIDEwKSAqIDEwO1xuICAgIHZhciBwcmV2aW91c1llYXIgPSBzdGFydFllYXIgLSAxO1xuICAgIHZhciBlbmRZZWFyID0gc3RhcnRZZWFyICsgOTtcbiAgICB2YXIgeWVhcnMgPSBbXTtcbiAgICB2YXIgaW5kZXggPSAwO1xuICAgIGZvciAodmFyIHJvd0luZGV4ID0gMDsgcm93SW5kZXggPCBST1c7IHJvd0luZGV4KyspIHtcbiAgICAgIHllYXJzW3Jvd0luZGV4XSA9IFtdO1xuICAgICAgZm9yICh2YXIgY29sSW5kZXggPSAwOyBjb2xJbmRleCA8IENPTDsgY29sSW5kZXgrKykge1xuICAgICAgICB2YXIgeWVhciA9IHByZXZpb3VzWWVhciArIGluZGV4O1xuICAgICAgICB2YXIgY29udGVudCA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKHllYXIgPCBzdGFydFllYXIpIHtcbiAgICAgICAgICBjb250ZW50ID0gJyc7XG4gICAgICAgIH0gZWxzZSBpZiAoeWVhciA+IGVuZFllYXIpIHtcbiAgICAgICAgICBjb250ZW50ID0gJyc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29udGVudCA9IFN0cmluZyh5ZWFyKTtcbiAgICAgICAgfVxuICAgICAgICB5ZWFyc1tyb3dJbmRleF1bY29sSW5kZXhdID0ge1xuICAgICAgICAgIGNvbnRlbnQ6IGNvbnRlbnQsXG4gICAgICAgICAgeWVhcjogeWVhcixcbiAgICAgICAgICB0aXRsZTogY29udGVudFxuICAgICAgICB9O1xuICAgICAgICBpbmRleCsrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geWVhcnM7XG4gIH07XG5cbiAgWWVhclBhbmVsLnByb3RvdHlwZS5zaG93RGVjYWRlUGFuZWwgPSBmdW5jdGlvbiBzaG93RGVjYWRlUGFuZWwoKSB7XG4gICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICBzaG93RGVjYWRlUGFuZWw6IDFcbiAgICB9KTtcbiAgfTtcblxuICBZZWFyUGFuZWwucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgIHZhciBwcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgdmFyIHZhbHVlID0gdGhpcy5zdGF0ZS52YWx1ZTtcbiAgICB2YXIgbG9jYWxlID0gcHJvcHMubG9jYWxlO1xuICAgIHZhciB5ZWFycyA9IHRoaXMuZ2V0WWVhcnMoKTtcbiAgICB2YXIgY3VycmVudFllYXIgPSB2YWx1ZS5nZXRZZWFyKCk7XG4gICAgdmFyIHN0YXJ0WWVhciA9IHBhcnNlSW50KGN1cnJlbnRZZWFyIC8gMTAsIDEwKSAqIDEwO1xuICAgIHZhciBlbmRZZWFyID0gc3RhcnRZZWFyICsgOTtcbiAgICB2YXIgcHJlZml4Q2xzID0gdGhpcy5wcmVmaXhDbHM7XG5cbiAgICB2YXIgeWVhc0VscyA9IHllYXJzLm1hcChmdW5jdGlvbiAocm93LCBpbmRleCkge1xuICAgICAgdmFyIHRkcyA9IHJvdy5tYXAoZnVuY3Rpb24gKHllYXJEYXRhKSB7XG4gICAgICAgIHZhciBfY2xhc3NOYW1lTWFwO1xuXG4gICAgICAgIHZhciBjbGFzc05hbWVNYXAgPSAoX2NsYXNzTmFtZU1hcCA9IHt9LCBfZGVmaW5lUHJvcGVydHkoX2NsYXNzTmFtZU1hcCwgcHJlZml4Q2xzICsgJy1jZWxsJywgMSksIF9kZWZpbmVQcm9wZXJ0eShfY2xhc3NOYW1lTWFwLCBwcmVmaXhDbHMgKyAnLXNlbGVjdGVkLWNlbGwnLCB5ZWFyRGF0YS55ZWFyID09PSBjdXJyZW50WWVhciksIF9kZWZpbmVQcm9wZXJ0eShfY2xhc3NOYW1lTWFwLCBwcmVmaXhDbHMgKyAnLWxhc3QtZGVjYWRlLWNlbGwnLCB5ZWFyRGF0YS55ZWFyIDwgc3RhcnRZZWFyKSwgX2RlZmluZVByb3BlcnR5KF9jbGFzc05hbWVNYXAsIHByZWZpeENscyArICctbmV4dC1kZWNhZGUtY2VsbCcsIHllYXJEYXRhLnllYXIgPiBlbmRZZWFyKSwgX2NsYXNzTmFtZU1hcCk7XG4gICAgICAgIHZhciBjbGlja0hhbmRsZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmICh5ZWFyRGF0YS55ZWFyIDwgc3RhcnRZZWFyKSB7XG4gICAgICAgICAgY2xpY2tIYW5kbGVyID0gX3RoaXMyLnByZXZpb3VzRGVjYWRlO1xuICAgICAgICB9IGVsc2UgaWYgKHllYXJEYXRhLnllYXIgPiBlbmRZZWFyKSB7XG4gICAgICAgICAgY2xpY2tIYW5kbGVyID0gX3RoaXMyLm5leHREZWNhZGU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2xpY2tIYW5kbGVyID0gY2hvb3NlWWVhci5iaW5kKF90aGlzMiwgeWVhckRhdGEueWVhcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF9yZWFjdDJbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgJ3RkJyxcbiAgICAgICAgICB7XG4gICAgICAgICAgICByb2xlOiAnZ3JpZGNlbGwnLFxuICAgICAgICAgICAgdGl0bGU6IHllYXJEYXRhLnRpdGxlLFxuICAgICAgICAgICAga2V5OiB5ZWFyRGF0YS5jb250ZW50LFxuICAgICAgICAgICAgb25DbGljazogY2xpY2tIYW5kbGVyLFxuICAgICAgICAgICAgY2xhc3NOYW1lOiAoMCwgX2NsYXNzbmFtZXMyW1wiZGVmYXVsdFwiXSkoY2xhc3NOYW1lTWFwKVxuICAgICAgICAgIH0sXG4gICAgICAgICAgX3JlYWN0MltcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAgICdhJyxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgY2xhc3NOYW1lOiBwcmVmaXhDbHMgKyAnLXllYXInXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgeWVhckRhdGEuY29udGVudFxuICAgICAgICAgIClcbiAgICAgICAgKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIF9yZWFjdDJbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICd0cicsXG4gICAgICAgIHsga2V5OiBpbmRleCwgcm9sZTogJ3JvdycgfSxcbiAgICAgICAgdGRzXG4gICAgICApO1xuICAgIH0pO1xuXG4gICAgdmFyIGRlY2FkZVBhbmVsID0gdW5kZWZpbmVkO1xuICAgIGlmICh0aGlzLnN0YXRlLnNob3dEZWNhZGVQYW5lbCkge1xuICAgICAgZGVjYWRlUGFuZWwgPSBfcmVhY3QyW1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KF9EZWNhZGVQYW5lbDJbXCJkZWZhdWx0XCJdLCB7XG4gICAgICAgIGxvY2FsZTogbG9jYWxlLFxuICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgIHJvb3RQcmVmaXhDbHM6IHByb3BzLnJvb3RQcmVmaXhDbHMsXG4gICAgICAgIG9uU2VsZWN0OiB0aGlzLm9uRGVjYWRlUGFuZWxTZWxlY3RcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBfcmVhY3QyW1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFxuICAgICAgJ2RpdicsXG4gICAgICB7IGNsYXNzTmFtZTogdGhpcy5wcmVmaXhDbHMgfSxcbiAgICAgIF9yZWFjdDJbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICdkaXYnLFxuICAgICAgICBudWxsLFxuICAgICAgICBfcmVhY3QyW1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICdkaXYnLFxuICAgICAgICAgIHsgY2xhc3NOYW1lOiBwcmVmaXhDbHMgKyAnLWhlYWRlcicgfSxcbiAgICAgICAgICBfcmVhY3QyW1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICAgJ2EnLFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBjbGFzc05hbWU6IHByZWZpeENscyArICctcHJldi1kZWNhZGUtYnRuJyxcbiAgICAgICAgICAgICAgcm9sZTogJ2J1dHRvbicsXG4gICAgICAgICAgICAgIG9uQ2xpY2s6IHRoaXMucHJldmlvdXNEZWNhZGUsXG4gICAgICAgICAgICAgIHRpdGxlOiBsb2NhbGUucHJldmlvdXNEZWNhZGVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnwqsnXG4gICAgICAgICAgKSxcbiAgICAgICAgICBfcmVhY3QyW1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICAgJ2EnLFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBjbGFzc05hbWU6IHByZWZpeENscyArICctZGVjYWRlLXNlbGVjdCcsXG4gICAgICAgICAgICAgIHJvbGU6ICdidXR0b24nLFxuICAgICAgICAgICAgICBvbkNsaWNrOiB0aGlzLnNob3dEZWNhZGVQYW5lbCxcbiAgICAgICAgICAgICAgdGl0bGU6IGxvY2FsZS5kZWNhZGVTZWxlY3RcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfcmVhY3QyW1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICAgICAnc3BhbicsXG4gICAgICAgICAgICAgIHsgY2xhc3NOYW1lOiBwcmVmaXhDbHMgKyAnLWRlY2FkZS1zZWxlY3QtY29udGVudCcgfSxcbiAgICAgICAgICAgICAgc3RhcnRZZWFyLFxuICAgICAgICAgICAgICAnLScsXG4gICAgICAgICAgICAgIGVuZFllYXJcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICBfcmVhY3QyW1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICAgICAnc3BhbicsXG4gICAgICAgICAgICAgIHsgY2xhc3NOYW1lOiBwcmVmaXhDbHMgKyAnLWRlY2FkZS1zZWxlY3QtYXJyb3cnIH0sXG4gICAgICAgICAgICAgICd4J1xuICAgICAgICAgICAgKVxuICAgICAgICAgICksXG4gICAgICAgICAgX3JlYWN0MltcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAgICdhJyxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgY2xhc3NOYW1lOiBwcmVmaXhDbHMgKyAnLW5leHQtZGVjYWRlLWJ0bicsXG4gICAgICAgICAgICAgIHJvbGU6ICdidXR0b24nLFxuICAgICAgICAgICAgICBvbkNsaWNrOiB0aGlzLm5leHREZWNhZGUsXG4gICAgICAgICAgICAgIHRpdGxlOiBsb2NhbGUubmV4dERlY2FkZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICfCuydcbiAgICAgICAgICApXG4gICAgICAgICksXG4gICAgICAgIF9yZWFjdDJbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgJ2RpdicsXG4gICAgICAgICAgeyBjbGFzc05hbWU6IHByZWZpeENscyArICctYm9keScgfSxcbiAgICAgICAgICBfcmVhY3QyW1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICAgJ3RhYmxlJyxcbiAgICAgICAgICAgIHsgY2xhc3NOYW1lOiBwcmVmaXhDbHMgKyAnLXRhYmxlJywgY2VsbFNwYWNpbmc6ICcwJywgcm9sZTogJ2dyaWQnIH0sXG4gICAgICAgICAgICBfcmVhY3QyW1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICAgICAndGJvZHknLFxuICAgICAgICAgICAgICB7IGNsYXNzTmFtZTogcHJlZml4Q2xzICsgJy10Ym9keScgfSxcbiAgICAgICAgICAgICAgeWVhc0Vsc1xuICAgICAgICAgICAgKVxuICAgICAgICAgIClcbiAgICAgICAgKVxuICAgICAgKSxcbiAgICAgIGRlY2FkZVBhbmVsXG4gICAgKTtcbiAgfTtcblxuICByZXR1cm4gWWVhclBhbmVsO1xufShfcmVhY3QyW1wiZGVmYXVsdFwiXS5Db21wb25lbnQpO1xuXG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IFllYXJQYW5lbDtcblxuXG5ZZWFyUGFuZWwucHJvcFR5cGVzID0ge1xuICByb290UHJlZml4Q2xzOiBfcmVhY3QuUHJvcFR5cGVzLnN0cmluZyxcbiAgdmFsdWU6IF9yZWFjdC5Qcm9wVHlwZXMub2JqZWN0LFxuICBkZWZhdWx0VmFsdWU6IF9yZWFjdC5Qcm9wVHlwZXMub2JqZWN0XG59O1xuXG5ZZWFyUGFuZWwuZGVmYXVsdFByb3BzID0ge1xuICBvblNlbGVjdDogZnVuY3Rpb24gb25TZWxlY3QoKSB7fVxufTtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3V4Y29yZS1mb3JtL34vdXhjb3JlLWRhdGUtZm9ybS1maWVsZC9+L3V4Y29yZS1jYWxlbmRhci9+L3JjLWNhbGVuZGFyL2xpYi95ZWFyL1llYXJQYW5lbC5qc1xuICoqIG1vZHVsZSBpZCA9IDQxNFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX3JlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxudmFyIF9yZWFjdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yZWFjdCk7XG5cbnZhciBfY2xhc3NuYW1lcyA9IHJlcXVpcmUoJ2NsYXNzbmFtZXMnKTtcblxudmFyIF9jbGFzc25hbWVzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NsYXNzbmFtZXMpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBcImRlZmF1bHRcIjogb2JqIH07IH1cblxuZnVuY3Rpb24gX2RlZmF1bHRzKG9iaiwgZGVmYXVsdHMpIHsgdmFyIGtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhkZWZhdWx0cyk7IGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykgeyB2YXIga2V5ID0ga2V5c1tpXTsgdmFyIHZhbHVlID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihkZWZhdWx0cywga2V5KTsgaWYgKHZhbHVlICYmIHZhbHVlLmNvbmZpZ3VyYWJsZSAmJiBvYmpba2V5XSA9PT0gdW5kZWZpbmVkKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpOyB9IH0gcmV0dXJuIG9iajsgfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBfZGVmYXVsdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpOyB9XG5cbnZhciBST1cgPSA0O1xudmFyIENPTCA9IDM7XG5cblxuZnVuY3Rpb24gZ29ZZWFyKGRpcmVjdGlvbikge1xuICB2YXIgbmV4dCA9IHRoaXMuc3RhdGUudmFsdWUuY2xvbmUoKTtcbiAgbmV4dC5hZGRZZWFyKGRpcmVjdGlvbik7XG4gIHRoaXMuc2V0U3RhdGUoe1xuICAgIHZhbHVlOiBuZXh0XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBjaG9vc2VEZWNhZGUoeWVhciwgZXZlbnQpIHtcbiAgdmFyIG5leHQgPSB0aGlzLnN0YXRlLnZhbHVlLmNsb25lKCk7XG4gIG5leHQuc2V0WWVhcih5ZWFyKTtcbiAgbmV4dC5yb2xsU2V0TW9udGgodGhpcy5zdGF0ZS52YWx1ZS5nZXRNb250aCgpKTtcbiAgdGhpcy5wcm9wcy5vblNlbGVjdChuZXh0KTtcbiAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbn1cblxudmFyIERlY2FkZVBhbmVsID0gZnVuY3Rpb24gKF9SZWFjdCRDb21wb25lbnQpIHtcbiAgX2luaGVyaXRzKERlY2FkZVBhbmVsLCBfUmVhY3QkQ29tcG9uZW50KTtcblxuICBmdW5jdGlvbiBEZWNhZGVQYW5lbChwcm9wcykge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBEZWNhZGVQYW5lbCk7XG5cbiAgICB2YXIgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfUmVhY3QkQ29tcG9uZW50LmNhbGwodGhpcywgcHJvcHMpKTtcblxuICAgIF90aGlzLnN0YXRlID0ge1xuICAgICAgdmFsdWU6IHByb3BzLnZhbHVlIHx8IHByb3BzLmRlZmF1bHRWYWx1ZVxuICAgIH07XG5cbiAgICAvLyBiaW5kIG1ldGhvZHNcbiAgICBfdGhpcy5wcmVmaXhDbHMgPSBwcm9wcy5yb290UHJlZml4Q2xzICsgJy1kZWNhZGUtcGFuZWwnO1xuICAgIF90aGlzLm5leHRDZW50dXJ5ID0gZ29ZZWFyLmJpbmQoX3RoaXMsIDEwMCk7XG4gICAgX3RoaXMucHJldmlvdXNDZW50dXJ5ID0gZ29ZZWFyLmJpbmQoX3RoaXMsIC0xMDApO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIERlY2FkZVBhbmVsLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICB2YXIgdmFsdWUgPSB0aGlzLnN0YXRlLnZhbHVlO1xuICAgIHZhciBsb2NhbGUgPSB0aGlzLnByb3BzLmxvY2FsZTtcbiAgICB2YXIgY3VycmVudFllYXIgPSB2YWx1ZS5nZXRZZWFyKCk7XG4gICAgdmFyIHN0YXJ0WWVhciA9IHBhcnNlSW50KGN1cnJlbnRZZWFyIC8gMTAwLCAxMCkgKiAxMDA7XG4gICAgdmFyIHByZVllYXIgPSBzdGFydFllYXIgLSAxMDtcbiAgICB2YXIgZW5kWWVhciA9IHN0YXJ0WWVhciArIDk5O1xuICAgIHZhciBkZWNhZGVzID0gW107XG4gICAgdmFyIGluZGV4ID0gMDtcbiAgICB2YXIgcHJlZml4Q2xzID0gdGhpcy5wcmVmaXhDbHM7XG5cbiAgICBmb3IgKHZhciByb3dJbmRleCA9IDA7IHJvd0luZGV4IDwgUk9XOyByb3dJbmRleCsrKSB7XG4gICAgICBkZWNhZGVzW3Jvd0luZGV4XSA9IFtdO1xuICAgICAgZm9yICh2YXIgY29sSW5kZXggPSAwOyBjb2xJbmRleCA8IENPTDsgY29sSW5kZXgrKykge1xuICAgICAgICB2YXIgc3RhcnREZWNhZGUgPSBwcmVZZWFyICsgaW5kZXggKiAxMDtcbiAgICAgICAgdmFyIGVuZERlY2FkZSA9IHByZVllYXIgKyBpbmRleCAqIDEwICsgOTtcbiAgICAgICAgZGVjYWRlc1tyb3dJbmRleF1bY29sSW5kZXhdID0ge1xuICAgICAgICAgIHN0YXJ0RGVjYWRlOiBzdGFydERlY2FkZSxcbiAgICAgICAgICBlbmREZWNhZGU6IGVuZERlY2FkZVxuICAgICAgICB9O1xuICAgICAgICBpbmRleCsrO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBkZWNhZGVzRWxzID0gZGVjYWRlcy5tYXAoZnVuY3Rpb24gKHJvdywgZGVjYWRlSW5kZXgpIHtcbiAgICAgIHZhciB0ZHMgPSByb3cubWFwKGZ1bmN0aW9uIChkZWNhZGVEYXRhKSB7XG4gICAgICAgIHZhciBfY2xhc3NOYW1lTWFwO1xuXG4gICAgICAgIHZhciBkU3RhcnREZWNhZGUgPSBkZWNhZGVEYXRhLnN0YXJ0RGVjYWRlO1xuICAgICAgICB2YXIgZEVuZERlY2FkZSA9IGRlY2FkZURhdGEuZW5kRGVjYWRlO1xuICAgICAgICB2YXIgaXNMYXN0ID0gZFN0YXJ0RGVjYWRlIDwgc3RhcnRZZWFyO1xuICAgICAgICB2YXIgaXNOZXh0ID0gZEVuZERlY2FkZSA+IGVuZFllYXI7XG4gICAgICAgIHZhciBjbGFzc05hbWVNYXAgPSAoX2NsYXNzTmFtZU1hcCA9IHt9LCBfZGVmaW5lUHJvcGVydHkoX2NsYXNzTmFtZU1hcCwgcHJlZml4Q2xzICsgJy1jZWxsJywgMSksIF9kZWZpbmVQcm9wZXJ0eShfY2xhc3NOYW1lTWFwLCBwcmVmaXhDbHMgKyAnLXNlbGVjdGVkLWNlbGwnLCBkU3RhcnREZWNhZGUgPD0gY3VycmVudFllYXIgJiYgY3VycmVudFllYXIgPD0gZEVuZERlY2FkZSksIF9kZWZpbmVQcm9wZXJ0eShfY2xhc3NOYW1lTWFwLCBwcmVmaXhDbHMgKyAnLWxhc3QtY2VudHVyeS1jZWxsJywgaXNMYXN0KSwgX2RlZmluZVByb3BlcnR5KF9jbGFzc05hbWVNYXAsIHByZWZpeENscyArICctbmV4dC1jZW50dXJ5LWNlbGwnLCBpc05leHQpLCBfY2xhc3NOYW1lTWFwKTtcbiAgICAgICAgdmFyIGNvbnRlbnQgPSB1bmRlZmluZWQ7XG4gICAgICAgIHZhciBjbGlja0hhbmRsZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmIChpc0xhc3QpIHtcbiAgICAgICAgICBjbGlja0hhbmRsZXIgPSBfdGhpczIucHJldmlvdXNDZW50dXJ5O1xuICAgICAgICB9IGVsc2UgaWYgKGlzTmV4dCkge1xuICAgICAgICAgIGNsaWNrSGFuZGxlciA9IF90aGlzMi5uZXh0Q2VudHVyeTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb250ZW50ID0gZFN0YXJ0RGVjYWRlICsgJy0nICsgZEVuZERlY2FkZTtcbiAgICAgICAgICBjbGlja0hhbmRsZXIgPSBjaG9vc2VEZWNhZGUuYmluZChfdGhpczIsIGRTdGFydERlY2FkZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF9yZWFjdDJbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgJ3RkJyxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBrZXk6IGRTdGFydERlY2FkZSxcbiAgICAgICAgICAgIG9uQ2xpY2s6IGNsaWNrSGFuZGxlcixcbiAgICAgICAgICAgIHJvbGU6ICdncmlkY2VsbCcsXG4gICAgICAgICAgICBjbGFzc05hbWU6ICgwLCBfY2xhc3NuYW1lczJbXCJkZWZhdWx0XCJdKShjbGFzc05hbWVNYXApXG4gICAgICAgICAgfSxcbiAgICAgICAgICBfcmVhY3QyW1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICAgJ2EnLFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBjbGFzc05hbWU6IHByZWZpeENscyArICctZGVjYWRlJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNvbnRlbnRcbiAgICAgICAgICApXG4gICAgICAgICk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBfcmVhY3QyW1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFxuICAgICAgICAndHInLFxuICAgICAgICB7IGtleTogZGVjYWRlSW5kZXgsIHJvbGU6ICdyb3cnIH0sXG4gICAgICAgIHRkc1xuICAgICAgKTtcbiAgICB9KTtcblxuICAgIHJldHVybiBfcmVhY3QyW1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFxuICAgICAgJ2RpdicsXG4gICAgICB7IGNsYXNzTmFtZTogdGhpcy5wcmVmaXhDbHMgfSxcbiAgICAgIF9yZWFjdDJbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICdkaXYnLFxuICAgICAgICB7IGNsYXNzTmFtZTogcHJlZml4Q2xzICsgJy1oZWFkZXInIH0sXG4gICAgICAgIF9yZWFjdDJbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgJ2EnLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGNsYXNzTmFtZTogcHJlZml4Q2xzICsgJy1wcmV2LWNlbnR1cnktYnRuJyxcbiAgICAgICAgICAgIHJvbGU6ICdidXR0b24nLFxuICAgICAgICAgICAgb25DbGljazogdGhpcy5wcmV2aW91c0NlbnR1cnksXG4gICAgICAgICAgICB0aXRsZTogbG9jYWxlLnByZXZpb3VzQ2VudHVyeVxuICAgICAgICAgIH0sXG4gICAgICAgICAgJ8KrJ1xuICAgICAgICApLFxuICAgICAgICBfcmVhY3QyW1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICdkaXYnLFxuICAgICAgICAgIHsgY2xhc3NOYW1lOiBwcmVmaXhDbHMgKyAnLWNlbnR1cnknIH0sXG4gICAgICAgICAgc3RhcnRZZWFyLFxuICAgICAgICAgICctJyxcbiAgICAgICAgICBlbmRZZWFyXG4gICAgICAgICksXG4gICAgICAgIF9yZWFjdDJbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgJ2EnLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGNsYXNzTmFtZTogcHJlZml4Q2xzICsgJy1uZXh0LWNlbnR1cnktYnRuJyxcbiAgICAgICAgICAgIHJvbGU6ICdidXR0b24nLFxuICAgICAgICAgICAgb25DbGljazogdGhpcy5uZXh0Q2VudHVyeSxcbiAgICAgICAgICAgIHRpdGxlOiBsb2NhbGUubmV4dENlbnR1cnlcbiAgICAgICAgICB9LFxuICAgICAgICAgICfCuydcbiAgICAgICAgKVxuICAgICAgKSxcbiAgICAgIF9yZWFjdDJbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICdkaXYnLFxuICAgICAgICB7IGNsYXNzTmFtZTogcHJlZml4Q2xzICsgJy1ib2R5JyB9LFxuICAgICAgICBfcmVhY3QyW1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICd0YWJsZScsXG4gICAgICAgICAgeyBjbGFzc05hbWU6IHByZWZpeENscyArICctdGFibGUnLCBjZWxsU3BhY2luZzogJzAnLCByb2xlOiAnZ3JpZCcgfSxcbiAgICAgICAgICBfcmVhY3QyW1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICAgJ3Rib2R5JyxcbiAgICAgICAgICAgIHsgY2xhc3NOYW1lOiBwcmVmaXhDbHMgKyAnLXRib2R5JyB9LFxuICAgICAgICAgICAgZGVjYWRlc0Vsc1xuICAgICAgICAgIClcbiAgICAgICAgKVxuICAgICAgKVxuICAgICk7XG4gIH07XG5cbiAgcmV0dXJuIERlY2FkZVBhbmVsO1xufShfcmVhY3QyW1wiZGVmYXVsdFwiXS5Db21wb25lbnQpO1xuXG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IERlY2FkZVBhbmVsO1xuXG5cbkRlY2FkZVBhbmVsLnByb3BUeXBlcyA9IHtcbiAgbG9jYWxlOiBfcmVhY3QuUHJvcFR5cGVzLm9iamVjdCxcbiAgdmFsdWU6IF9yZWFjdC5Qcm9wVHlwZXMub2JqZWN0LFxuICBkZWZhdWx0VmFsdWU6IF9yZWFjdC5Qcm9wVHlwZXMub2JqZWN0LFxuICByb290UHJlZml4Q2xzOiBfcmVhY3QuUHJvcFR5cGVzLnN0cmluZ1xufTtcblxuRGVjYWRlUGFuZWwuZGVmYXVsdFByb3BzID0ge1xuICBvblNlbGVjdDogZnVuY3Rpb24gb25TZWxlY3QoKSB7fVxufTtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3V4Y29yZS1mb3JtL34vdXhjb3JlLWRhdGUtZm9ybS1maWVsZC9+L3V4Y29yZS1jYWxlbmRhci9+L3JjLWNhbGVuZGFyL2xpYi9kZWNhZGUvRGVjYWRlUGFuZWwuanNcbiAqKiBtb2R1bGUgaWQgPSA0MTVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9yZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5cbnZhciBfcmVhY3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmVhY3QpO1xuXG52YXIgX2NsYXNzbmFtZXMgPSByZXF1aXJlKCdjbGFzc25hbWVzJyk7XG5cbnZhciBfY2xhc3NuYW1lczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jbGFzc25hbWVzKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgXCJkZWZhdWx0XCI6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9kZWZhdWx0cyhvYmosIGRlZmF1bHRzKSB7IHZhciBrZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoZGVmYXVsdHMpOyBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHsgdmFyIGtleSA9IGtleXNbaV07IHZhciB2YWx1ZSA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZGVmYXVsdHMsIGtleSk7IGlmICh2YWx1ZSAmJiB2YWx1ZS5jb25maWd1cmFibGUgJiYgb2JqW2tleV0gPT09IHVuZGVmaW5lZCkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKTsgfSB9IHJldHVybiBvYmo7IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogX2RlZmF1bHRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKTsgfVxuXG52YXIgUk9XID0gNDtcbnZhciBDT0wgPSAzO1xuXG5mdW5jdGlvbiBjaG9vc2VNb250aChtb250aCkge1xuICB2YXIgbmV4dCA9IHRoaXMuc3RhdGUudmFsdWUuY2xvbmUoKTtcbiAgbmV4dC5yb2xsU2V0TW9udGgobW9udGgpO1xuICB0aGlzLnNldEFuZFNlbGVjdFZhbHVlKG5leHQpO1xufVxuXG5mdW5jdGlvbiBub29wKCkge31cblxudmFyIE1vbnRoVGFibGUgPSBmdW5jdGlvbiAoX0NvbXBvbmVudCkge1xuICBfaW5oZXJpdHMoTW9udGhUYWJsZSwgX0NvbXBvbmVudCk7XG5cbiAgZnVuY3Rpb24gTW9udGhUYWJsZShwcm9wcykge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBNb250aFRhYmxlKTtcblxuICAgIHZhciBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9Db21wb25lbnQuY2FsbCh0aGlzLCBwcm9wcykpO1xuXG4gICAgX3RoaXMuc3RhdGUgPSB7XG4gICAgICB2YWx1ZTogcHJvcHMudmFsdWVcbiAgICB9O1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIE1vbnRoVGFibGUucHJvdG90eXBlLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgPSBmdW5jdGlvbiBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKG5leHRQcm9wcykge1xuICAgIGlmICgndmFsdWUnIGluIG5leHRQcm9wcykge1xuICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgIHZhbHVlOiBuZXh0UHJvcHMudmFsdWVcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcblxuICBNb250aFRhYmxlLnByb3RvdHlwZS5nZXRNb250aHMgPSBmdW5jdGlvbiBnZXRNb250aHMoKSB7XG4gICAgdmFyIHByb3BzID0gdGhpcy5wcm9wcztcbiAgICB2YXIgdmFsdWUgPSB0aGlzLnN0YXRlLnZhbHVlO1xuICAgIHZhciBjdXJyZW50ID0gdmFsdWUuY2xvbmUoKTtcbiAgICB2YXIgbG9jYWxlID0gcHJvcHMubG9jYWxlO1xuICAgIHZhciBtb250aHMgPSBbXTtcbiAgICB2YXIgc2hvcnRNb250aHMgPSBsb2NhbGUuZm9ybWF0LnNob3J0TW9udGhzO1xuICAgIHZhciBpbmRleCA9IDA7XG4gICAgZm9yICh2YXIgcm93SW5kZXggPSAwOyByb3dJbmRleCA8IFJPVzsgcm93SW5kZXgrKykge1xuICAgICAgbW9udGhzW3Jvd0luZGV4XSA9IFtdO1xuICAgICAgZm9yICh2YXIgY29sSW5kZXggPSAwOyBjb2xJbmRleCA8IENPTDsgY29sSW5kZXgrKykge1xuICAgICAgICBjdXJyZW50LnJvbGxTZXRNb250aChpbmRleCk7XG4gICAgICAgIG1vbnRoc1tyb3dJbmRleF1bY29sSW5kZXhdID0ge1xuICAgICAgICAgIHZhbHVlOiBpbmRleCxcbiAgICAgICAgICBjb250ZW50OiBzaG9ydE1vbnRoc1tpbmRleF0sXG4gICAgICAgICAgdGl0bGU6IHNob3J0TW9udGhzW2luZGV4XVxuICAgICAgICB9O1xuICAgICAgICBpbmRleCsrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbW9udGhzO1xuICB9O1xuXG4gIE1vbnRoVGFibGUucHJvdG90eXBlLnNldEFuZFNlbGVjdFZhbHVlID0gZnVuY3Rpb24gc2V0QW5kU2VsZWN0VmFsdWUodmFsdWUpIHtcbiAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgIHZhbHVlOiB2YWx1ZVxuICAgIH0pO1xuICAgIHRoaXMucHJvcHMub25TZWxlY3QodmFsdWUpO1xuICB9O1xuXG4gIE1vbnRoVGFibGUucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgIHZhciBwcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgdmFyIHZhbHVlID0gdGhpcy5zdGF0ZS52YWx1ZTtcbiAgICB2YXIgdG9kYXkgPSB2YWx1ZS5jbG9uZSgpO1xuICAgIHRvZGF5LnNldFRpbWUoRGF0ZS5ub3coKSk7XG4gICAgdmFyIG1vbnRocyA9IHRoaXMuZ2V0TW9udGhzKCk7XG4gICAgdmFyIGN1cnJlbnRNb250aCA9IHZhbHVlLmdldE1vbnRoKCk7XG4gICAgdmFyIHByZWZpeENscyA9IHByb3BzLnByZWZpeENscztcbiAgICB2YXIgbG9jYWxlID0gcHJvcHMubG9jYWxlO1xuICAgIHZhciBjb250ZW50UmVuZGVyID0gcHJvcHMuY29udGVudFJlbmRlcjtcbiAgICB2YXIgY2VsbFJlbmRlciA9IHByb3BzLmNlbGxSZW5kZXI7XG5cbiAgICB2YXIgbW9udGhzRWxzID0gbW9udGhzLm1hcChmdW5jdGlvbiAobW9udGgsIGluZGV4KSB7XG4gICAgICB2YXIgdGRzID0gbW9udGgubWFwKGZ1bmN0aW9uIChtb250aERhdGEpIHtcbiAgICAgICAgdmFyIF9jbGFzc05hbWVNYXA7XG5cbiAgICAgICAgdmFyIGRpc2FibGVkID0gZmFsc2U7XG4gICAgICAgIGlmIChwcm9wcy5kaXNhYmxlZERhdGUpIHtcbiAgICAgICAgICB2YXIgdGVzdFZhbHVlID0gdmFsdWUuY2xvbmUoKTtcbiAgICAgICAgICB0ZXN0VmFsdWUucm9sbFNldE1vbnRoKG1vbnRoRGF0YS52YWx1ZSk7XG4gICAgICAgICAgZGlzYWJsZWQgPSBwcm9wcy5kaXNhYmxlZERhdGUodGVzdFZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY2xhc3NOYW1lTWFwID0gKF9jbGFzc05hbWVNYXAgPSB7fSwgX2RlZmluZVByb3BlcnR5KF9jbGFzc05hbWVNYXAsIHByZWZpeENscyArICctY2VsbCcsIDEpLCBfZGVmaW5lUHJvcGVydHkoX2NsYXNzTmFtZU1hcCwgcHJlZml4Q2xzICsgJy1jZWxsLWRpc2FibGVkJywgZGlzYWJsZWQpLCBfZGVmaW5lUHJvcGVydHkoX2NsYXNzTmFtZU1hcCwgcHJlZml4Q2xzICsgJy1zZWxlY3RlZC1jZWxsJywgbW9udGhEYXRhLnZhbHVlID09PSBjdXJyZW50TW9udGgpLCBfZGVmaW5lUHJvcGVydHkoX2NsYXNzTmFtZU1hcCwgcHJlZml4Q2xzICsgJy1jdXJyZW50LWNlbGwnLCB0b2RheS5nZXRZZWFyKCkgPT09IHZhbHVlLmdldFllYXIoKSAmJiBtb250aERhdGEudmFsdWUgPT09IHRvZGF5LmdldE1vbnRoKCkpLCBfY2xhc3NOYW1lTWFwKTtcbiAgICAgICAgdmFyIGNlbGxFbCA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKGNlbGxSZW5kZXIpIHtcbiAgICAgICAgICB2YXIgY3VycmVudFZhbHVlID0gdmFsdWUuY2xvbmUoKTtcbiAgICAgICAgICBjdXJyZW50VmFsdWUucm9sbFNldE1vbnRoKG1vbnRoRGF0YS52YWx1ZSk7XG4gICAgICAgICAgY2VsbEVsID0gY2VsbFJlbmRlcihjdXJyZW50VmFsdWUsIGxvY2FsZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIGNvbnRlbnQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgaWYgKGNvbnRlbnRSZW5kZXIpIHtcbiAgICAgICAgICAgIHZhciBfY3VycmVudFZhbHVlID0gdmFsdWUuY2xvbmUoKTtcbiAgICAgICAgICAgIF9jdXJyZW50VmFsdWUucm9sbFNldE1vbnRoKG1vbnRoRGF0YS52YWx1ZSk7XG4gICAgICAgICAgICBjb250ZW50ID0gY29udGVudFJlbmRlcihfY3VycmVudFZhbHVlLCBsb2NhbGUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb250ZW50ID0gbW9udGhEYXRhLmNvbnRlbnQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNlbGxFbCA9IF9yZWFjdDJbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgICAnZGl2JyxcbiAgICAgICAgICAgIHsgY2xhc3NOYW1lOiBwcmVmaXhDbHMgKyAnLW1vbnRoJyB9LFxuICAgICAgICAgICAgY29udGVudFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF9yZWFjdDJbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgJ3RkJyxcbiAgICAgICAgICB7XG4gICAgICAgICAgICByb2xlOiAnZ3JpZGNlbGwnLFxuICAgICAgICAgICAga2V5OiBtb250aERhdGEudmFsdWUsXG4gICAgICAgICAgICBvbkNsaWNrOiBkaXNhYmxlZCA/IG51bGwgOiBjaG9vc2VNb250aC5iaW5kKF90aGlzMiwgbW9udGhEYXRhLnZhbHVlKSxcbiAgICAgICAgICAgIHRpdGxlOiBtb250aERhdGEudGl0bGUsXG4gICAgICAgICAgICBjbGFzc05hbWU6ICgwLCBfY2xhc3NuYW1lczJbXCJkZWZhdWx0XCJdKShjbGFzc05hbWVNYXApXG4gICAgICAgICAgfSxcbiAgICAgICAgICBjZWxsRWxcbiAgICAgICAgKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIF9yZWFjdDJbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICd0cicsXG4gICAgICAgIHsga2V5OiBpbmRleCwgcm9sZTogJ3JvdycgfSxcbiAgICAgICAgdGRzXG4gICAgICApO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIF9yZWFjdDJbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXG4gICAgICAndGFibGUnLFxuICAgICAgeyBjbGFzc05hbWU6IHByZWZpeENscyArICctdGFibGUnLCBjZWxsU3BhY2luZzogJzAnLCByb2xlOiAnZ3JpZCcgfSxcbiAgICAgIF9yZWFjdDJbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICd0Ym9keScsXG4gICAgICAgIHsgY2xhc3NOYW1lOiBwcmVmaXhDbHMgKyAnLXRib2R5JyB9LFxuICAgICAgICBtb250aHNFbHNcbiAgICAgIClcbiAgICApO1xuICB9O1xuXG4gIHJldHVybiBNb250aFRhYmxlO1xufShfcmVhY3QuQ29tcG9uZW50KTtcblxuTW9udGhUYWJsZS5kZWZhdWx0UHJvcHMgPSB7XG4gIG9uU2VsZWN0OiBub29wXG59O1xuTW9udGhUYWJsZS5wcm9wVHlwZXMgPSB7XG4gIG9uU2VsZWN0OiBfcmVhY3QuUHJvcFR5cGVzLmZ1bmMsXG4gIGNlbGxSZW5kZXI6IF9yZWFjdC5Qcm9wVHlwZXMuZnVuYyxcbiAgcHJlZml4Q2xzOiBfcmVhY3QuUHJvcFR5cGVzLnN0cmluZyxcbiAgdmFsdWU6IF9yZWFjdC5Qcm9wVHlwZXMub2JqZWN0XG59O1xuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBNb250aFRhYmxlO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vdXhjb3JlLWZvcm0vfi91eGNvcmUtZGF0ZS1mb3JtLWZpZWxkL34vdXhjb3JlLWNhbGVuZGFyL34vcmMtY2FsZW5kYXIvbGliL21vbnRoL01vbnRoVGFibGUuanNcbiAqKiBtb2R1bGUgaWQgPSA0MTZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcblxudmFyIF9yZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5cbnZhciBfcmVhY3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmVhY3QpO1xuXG52YXIgX3JlYWN0RG9tID0gcmVxdWlyZSgncmVhY3QtZG9tJyk7XG5cbnZhciBfcmVhY3REb20yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmVhY3REb20pO1xuXG52YXIgX3JjVXRpbCA9IHJlcXVpcmUoJ3JjLXV0aWwnKTtcblxudmFyIF9yY1V0aWwyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmNVdGlsKTtcblxudmFyIF9Ub2RheUJ1dHRvbiA9IHJlcXVpcmUoJy4uL2NhbGVuZGFyL1RvZGF5QnV0dG9uJyk7XG5cbnZhciBfVG9kYXlCdXR0b24yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfVG9kYXlCdXR0b24pO1xuXG52YXIgX09rQnV0dG9uID0gcmVxdWlyZSgnLi4vY2FsZW5kYXIvT2tCdXR0b24nKTtcblxudmFyIF9Pa0J1dHRvbjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9Pa0J1dHRvbik7XG5cbnZhciBfaW5kZXggPSByZXF1aXJlKCcuLi91dGlsL2luZGV4Jyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IFwiZGVmYXVsdFwiOiBvYmogfTsgfVxuXG52YXIgdG9GcmFnbWVudCA9IF9yY1V0aWwyW1wiZGVmYXVsdFwiXS5DaGlsZHJlbi5tYXBTZWxmO1xuXG5cbnZhciBDYWxlbmRhckZvb3RlciA9IF9yZWFjdDJbXCJkZWZhdWx0XCJdLmNyZWF0ZUNsYXNzKHtcbiAgZGlzcGxheU5hbWU6ICdDYWxlbmRhckZvb3RlcicsXG5cbiAgcHJvcFR5cGVzOiB7XG4gICAgcHJlZml4Q2xzOiBfcmVhY3QuUHJvcFR5cGVzLnN0cmluZyxcbiAgICBzaG93RGF0ZUlucHV0OiBfcmVhY3QuUHJvcFR5cGVzLmJvb2wsXG4gICAgZGlzYWJsZWRUaW1lOiBfcmVhY3QuUHJvcFR5cGVzLmFueSxcbiAgICBncmVnb3JpYW5DYWxlbmRhckxvY2FsZTogX3JlYWN0LlByb3BUeXBlcy5vYmplY3QsXG4gICAgc2VsZWN0ZWRWYWx1ZTogX3JlYWN0LlByb3BUeXBlcy5hbnksXG4gICAgc2hvd09rOiBfcmVhY3QuUHJvcFR5cGVzLmJvb2wsXG4gICAgb25TZWxlY3Q6IF9yZWFjdC5Qcm9wVHlwZXMuZnVuYyxcbiAgICB2YWx1ZTogX3JlYWN0LlByb3BUeXBlcy5vYmplY3QsXG4gICAgZGVmYXVsdFZhbHVlOiBfcmVhY3QuUHJvcFR5cGVzLm9iamVjdFxuICB9LFxuXG4gIG9uU2VsZWN0OiBmdW5jdGlvbiBvblNlbGVjdCh2YWx1ZSkge1xuICAgIHRoaXMucHJvcHMub25TZWxlY3QodmFsdWUpO1xuICB9LFxuICBnZXRSb290RE9NTm9kZTogZnVuY3Rpb24gZ2V0Um9vdERPTU5vZGUoKSB7XG4gICAgcmV0dXJuIF9yZWFjdERvbTJbXCJkZWZhdWx0XCJdLmZpbmRET01Ob2RlKHRoaXMpO1xuICB9LFxuICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICB2YXIgcHJvcHMgPSB0aGlzLnByb3BzO1xuICAgIHZhciB2YWx1ZSA9IHByb3BzLnZhbHVlO1xuICAgIHZhciBwcmVmaXhDbHMgPSBwcm9wcy5wcmVmaXhDbHM7XG4gICAgdmFyIHNob3dEYXRlSW5wdXQgPSBwcm9wcy5zaG93RGF0ZUlucHV0O1xuICAgIHZhciBkaXNhYmxlZFRpbWUgPSBwcm9wcy5kaXNhYmxlZFRpbWU7XG4gICAgdmFyIGdyZWdvcmlhbkNhbGVuZGFyTG9jYWxlID0gcHJvcHMuZ3JlZ29yaWFuQ2FsZW5kYXJMb2NhbGU7XG4gICAgdmFyIHNlbGVjdGVkVmFsdWUgPSBwcm9wcy5zZWxlY3RlZFZhbHVlO1xuICAgIHZhciBzaG93T2sgPSBwcm9wcy5zaG93T2s7XG5cbiAgICB2YXIgdGltZVBpY2tlciA9ICFzaG93RGF0ZUlucHV0ICYmIHByb3BzLnRpbWVQaWNrZXIgfHwgbnVsbDtcbiAgICB2YXIgZGlzYWJsZWRUaW1lQ29uZmlnID0gZGlzYWJsZWRUaW1lICYmIHRpbWVQaWNrZXIgPyAoMCwgX2luZGV4LmdldFRpbWVDb25maWcpKHNlbGVjdGVkVmFsdWUsIGRpc2FibGVkVGltZSkgOiBudWxsO1xuICAgIHZhciBmb290ZXJFbCA9IG51bGw7XG4gICAgaWYgKHByb3BzLnNob3dUb2RheSB8fCB0aW1lUGlja2VyKSB7XG4gICAgICB2YXIgbm93RWwgPSB1bmRlZmluZWQ7XG4gICAgICBpZiAocHJvcHMuc2hvd1RvZGF5KSB7XG4gICAgICAgIG5vd0VsID0gX3JlYWN0MltcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChfVG9kYXlCdXR0b24yW1wiZGVmYXVsdFwiXSwgX2V4dGVuZHMoe30sIHByb3BzLCB7IHZhbHVlOiB2YWx1ZSB9KSk7XG4gICAgICB9XG4gICAgICB2YXIgb2tCdG4gPSB1bmRlZmluZWQ7XG4gICAgICBpZiAoc2hvd09rID09PSB0cnVlIHx8IHNob3dPayAhPT0gZmFsc2UgJiYgISFwcm9wcy50aW1lUGlja2VyKSB7XG4gICAgICAgIG9rQnRuID0gX3JlYWN0MltcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChfT2tCdXR0b24yW1wiZGVmYXVsdFwiXSwgcHJvcHMpO1xuICAgICAgfVxuICAgICAgdmFyIGZvb3RlckJ0biA9IHVuZGVmaW5lZDtcbiAgICAgIGlmIChub3dFbCB8fCBva0J0bikge1xuICAgICAgICBmb290ZXJCdG4gPSBfcmVhY3QyW1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICdzcGFuJyxcbiAgICAgICAgICB7IGNsYXNzTmFtZTogcHJlZml4Q2xzICsgJy1mb290ZXItYnRuJyB9LFxuICAgICAgICAgIHRvRnJhZ21lbnQoW25vd0VsLCBva0J0bl0pXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBpZiAodGltZVBpY2tlcikge1xuICAgICAgICB0aW1lUGlja2VyID0gX3JlYWN0MltcImRlZmF1bHRcIl0uY2xvbmVFbGVtZW50KHRpbWVQaWNrZXIsIF9leHRlbmRzKHtcbiAgICAgICAgICBvbkNoYW5nZTogdGhpcy5vblNlbGVjdCxcbiAgICAgICAgICBhbGxvd0VtcHR5OiBmYWxzZSxcbiAgICAgICAgICBncmVnb3JpYW5DYWxlbmRhckxvY2FsZTogZ3JlZ29yaWFuQ2FsZW5kYXJMb2NhbGVcbiAgICAgICAgfSwgZGlzYWJsZWRUaW1lQ29uZmlnLCB7XG4gICAgICAgICAgZ2V0UG9wdXBDb250YWluZXI6IHRoaXMuZ2V0Um9vdERPTU5vZGUsXG4gICAgICAgICAgdmFsdWU6IHNlbGVjdGVkVmFsdWVcbiAgICAgICAgfSkpO1xuICAgICAgfVxuICAgICAgZm9vdGVyRWwgPSBfcmVhY3QyW1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFxuICAgICAgICAnZGl2JyxcbiAgICAgICAgeyBjbGFzc05hbWU6IHByZWZpeENscyArICctZm9vdGVyJyB9LFxuICAgICAgICB0aW1lUGlja2VyLFxuICAgICAgICBmb290ZXJCdG5cbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiBmb290ZXJFbDtcbiAgfVxufSk7XG5cbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gQ2FsZW5kYXJGb290ZXI7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi91eGNvcmUtZm9ybS9+L3V4Y29yZS1kYXRlLWZvcm0tZmllbGQvfi91eGNvcmUtY2FsZW5kYXIvfi9yYy1jYWxlbmRhci9saWIvY2FsZW5kYXIvQ2FsZW5kYXJGb290ZXIuanNcbiAqKiBtb2R1bGUgaWQgPSA0MTdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gVG9kYXlCdXR0b247XG5cbnZhciBfcmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xuXG52YXIgX3JlYWN0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JlYWN0KTtcblxudmFyIF91dGlsID0gcmVxdWlyZSgnLi4vdXRpbC8nKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgXCJkZWZhdWx0XCI6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIFRvZGF5QnV0dG9uKF9yZWYpIHtcbiAgdmFyIHByZWZpeENscyA9IF9yZWYucHJlZml4Q2xzO1xuICB2YXIgbG9jYWxlID0gX3JlZi5sb2NhbGU7XG4gIHZhciB2YWx1ZSA9IF9yZWYudmFsdWU7XG4gIHZhciB0aW1lUGlja2VyID0gX3JlZi50aW1lUGlja2VyO1xuICB2YXIgZGlzYWJsZWREYXRlID0gX3JlZi5kaXNhYmxlZERhdGU7XG4gIHZhciBkaXNhYmxlZFRpbWUgPSBfcmVmLmRpc2FibGVkVGltZTtcbiAgdmFyIG9uVG9kYXkgPSBfcmVmLm9uVG9kYXk7XG4gIHZhciB0ZXh0ID0gX3JlZi50ZXh0O1xuXG4gIHZhciBkaXNhYmxlZFRvZGF5ID0gZmFsc2U7XG4gIHZhciBsb2NhbGVOb3cgPSB0ZXh0O1xuICBpZiAoIWxvY2FsZU5vdyAmJiB0aW1lUGlja2VyKSB7XG4gICAgbG9jYWxlTm93ID0gbG9jYWxlLm5vdztcbiAgfVxuICBsb2NhbGVOb3cgPSBsb2NhbGVOb3cgfHwgbG9jYWxlLnRvZGF5O1xuICB2YXIgZGlzYWJsZWRUb2RheUNsYXNzID0gJyc7XG4gIGlmIChkaXNhYmxlZERhdGUpIHtcbiAgICBkaXNhYmxlZFRvZGF5ID0gISgwLCBfdXRpbC5pc0FsbG93ZWREYXRlKSgoMCwgX3V0aWwuZ2V0VG9kYXlUaW1lKSh2YWx1ZSksIGRpc2FibGVkRGF0ZSwgZGlzYWJsZWRUaW1lKTtcbiAgICBpZiAoZGlzYWJsZWRUb2RheSkge1xuICAgICAgZGlzYWJsZWRUb2RheUNsYXNzID0gcHJlZml4Q2xzICsgJy10b2RheS1idG4tZGlzYWJsZWQnO1xuICAgIH1cbiAgfVxuICByZXR1cm4gX3JlYWN0MltcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChcbiAgICAnYScsXG4gICAge1xuICAgICAgY2xhc3NOYW1lOiBwcmVmaXhDbHMgKyAnLXRvZGF5LWJ0biAnICsgZGlzYWJsZWRUb2RheUNsYXNzLFxuICAgICAgcm9sZTogJ2J1dHRvbicsXG4gICAgICBvbkNsaWNrOiBkaXNhYmxlZFRvZGF5ID8gbnVsbCA6IG9uVG9kYXksXG4gICAgICB0aXRsZTogKDAsIF91dGlsLmdldFRvZGF5VGltZVN0cikodmFsdWUpXG4gICAgfSxcbiAgICBsb2NhbGVOb3dcbiAgKTtcbn1cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3V4Y29yZS1mb3JtL34vdXhjb3JlLWRhdGUtZm9ybS1maWVsZC9+L3V4Y29yZS1jYWxlbmRhci9+L3JjLWNhbGVuZGFyL2xpYi9jYWxlbmRhci9Ub2RheUJ1dHRvbi5qc1xuICoqIG1vZHVsZSBpZCA9IDQxOFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IE9rQnV0dG9uO1xuXG52YXIgX3JlYWN0ID0gcmVxdWlyZShcInJlYWN0XCIpO1xuXG52YXIgX3JlYWN0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JlYWN0KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgXCJkZWZhdWx0XCI6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIE9rQnV0dG9uKF9yZWYpIHtcbiAgdmFyIHByZWZpeENscyA9IF9yZWYucHJlZml4Q2xzO1xuICB2YXIgbG9jYWxlID0gX3JlZi5sb2NhbGU7XG4gIHZhciBva0Rpc2FibGVkID0gX3JlZi5va0Rpc2FibGVkO1xuICB2YXIgb25PayA9IF9yZWYub25PaztcblxuICB2YXIgY2xhc3NOYW1lID0gcHJlZml4Q2xzICsgXCItb2stYnRuXCI7XG4gIGlmIChva0Rpc2FibGVkKSB7XG4gICAgY2xhc3NOYW1lICs9IFwiIFwiICsgcHJlZml4Q2xzICsgXCItb2stYnRuLWRpc2FibGVkXCI7XG4gIH1cbiAgcmV0dXJuIF9yZWFjdDJbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXG4gICAgXCJhXCIsXG4gICAge1xuICAgICAgY2xhc3NOYW1lOiBjbGFzc05hbWUsXG4gICAgICByb2xlOiBcImJ1dHRvblwiLFxuICAgICAgb25DbGljazogb2tEaXNhYmxlZCA/IG51bGwgOiBvbk9rXG4gICAgfSxcbiAgICBsb2NhbGUub2tcbiAgKTtcbn1cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3V4Y29yZS1mb3JtL34vdXhjb3JlLWRhdGUtZm9ybS1maWVsZC9+L3V4Y29yZS1jYWxlbmRhci9+L3JjLWNhbGVuZGFyL2xpYi9jYWxlbmRhci9Pa0J1dHRvbi5qc1xuICoqIG1vZHVsZSBpZCA9IDQxOVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX3JlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxudmFyIF9yZWFjdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yZWFjdCk7XG5cbnZhciBfY2xhc3NuYW1lcyA9IHJlcXVpcmUoJ2NsYXNzbmFtZXMnKTtcblxudmFyIF9jbGFzc25hbWVzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NsYXNzbmFtZXMpO1xuXG52YXIgX2dyZWdvcmlhbkNhbGVuZGFyID0gcmVxdWlyZSgnZ3JlZ29yaWFuLWNhbGVuZGFyJyk7XG5cbnZhciBfZ3JlZ29yaWFuQ2FsZW5kYXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZ3JlZ29yaWFuQ2FsZW5kYXIpO1xuXG52YXIgX2luZGV4ID0gcmVxdWlyZSgnLi4vdXRpbC9pbmRleCcpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBcImRlZmF1bHRcIjogb2JqIH07IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbmZ1bmN0aW9uIGdldE5vdygpIHtcbiAgdmFyIHZhbHVlID0gbmV3IF9ncmVnb3JpYW5DYWxlbmRhcjJbXCJkZWZhdWx0XCJdKCk7XG4gIHZhbHVlLnNldFRpbWUoRGF0ZS5ub3coKSk7XG4gIHJldHVybiB2YWx1ZTtcbn1cblxuZnVuY3Rpb24gZ2V0Tm93QnlDdXJyZW50U3RhdGVWYWx1ZSh2YWx1ZSkge1xuICB2YXIgcmV0ID0gdW5kZWZpbmVkO1xuICBpZiAodmFsdWUpIHtcbiAgICByZXQgPSB2YWx1ZS5jbG9uZSgpO1xuICAgIHJldC5zZXRUaW1lKERhdGUubm93KCkpO1xuICB9IGVsc2Uge1xuICAgIHJldCA9IGdldE5vdygpO1xuICB9XG4gIHJldHVybiByZXQ7XG59XG5cbnZhciBDYWxlbmRhck1peGluID0ge1xuICBwcm9wVHlwZXM6IHtcbiAgICB2YWx1ZTogX3JlYWN0LlByb3BUeXBlcy5vYmplY3QsXG4gICAgZGVmYXVsdFZhbHVlOiBfcmVhY3QuUHJvcFR5cGVzLm9iamVjdCxcbiAgICBvbktleURvd246IF9yZWFjdC5Qcm9wVHlwZXMuZnVuY1xuICB9LFxuXG4gIGdldERlZmF1bHRQcm9wczogZnVuY3Rpb24gZ2V0RGVmYXVsdFByb3BzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBvbktleURvd246IG5vb3BcbiAgICB9O1xuICB9LFxuICBnZXRJbml0aWFsU3RhdGU6IGZ1bmN0aW9uIGdldEluaXRpYWxTdGF0ZSgpIHtcbiAgICB2YXIgcHJvcHMgPSB0aGlzLnByb3BzO1xuICAgIHZhciB2YWx1ZSA9IHByb3BzLnZhbHVlIHx8IHByb3BzLmRlZmF1bHRWYWx1ZSB8fCBnZXROb3coKTtcbiAgICByZXR1cm4ge1xuICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgc2VsZWN0ZWRWYWx1ZTogcHJvcHMuc2VsZWN0ZWRWYWx1ZSB8fCBwcm9wcy5kZWZhdWx0U2VsZWN0ZWRWYWx1ZVxuICAgIH07XG4gIH0sXG4gIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHM6IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMobmV4dFByb3BzKSB7XG4gICAgdmFyIHZhbHVlID0gbmV4dFByb3BzLnZhbHVlO1xuICAgIHZhciBzZWxlY3RlZFZhbHVlID0gbmV4dFByb3BzLnNlbGVjdGVkVmFsdWU7XG5cbiAgICBpZiAoJ3ZhbHVlJyBpbiBuZXh0UHJvcHMpIHtcbiAgICAgIHZhbHVlID0gdmFsdWUgfHwgbmV4dFByb3BzLmRlZmF1bHRWYWx1ZSB8fCBnZXROb3dCeUN1cnJlbnRTdGF0ZVZhbHVlKHRoaXMuc3RhdGUudmFsdWUpO1xuICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmICgnc2VsZWN0ZWRWYWx1ZScgaW4gbmV4dFByb3BzKSB7XG4gICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgc2VsZWN0ZWRWYWx1ZTogc2VsZWN0ZWRWYWx1ZVxuICAgICAgfSk7XG4gICAgfVxuICB9LFxuICBvblNlbGVjdDogZnVuY3Rpb24gb25TZWxlY3QodmFsdWUsIGNhdXNlKSB7XG4gICAgaWYgKHZhbHVlKSB7XG4gICAgICB0aGlzLnNldFZhbHVlKHZhbHVlKTtcbiAgICB9XG4gICAgdGhpcy5zZXRTZWxlY3RlZFZhbHVlKHZhbHVlLCBjYXVzZSk7XG4gIH0sXG4gIHJlbmRlclJvb3Q6IGZ1bmN0aW9uIHJlbmRlclJvb3QobmV3UHJvcHMpIHtcbiAgICB2YXIgX2NsYXNzTmFtZTtcblxuICAgIHZhciBwcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgdmFyIHByZWZpeENscyA9IHByb3BzLnByZWZpeENscztcblxuICAgIHZhciBjbGFzc05hbWUgPSAoX2NsYXNzTmFtZSA9IHt9LCBfZGVmaW5lUHJvcGVydHkoX2NsYXNzTmFtZSwgcHJlZml4Q2xzLCAxKSwgX2RlZmluZVByb3BlcnR5KF9jbGFzc05hbWUsIHByZWZpeENscyArICctaGlkZGVuJywgIXByb3BzLnZpc2libGUpLCBfZGVmaW5lUHJvcGVydHkoX2NsYXNzTmFtZSwgcHJvcHMuY2xhc3NOYW1lLCAhIXByb3BzLmNsYXNzTmFtZSksIF9kZWZpbmVQcm9wZXJ0eShfY2xhc3NOYW1lLCBuZXdQcm9wcy5jbGFzc05hbWUsICEhbmV3UHJvcHMuY2xhc3NOYW1lKSwgX2NsYXNzTmFtZSk7XG5cbiAgICByZXR1cm4gX3JlYWN0MltcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChcbiAgICAgICdkaXYnLFxuICAgICAge1xuICAgICAgICBjbGFzc05hbWU6ICcnICsgKDAsIF9jbGFzc25hbWVzMltcImRlZmF1bHRcIl0pKGNsYXNzTmFtZSksXG4gICAgICAgIHN0eWxlOiB0aGlzLnByb3BzLnN0eWxlLFxuICAgICAgICB0YWJJbmRleDogJzAnLCBvbktleURvd246IHRoaXMub25LZXlEb3duXG4gICAgICB9LFxuICAgICAgbmV3UHJvcHMuY2hpbGRyZW5cbiAgICApO1xuICB9LFxuICBzZXRTZWxlY3RlZFZhbHVlOiBmdW5jdGlvbiBzZXRTZWxlY3RlZFZhbHVlKHNlbGVjdGVkVmFsdWUsIGNhdXNlKSB7XG4gICAgaWYgKHRoaXMuaXNBbGxvd2VkRGF0ZShzZWxlY3RlZFZhbHVlKSkge1xuICAgICAgaWYgKCEoJ3NlbGVjdGVkVmFsdWUnIGluIHRoaXMucHJvcHMpKSB7XG4gICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgIHNlbGVjdGVkVmFsdWU6IHNlbGVjdGVkVmFsdWVcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICB0aGlzLnByb3BzLm9uU2VsZWN0KHNlbGVjdGVkVmFsdWUsIGNhdXNlKTtcbiAgICB9XG4gIH0sXG4gIHNldFZhbHVlOiBmdW5jdGlvbiBzZXRWYWx1ZSh2YWx1ZSkge1xuICAgIHZhciBvcmlnaW5hbFZhbHVlID0gdGhpcy5zdGF0ZS52YWx1ZTtcbiAgICBpZiAoISgndmFsdWUnIGluIHRoaXMucHJvcHMpKSB7XG4gICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKG9yaWdpbmFsVmFsdWUgJiYgdmFsdWUgJiYgb3JpZ2luYWxWYWx1ZS5nZXRUaW1lKCkgIT09IHZhbHVlLmdldFRpbWUoKSB8fCAhb3JpZ2luYWxWYWx1ZSAmJiB2YWx1ZSB8fCBvcmlnaW5hbFZhbHVlICYmICF2YWx1ZSkge1xuICAgICAgdGhpcy5wcm9wcy5vbkNoYW5nZSh2YWx1ZSk7XG4gICAgfVxuICB9LFxuICBpc0FsbG93ZWREYXRlOiBmdW5jdGlvbiBpc0FsbG93ZWREYXRlKHZhbHVlKSB7XG4gICAgdmFyIGRpc2FibGVkRGF0ZSA9IHRoaXMucHJvcHMuZGlzYWJsZWREYXRlO1xuICAgIHZhciBkaXNhYmxlZFRpbWUgPSB0aGlzLnByb3BzLmRpc2FibGVkVGltZTtcbiAgICByZXR1cm4gKDAsIF9pbmRleC5pc0FsbG93ZWREYXRlKSh2YWx1ZSwgZGlzYWJsZWREYXRlLCBkaXNhYmxlZFRpbWUpO1xuICB9XG59O1xuXG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IENhbGVuZGFyTWl4aW47XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi91eGNvcmUtZm9ybS9+L3V4Y29yZS1kYXRlLWZvcm0tZmllbGQvfi91eGNvcmUtY2FsZW5kYXIvfi9yYy1jYWxlbmRhci9saWIvbWl4aW4vQ2FsZW5kYXJNaXhpbi5qc1xuICoqIG1vZHVsZSBpZCA9IDQyMFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX3JlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxudmFyIF9lbl9VUyA9IHJlcXVpcmUoJy4uL2xvY2FsZS9lbl9VUycpO1xuXG52YXIgX2VuX1VTMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2VuX1VTKTtcblxudmFyIF9pbmRleCA9IHJlcXVpcmUoJy4uL3V0aWwvaW5kZXgnKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgXCJkZWZhdWx0XCI6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IHtcbiAgcHJvcFR5cGVzOiB7XG4gICAgY2xhc3NOYW1lOiBfcmVhY3QuUHJvcFR5cGVzLnN0cmluZyxcbiAgICBsb2NhbGU6IF9yZWFjdC5Qcm9wVHlwZXMub2JqZWN0LFxuICAgIHN0eWxlOiBfcmVhY3QuUHJvcFR5cGVzLm9iamVjdCxcbiAgICB2aXNpYmxlOiBfcmVhY3QuUHJvcFR5cGVzLmJvb2wsXG4gICAgb25TZWxlY3Q6IF9yZWFjdC5Qcm9wVHlwZXMuZnVuYyxcbiAgICBwcmVmaXhDbHM6IF9yZWFjdC5Qcm9wVHlwZXMuc3RyaW5nLFxuICAgIG9uQ2hhbmdlOiBfcmVhY3QuUHJvcFR5cGVzLmZ1bmMsXG4gICAgb25PazogX3JlYWN0LlByb3BUeXBlcy5mdW5jXG4gIH0sXG5cbiAgZ2V0RGVmYXVsdFByb3BzOiBmdW5jdGlvbiBnZXREZWZhdWx0UHJvcHMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGxvY2FsZTogX2VuX1VTMltcImRlZmF1bHRcIl0sXG4gICAgICBzdHlsZToge30sXG4gICAgICB2aXNpYmxlOiB0cnVlLFxuICAgICAgcHJlZml4Q2xzOiAncmMtY2FsZW5kYXInLFxuICAgICAgZm9ybWF0dGVyOiAneXl5eS1NTS1kZCcsXG4gICAgICBjbGFzc05hbWU6ICcnLFxuICAgICAgb25TZWxlY3Q6IG5vb3AsXG4gICAgICBvbkNoYW5nZTogbm9vcCxcbiAgICAgIG9uQ2xlYXI6IG5vb3BcbiAgICB9O1xuICB9LFxuICBzaG91bGRDb21wb25lbnRVcGRhdGU6IGZ1bmN0aW9uIHNob3VsZENvbXBvbmVudFVwZGF0ZShuZXh0UHJvcHMpIHtcbiAgICByZXR1cm4gdGhpcy5wcm9wcy52aXNpYmxlIHx8IG5leHRQcm9wcy52aXNpYmxlO1xuICB9LFxuICBnZXRGb3JtYXR0ZXI6IGZ1bmN0aW9uIGdldEZvcm1hdHRlcigpIHtcbiAgICB2YXIgZm9ybWF0dGVyID0gdGhpcy5wcm9wcy5mb3JtYXR0ZXI7XG4gICAgdmFyIGxvY2FsZSA9IHRoaXMucHJvcHMubG9jYWxlO1xuICAgIGlmICh0aGlzLm5vcm1hbEZvcm1hdHRlciAmJiBmb3JtYXR0ZXIgPT09IHRoaXMubGFzdEZvcm1hdHRlcikge1xuICAgICAgcmV0dXJuIHRoaXMubm9ybWFsRm9ybWF0dGVyO1xuICAgIH1cbiAgICB0aGlzLm5vcm1hbEZvcm1hdHRlciA9ICgwLCBfaW5kZXguZ2V0Rm9ybWF0dGVyKShmb3JtYXR0ZXIsIGxvY2FsZSk7XG4gICAgdGhpcy5sYXN0Rm9ybWF0dGVyID0gZm9ybWF0dGVyO1xuICAgIHJldHVybiB0aGlzLm5vcm1hbEZvcm1hdHRlcjtcbiAgfVxufTtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3V4Y29yZS1mb3JtL34vdXhjb3JlLWRhdGUtZm9ybS1maWVsZC9+L3V4Y29yZS1jYWxlbmRhci9+L3JjLWNhbGVuZGFyL2xpYi9taXhpbi9Db21tb25NaXhpbi5qc1xuICoqIG1vZHVsZSBpZCA9IDQyMVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2VuX1VTID0gcmVxdWlyZSgnZ3JlZ29yaWFuLWNhbGVuZGFyLWZvcm1hdC9saWIvbG9jYWxlL2VuX1VTJyk7XG5cbnZhciBfZW5fVVMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZW5fVVMpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBcImRlZmF1bHRcIjogb2JqIH07IH1cblxuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSB7XG4gIHRvZGF5OiAnVG9kYXknLFxuICBub3c6ICdOb3cnLFxuICBiYWNrVG9Ub2RheTogJ0JhY2sgdG8gdG9kYXknLFxuICBvazogJ09rJyxcbiAgY2xlYXI6ICdDbGVhcicsXG4gIG1vbnRoOiAnTW9udGgnLFxuICB5ZWFyOiAnWWVhcicsXG4gIG1vbnRoU2VsZWN0OiAnQ2hvb3NlIGEgbW9udGgnLFxuICB5ZWFyU2VsZWN0OiAnQ2hvb3NlIGEgeWVhcicsXG4gIGRlY2FkZVNlbGVjdDogJ0Nob29zZSBhIGRlY2FkZScsXG4gIHllYXJGb3JtYXQ6ICd5eXl5JyxcbiAgZGF0ZUZvcm1hdDogJ00vZC95eXl5JyxcbiAgbW9udGhGb3JtYXQ6ICdNTU1NJyxcbiAgbW9udGhCZWZvcmVZZWFyOiB0cnVlLFxuICBwcmV2aW91c01vbnRoOiAnUHJldmlvdXMgbW9udGggKFBhZ2VVcCknLFxuICBuZXh0TW9udGg6ICdOZXh0IG1vbnRoIChQYWdlRG93biknLFxuICBwcmV2aW91c1llYXI6ICdMYXN0IHllYXIgKENvbnRyb2wgKyBsZWZ0KScsXG4gIG5leHRZZWFyOiAnTmV4dCB5ZWFyIChDb250cm9sICsgcmlnaHQpJyxcbiAgcHJldmlvdXNEZWNhZGU6ICdMYXN0IGRlY2FkZScsXG4gIG5leHREZWNhZGU6ICdOZXh0IGRlY2FkZScsXG4gIHByZXZpb3VzQ2VudHVyeTogJ0xhc3QgY2VudHVyeScsXG4gIG5leHRDZW50dXJ5OiAnTmV4dCBjZW50dXJ5JyxcbiAgZm9ybWF0OiBfZW5fVVMyW1wiZGVmYXVsdFwiXVxufTtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3V4Y29yZS1mb3JtL34vdXhjb3JlLWRhdGUtZm9ybS1maWVsZC9+L3V4Y29yZS1jYWxlbmRhci9+L3JjLWNhbGVuZGFyL2xpYi9sb2NhbGUvZW5fVVMuanNcbiAqKiBtb2R1bGUgaWQgPSA0MjJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcblxudmFyIF9yZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5cbnZhciBfcmVhY3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmVhY3QpO1xuXG52YXIgX3JlYWN0RG9tID0gcmVxdWlyZSgncmVhY3QtZG9tJyk7XG5cbnZhciBfcmVhY3REb20yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmVhY3REb20pO1xuXG52YXIgX2luZGV4ID0gcmVxdWlyZSgnLi4vdXRpbC9pbmRleCcpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBcImRlZmF1bHRcIjogb2JqIH07IH1cblxuZnVuY3Rpb24gY29weVRpbWUodGFyZ2V0LCBzb3VyY2UpIHtcbiAgaWYgKHNvdXJjZSkge1xuICAgIHRhcmdldC5zZXRIb3VyT2ZEYXkoc291cmNlLmdldEhvdXJPZkRheSgpKTtcbiAgICB0YXJnZXQuc2V0TWludXRlcyhzb3VyY2UuZ2V0TWludXRlcygpKTtcbiAgICB0YXJnZXQuc2V0U2Vjb25kcyhzb3VyY2UuZ2V0U2Vjb25kcygpKTtcbiAgfVxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG52YXIgRGF0ZUlucHV0ID0gX3JlYWN0MltcImRlZmF1bHRcIl0uY3JlYXRlQ2xhc3Moe1xuICBkaXNwbGF5TmFtZTogJ0RhdGVJbnB1dCcsXG5cbiAgcHJvcFR5cGVzOiB7XG4gICAgcHJlZml4Q2xzOiBfcmVhY3QuUHJvcFR5cGVzLnN0cmluZyxcbiAgICB0aW1lUGlja2VyOiBfcmVhY3QuUHJvcFR5cGVzLm9iamVjdCxcbiAgICBkaXNhYmxlZFRpbWU6IF9yZWFjdC5Qcm9wVHlwZXMuYW55LFxuICAgIGZvcm1hdHRlcjogX3JlYWN0LlByb3BUeXBlcy5vYmplY3QsXG4gICAgbG9jYWxlOiBfcmVhY3QuUHJvcFR5cGVzLm9iamVjdCxcbiAgICBncmVnb3JpYW5DYWxlbmRhckxvY2FsZTogX3JlYWN0LlByb3BUeXBlcy5vYmplY3QsXG4gICAgZGlzYWJsZWREYXRlOiBfcmVhY3QuUHJvcFR5cGVzLmZ1bmMsXG4gICAgb25DaGFuZ2U6IF9yZWFjdC5Qcm9wVHlwZXMuZnVuYyxcbiAgICBvbkNsZWFyOiBfcmVhY3QuUHJvcFR5cGVzLmZ1bmMsXG4gICAgcGxhY2Vob2xkZXI6IF9yZWFjdC5Qcm9wVHlwZXMuc3RyaW5nLFxuICAgIG9uU2VsZWN0OiBfcmVhY3QuUHJvcFR5cGVzLmZ1bmMsXG4gICAgc2VsZWN0ZWRWYWx1ZTogX3JlYWN0LlByb3BUeXBlcy5vYmplY3RcbiAgfSxcblxuICBnZXRJbml0aWFsU3RhdGU6IGZ1bmN0aW9uIGdldEluaXRpYWxTdGF0ZSgpIHtcbiAgICB2YXIgc2VsZWN0ZWRWYWx1ZSA9IHRoaXMucHJvcHMuc2VsZWN0ZWRWYWx1ZTtcbiAgICByZXR1cm4ge1xuICAgICAgc3RyOiBzZWxlY3RlZFZhbHVlICYmIHRoaXMucHJvcHMuZm9ybWF0dGVyLmZvcm1hdChzZWxlY3RlZFZhbHVlKSB8fCAnJyxcbiAgICAgIGludmFsaWQ6IGZhbHNlXG4gICAgfTtcbiAgfSxcbiAgY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wczogZnVuY3Rpb24gY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhuZXh0UHJvcHMpIHtcbiAgICAvLyB3aGVuIHBvcHVwIHNob3csIGNsaWNrIGJvZHkgd2lsbCBjYWxsIHRoaXMsIGJ1ZyFcbiAgICB2YXIgc2VsZWN0ZWRWYWx1ZSA9IG5leHRQcm9wcy5zZWxlY3RlZFZhbHVlO1xuICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgc3RyOiBzZWxlY3RlZFZhbHVlICYmIG5leHRQcm9wcy5mb3JtYXR0ZXIuZm9ybWF0KHNlbGVjdGVkVmFsdWUpIHx8ICcnLFxuICAgICAgaW52YWxpZDogZmFsc2VcbiAgICB9KTtcbiAgfSxcbiAgb25JbnB1dENoYW5nZTogZnVuY3Rpb24gb25JbnB1dENoYW5nZShldmVudCkge1xuICAgIHZhciBzdHIgPSBldmVudC50YXJnZXQudmFsdWU7XG4gICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICBzdHI6IHN0clxuICAgIH0pO1xuICAgIHZhciB2YWx1ZSA9IHVuZGVmaW5lZDtcbiAgICB2YXIgX3Byb3BzID0gdGhpcy5wcm9wcztcbiAgICB2YXIgZGlzYWJsZWREYXRlID0gX3Byb3BzLmRpc2FibGVkRGF0ZTtcbiAgICB2YXIgZm9ybWF0dGVyID0gX3Byb3BzLmZvcm1hdHRlcjtcbiAgICB2YXIgZ3JlZ29yaWFuQ2FsZW5kYXJMb2NhbGUgPSBfcHJvcHMuZ3JlZ29yaWFuQ2FsZW5kYXJMb2NhbGU7XG4gICAgdmFyIG9uQ2hhbmdlID0gX3Byb3BzLm9uQ2hhbmdlO1xuXG4gICAgaWYgKHN0cikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFsdWUgPSBjb3B5VGltZShmb3JtYXR0ZXIucGFyc2Uoc3RyLCB7XG4gICAgICAgICAgbG9jYWxlOiBncmVnb3JpYW5DYWxlbmRhckxvY2FsZSxcbiAgICAgICAgICBvYmV5Q291bnQ6IHRydWVcbiAgICAgICAgfSksIHRoaXMucHJvcHMuc2VsZWN0ZWRWYWx1ZSk7XG4gICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICBpbnZhbGlkOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAodmFsdWUgJiYgKCFkaXNhYmxlZERhdGUgfHwgIWRpc2FibGVkRGF0ZSh2YWx1ZSkpKSB7XG4gICAgICAgIHZhciBvcmlnaW5hbFZhbHVlID0gdGhpcy5wcm9wcy5zZWxlY3RlZFZhbHVlO1xuICAgICAgICBpZiAob3JpZ2luYWxWYWx1ZSAmJiB2YWx1ZSkge1xuICAgICAgICAgIGlmIChvcmlnaW5hbFZhbHVlLmdldFRpbWUoKSAhPT0gdmFsdWUuZ2V0VGltZSgpKSB7XG4gICAgICAgICAgICBvbkNoYW5nZSh2YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKG9yaWdpbmFsVmFsdWUgIT09IHZhbHVlKSB7XG4gICAgICAgICAgb25DaGFuZ2UodmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICBpbnZhbGlkOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG9uQ2hhbmdlKG51bGwpO1xuICAgIH1cbiAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgIGludmFsaWQ6IGZhbHNlXG4gICAgfSk7XG4gIH0sXG4gIG9uQ2xlYXI6IGZ1bmN0aW9uIG9uQ2xlYXIoKSB7XG4gICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICBzdHI6ICcnXG4gICAgfSk7XG4gICAgdGhpcy5wcm9wcy5vbkNsZWFyKG51bGwpO1xuICB9LFxuICBnZXRSb290RE9NTm9kZTogZnVuY3Rpb24gZ2V0Um9vdERPTU5vZGUoKSB7XG4gICAgcmV0dXJuIF9yZWFjdERvbTJbXCJkZWZhdWx0XCJdLmZpbmRET01Ob2RlKHRoaXMpO1xuICB9LFxuICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICB2YXIgcHJvcHMgPSB0aGlzLnByb3BzO1xuICAgIHZhciBfc3RhdGUgPSB0aGlzLnN0YXRlO1xuICAgIHZhciBpbnZhbGlkID0gX3N0YXRlLmludmFsaWQ7XG4gICAgdmFyIHN0ciA9IF9zdGF0ZS5zdHI7XG4gICAgdmFyIHNlbGVjdGVkVmFsdWUgPSBwcm9wcy5zZWxlY3RlZFZhbHVlO1xuICAgIHZhciBsb2NhbGUgPSBwcm9wcy5sb2NhbGU7XG4gICAgdmFyIHByZWZpeENscyA9IHByb3BzLnByZWZpeENscztcbiAgICB2YXIgcGxhY2Vob2xkZXIgPSBwcm9wcy5wbGFjZWhvbGRlcjtcbiAgICB2YXIgb25DaGFuZ2UgPSBwcm9wcy5vbkNoYW5nZTtcbiAgICB2YXIgdGltZVBpY2tlciA9IHByb3BzLnRpbWVQaWNrZXI7XG4gICAgdmFyIGRpc2FibGVkVGltZSA9IHByb3BzLmRpc2FibGVkVGltZTtcbiAgICB2YXIgZ3JlZ29yaWFuQ2FsZW5kYXJMb2NhbGUgPSBwcm9wcy5ncmVnb3JpYW5DYWxlbmRhckxvY2FsZTtcblxuICAgIHZhciBpbnZhbGlkQ2xhc3MgPSBpbnZhbGlkID8gcHJlZml4Q2xzICsgJy1pbnB1dC1pbnZhbGlkJyA6ICcnO1xuICAgIHZhciBkaXNhYmxlZFRpbWVDb25maWcgPSBkaXNhYmxlZFRpbWUgJiYgdGltZVBpY2tlciA/ICgwLCBfaW5kZXguZ2V0VGltZUNvbmZpZykoc2VsZWN0ZWRWYWx1ZSwgZGlzYWJsZWRUaW1lKSA6IG51bGw7XG4gICAgcmV0dXJuIF9yZWFjdDJbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXG4gICAgICAnZGl2JyxcbiAgICAgIHsgY2xhc3NOYW1lOiBwcmVmaXhDbHMgKyAnLWlucHV0LXdyYXAnIH0sXG4gICAgICBfcmVhY3QyW1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFxuICAgICAgICAnZGl2JyxcbiAgICAgICAgeyBjbGFzc05hbWU6IHByZWZpeENscyArICctdGltZS1waWNrZXItd3JhcCcgfSxcbiAgICAgICAgdGltZVBpY2tlciA/IF9yZWFjdDJbXCJkZWZhdWx0XCJdLmNsb25lRWxlbWVudCh0aW1lUGlja2VyLCBfZXh0ZW5kcyh7XG4gICAgICAgICAgc2hvd0NsZWFyOiBmYWxzZSxcbiAgICAgICAgICBhbGxvd0VtcHR5OiBmYWxzZSxcbiAgICAgICAgICBnZXRQb3B1cENvbnRhaW5lcjogdGhpcy5nZXRSb290RE9NTm9kZSxcbiAgICAgICAgICBncmVnb3JpYW5DYWxlbmRhckxvY2FsZTogZ3JlZ29yaWFuQ2FsZW5kYXJMb2NhbGUsXG4gICAgICAgICAgdmFsdWU6IHNlbGVjdGVkVmFsdWUsXG4gICAgICAgICAgb25DaGFuZ2U6IG9uQ2hhbmdlXG4gICAgICAgIH0sIGRpc2FibGVkVGltZUNvbmZpZykpIDogbnVsbFxuICAgICAgKSxcbiAgICAgIF9yZWFjdDJbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICdkaXYnLFxuICAgICAgICB7IGNsYXNzTmFtZTogcHJlZml4Q2xzICsgJy1kYXRlLWlucHV0LXdyYXAnIH0sXG4gICAgICAgIF9yZWFjdDJbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoJ2lucHV0Jywge1xuICAgICAgICAgIGNsYXNzTmFtZTogcHJlZml4Q2xzICsgJy1pbnB1dCAgJyArIGludmFsaWRDbGFzcyxcbiAgICAgICAgICB2YWx1ZTogc3RyLFxuICAgICAgICAgIHBsYWNlaG9sZGVyOiBwbGFjZWhvbGRlcixcbiAgICAgICAgICBvbkNoYW5nZTogdGhpcy5vbklucHV0Q2hhbmdlXG4gICAgICAgIH0pXG4gICAgICApLFxuICAgICAgcHJvcHMuc2hvd0NsZWFyID8gX3JlYWN0MltcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudCgnYScsIHtcbiAgICAgICAgY2xhc3NOYW1lOiBwcmVmaXhDbHMgKyAnLWNsZWFyLWJ0bicsXG4gICAgICAgIHJvbGU6ICdidXR0b24nLFxuICAgICAgICB0aXRsZTogbG9jYWxlLmNsZWFyLFxuICAgICAgICBvbkNsaWNrOiB0aGlzLm9uQ2xlYXJcbiAgICAgIH0pIDogbnVsbFxuICAgICk7XG4gIH1cbn0pO1xuXG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IERhdGVJbnB1dDtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3V4Y29yZS1mb3JtL34vdXhjb3JlLWRhdGUtZm9ybS1maWVsZC9+L3V4Y29yZS1jYWxlbmRhci9+L3JjLWNhbGVuZGFyL2xpYi9kYXRlL0RhdGVJbnB1dC5qc1xuICoqIG1vZHVsZSBpZCA9IDQyM1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX3JlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxudmFyIF9yZWFjdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yZWFjdCk7XG5cbnZhciBfcmVhY3REb20gPSByZXF1aXJlKCdyZWFjdC1kb20nKTtcblxudmFyIF9yZWFjdERvbTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yZWFjdERvbSk7XG5cbnZhciBfcmNVdGlsID0gcmVxdWlyZSgncmMtdXRpbCcpO1xuXG52YXIgX3BsYWNlbWVudHMgPSByZXF1aXJlKCcuL3BpY2tlci9wbGFjZW1lbnRzJyk7XG5cbnZhciBfcGxhY2VtZW50czIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9wbGFjZW1lbnRzKTtcblxudmFyIF9yY1RyaWdnZXIgPSByZXF1aXJlKCdyYy10cmlnZ2VyJyk7XG5cbnZhciBfcmNUcmlnZ2VyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JjVHJpZ2dlcik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IFwiZGVmYXVsdFwiOiBvYmogfTsgfVxuXG5mdW5jdGlvbiBub29wKCkge31cblxuZnVuY3Rpb24gcmVmRm4oZmllbGQsIGNvbXBvbmVudCkge1xuICB0aGlzW2ZpZWxkXSA9IGNvbXBvbmVudDtcbn1cblxudmFyIFBpY2tlciA9IF9yZWFjdDJbXCJkZWZhdWx0XCJdLmNyZWF0ZUNsYXNzKHtcbiAgZGlzcGxheU5hbWU6ICdQaWNrZXInLFxuXG4gIHByb3BUeXBlczoge1xuICAgIGFuaW1hdGlvbjogX3JlYWN0LlByb3BUeXBlcy5vbmVPZlR5cGUoW19yZWFjdC5Qcm9wVHlwZXMuZnVuYywgX3JlYWN0LlByb3BUeXBlcy5zdHJpbmddKSxcbiAgICBkaXNhYmxlZDogX3JlYWN0LlByb3BUeXBlcy5ib29sLFxuICAgIHRyYW5zaXRpb25OYW1lOiBfcmVhY3QuUHJvcFR5cGVzLnN0cmluZyxcbiAgICBvbkNoYW5nZTogX3JlYWN0LlByb3BUeXBlcy5mdW5jLFxuICAgIG9uT3BlbjogX3JlYWN0LlByb3BUeXBlcy5mdW5jLFxuICAgIG9uQ2xvc2U6IF9yZWFjdC5Qcm9wVHlwZXMuZnVuYyxcbiAgICBjaGlsZHJlbjogX3JlYWN0LlByb3BUeXBlcy5mdW5jLFxuICAgIGdldENhbGVuZGFyQ29udGFpbmVyOiBfcmVhY3QuUHJvcFR5cGVzLmZ1bmMsXG4gICAgY2FsZW5kYXI6IF9yZWFjdC5Qcm9wVHlwZXMuZWxlbWVudCxcbiAgICBzdHlsZTogX3JlYWN0LlByb3BUeXBlcy5vYmplY3QsXG4gICAgb3BlbjogX3JlYWN0LlByb3BUeXBlcy5ib29sLFxuICAgIGRlZmF1bHRPcGVuOiBfcmVhY3QuUHJvcFR5cGVzLmJvb2wsXG4gICAgcHJlZml4Q2xzOiBfcmVhY3QuUHJvcFR5cGVzLnN0cmluZyxcbiAgICBwbGFjZW1lbnQ6IF9yZWFjdC5Qcm9wVHlwZXMuYW55LFxuICAgIHZhbHVlOiBfcmVhY3QuUHJvcFR5cGVzLm9uZU9mVHlwZShbX3JlYWN0LlByb3BUeXBlcy5vYmplY3QsIF9yZWFjdC5Qcm9wVHlwZXMuYXJyYXldKSxcbiAgICBkZWZhdWx0VmFsdWU6IF9yZWFjdC5Qcm9wVHlwZXMub25lT2ZUeXBlKFtfcmVhY3QuUHJvcFR5cGVzLm9iamVjdCwgX3JlYWN0LlByb3BUeXBlcy5hcnJheV0pLFxuICAgIGFsaWduOiBfcmVhY3QuUHJvcFR5cGVzLm9iamVjdFxuICB9LFxuXG4gIGdldERlZmF1bHRQcm9wczogZnVuY3Rpb24gZ2V0RGVmYXVsdFByb3BzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBwcmVmaXhDbHM6ICdyYy1jYWxlbmRhci1waWNrZXInLFxuICAgICAgc3R5bGU6IHt9LFxuICAgICAgYWxpZ246IHt9LFxuICAgICAgcGxhY2VtZW50OiAnYm90dG9tTGVmdCcsXG4gICAgICBkZWZhdWx0T3BlbjogZmFsc2UsXG4gICAgICBvbkNoYW5nZTogbm9vcCxcbiAgICAgIG9uT3Blbjogbm9vcCxcbiAgICAgIG9uQ2xvc2U6IG5vb3BcbiAgICB9O1xuICB9LFxuICBnZXRJbml0aWFsU3RhdGU6IGZ1bmN0aW9uIGdldEluaXRpYWxTdGF0ZSgpIHtcbiAgICB2YXIgcHJvcHMgPSB0aGlzLnByb3BzO1xuICAgIHZhciBvcGVuID0gdW5kZWZpbmVkO1xuICAgIGlmICgnb3BlbicgaW4gcHJvcHMpIHtcbiAgICAgIG9wZW4gPSBwcm9wcy5vcGVuO1xuICAgIH0gZWxzZSB7XG4gICAgICBvcGVuID0gcHJvcHMuZGVmYXVsdE9wZW47XG4gICAgfVxuICAgIHZhciB2YWx1ZSA9IHByb3BzLnZhbHVlIHx8IHByb3BzLmRlZmF1bHRWYWx1ZTtcbiAgICB0aGlzLnNhdmVDYWxlbmRhclJlZiA9IHJlZkZuLmJpbmQodGhpcywgJ2NhbGVuZGFySW5zdGFuY2UnKTtcbiAgICByZXR1cm4ge1xuICAgICAgb3Blbjogb3BlbixcbiAgICAgIHZhbHVlOiB2YWx1ZVxuICAgIH07XG4gIH0sXG4gIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHM6IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMobmV4dFByb3BzKSB7XG4gICAgdmFyIHZhbHVlID0gbmV4dFByb3BzLnZhbHVlO1xuICAgIHZhciBvcGVuID0gbmV4dFByb3BzLm9wZW47XG5cbiAgICBpZiAoJ3ZhbHVlJyBpbiBuZXh0UHJvcHMpIHtcbiAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAob3BlbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgb3Blbjogb3BlblxuICAgICAgfSk7XG4gICAgfVxuICB9LFxuICBvbkNhbGVuZGFyS2V5RG93bjogZnVuY3Rpb24gb25DYWxlbmRhcktleURvd24oZXZlbnQpIHtcbiAgICBpZiAoZXZlbnQua2V5Q29kZSA9PT0gX3JjVXRpbC5LZXlDb2RlLkVTQykge1xuICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICB0aGlzLmNsb3NlKHRoaXMuZm9jdXMpO1xuICAgIH1cbiAgfSxcbiAgb25DYWxlbmRhclNlbGVjdDogZnVuY3Rpb24gb25DYWxlbmRhclNlbGVjdCh2YWx1ZSkge1xuICAgIHZhciBjYXVzZSA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMSB8fCBhcmd1bWVudHNbMV0gPT09IHVuZGVmaW5lZCA/IHt9IDogYXJndW1lbnRzWzFdO1xuXG4gICAgdmFyIHByb3BzID0gdGhpcy5wcm9wcztcbiAgICBpZiAoISgndmFsdWUnIGluIHByb3BzKSkge1xuICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmICghcHJvcHMuY2FsZW5kYXIucHJvcHMudGltZVBpY2tlciAmJiBjYXVzZS5zb3VyY2UgIT09ICdkYXRlSW5wdXQnIHx8IGNhdXNlLnNvdXJjZSA9PT0gJ3RvZGF5QnV0dG9uJykge1xuICAgICAgdGhpcy5jbG9zZSh0aGlzLmZvY3VzKTtcbiAgICB9XG4gICAgcHJvcHMub25DaGFuZ2UodmFsdWUpO1xuICB9LFxuICBvbkNhbGVuZGFyT2s6IGZ1bmN0aW9uIG9uQ2FsZW5kYXJPaygpIHtcbiAgICB0aGlzLmNsb3NlKHRoaXMuZm9jdXMpO1xuICB9LFxuICBvbkNhbGVuZGFyQ2xlYXI6IGZ1bmN0aW9uIG9uQ2FsZW5kYXJDbGVhcigpIHtcbiAgICB0aGlzLmNsb3NlKHRoaXMuZm9jdXMpO1xuICB9LFxuICBvblZpc2libGVDaGFuZ2U6IGZ1bmN0aW9uIG9uVmlzaWJsZUNoYW5nZShvcGVuKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIHRoaXMuc2V0T3BlbihvcGVuLCBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAob3Blbikge1xuICAgICAgICBfcmVhY3REb20yW1wiZGVmYXVsdFwiXS5maW5kRE9NTm9kZShfdGhpcy5jYWxlbmRhckluc3RhbmNlKS5mb2N1cygpO1xuICAgICAgfVxuICAgIH0pO1xuICB9LFxuICBnZXRDYWxlbmRhckVsZW1lbnQ6IGZ1bmN0aW9uIGdldENhbGVuZGFyRWxlbWVudCgpIHtcbiAgICB2YXIgcHJvcHMgPSB0aGlzLnByb3BzO1xuICAgIHZhciBzdGF0ZSA9IHRoaXMuc3RhdGU7XG4gICAgdmFyIGNhbGVuZGFyUHJvcCA9IHByb3BzLmNhbGVuZGFyO1xuICAgIHZhciB2YWx1ZSA9IHN0YXRlLnZhbHVlO1xuXG4gICAgdmFyIGRlZmF1bHRWYWx1ZSA9IHVuZGVmaW5lZDtcbiAgICAvLyBSYW5nZUNhbGVuZGFyXG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICBkZWZhdWx0VmFsdWUgPSB2YWx1ZVswXTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVmYXVsdFZhbHVlID0gdmFsdWU7XG4gICAgfVxuICAgIHZhciBleHRyYVByb3BzID0ge1xuICAgICAgcmVmOiB0aGlzLnNhdmVDYWxlbmRhclJlZixcbiAgICAgIGRlZmF1bHRWYWx1ZTogZGVmYXVsdFZhbHVlIHx8IGNhbGVuZGFyUHJvcC5wcm9wcy5kZWZhdWx0VmFsdWUsXG4gICAgICBkZWZhdWx0U2VsZWN0ZWRWYWx1ZTogdmFsdWUsXG4gICAgICBvbktleURvd246IHRoaXMub25DYWxlbmRhcktleURvd24sXG4gICAgICBvbk9rOiAoMCwgX3JjVXRpbC5jcmVhdGVDaGFpbmVkRnVuY3Rpb24pKGNhbGVuZGFyUHJvcC5wcm9wcy5vbk9rLCB0aGlzLm9uQ2FsZW5kYXJPayksXG4gICAgICBvblNlbGVjdDogKDAsIF9yY1V0aWwuY3JlYXRlQ2hhaW5lZEZ1bmN0aW9uKShjYWxlbmRhclByb3AucHJvcHMub25TZWxlY3QsIHRoaXMub25DYWxlbmRhclNlbGVjdCksXG4gICAgICBvbkNsZWFyOiAoMCwgX3JjVXRpbC5jcmVhdGVDaGFpbmVkRnVuY3Rpb24pKGNhbGVuZGFyUHJvcC5wcm9wcy5vbkNsZWFyLCB0aGlzLm9uQ2FsZW5kYXJDbGVhcilcbiAgICB9O1xuXG4gICAgcmV0dXJuIF9yZWFjdDJbXCJkZWZhdWx0XCJdLmNsb25lRWxlbWVudChjYWxlbmRhclByb3AsIGV4dHJhUHJvcHMpO1xuICB9LFxuICBzZXRPcGVuOiBmdW5jdGlvbiBzZXRPcGVuKG9wZW4sIGNhbGxiYWNrKSB7XG4gICAgdmFyIF9wcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgdmFyIG9uT3BlbiA9IF9wcm9wcy5vbk9wZW47XG4gICAgdmFyIG9uQ2xvc2UgPSBfcHJvcHMub25DbG9zZTtcblxuICAgIGlmICh0aGlzLnN0YXRlLm9wZW4gIT09IG9wZW4pIHtcbiAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICBvcGVuOiBvcGVuXG4gICAgICB9LCBjYWxsYmFjayk7XG4gICAgICB2YXIgZXZlbnQgPSB7XG4gICAgICAgIG9wZW46IG9wZW5cbiAgICAgIH07XG4gICAgICBpZiAob3Blbikge1xuICAgICAgICBvbk9wZW4oZXZlbnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb25DbG9zZShldmVudCk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBvcGVuOiBmdW5jdGlvbiBvcGVuKGNhbGxiYWNrKSB7XG4gICAgdGhpcy5zZXRPcGVuKHRydWUsIGNhbGxiYWNrKTtcbiAgfSxcbiAgY2xvc2U6IGZ1bmN0aW9uIGNsb3NlKGNhbGxiYWNrKSB7XG4gICAgdGhpcy5zZXRPcGVuKGZhbHNlLCBjYWxsYmFjayk7XG4gIH0sXG4gIGZvY3VzOiBmdW5jdGlvbiBmb2N1cygpIHtcbiAgICBpZiAoIXRoaXMuc3RhdGUub3Blbikge1xuICAgICAgX3JlYWN0RG9tMltcImRlZmF1bHRcIl0uZmluZERPTU5vZGUodGhpcykuZm9jdXMoKTtcbiAgICB9XG4gIH0sXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgIHZhciBwcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgdmFyIHByZWZpeENscyA9IHByb3BzLnByZWZpeENscztcbiAgICB2YXIgcGxhY2VtZW50ID0gcHJvcHMucGxhY2VtZW50O1xuICAgIHZhciBzdHlsZSA9IHByb3BzLnN0eWxlO1xuICAgIHZhciBnZXRDYWxlbmRhckNvbnRhaW5lciA9IHByb3BzLmdldENhbGVuZGFyQ29udGFpbmVyO1xuICAgIHZhciBhbGlnbiA9IHByb3BzLmFsaWduO1xuICAgIHZhciBhbmltYXRpb24gPSBwcm9wcy5hbmltYXRpb247XG4gICAgdmFyIGRpc2FibGVkID0gcHJvcHMuZGlzYWJsZWQ7XG4gICAgdmFyIHRyYW5zaXRpb25OYW1lID0gcHJvcHMudHJhbnNpdGlvbk5hbWU7XG4gICAgdmFyIGNoaWxkcmVuID0gcHJvcHMuY2hpbGRyZW47XG5cbiAgICB2YXIgc3RhdGUgPSB0aGlzLnN0YXRlO1xuICAgIHJldHVybiBfcmVhY3QyW1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFxuICAgICAgX3JjVHJpZ2dlcjJbXCJkZWZhdWx0XCJdLFxuICAgICAge1xuICAgICAgICBwb3B1cDogdGhpcy5nZXRDYWxlbmRhckVsZW1lbnQoKSxcbiAgICAgICAgcG9wdXBBbGlnbjogYWxpZ24sXG4gICAgICAgIGJ1aWx0aW5QbGFjZW1lbnRzOiBfcGxhY2VtZW50czJbXCJkZWZhdWx0XCJdLFxuICAgICAgICBwb3B1cFBsYWNlbWVudDogcGxhY2VtZW50LFxuICAgICAgICBhY3Rpb246IGRpc2FibGVkID8gW10gOiBbJ2NsaWNrJ10sXG4gICAgICAgIGRlc3Ryb3lQb3B1cE9uSGlkZTogdHJ1ZSxcbiAgICAgICAgZ2V0UG9wdXBDb250YWluZXI6IGdldENhbGVuZGFyQ29udGFpbmVyLFxuICAgICAgICBwb3B1cFN0eWxlOiBzdHlsZSxcbiAgICAgICAgcG9wdXBBbmltYXRpb246IGFuaW1hdGlvbixcbiAgICAgICAgcG9wdXBUcmFuc2l0aW9uTmFtZTogdHJhbnNpdGlvbk5hbWUsXG4gICAgICAgIHBvcHVwVmlzaWJsZTogc3RhdGUub3BlbixcbiAgICAgICAgb25Qb3B1cFZpc2libGVDaGFuZ2U6IHRoaXMub25WaXNpYmxlQ2hhbmdlLFxuICAgICAgICBwcmVmaXhDbHM6IHByZWZpeENsc1xuICAgICAgfSxcbiAgICAgIGNoaWxkcmVuKHN0YXRlLCBwcm9wcylcbiAgICApO1xuICB9XG59KTtcblxuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBQaWNrZXI7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi91eGNvcmUtZm9ybS9+L3V4Y29yZS1kYXRlLWZvcm0tZmllbGQvfi91eGNvcmUtY2FsZW5kYXIvfi9yYy1jYWxlbmRhci9saWIvUGlja2VyLmpzXG4gKiogbW9kdWxlIGlkID0gNDI0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG52YXIgYXV0b0FkanVzdE92ZXJmbG93ID0ge1xuICBhZGp1c3RYOiAxLFxuICBhZGp1c3RZOiAxXG59O1xuXG52YXIgdGFyZ2V0T2Zmc2V0ID0gWzAsIDBdO1xuXG52YXIgcGxhY2VtZW50cyA9IHtcbiAgYm90dG9tTGVmdDoge1xuICAgIHBvaW50czogWyd0bCcsICd0bCddLFxuICAgIG92ZXJmbG93OiBhdXRvQWRqdXN0T3ZlcmZsb3csXG4gICAgb2Zmc2V0OiBbMCwgLTNdLFxuICAgIHRhcmdldE9mZnNldDogdGFyZ2V0T2Zmc2V0XG4gIH0sXG4gIGJvdHRvbVJpZ2h0OiB7XG4gICAgcG9pbnRzOiBbJ3RyJywgJ3RyJ10sXG4gICAgb3ZlcmZsb3c6IGF1dG9BZGp1c3RPdmVyZmxvdyxcbiAgICBvZmZzZXQ6IFswLCAtM10sXG4gICAgdGFyZ2V0T2Zmc2V0OiB0YXJnZXRPZmZzZXRcbiAgfSxcbiAgdG9wUmlnaHQ6IHtcbiAgICBwb2ludHM6IFsnYnInLCAnYnInXSxcbiAgICBvdmVyZmxvdzogYXV0b0FkanVzdE92ZXJmbG93LFxuICAgIG9mZnNldDogWzAsIDNdLFxuICAgIHRhcmdldE9mZnNldDogdGFyZ2V0T2Zmc2V0XG4gIH0sXG4gIHRvcExlZnQ6IHtcbiAgICBwb2ludHM6IFsnYmwnLCAnYmwnXSxcbiAgICBvdmVyZmxvdzogYXV0b0FkanVzdE92ZXJmbG93LFxuICAgIG9mZnNldDogWzAsIDNdLFxuICAgIHRhcmdldE9mZnNldDogdGFyZ2V0T2Zmc2V0XG4gIH1cbn07XG5cbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gcGxhY2VtZW50cztcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3V4Y29yZS1mb3JtL34vdXhjb3JlLWRhdGUtZm9ybS1maWVsZC9+L3V4Y29yZS1jYWxlbmRhci9+L3JjLWNhbGVuZGFyL2xpYi9waWNrZXIvcGxhY2VtZW50cy5qc1xuICoqIG1vZHVsZSBpZCA9IDQyNVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX3JlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxudmFyIF9yZWFjdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yZWFjdCk7XG5cbnZhciBfTW9udGhQYW5lbCA9IHJlcXVpcmUoJy4vbW9udGgvTW9udGhQYW5lbCcpO1xuXG52YXIgX01vbnRoUGFuZWwyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfTW9udGhQYW5lbCk7XG5cbnZhciBfQ2FsZW5kYXJNaXhpbiA9IHJlcXVpcmUoJy4vbWl4aW4vQ2FsZW5kYXJNaXhpbicpO1xuXG52YXIgX0NhbGVuZGFyTWl4aW4yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfQ2FsZW5kYXJNaXhpbik7XG5cbnZhciBfQ29tbW9uTWl4aW4gPSByZXF1aXJlKCcuL21peGluL0NvbW1vbk1peGluJyk7XG5cbnZhciBfQ29tbW9uTWl4aW4yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfQ29tbW9uTWl4aW4pO1xuXG52YXIgX3JjVXRpbCA9IHJlcXVpcmUoJ3JjLXV0aWwnKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgXCJkZWZhdWx0XCI6IG9iaiB9OyB9XG5cbnZhciBNb250aENhbGVuZGFyID0gX3JlYWN0MltcImRlZmF1bHRcIl0uY3JlYXRlQ2xhc3Moe1xuICBkaXNwbGF5TmFtZTogJ01vbnRoQ2FsZW5kYXInLFxuXG4gIG1peGluczogW19Db21tb25NaXhpbjJbXCJkZWZhdWx0XCJdLCBfQ2FsZW5kYXJNaXhpbjJbXCJkZWZhdWx0XCJdXSxcblxuICBvbktleURvd246IGZ1bmN0aW9uIG9uS2V5RG93bihldmVudCkge1xuICAgIHZhciBrZXlDb2RlID0gZXZlbnQua2V5Q29kZTtcbiAgICB2YXIgY3RybEtleSA9IGV2ZW50LmN0cmxLZXkgfHwgZXZlbnQubWV0YUtleTtcbiAgICB2YXIgc3RhdGVWYWx1ZSA9IHRoaXMuc3RhdGUudmFsdWU7XG4gICAgdmFyIHZhbHVlID0gc3RhdGVWYWx1ZTtcbiAgICBzd2l0Y2ggKGtleUNvZGUpIHtcbiAgICAgIGNhc2UgX3JjVXRpbC5LZXlDb2RlLkRPV046XG4gICAgICAgIHZhbHVlID0gc3RhdGVWYWx1ZS5jbG9uZSgpO1xuICAgICAgICB2YWx1ZS5hZGRNb250aCgzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIF9yY1V0aWwuS2V5Q29kZS5VUDpcbiAgICAgICAgdmFsdWUgPSBzdGF0ZVZhbHVlLmNsb25lKCk7XG4gICAgICAgIHZhbHVlLmFkZE1vbnRoKC0zKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIF9yY1V0aWwuS2V5Q29kZS5MRUZUOlxuICAgICAgICB2YWx1ZSA9IHN0YXRlVmFsdWUuY2xvbmUoKTtcbiAgICAgICAgaWYgKGN0cmxLZXkpIHtcbiAgICAgICAgICB2YWx1ZS5hZGRZZWFyKC0xKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YWx1ZS5hZGRNb250aCgtMSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIF9yY1V0aWwuS2V5Q29kZS5SSUdIVDpcbiAgICAgICAgdmFsdWUgPSBzdGF0ZVZhbHVlLmNsb25lKCk7XG4gICAgICAgIGlmIChjdHJsS2V5KSB7XG4gICAgICAgICAgdmFsdWUuYWRkWWVhcigxKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YWx1ZS5hZGRNb250aCgxKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgX3JjVXRpbC5LZXlDb2RlLkVOVEVSOlxuICAgICAgICB0aGlzLm9uU2VsZWN0KHN0YXRlVmFsdWUpO1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICByZXR1cm4gMTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGlmICh2YWx1ZSAhPT0gc3RhdGVWYWx1ZSkge1xuICAgICAgdGhpcy5zZXRWYWx1ZSh2YWx1ZSk7XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICB9LFxuICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICB2YXIgcHJvcHMgPSB0aGlzLnByb3BzO1xuICAgIHZhciBjaGlsZHJlbiA9IF9yZWFjdDJbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoX01vbnRoUGFuZWwyW1wiZGVmYXVsdFwiXSwge1xuICAgICAgbG9jYWxlOiBwcm9wcy5sb2NhbGUsXG4gICAgICBkaXNhYmxlZERhdGU6IHByb3BzLmRpc2FibGVkRGF0ZSxcbiAgICAgIHN0eWxlOiB7IHBvc2l0aW9uOiAncmVsYXRpdmUnIH0sXG4gICAgICB2YWx1ZTogdGhpcy5zdGF0ZS52YWx1ZSxcbiAgICAgIHJvb3RQcmVmaXhDbHM6IHByb3BzLnByZWZpeENscyxcbiAgICAgIG9uQ2hhbmdlOiB0aGlzLnNldFZhbHVlLFxuICAgICAgb25TZWxlY3Q6IHRoaXMub25TZWxlY3RcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcy5yZW5kZXJSb290KHtcbiAgICAgIGNoaWxkcmVuOiBjaGlsZHJlblxuICAgIH0pO1xuICB9XG59KTtcblxuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBNb250aENhbGVuZGFyO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vdXhjb3JlLWZvcm0vfi91eGNvcmUtZGF0ZS1mb3JtLWZpZWxkL34vdXhjb3JlLWNhbGVuZGFyL34vcmMtY2FsZW5kYXIvbGliL01vbnRoQ2FsZW5kYXIuanNcbiAqKiBtb2R1bGUgaWQgPSA0NTJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9ZZWFyUGFuZWwgPSByZXF1aXJlKCdyYy1jYWxlbmRhci9saWIveWVhci9ZZWFyUGFuZWwnKTtcblxudmFyIF9ZZWFyUGFuZWwyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfWWVhclBhbmVsKTtcblxudmFyIF9DYWxlbmRhck1peGluID0gcmVxdWlyZSgncmMtY2FsZW5kYXIvbGliL21peGluL0NhbGVuZGFyTWl4aW4nKTtcblxudmFyIF9DYWxlbmRhck1peGluMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0NhbGVuZGFyTWl4aW4pO1xuXG52YXIgX0NvbW1vbk1peGluID0gcmVxdWlyZSgncmMtY2FsZW5kYXIvbGliL21peGluL0NvbW1vbk1peGluJyk7XG5cbnZhciBfQ29tbW9uTWl4aW4yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfQ29tbW9uTWl4aW4pO1xuXG52YXIgX3JjVXRpbCA9IHJlcXVpcmUoJ3JjLXV0aWwnKTtcblxudmFyIF9yZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5cbnZhciBfcmVhY3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmVhY3QpO1xuXG52YXIgX3JlYWN0RG9tID0gcmVxdWlyZSgncmVhY3QtZG9tJyk7XG5cbnZhciBfcmVhY3REb20yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmVhY3REb20pO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBcImRlZmF1bHRcIjogb2JqIH07IH1cblxudmFyIFllYXJDYWxlbmRhciA9IF9yZWFjdDJbXCJkZWZhdWx0XCJdLmNyZWF0ZUNsYXNzKHtcbiAgICBkaXNwbGF5TmFtZTogJ1llYXJDYWxlbmRhcicsXG5cbiAgICBtaXhpbnM6IFtfQ2FsZW5kYXJNaXhpbjJbXCJkZWZhdWx0XCJdLCBfQ29tbW9uTWl4aW4yW1wiZGVmYXVsdFwiXV0sXG5cbiAgICBvbktleURvd246IGZ1bmN0aW9uIG9uS2V5RG93bihlKSB7XG4gICAgICAgIHZhciBrZXlDb2RlID0gZS5rZXlDb2RlO1xuICAgICAgICB2YXIgY3RybEtleSA9IGUuY3RybEtleSB8fCBlLm1ldGFLZXk7XG4gICAgICAgIHZhciBzdGF0ZVZhbHVlID0gdGhpcy5zdGF0ZS52YWx1ZTtcbiAgICAgICAgdmFyIHZhbHVlID0gc3RhdGVWYWx1ZTtcbiAgICAgICAgc3dpdGNoIChrZXlDb2RlKSB7XG4gICAgICAgICAgICBjYXNlIF9yY1V0aWwuS2V5Q29kZS5ET1dOOlxuICAgICAgICAgICAgICAgIHZhbHVlID0gc3RhdGVWYWx1ZS5jbG9uZSgpO1xuICAgICAgICAgICAgICAgIHZhbHVlLmFkZE1vbnRoKDMpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBfcmNVdGlsLktleUNvZGUuVVA6XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBzdGF0ZVZhbHVlLmNsb25lKCk7XG4gICAgICAgICAgICAgICAgdmFsdWUuYWRkTW9udGgoLTMpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBfcmNVdGlsLktleUNvZGUuTEVGVDpcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHN0YXRlVmFsdWUuY2xvbmUoKTtcbiAgICAgICAgICAgICAgICBpZiAoY3RybEtleSkge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZS5hZGRZZWFyKC0xKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZS5hZGRNb250aCgtMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBfcmNVdGlsLktleUNvZGUuUklHSFQ6XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBzdGF0ZVZhbHVlLmNsb25lKCk7XG4gICAgICAgICAgICAgICAgaWYgKGN0cmxLZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUuYWRkWWVhcigxKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZS5hZGRNb250aCgxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIF9yY1V0aWwuS2V5Q29kZS5FTlRFUjpcbiAgICAgICAgICAgICAgICB0aGlzLm9uU2VsZWN0KHN0YXRlVmFsdWUpO1xuICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsdWUgIT09IHN0YXRlVmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0VmFsdWUodmFsdWUpO1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgICAgICB2YXIgcHJvcHMgPSB0aGlzLnByb3BzO1xuICAgICAgICB2YXIgY2hpbGRyZW4gPSBfcmVhY3QyW1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KF9ZZWFyUGFuZWwyW1wiZGVmYXVsdFwiXSwgeyBsb2NhbGU6IHByb3BzLmxvY2FsZSxcbiAgICAgICAgICAgIGRpc2FibGVkRGF0ZTogcHJvcHMuZGlzYWJsZWREYXRlLFxuICAgICAgICAgICAgdmFsdWU6IHRoaXMuc3RhdGUudmFsdWUsXG4gICAgICAgICAgICByb290UHJlZml4Q2xzOiBwcm9wcy5wcmVmaXhDbHMsXG4gICAgICAgICAgICBvbkNoYW5nZTogdGhpcy5zZXRWYWx1ZSxcbiAgICAgICAgICAgIG9uU2VsZWN0OiB0aGlzLm9uU2VsZWN0IH0pO1xuICAgICAgICByZXR1cm4gdGhpcy5yZW5kZXJSb290KHtcbiAgICAgICAgICAgIGNoaWxkcmVuOiBjaGlsZHJlbixcbiAgICAgICAgICAgIGNsYXNzTmFtZTogcHJvcHMucHJlZml4Q2xzICsgJy15ZWFyLWNhbGVuZGFyLWNvbnRhaW5lcidcblxuICAgICAgICB9KTtcbiAgICB9XG59KTtcblxuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBZZWFyQ2FsZW5kYXI7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi91eGNvcmUtZm9ybS9+L3V4Y29yZS1kYXRlLWZvcm0tZmllbGQvfi91eGNvcmUtY2FsZW5kYXIvYnVpbGQvWWVhckNhbGVuZGFyLmpzXG4gKiogbW9kdWxlIGlkID0gNDUzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbnZhciBfVGltZVBpY2tlciA9IHJlcXVpcmUoJy4vVGltZVBpY2tlcicpO1xuXG52YXIgX1RpbWVQaWNrZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfVGltZVBpY2tlcik7XG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IF9UaW1lUGlja2VyMlsnZGVmYXVsdCddO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vdXhjb3JlLWZvcm0vfi91eGNvcmUtZGF0ZS1mb3JtLWZpZWxkL34vdXhjb3JlLWNhbGVuZGFyL34vcmMtdGltZS1waWNrZXIvbGliL2luZGV4LmpzXG4gKiogbW9kdWxlIGlkID0gNDU0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbnZhciBfcmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xuXG52YXIgX3JlYWN0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JlYWN0KTtcblxudmFyIF9yY1RyaWdnZXIgPSByZXF1aXJlKCdyYy10cmlnZ2VyJyk7XG5cbnZhciBfcmNUcmlnZ2VyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JjVHJpZ2dlcik7XG5cbnZhciBfbW9kdWxlUGFuZWwgPSByZXF1aXJlKCcuL21vZHVsZS9QYW5lbCcpO1xuXG52YXIgX21vZHVsZVBhbmVsMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX21vZHVsZVBhbmVsKTtcblxudmFyIF91dGlsUGxhY2VtZW50cyA9IHJlcXVpcmUoJy4vdXRpbC9wbGFjZW1lbnRzJyk7XG5cbnZhciBfdXRpbFBsYWNlbWVudHMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdXRpbFBsYWNlbWVudHMpO1xuXG52YXIgX21peGluQ29tbW9uTWl4aW4gPSByZXF1aXJlKCcuL21peGluL0NvbW1vbk1peGluJyk7XG5cbnZhciBfbWl4aW5Db21tb25NaXhpbjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9taXhpbkNvbW1vbk1peGluKTtcblxudmFyIF91dGlsSW5kZXggPSByZXF1aXJlKCcuL3V0aWwvaW5kZXgnKTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbmZ1bmN0aW9uIHJlZkZuKGZpZWxkLCBjb21wb25lbnQpIHtcbiAgdGhpc1tmaWVsZF0gPSBjb21wb25lbnQ7XG59XG5cbnZhciBQaWNrZXIgPSBfcmVhY3QyWydkZWZhdWx0J10uY3JlYXRlQ2xhc3Moe1xuICBkaXNwbGF5TmFtZTogJ1BpY2tlcicsXG5cbiAgcHJvcFR5cGVzOiB7XG4gICAgcHJlZml4Q2xzOiBfcmVhY3QuUHJvcFR5cGVzLnN0cmluZyxcbiAgICBsb2NhbGU6IF9yZWFjdC5Qcm9wVHlwZXMub2JqZWN0LFxuICAgIHZhbHVlOiBfcmVhY3QuUHJvcFR5cGVzLm9iamVjdCxcbiAgICBkaXNhYmxlZDogX3JlYWN0LlByb3BUeXBlcy5ib29sLFxuICAgIGFsbG93RW1wdHk6IF9yZWFjdC5Qcm9wVHlwZXMuYm9vbCxcbiAgICBkZWZhdWx0VmFsdWU6IF9yZWFjdC5Qcm9wVHlwZXMub2JqZWN0LFxuICAgIG9wZW46IF9yZWFjdC5Qcm9wVHlwZXMuYm9vbCxcbiAgICBkZWZhdWx0T3BlbjogX3JlYWN0LlByb3BUeXBlcy5ib29sLFxuICAgIGFsaWduOiBfcmVhY3QuUHJvcFR5cGVzLm9iamVjdCxcbiAgICBwbGFjZW1lbnQ6IF9yZWFjdC5Qcm9wVHlwZXMuYW55LFxuICAgIHRyYW5zaXRpb25OYW1lOiBfcmVhY3QuUHJvcFR5cGVzLnN0cmluZyxcbiAgICBnZXRQb3B1cENvbnRhaW5lcjogX3JlYWN0LlByb3BUeXBlcy5mdW5jLFxuICAgIHBsYWNlaG9sZGVyOiBfcmVhY3QuUHJvcFR5cGVzLnN0cmluZyxcbiAgICBmb3JtYXR0ZXI6IF9yZWFjdC5Qcm9wVHlwZXMuYW55LFxuICAgIHNob3dIb3VyOiBfcmVhY3QuUHJvcFR5cGVzLmJvb2wsXG4gICAgc3R5bGU6IF9yZWFjdC5Qcm9wVHlwZXMub2JqZWN0LFxuICAgIGNsYXNzTmFtZTogX3JlYWN0LlByb3BUeXBlcy5zdHJpbmcsXG4gICAgc2hvd1NlY29uZDogX3JlYWN0LlByb3BUeXBlcy5ib29sLFxuICAgIGRpc2FibGVkSG91cnM6IF9yZWFjdC5Qcm9wVHlwZXMuZnVuYyxcbiAgICBkaXNhYmxlZE1pbnV0ZXM6IF9yZWFjdC5Qcm9wVHlwZXMuZnVuYyxcbiAgICBkaXNhYmxlZFNlY29uZHM6IF9yZWFjdC5Qcm9wVHlwZXMuZnVuYyxcbiAgICBoaWRlRGlzYWJsZWRPcHRpb25zOiBfcmVhY3QuUHJvcFR5cGVzLmJvb2wsXG4gICAgb25DaGFuZ2U6IF9yZWFjdC5Qcm9wVHlwZXMuZnVuYyxcbiAgICBvbk9wZW46IF9yZWFjdC5Qcm9wVHlwZXMuZnVuYyxcbiAgICBvbkNsb3NlOiBfcmVhY3QuUHJvcFR5cGVzLmZ1bmNcbiAgfSxcblxuICBtaXhpbnM6IFtfbWl4aW5Db21tb25NaXhpbjJbJ2RlZmF1bHQnXV0sXG5cbiAgZ2V0RGVmYXVsdFByb3BzOiBmdW5jdGlvbiBnZXREZWZhdWx0UHJvcHMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGRlZmF1bHRPcGVuOiBmYWxzZSxcbiAgICAgIHN0eWxlOiB7fSxcbiAgICAgIGNsYXNzTmFtZTogJycsXG4gICAgICBhbGlnbjoge30sXG4gICAgICBhbGxvd0VtcHR5OiB0cnVlLFxuICAgICAgc2hvd0hvdXI6IHRydWUsXG4gICAgICBzaG93U2Vjb25kOiB0cnVlLFxuICAgICAgZGlzYWJsZWRIb3Vyczogbm9vcCxcbiAgICAgIGRpc2FibGVkTWludXRlczogbm9vcCxcbiAgICAgIGRpc2FibGVkU2Vjb25kczogbm9vcCxcbiAgICAgIGhpZGVEaXNhYmxlZE9wdGlvbnM6IGZhbHNlLFxuICAgICAgcGxhY2VtZW50OiAnYm90dG9tTGVmdCcsXG4gICAgICBvbkNoYW5nZTogbm9vcCxcbiAgICAgIG9uT3Blbjogbm9vcCxcbiAgICAgIG9uQ2xvc2U6IG5vb3BcbiAgICB9O1xuICB9LFxuXG4gIGdldEluaXRpYWxTdGF0ZTogZnVuY3Rpb24gZ2V0SW5pdGlhbFN0YXRlKCkge1xuICAgIHRoaXMuc2F2ZVBhbmVsUmVmID0gcmVmRm4uYmluZCh0aGlzLCAncGFuZWxJbnN0YW5jZScpO1xuICAgIHZhciBfcHJvcHMgPSB0aGlzLnByb3BzO1xuICAgIHZhciBkZWZhdWx0T3BlbiA9IF9wcm9wcy5kZWZhdWx0T3BlbjtcbiAgICB2YXIgZGVmYXVsdFZhbHVlID0gX3Byb3BzLmRlZmF1bHRWYWx1ZTtcbiAgICB2YXIgX3Byb3BzJG9wZW4gPSBfcHJvcHMub3BlbjtcbiAgICB2YXIgb3BlbiA9IF9wcm9wcyRvcGVuID09PSB1bmRlZmluZWQgPyBkZWZhdWx0T3BlbiA6IF9wcm9wcyRvcGVuO1xuICAgIHZhciBfcHJvcHMkdmFsdWUgPSBfcHJvcHMudmFsdWU7XG4gICAgdmFyIHZhbHVlID0gX3Byb3BzJHZhbHVlID09PSB1bmRlZmluZWQgPyBkZWZhdWx0VmFsdWUgOiBfcHJvcHMkdmFsdWU7XG5cbiAgICByZXR1cm4ge1xuICAgICAgb3Blbjogb3BlbixcbiAgICAgIHZhbHVlOiB2YWx1ZVxuICAgIH07XG4gIH0sXG5cbiAgY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wczogZnVuY3Rpb24gY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhuZXh0UHJvcHMpIHtcbiAgICB2YXIgdmFsdWUgPSBuZXh0UHJvcHMudmFsdWU7XG4gICAgdmFyIG9wZW4gPSBuZXh0UHJvcHMub3BlbjtcblxuICAgIGlmICgndmFsdWUnIGluIG5leHRQcm9wcykge1xuICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChvcGVuICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuc2V0U3RhdGUoeyBvcGVuOiBvcGVuIH0pO1xuICAgIH1cbiAgfSxcblxuICBvblBhbmVsQ2hhbmdlOiBmdW5jdGlvbiBvblBhbmVsQ2hhbmdlKHZhbHVlKSB7XG4gICAgdGhpcy5zZXRWYWx1ZSh2YWx1ZSk7XG4gIH0sXG5cbiAgb25QYW5lbENsZWFyOiBmdW5jdGlvbiBvblBhbmVsQ2xlYXIoKSB7XG4gICAgdGhpcy5zZXRWYWx1ZShudWxsKTtcbiAgICB0aGlzLnNldE9wZW4oZmFsc2UpO1xuICB9LFxuXG4gIG9uVmlzaWJsZUNoYW5nZTogZnVuY3Rpb24gb25WaXNpYmxlQ2hhbmdlKG9wZW4pIHtcbiAgICB0aGlzLnNldE9wZW4ob3Blbik7XG4gIH0sXG5cbiAgb25Fc2M6IGZ1bmN0aW9uIG9uRXNjKCkge1xuICAgIHRoaXMuc2V0T3BlbihmYWxzZSk7XG4gICAgdGhpcy5yZWZzLnBpY2tlci5mb2N1cygpO1xuICB9LFxuXG4gIG9uS2V5RG93bjogZnVuY3Rpb24gb25LZXlEb3duKGUpIHtcbiAgICBpZiAoZS5rZXlDb2RlID09PSA0MCkge1xuICAgICAgdGhpcy5zZXRPcGVuKHRydWUpO1xuICAgIH1cbiAgfSxcblxuICBzZXRWYWx1ZTogZnVuY3Rpb24gc2V0VmFsdWUodmFsdWUpIHtcbiAgICBpZiAoISgndmFsdWUnIGluIHRoaXMucHJvcHMpKSB7XG4gICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgICB9KTtcbiAgICB9XG4gICAgdGhpcy5wcm9wcy5vbkNoYW5nZSh2YWx1ZSk7XG4gIH0sXG5cbiAgZ2V0Rm9ybWF0dGVyOiBmdW5jdGlvbiBnZXRGb3JtYXR0ZXIoKSB7XG4gICAgdmFyIGZvcm1hdHRlciA9IHRoaXMucHJvcHMuZm9ybWF0dGVyO1xuICAgIHZhciBsb2NhbGUgPSB0aGlzLnByb3BzLmxvY2FsZTtcbiAgICBpZiAoZm9ybWF0dGVyKSB7XG4gICAgICBpZiAoZm9ybWF0dGVyID09PSB0aGlzLmxhc3RGb3JtYXR0ZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubm9ybWFsRm9ybWF0dGVyO1xuICAgICAgfVxuICAgICAgdGhpcy5ub3JtYWxGb3JtYXR0ZXIgPSAoMCwgX3V0aWxJbmRleC5nZXRGb3JtYXR0ZXIpKGZvcm1hdHRlciwgbG9jYWxlKTtcbiAgICAgIHRoaXMubGFzdEZvcm1hdHRlciA9IGZvcm1hdHRlcjtcbiAgICAgIHJldHVybiB0aGlzLm5vcm1hbEZvcm1hdHRlcjtcbiAgICB9XG4gICAgaWYgKCF0aGlzLnByb3BzLnNob3dTZWNvbmQpIHtcbiAgICAgIGlmICghdGhpcy5ub3RTaG93U2Vjb25kRm9ybWF0dGVyKSB7XG4gICAgICAgIHRoaXMubm90U2hvd1NlY29uZEZvcm1hdHRlciA9ICgwLCBfdXRpbEluZGV4LmdldEZvcm1hdHRlcikoJ0hIOm1tJywgbG9jYWxlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLm5vdFNob3dTZWNvbmRGb3JtYXR0ZXI7XG4gICAgfVxuICAgIGlmICghdGhpcy5wcm9wcy5zaG93SG91cikge1xuICAgICAgaWYgKCF0aGlzLm5vdFNob3dIb3VyRm9ybWF0dGVyKSB7XG4gICAgICAgIHRoaXMubm90U2hvd0hvdXJGb3JtYXR0ZXIgPSAoMCwgX3V0aWxJbmRleC5nZXRGb3JtYXR0ZXIpKCdtbTpzcycsIGxvY2FsZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5ub3RTaG93SG91ckZvcm1hdHRlcjtcbiAgICB9XG4gICAgaWYgKCF0aGlzLm5vcm1hbEZvcm1hdHRlcikge1xuICAgICAgdGhpcy5ub3JtYWxGb3JtYXR0ZXIgPSAoMCwgX3V0aWxJbmRleC5nZXRGb3JtYXR0ZXIpKCdISDptbTpzcycsIGxvY2FsZSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLm5vcm1hbEZvcm1hdHRlcjtcbiAgfSxcblxuICBnZXRQYW5lbEVsZW1lbnQ6IGZ1bmN0aW9uIGdldFBhbmVsRWxlbWVudCgpIHtcbiAgICB2YXIgX3Byb3BzMiA9IHRoaXMucHJvcHM7XG4gICAgdmFyIHByZWZpeENscyA9IF9wcm9wczIucHJlZml4Q2xzO1xuICAgIHZhciBkZWZhdWx0VmFsdWUgPSBfcHJvcHMyLmRlZmF1bHRWYWx1ZTtcbiAgICB2YXIgbG9jYWxlID0gX3Byb3BzMi5sb2NhbGU7XG4gICAgdmFyIHBsYWNlaG9sZGVyID0gX3Byb3BzMi5wbGFjZWhvbGRlcjtcbiAgICB2YXIgZGlzYWJsZWRIb3VycyA9IF9wcm9wczIuZGlzYWJsZWRIb3VycztcbiAgICB2YXIgZGlzYWJsZWRNaW51dGVzID0gX3Byb3BzMi5kaXNhYmxlZE1pbnV0ZXM7XG4gICAgdmFyIGRpc2FibGVkU2Vjb25kcyA9IF9wcm9wczIuZGlzYWJsZWRTZWNvbmRzO1xuICAgIHZhciBoaWRlRGlzYWJsZWRPcHRpb25zID0gX3Byb3BzMi5oaWRlRGlzYWJsZWRPcHRpb25zO1xuICAgIHZhciBhbGxvd0VtcHR5ID0gX3Byb3BzMi5hbGxvd0VtcHR5O1xuICAgIHZhciBzaG93SG91ciA9IF9wcm9wczIuc2hvd0hvdXI7XG4gICAgdmFyIHNob3dTZWNvbmQgPSBfcHJvcHMyLnNob3dTZWNvbmQ7XG5cbiAgICByZXR1cm4gX3JlYWN0MlsnZGVmYXVsdCddLmNyZWF0ZUVsZW1lbnQoX21vZHVsZVBhbmVsMlsnZGVmYXVsdCddLCB7XG4gICAgICBwcmVmaXhDbHM6IHByZWZpeENscyArICctcGFuZWwnLFxuICAgICAgcmVmOiB0aGlzLnNhdmVQYW5lbFJlZixcbiAgICAgIHZhbHVlOiB0aGlzLnN0YXRlLnZhbHVlLFxuICAgICAgb25DaGFuZ2U6IHRoaXMub25QYW5lbENoYW5nZSxcbiAgICAgIGdyZWdvcmlhbkNhbGVuZGFyTG9jYWxlOiBsb2NhbGUuY2FsZW5kYXIsXG4gICAgICBvbkNsZWFyOiB0aGlzLm9uUGFuZWxDbGVhcixcbiAgICAgIGRlZmF1bHRWYWx1ZTogZGVmYXVsdFZhbHVlLFxuICAgICAgc2hvd0hvdXI6IHNob3dIb3VyLFxuICAgICAgb25Fc2M6IHRoaXMub25Fc2MsXG4gICAgICBzaG93U2Vjb25kOiBzaG93U2Vjb25kLFxuICAgICAgbG9jYWxlOiBsb2NhbGUsXG4gICAgICBhbGxvd0VtcHR5OiBhbGxvd0VtcHR5LFxuICAgICAgZm9ybWF0dGVyOiB0aGlzLmdldEZvcm1hdHRlcigpLFxuICAgICAgcGxhY2Vob2xkZXI6IHBsYWNlaG9sZGVyLFxuICAgICAgZGlzYWJsZWRIb3VyczogZGlzYWJsZWRIb3VycyxcbiAgICAgIGRpc2FibGVkTWludXRlczogZGlzYWJsZWRNaW51dGVzLFxuICAgICAgZGlzYWJsZWRTZWNvbmRzOiBkaXNhYmxlZFNlY29uZHMsXG4gICAgICBoaWRlRGlzYWJsZWRPcHRpb25zOiBoaWRlRGlzYWJsZWRPcHRpb25zXG4gICAgfSk7XG4gIH0sXG5cbiAgc2V0T3BlbjogZnVuY3Rpb24gc2V0T3BlbihvcGVuLCBjYWxsYmFjaykge1xuICAgIHZhciBfcHJvcHMzID0gdGhpcy5wcm9wcztcbiAgICB2YXIgb25PcGVuID0gX3Byb3BzMy5vbk9wZW47XG4gICAgdmFyIG9uQ2xvc2UgPSBfcHJvcHMzLm9uQ2xvc2U7XG5cbiAgICBpZiAodGhpcy5zdGF0ZS5vcGVuICE9PSBvcGVuKSB7XG4gICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgb3Blbjogb3BlblxuICAgICAgfSwgY2FsbGJhY2spO1xuICAgICAgdmFyIF9ldmVudCA9IHtcbiAgICAgICAgb3Blbjogb3BlblxuICAgICAgfTtcbiAgICAgIGlmIChvcGVuKSB7XG4gICAgICAgIG9uT3BlbihfZXZlbnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb25DbG9zZShfZXZlbnQpO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICB2YXIgX3Byb3BzNCA9IHRoaXMucHJvcHM7XG4gICAgdmFyIHByZWZpeENscyA9IF9wcm9wczQucHJlZml4Q2xzO1xuICAgIHZhciBwbGFjZWhvbGRlciA9IF9wcm9wczQucGxhY2Vob2xkZXI7XG4gICAgdmFyIHBsYWNlbWVudCA9IF9wcm9wczQucGxhY2VtZW50O1xuICAgIHZhciBhbGlnbiA9IF9wcm9wczQuYWxpZ247XG4gICAgdmFyIGRpc2FibGVkID0gX3Byb3BzNC5kaXNhYmxlZDtcbiAgICB2YXIgdHJhbnNpdGlvbk5hbWUgPSBfcHJvcHM0LnRyYW5zaXRpb25OYW1lO1xuICAgIHZhciBzdHlsZSA9IF9wcm9wczQuc3R5bGU7XG4gICAgdmFyIGNsYXNzTmFtZSA9IF9wcm9wczQuY2xhc3NOYW1lO1xuICAgIHZhciBzaG93SG91ciA9IF9wcm9wczQuc2hvd0hvdXI7XG4gICAgdmFyIHNob3dTZWNvbmQgPSBfcHJvcHM0LnNob3dTZWNvbmQ7XG4gICAgdmFyIGdldFBvcHVwQ29udGFpbmVyID0gX3Byb3BzNC5nZXRQb3B1cENvbnRhaW5lcjtcbiAgICB2YXIgX3N0YXRlID0gdGhpcy5zdGF0ZTtcbiAgICB2YXIgb3BlbiA9IF9zdGF0ZS5vcGVuO1xuICAgIHZhciB2YWx1ZSA9IF9zdGF0ZS52YWx1ZTtcblxuICAgIHZhciBwb3B1cENsYXNzTmFtZSA9IHVuZGVmaW5lZDtcbiAgICBpZiAoIXNob3dIb3VyIHx8ICFzaG93U2Vjb25kKSB7XG4gICAgICBwb3B1cENsYXNzTmFtZSA9IHByZWZpeENscyArICctcGFuZWwtbmFycm93JztcbiAgICB9XG4gICAgcmV0dXJuIF9yZWFjdDJbJ2RlZmF1bHQnXS5jcmVhdGVFbGVtZW50KFxuICAgICAgX3JjVHJpZ2dlcjJbJ2RlZmF1bHQnXSxcbiAgICAgIHtcbiAgICAgICAgcHJlZml4Q2xzOiBwcmVmaXhDbHMgKyAnLXBhbmVsJyxcbiAgICAgICAgcG9wdXBDbGFzc05hbWU6IHBvcHVwQ2xhc3NOYW1lLFxuICAgICAgICBwb3B1cDogdGhpcy5nZXRQYW5lbEVsZW1lbnQoKSxcbiAgICAgICAgcG9wdXBBbGlnbjogYWxpZ24sXG4gICAgICAgIGJ1aWx0aW5QbGFjZW1lbnRzOiBfdXRpbFBsYWNlbWVudHMyWydkZWZhdWx0J10sXG4gICAgICAgIHBvcHVwUGxhY2VtZW50OiBwbGFjZW1lbnQsXG4gICAgICAgIGFjdGlvbjogZGlzYWJsZWQgPyBbXSA6IFsnY2xpY2snXSxcbiAgICAgICAgZGVzdHJveVBvcHVwT25IaWRlOiB0cnVlLFxuICAgICAgICBnZXRQb3B1cENvbnRhaW5lcjogZ2V0UG9wdXBDb250YWluZXIsXG4gICAgICAgIHBvcHVwVHJhbnNpdGlvbk5hbWU6IHRyYW5zaXRpb25OYW1lLFxuICAgICAgICBwb3B1cFZpc2libGU6IG9wZW4sXG4gICAgICAgIG9uUG9wdXBWaXNpYmxlQ2hhbmdlOiB0aGlzLm9uVmlzaWJsZUNoYW5nZVxuICAgICAgfSxcbiAgICAgIF9yZWFjdDJbJ2RlZmF1bHQnXS5jcmVhdGVFbGVtZW50KFxuICAgICAgICAnc3BhbicsXG4gICAgICAgIHsgY2xhc3NOYW1lOiBwcmVmaXhDbHMgKyAnICcgKyBjbGFzc05hbWUsIHN0eWxlOiBzdHlsZSB9LFxuICAgICAgICBfcmVhY3QyWydkZWZhdWx0J10uY3JlYXRlRWxlbWVudCgnaW5wdXQnLCB7XG4gICAgICAgICAgY2xhc3NOYW1lOiBwcmVmaXhDbHMgKyAnLWlucHV0JyxcbiAgICAgICAgICByZWY6ICdwaWNrZXInLCB0eXBlOiAndGV4dCcsIHBsYWNlaG9sZGVyOiBwbGFjZWhvbGRlcixcbiAgICAgICAgICByZWFkT25seTogdHJ1ZSxcbiAgICAgICAgICBvbktleURvd246IHRoaXMub25LZXlEb3duLFxuICAgICAgICAgIGRpc2FibGVkOiBkaXNhYmxlZCwgdmFsdWU6IHZhbHVlICYmIHRoaXMuZ2V0Rm9ybWF0dGVyKCkuZm9ybWF0KHZhbHVlKSB8fCAnJ1xuICAgICAgICB9KSxcbiAgICAgICAgX3JlYWN0MlsnZGVmYXVsdCddLmNyZWF0ZUVsZW1lbnQoJ3NwYW4nLCB7IGNsYXNzTmFtZTogcHJlZml4Q2xzICsgJy1pY29uJyB9KVxuICAgICAgKVxuICAgICk7XG4gIH1cbn0pO1xuXG5leHBvcnRzWydkZWZhdWx0J10gPSBQaWNrZXI7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi91eGNvcmUtZm9ybS9+L3V4Y29yZS1kYXRlLWZvcm0tZmllbGQvfi91eGNvcmUtY2FsZW5kYXIvfi9yYy10aW1lLXBpY2tlci9saWIvVGltZVBpY2tlci5qc1xuICoqIG1vZHVsZSBpZCA9IDQ1NVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG52YXIgX3JlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxudmFyIF9yZWFjdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yZWFjdCk7XG5cbnZhciBfbWl4aW5Db21tb25NaXhpbiA9IHJlcXVpcmUoJy4uL21peGluL0NvbW1vbk1peGluJyk7XG5cbnZhciBfbWl4aW5Db21tb25NaXhpbjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9taXhpbkNvbW1vbk1peGluKTtcblxudmFyIF9IZWFkZXIgPSByZXF1aXJlKCcuL0hlYWRlcicpO1xuXG52YXIgX0hlYWRlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9IZWFkZXIpO1xuXG52YXIgX0NvbWJvYm94ID0gcmVxdWlyZSgnLi9Db21ib2JveCcpO1xuXG52YXIgX0NvbWJvYm94MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0NvbWJvYm94KTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbmZ1bmN0aW9uIGdlbmVyYXRlT3B0aW9ucyhsZW5ndGgsIGRpc2FibGVkT3B0aW9ucywgaGlkZURpc2FibGVkT3B0aW9ucykge1xuICB2YXIgYXJyID0gW107XG4gIGZvciAodmFyIHZhbHVlID0gMDsgdmFsdWUgPCBsZW5ndGg7IHZhbHVlKyspIHtcbiAgICBpZiAoIWRpc2FibGVkT3B0aW9ucyB8fCBkaXNhYmxlZE9wdGlvbnMuaW5kZXhPZih2YWx1ZSkgPCAwIHx8ICFoaWRlRGlzYWJsZWRPcHRpb25zKSB7XG4gICAgICBhcnIucHVzaCh2YWx1ZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBhcnI7XG59XG5cbnZhciBQYW5lbCA9IF9yZWFjdDJbJ2RlZmF1bHQnXS5jcmVhdGVDbGFzcyh7XG4gIGRpc3BsYXlOYW1lOiAnUGFuZWwnLFxuXG4gIHByb3BUeXBlczoge1xuICAgIHByZWZpeENsczogX3JlYWN0LlByb3BUeXBlcy5zdHJpbmcsXG4gICAgdmFsdWU6IF9yZWFjdC5Qcm9wVHlwZXMub2JqZWN0LFxuICAgIGxvY2FsZTogX3JlYWN0LlByb3BUeXBlcy5vYmplY3QsXG4gICAgcGxhY2Vob2xkZXI6IF9yZWFjdC5Qcm9wVHlwZXMuc3RyaW5nLFxuICAgIGdyZWdvcmlhbkNhbGVuZGFyTG9jYWxlOiBfcmVhY3QuUHJvcFR5cGVzLm9iamVjdCxcbiAgICBmb3JtYXR0ZXI6IF9yZWFjdC5Qcm9wVHlwZXMub2JqZWN0LFxuICAgIGRpc2FibGVkSG91cnM6IF9yZWFjdC5Qcm9wVHlwZXMuZnVuYyxcbiAgICBkaXNhYmxlZE1pbnV0ZXM6IF9yZWFjdC5Qcm9wVHlwZXMuZnVuYyxcbiAgICBkaXNhYmxlZFNlY29uZHM6IF9yZWFjdC5Qcm9wVHlwZXMuZnVuYyxcbiAgICBoaWRlRGlzYWJsZWRPcHRpb25zOiBfcmVhY3QuUHJvcFR5cGVzLmJvb2wsXG4gICAgb25DaGFuZ2U6IF9yZWFjdC5Qcm9wVHlwZXMuZnVuYyxcbiAgICBvbkVzYzogX3JlYWN0LlByb3BUeXBlcy5mdW5jLFxuICAgIGFsbG93RW1wdHk6IF9yZWFjdC5Qcm9wVHlwZXMuYm9vbCxcbiAgICBzaG93SG91cjogX3JlYWN0LlByb3BUeXBlcy5ib29sLFxuICAgIHNob3dTZWNvbmQ6IF9yZWFjdC5Qcm9wVHlwZXMuYm9vbCxcbiAgICBvbkNsZWFyOiBfcmVhY3QuUHJvcFR5cGVzLmZ1bmNcbiAgfSxcblxuICBtaXhpbnM6IFtfbWl4aW5Db21tb25NaXhpbjJbJ2RlZmF1bHQnXV0sXG5cbiAgZ2V0RGVmYXVsdFByb3BzOiBmdW5jdGlvbiBnZXREZWZhdWx0UHJvcHMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG9uQ2hhbmdlOiBub29wLFxuICAgICAgb25DbGVhcjogbm9vcFxuICAgIH07XG4gIH0sXG5cbiAgZ2V0SW5pdGlhbFN0YXRlOiBmdW5jdGlvbiBnZXRJbml0aWFsU3RhdGUoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHZhbHVlOiB0aGlzLnByb3BzLnZhbHVlLFxuICAgICAgc2VsZWN0aW9uUmFuZ2U6IFtdXG4gICAgfTtcbiAgfSxcblxuICBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzOiBmdW5jdGlvbiBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKG5leHRQcm9wcykge1xuICAgIHZhciB2YWx1ZSA9IG5leHRQcm9wcy52YWx1ZTtcbiAgICBpZiAodmFsdWUpIHtcbiAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgIH0pO1xuICAgIH1cbiAgfSxcblxuICBvbkNoYW5nZTogZnVuY3Rpb24gb25DaGFuZ2UobmV3VmFsdWUpIHtcbiAgICB0aGlzLnNldFN0YXRlKHsgdmFsdWU6IG5ld1ZhbHVlIH0pO1xuICAgIHRoaXMucHJvcHMub25DaGFuZ2UobmV3VmFsdWUpO1xuICB9LFxuXG4gIG9uQ2xlYXI6IGZ1bmN0aW9uIG9uQ2xlYXIoKSB7XG4gICAgdGhpcy5wcm9wcy5vbkNsZWFyKCk7XG4gIH0sXG5cbiAgb25DdXJyZW50U2VsZWN0UGFuZWxDaGFuZ2U6IGZ1bmN0aW9uIG9uQ3VycmVudFNlbGVjdFBhbmVsQ2hhbmdlKGN1cnJlbnRTZWxlY3RQYW5lbCkge1xuICAgIHRoaXMuc2V0U3RhdGUoeyBjdXJyZW50U2VsZWN0UGFuZWw6IGN1cnJlbnRTZWxlY3RQYW5lbCB9KTtcbiAgfSxcblxuICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICB2YXIgX3Byb3BzID0gdGhpcy5wcm9wcztcbiAgICB2YXIgbG9jYWxlID0gX3Byb3BzLmxvY2FsZTtcbiAgICB2YXIgcHJlZml4Q2xzID0gX3Byb3BzLnByZWZpeENscztcbiAgICB2YXIgcGxhY2Vob2xkZXIgPSBfcHJvcHMucGxhY2Vob2xkZXI7XG4gICAgdmFyIGRpc2FibGVkSG91cnMgPSBfcHJvcHMuZGlzYWJsZWRIb3VycztcbiAgICB2YXIgZGlzYWJsZWRNaW51dGVzID0gX3Byb3BzLmRpc2FibGVkTWludXRlcztcbiAgICB2YXIgZGlzYWJsZWRTZWNvbmRzID0gX3Byb3BzLmRpc2FibGVkU2Vjb25kcztcbiAgICB2YXIgaGlkZURpc2FibGVkT3B0aW9ucyA9IF9wcm9wcy5oaWRlRGlzYWJsZWRPcHRpb25zO1xuICAgIHZhciBhbGxvd0VtcHR5ID0gX3Byb3BzLmFsbG93RW1wdHk7XG4gICAgdmFyIHNob3dIb3VyID0gX3Byb3BzLnNob3dIb3VyO1xuICAgIHZhciBzaG93U2Vjb25kID0gX3Byb3BzLnNob3dTZWNvbmQ7XG4gICAgdmFyIGZvcm1hdHRlciA9IF9wcm9wcy5mb3JtYXR0ZXI7XG4gICAgdmFyIGdyZWdvcmlhbkNhbGVuZGFyTG9jYWxlID0gX3Byb3BzLmdyZWdvcmlhbkNhbGVuZGFyTG9jYWxlO1xuXG4gICAgdmFyIHZhbHVlID0gdGhpcy5zdGF0ZS52YWx1ZTtcbiAgICB2YXIgZGlzYWJsZWRIb3VyT3B0aW9ucyA9IGRpc2FibGVkSG91cnMoKTtcbiAgICB2YXIgZGlzYWJsZWRNaW51dGVPcHRpb25zID0gZGlzYWJsZWRNaW51dGVzKHZhbHVlID8gdmFsdWUuZ2V0SG91ck9mRGF5KCkgOiBudWxsKTtcbiAgICB2YXIgZGlzYWJsZWRTZWNvbmRPcHRpb25zID0gZGlzYWJsZWRTZWNvbmRzKHZhbHVlID8gdmFsdWUuZ2V0SG91ck9mRGF5KCkgOiBudWxsLCB2YWx1ZSA/IHZhbHVlLmdldE1pbnV0ZXMoKSA6IG51bGwpO1xuICAgIHZhciBob3VyT3B0aW9ucyA9IGdlbmVyYXRlT3B0aW9ucygyNCwgZGlzYWJsZWRIb3VyT3B0aW9ucywgaGlkZURpc2FibGVkT3B0aW9ucyk7XG4gICAgdmFyIG1pbnV0ZU9wdGlvbnMgPSBnZW5lcmF0ZU9wdGlvbnMoNjAsIGRpc2FibGVkTWludXRlT3B0aW9ucywgaGlkZURpc2FibGVkT3B0aW9ucyk7XG4gICAgdmFyIHNlY29uZE9wdGlvbnMgPSBnZW5lcmF0ZU9wdGlvbnMoNjAsIGRpc2FibGVkU2Vjb25kT3B0aW9ucywgaGlkZURpc2FibGVkT3B0aW9ucyk7XG5cbiAgICByZXR1cm4gX3JlYWN0MlsnZGVmYXVsdCddLmNyZWF0ZUVsZW1lbnQoXG4gICAgICAnZGl2JyxcbiAgICAgIHsgY2xhc3NOYW1lOiBwcmVmaXhDbHMgKyAnLWlubmVyJyB9LFxuICAgICAgX3JlYWN0MlsnZGVmYXVsdCddLmNyZWF0ZUVsZW1lbnQoX0hlYWRlcjJbJ2RlZmF1bHQnXSwge1xuICAgICAgICBwcmVmaXhDbHM6IHByZWZpeENscyxcbiAgICAgICAgZ3JlZ29yaWFuQ2FsZW5kYXJMb2NhbGU6IGdyZWdvcmlhbkNhbGVuZGFyTG9jYWxlLFxuICAgICAgICBsb2NhbGU6IGxvY2FsZSxcbiAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICBjdXJyZW50U2VsZWN0UGFuZWw6IHRoaXMuc3RhdGUuY3VycmVudFNlbGVjdFBhbmVsLFxuICAgICAgICBvbkVzYzogdGhpcy5wcm9wcy5vbkVzYyxcbiAgICAgICAgZm9ybWF0dGVyOiBmb3JtYXR0ZXIsXG4gICAgICAgIHBsYWNlaG9sZGVyOiBwbGFjZWhvbGRlcixcbiAgICAgICAgaG91ck9wdGlvbnM6IGhvdXJPcHRpb25zLFxuICAgICAgICBtaW51dGVPcHRpb25zOiBtaW51dGVPcHRpb25zLFxuICAgICAgICBzZWNvbmRPcHRpb25zOiBzZWNvbmRPcHRpb25zLFxuICAgICAgICBkaXNhYmxlZEhvdXJzOiBkaXNhYmxlZEhvdXJzLFxuICAgICAgICBkaXNhYmxlZE1pbnV0ZXM6IGRpc2FibGVkTWludXRlcyxcbiAgICAgICAgZGlzYWJsZWRTZWNvbmRzOiBkaXNhYmxlZFNlY29uZHMsXG4gICAgICAgIG9uQ2hhbmdlOiB0aGlzLm9uQ2hhbmdlLFxuICAgICAgICBvbkNsZWFyOiB0aGlzLm9uQ2xlYXIsXG4gICAgICAgIGFsbG93RW1wdHk6IGFsbG93RW1wdHlcbiAgICAgIH0pLFxuICAgICAgX3JlYWN0MlsnZGVmYXVsdCddLmNyZWF0ZUVsZW1lbnQoX0NvbWJvYm94MlsnZGVmYXVsdCddLCB7XG4gICAgICAgIHByZWZpeENsczogcHJlZml4Q2xzLFxuICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgIGdyZWdvcmlhbkNhbGVuZGFyTG9jYWxlOiBncmVnb3JpYW5DYWxlbmRhckxvY2FsZSxcbiAgICAgICAgZm9ybWF0dGVyOiBmb3JtYXR0ZXIsXG4gICAgICAgIG9uQ2hhbmdlOiB0aGlzLm9uQ2hhbmdlLFxuICAgICAgICBzaG93SG91cjogc2hvd0hvdXIsXG4gICAgICAgIHNob3dTZWNvbmQ6IHNob3dTZWNvbmQsXG4gICAgICAgIGhvdXJPcHRpb25zOiBob3VyT3B0aW9ucyxcbiAgICAgICAgbWludXRlT3B0aW9uczogbWludXRlT3B0aW9ucyxcbiAgICAgICAgc2Vjb25kT3B0aW9uczogc2Vjb25kT3B0aW9ucyxcbiAgICAgICAgZGlzYWJsZWRIb3VyczogZGlzYWJsZWRIb3VycyxcbiAgICAgICAgZGlzYWJsZWRNaW51dGVzOiBkaXNhYmxlZE1pbnV0ZXMsXG4gICAgICAgIGRpc2FibGVkU2Vjb25kczogZGlzYWJsZWRTZWNvbmRzLFxuICAgICAgICBvbkN1cnJlbnRTZWxlY3RQYW5lbENoYW5nZTogdGhpcy5vbkN1cnJlbnRTZWxlY3RQYW5lbENoYW5nZVxuICAgICAgfSlcbiAgICApO1xuICB9XG59KTtcblxuZXhwb3J0c1snZGVmYXVsdCddID0gUGFuZWw7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi91eGNvcmUtZm9ybS9+L3V4Y29yZS1kYXRlLWZvcm0tZmllbGQvfi91eGNvcmUtY2FsZW5kYXIvfi9yYy10aW1lLXBpY2tlci9saWIvbW9kdWxlL1BhbmVsLmpzXG4gKiogbW9kdWxlIGlkID0gNDgyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbnZhciBfcmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xuXG52YXIgX2xvY2FsZUVuX1VTID0gcmVxdWlyZSgnLi4vbG9jYWxlL2VuX1VTJyk7XG5cbnZhciBfbG9jYWxlRW5fVVMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfbG9jYWxlRW5fVVMpO1xuXG5leHBvcnRzWydkZWZhdWx0J10gPSB7XG4gIHByb3BUeXBlczoge1xuICAgIHByZWZpeENsczogX3JlYWN0LlByb3BUeXBlcy5zdHJpbmcsXG4gICAgbG9jYWxlOiBfcmVhY3QuUHJvcFR5cGVzLm9iamVjdFxuICB9LFxuXG4gIGdldERlZmF1bHRQcm9wczogZnVuY3Rpb24gZ2V0RGVmYXVsdFByb3BzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBwcmVmaXhDbHM6ICdyYy10aW1lLXBpY2tlcicsXG4gICAgICBsb2NhbGU6IF9sb2NhbGVFbl9VUzJbJ2RlZmF1bHQnXVxuICAgIH07XG4gIH1cbn07XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi91eGNvcmUtZm9ybS9+L3V4Y29yZS1kYXRlLWZvcm0tZmllbGQvfi91eGNvcmUtY2FsZW5kYXIvfi9yYy10aW1lLXBpY2tlci9saWIvbWl4aW4vQ29tbW9uTWl4aW4uanNcbiAqKiBtb2R1bGUgaWQgPSA0ODNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxudmFyIF9ncmVnb3JpYW5DYWxlbmRhckZvcm1hdExpYkxvY2FsZUVuX1VTID0gcmVxdWlyZSgnZ3JlZ29yaWFuLWNhbGVuZGFyLWZvcm1hdC9saWIvbG9jYWxlL2VuX1VTJyk7XG5cbnZhciBfZ3JlZ29yaWFuQ2FsZW5kYXJGb3JtYXRMaWJMb2NhbGVFbl9VUzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9ncmVnb3JpYW5DYWxlbmRhckZvcm1hdExpYkxvY2FsZUVuX1VTKTtcblxudmFyIF9ncmVnb3JpYW5DYWxlbmRhckxpYkxvY2FsZUVuX1VTID0gcmVxdWlyZSgnZ3JlZ29yaWFuLWNhbGVuZGFyL2xpYi9sb2NhbGUvZW5fVVMnKTtcblxudmFyIF9ncmVnb3JpYW5DYWxlbmRhckxpYkxvY2FsZUVuX1VTMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2dyZWdvcmlhbkNhbGVuZGFyTGliTG9jYWxlRW5fVVMpO1xuXG5leHBvcnRzWydkZWZhdWx0J10gPSB7XG4gIGNsZWFyOiAnQ2xlYXInLFxuICBmb3JtYXQ6IF9ncmVnb3JpYW5DYWxlbmRhckZvcm1hdExpYkxvY2FsZUVuX1VTMlsnZGVmYXVsdCddLFxuICBjYWxlbmRhcjogX2dyZWdvcmlhbkNhbGVuZGFyTGliTG9jYWxlRW5fVVMyWydkZWZhdWx0J11cbn07XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi91eGNvcmUtZm9ybS9+L3V4Y29yZS1kYXRlLWZvcm0tZmllbGQvfi91eGNvcmUtY2FsZW5kYXIvfi9yYy10aW1lLXBpY2tlci9saWIvbG9jYWxlL2VuX1VTLmpzXG4gKiogbW9kdWxlIGlkID0gNDg0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbnZhciBfcmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xuXG52YXIgX3JlYWN0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JlYWN0KTtcblxudmFyIF91dGlsU2VsZWN0aW9uID0gcmVxdWlyZSgnLi4vdXRpbC9zZWxlY3Rpb24nKTtcblxudmFyIF91dGlsU2VsZWN0aW9uMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3V0aWxTZWxlY3Rpb24pO1xuXG52YXIgSGVhZGVyID0gX3JlYWN0MlsnZGVmYXVsdCddLmNyZWF0ZUNsYXNzKHtcbiAgZGlzcGxheU5hbWU6ICdIZWFkZXInLFxuXG4gIHByb3BUeXBlczoge1xuICAgIGZvcm1hdHRlcjogX3JlYWN0LlByb3BUeXBlcy5vYmplY3QsXG4gICAgcHJlZml4Q2xzOiBfcmVhY3QuUHJvcFR5cGVzLnN0cmluZyxcbiAgICBncmVnb3JpYW5DYWxlbmRhckxvY2FsZTogX3JlYWN0LlByb3BUeXBlcy5vYmplY3QsXG4gICAgbG9jYWxlOiBfcmVhY3QuUHJvcFR5cGVzLm9iamVjdCxcbiAgICBkaXNhYmxlZERhdGU6IF9yZWFjdC5Qcm9wVHlwZXMuZnVuYyxcbiAgICBwbGFjZWhvbGRlcjogX3JlYWN0LlByb3BUeXBlcy5zdHJpbmcsXG4gICAgdmFsdWU6IF9yZWFjdC5Qcm9wVHlwZXMub2JqZWN0LFxuICAgIGhvdXJPcHRpb25zOiBfcmVhY3QuUHJvcFR5cGVzLmFycmF5LFxuICAgIG1pbnV0ZU9wdGlvbnM6IF9yZWFjdC5Qcm9wVHlwZXMuYXJyYXksXG4gICAgc2Vjb25kT3B0aW9uczogX3JlYWN0LlByb3BUeXBlcy5hcnJheSxcbiAgICBkaXNhYmxlZEhvdXJzOiBfcmVhY3QuUHJvcFR5cGVzLmZ1bmMsXG4gICAgZGlzYWJsZWRNaW51dGVzOiBfcmVhY3QuUHJvcFR5cGVzLmZ1bmMsXG4gICAgZGlzYWJsZWRTZWNvbmRzOiBfcmVhY3QuUHJvcFR5cGVzLmZ1bmMsXG4gICAgb25DaGFuZ2U6IF9yZWFjdC5Qcm9wVHlwZXMuZnVuYyxcbiAgICBvbkNsZWFyOiBfcmVhY3QuUHJvcFR5cGVzLmZ1bmMsXG4gICAgb25Fc2M6IF9yZWFjdC5Qcm9wVHlwZXMuZnVuYyxcbiAgICBhbGxvd0VtcHR5OiBfcmVhY3QuUHJvcFR5cGVzLmJvb2wsXG4gICAgY3VycmVudFNlbGVjdFBhbmVsOiBfcmVhY3QuUHJvcFR5cGVzLnN0cmluZ1xuICB9LFxuXG4gIGdldEluaXRpYWxTdGF0ZTogZnVuY3Rpb24gZ2V0SW5pdGlhbFN0YXRlKCkge1xuICAgIHZhciB2YWx1ZSA9IHRoaXMucHJvcHMudmFsdWU7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN0cjogdmFsdWUgJiYgdGhpcy5wcm9wcy5mb3JtYXR0ZXIuZm9ybWF0KHZhbHVlKSB8fCAnJyxcbiAgICAgIGludmFsaWQ6IGZhbHNlXG4gICAgfTtcbiAgfSxcblxuICBjb21wb25lbnREaWRNb3VudDogZnVuY3Rpb24gY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgdGhpcy50aW1lciA9IHNldFRpbWVvdXQodGhpcy5zZWxlY3RSYW5nZSwgMCk7XG4gIH0sXG5cbiAgY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wczogZnVuY3Rpb24gY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhuZXh0UHJvcHMpIHtcbiAgICB2YXIgdmFsdWUgPSBuZXh0UHJvcHMudmFsdWU7XG4gICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICBzdHI6IHZhbHVlICYmIG5leHRQcm9wcy5mb3JtYXR0ZXIuZm9ybWF0KHZhbHVlKSB8fCAnJyxcbiAgICAgIGludmFsaWQ6IGZhbHNlXG4gICAgfSk7XG4gIH0sXG5cbiAgY29tcG9uZW50RGlkVXBkYXRlOiBmdW5jdGlvbiBjb21wb25lbnREaWRVcGRhdGUoKSB7XG4gICAgdGhpcy50aW1lciA9IHNldFRpbWVvdXQodGhpcy5zZWxlY3RSYW5nZSwgMCk7XG4gIH0sXG5cbiAgY29tcG9uZW50V2lsbFVubW91bnQ6IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVyKTtcbiAgfSxcblxuICBvbklucHV0Q2hhbmdlOiBmdW5jdGlvbiBvbklucHV0Q2hhbmdlKGV2ZW50KSB7XG4gICAgdmFyIHN0ciA9IGV2ZW50LnRhcmdldC52YWx1ZTtcbiAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgIHN0cjogc3RyXG4gICAgfSk7XG4gICAgdmFyIHZhbHVlID0gbnVsbDtcbiAgICB2YXIgX3Byb3BzID0gdGhpcy5wcm9wcztcbiAgICB2YXIgZm9ybWF0dGVyID0gX3Byb3BzLmZvcm1hdHRlcjtcbiAgICB2YXIgZ3JlZ29yaWFuQ2FsZW5kYXJMb2NhbGUgPSBfcHJvcHMuZ3JlZ29yaWFuQ2FsZW5kYXJMb2NhbGU7XG4gICAgdmFyIGhvdXJPcHRpb25zID0gX3Byb3BzLmhvdXJPcHRpb25zO1xuICAgIHZhciBtaW51dGVPcHRpb25zID0gX3Byb3BzLm1pbnV0ZU9wdGlvbnM7XG4gICAgdmFyIHNlY29uZE9wdGlvbnMgPSBfcHJvcHMuc2Vjb25kT3B0aW9ucztcbiAgICB2YXIgZGlzYWJsZWRIb3VycyA9IF9wcm9wcy5kaXNhYmxlZEhvdXJzO1xuICAgIHZhciBkaXNhYmxlZE1pbnV0ZXMgPSBfcHJvcHMuZGlzYWJsZWRNaW51dGVzO1xuICAgIHZhciBkaXNhYmxlZFNlY29uZHMgPSBfcHJvcHMuZGlzYWJsZWRTZWNvbmRzO1xuICAgIHZhciBvbkNoYW5nZSA9IF9wcm9wcy5vbkNoYW5nZTtcbiAgICB2YXIgYWxsb3dFbXB0eSA9IF9wcm9wcy5hbGxvd0VtcHR5O1xuXG4gICAgaWYgKHN0cikge1xuICAgICAgdmFyIG9yaWdpbmFsVmFsdWUgPSB0aGlzLnByb3BzLnZhbHVlO1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFsdWUgPSBmb3JtYXR0ZXIucGFyc2Uoc3RyLCB7XG4gICAgICAgICAgbG9jYWxlOiBncmVnb3JpYW5DYWxlbmRhckxvY2FsZSxcbiAgICAgICAgICBvYmV5Q291bnQ6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICBpbnZhbGlkOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAvLyBpZiB0aW1lIHZhbHVlIG5vdCBhbGxvd2VkLCByZXNwb25zZSB3YXJuaW5nLlxuICAgICAgICBpZiAoaG91ck9wdGlvbnMuaW5kZXhPZih2YWx1ZS5nZXRIb3VyT2ZEYXkoKSkgPCAwIHx8IG1pbnV0ZU9wdGlvbnMuaW5kZXhPZih2YWx1ZS5nZXRNaW51dGVzKCkpIDwgMCB8fCBzZWNvbmRPcHRpb25zLmluZGV4T2YodmFsdWUuZ2V0U2Vjb25kcygpKSA8IDApIHtcbiAgICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgIGludmFsaWQ6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpZiB0aW1lIHZhbHVlIGlzIGRpc2FibGVkLCByZXNwb25zZSB3YXJuaW5nLlxuICAgICAgICB2YXIgZGlzYWJsZWRIb3VyT3B0aW9ucyA9IGRpc2FibGVkSG91cnMoKTtcbiAgICAgICAgdmFyIGRpc2FibGVkTWludXRlT3B0aW9ucyA9IGRpc2FibGVkTWludXRlcyh2YWx1ZS5nZXRIb3VyT2ZEYXkoKSk7XG4gICAgICAgIHZhciBkaXNhYmxlZFNlY29uZE9wdGlvbnMgPSBkaXNhYmxlZFNlY29uZHModmFsdWUuZ2V0SG91ck9mRGF5KCksIHZhbHVlLmdldE1pbnV0ZXMoKSk7XG4gICAgICAgIGlmIChkaXNhYmxlZEhvdXJPcHRpb25zICYmIGRpc2FibGVkSG91ck9wdGlvbnMuaW5kZXhPZih2YWx1ZS5nZXRIb3VyT2ZEYXkoKSkgPj0gMCB8fCBkaXNhYmxlZE1pbnV0ZU9wdGlvbnMgJiYgZGlzYWJsZWRNaW51dGVPcHRpb25zLmluZGV4T2YodmFsdWUuZ2V0TWludXRlcygpKSA+PSAwIHx8IGRpc2FibGVkU2Vjb25kT3B0aW9ucyAmJiBkaXNhYmxlZFNlY29uZE9wdGlvbnMuaW5kZXhPZih2YWx1ZS5nZXRTZWNvbmRzKCkpID49IDApIHtcbiAgICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgIGludmFsaWQ6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3JpZ2luYWxWYWx1ZSAmJiB2YWx1ZSkge1xuICAgICAgICAgIGlmIChvcmlnaW5hbFZhbHVlLmdldEhvdXJPZkRheSgpICE9PSB2YWx1ZS5nZXRIb3VyT2ZEYXkoKSB8fCBvcmlnaW5hbFZhbHVlLmdldE1pbnV0ZXMoKSAhPT0gdmFsdWUuZ2V0TWludXRlcygpIHx8IG9yaWdpbmFsVmFsdWUuZ2V0U2Vjb25kcygpICE9PSB2YWx1ZS5nZXRTZWNvbmRzKCkpIHtcbiAgICAgICAgICAgIC8vIGtlZXAgb3RoZXIgZmllbGRzIGZvciByYy1jYWxlbmRhclxuICAgICAgICAgICAgdmFyIGNoYW5nZWRWYWx1ZSA9IG9yaWdpbmFsVmFsdWUuY2xvbmUoKTtcbiAgICAgICAgICAgIGNoYW5nZWRWYWx1ZS5zZXRIb3VyT2ZEYXkodmFsdWUuZ2V0SG91ck9mRGF5KCkpO1xuICAgICAgICAgICAgY2hhbmdlZFZhbHVlLnNldE1pbnV0ZXModmFsdWUuZ2V0TWludXRlcygpKTtcbiAgICAgICAgICAgIGNoYW5nZWRWYWx1ZS5zZXRTZWNvbmRzKHZhbHVlLmdldFNlY29uZHMoKSk7XG4gICAgICAgICAgICBvbkNoYW5nZShjaGFuZ2VkVmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChvcmlnaW5hbFZhbHVlICE9PSB2YWx1ZSkge1xuICAgICAgICAgIG9uQ2hhbmdlKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgaW52YWxpZDogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoYWxsb3dFbXB0eSkge1xuICAgICAgb25DaGFuZ2UobnVsbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICBpbnZhbGlkOiB0cnVlXG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgIGludmFsaWQ6IGZhbHNlXG4gICAgfSk7XG4gIH0sXG5cbiAgb25LZXlEb3duOiBmdW5jdGlvbiBvbktleURvd24oZSkge1xuICAgIGlmIChlLmtleUNvZGUgPT09IDI3KSB7XG4gICAgICB0aGlzLnByb3BzLm9uRXNjKCk7XG4gICAgfVxuICB9LFxuXG4gIG9uQ2xlYXI6IGZ1bmN0aW9uIG9uQ2xlYXIoKSB7XG4gICAgdGhpcy5zZXRTdGF0ZSh7IHN0cjogJycgfSk7XG4gICAgdGhpcy5wcm9wcy5vbkNsZWFyKCk7XG4gIH0sXG5cbiAgZ2V0Q2xlYXJCdXR0b246IGZ1bmN0aW9uIGdldENsZWFyQnV0dG9uKCkge1xuICAgIHZhciBfcHJvcHMyID0gdGhpcy5wcm9wcztcbiAgICB2YXIgbG9jYWxlID0gX3Byb3BzMi5sb2NhbGU7XG4gICAgdmFyIHByZWZpeENscyA9IF9wcm9wczIucHJlZml4Q2xzO1xuICAgIHZhciBhbGxvd0VtcHR5ID0gX3Byb3BzMi5hbGxvd0VtcHR5O1xuXG4gICAgaWYgKCFhbGxvd0VtcHR5KSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIF9yZWFjdDJbJ2RlZmF1bHQnXS5jcmVhdGVFbGVtZW50KCdhJywgeyBjbGFzc05hbWU6IHByZWZpeENscyArICctY2xlYXItYnRuJywgcm9sZTogJ2J1dHRvbicsIHRpdGxlOiBsb2NhbGUuY2xlYXIsIG9uTW91c2VEb3duOiB0aGlzLm9uQ2xlYXIgfSk7XG4gIH0sXG5cbiAgZ2V0SW5wdXQ6IGZ1bmN0aW9uIGdldElucHV0KCkge1xuICAgIHZhciBfcHJvcHMzID0gdGhpcy5wcm9wcztcbiAgICB2YXIgcHJlZml4Q2xzID0gX3Byb3BzMy5wcmVmaXhDbHM7XG4gICAgdmFyIHBsYWNlaG9sZGVyID0gX3Byb3BzMy5wbGFjZWhvbGRlcjtcbiAgICB2YXIgX3N0YXRlID0gdGhpcy5zdGF0ZTtcbiAgICB2YXIgaW52YWxpZCA9IF9zdGF0ZS5pbnZhbGlkO1xuICAgIHZhciBzdHIgPSBfc3RhdGUuc3RyO1xuXG4gICAgdmFyIGludmFsaWRDbGFzcyA9IGludmFsaWQgPyBwcmVmaXhDbHMgKyAnLWlucHV0LWludmFsaWQnIDogJyc7XG4gICAgcmV0dXJuIF9yZWFjdDJbJ2RlZmF1bHQnXS5jcmVhdGVFbGVtZW50KCdpbnB1dCcsIHtcbiAgICAgIGNsYXNzTmFtZTogcHJlZml4Q2xzICsgJy1pbnB1dCAgJyArIGludmFsaWRDbGFzcyxcbiAgICAgIHJlZjogJ2lucHV0JyxcbiAgICAgIG9uS2V5RG93bjogdGhpcy5vbktleURvd24sXG4gICAgICB2YWx1ZTogc3RyLFxuICAgICAgcGxhY2Vob2xkZXI6IHBsYWNlaG9sZGVyLCBvbkNoYW5nZTogdGhpcy5vbklucHV0Q2hhbmdlXG4gICAgfSk7XG4gIH0sXG5cbiAgc2VsZWN0UmFuZ2U6IGZ1bmN0aW9uIHNlbGVjdFJhbmdlKCkge1xuICAgIHRoaXMucmVmcy5pbnB1dC5mb2N1cygpO1xuICAgIGlmICh0aGlzLnByb3BzLmN1cnJlbnRTZWxlY3RQYW5lbCAmJiB0aGlzLnJlZnMuaW5wdXQudmFsdWUpIHtcbiAgICAgIHZhciBzZWxlY3Rpb25SYW5nZVN0YXJ0ID0gMDtcbiAgICAgIHZhciBzZWxlY3Rpb25SYW5nZUVuZCA9IDA7XG4gICAgICBpZiAodGhpcy5wcm9wcy5jdXJyZW50U2VsZWN0UGFuZWwgPT09ICdob3VyJykge1xuICAgICAgICBzZWxlY3Rpb25SYW5nZVN0YXJ0ID0gMDtcbiAgICAgICAgc2VsZWN0aW9uUmFuZ2VFbmQgPSB0aGlzLnJlZnMuaW5wdXQudmFsdWUuaW5kZXhPZignOicpO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLnByb3BzLmN1cnJlbnRTZWxlY3RQYW5lbCA9PT0gJ21pbnV0ZScpIHtcbiAgICAgICAgc2VsZWN0aW9uUmFuZ2VTdGFydCA9IHRoaXMucmVmcy5pbnB1dC52YWx1ZS5pbmRleE9mKCc6JykgKyAxO1xuICAgICAgICBzZWxlY3Rpb25SYW5nZUVuZCA9IHRoaXMucmVmcy5pbnB1dC52YWx1ZS5sYXN0SW5kZXhPZignOicpO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLnByb3BzLmN1cnJlbnRTZWxlY3RQYW5lbCA9PT0gJ3NlY29uZCcpIHtcbiAgICAgICAgc2VsZWN0aW9uUmFuZ2VTdGFydCA9IHRoaXMucmVmcy5pbnB1dC52YWx1ZS5sYXN0SW5kZXhPZignOicpICsgMTtcbiAgICAgICAgc2VsZWN0aW9uUmFuZ2VFbmQgPSB0aGlzLnJlZnMuaW5wdXQudmFsdWUubGVuZ3RoO1xuICAgICAgfVxuICAgICAgaWYgKHNlbGVjdGlvblJhbmdlRW5kIC0gc2VsZWN0aW9uUmFuZ2VTdGFydCA9PT0gMikge1xuICAgICAgICAoMCwgX3V0aWxTZWxlY3Rpb24yWydkZWZhdWx0J10pKHRoaXMucmVmcy5pbnB1dCwgc2VsZWN0aW9uUmFuZ2VTdGFydCwgc2VsZWN0aW9uUmFuZ2VFbmQpO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICB2YXIgcHJlZml4Q2xzID0gdGhpcy5wcm9wcy5wcmVmaXhDbHM7XG5cbiAgICByZXR1cm4gX3JlYWN0MlsnZGVmYXVsdCddLmNyZWF0ZUVsZW1lbnQoXG4gICAgICAnZGl2JyxcbiAgICAgIHsgY2xhc3NOYW1lOiBwcmVmaXhDbHMgKyAnLWlucHV0LXdyYXAnIH0sXG4gICAgICB0aGlzLmdldElucHV0KCksXG4gICAgICB0aGlzLmdldENsZWFyQnV0dG9uKClcbiAgICApO1xuICB9XG59KTtcblxuZXhwb3J0c1snZGVmYXVsdCddID0gSGVhZGVyO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vdXhjb3JlLWZvcm0vfi91eGNvcmUtZGF0ZS1mb3JtLWZpZWxkL34vdXhjb3JlLWNhbGVuZGFyL34vcmMtdGltZS1waWNrZXIvbGliL21vZHVsZS9IZWFkZXIuanNcbiAqKiBtb2R1bGUgaWQgPSA0ODVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzWydkZWZhdWx0J10gPSBjcmVhdGVTZWxlY3Rpb247XG5cbmZ1bmN0aW9uIGNyZWF0ZVNlbGVjdGlvbihmaWVsZCwgc3RhcnQsIGVuZCkge1xuICBpZiAoZmllbGQuY3JlYXRlVGV4dFJhbmdlKSB7XG4gICAgdmFyIHNlbFJhbmdlID0gZmllbGQuY3JlYXRlVGV4dFJhbmdlKCk7XG4gICAgc2VsUmFuZ2UuY29sbGFwc2UodHJ1ZSk7XG4gICAgc2VsUmFuZ2UubW92ZVN0YXJ0KCdjaGFyYWN0ZXInLCBzdGFydCk7XG4gICAgc2VsUmFuZ2UubW92ZUVuZCgnY2hhcmFjdGVyJywgZW5kKTtcbiAgICBzZWxSYW5nZS5zZWxlY3QoKTtcbiAgICBmaWVsZC5mb2N1cygpO1xuICB9IGVsc2UgaWYgKGZpZWxkLnNldFNlbGVjdGlvblJhbmdlKSB7XG4gICAgZmllbGQuZm9jdXMoKTtcbiAgICBmaWVsZC5zZXRTZWxlY3Rpb25SYW5nZShzdGFydCwgZW5kKTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgZmllbGQuc2VsZWN0aW9uU3RhcnQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgZmllbGQuc2VsZWN0aW9uU3RhcnQgPSBzdGFydDtcbiAgICBmaWVsZC5zZWxlY3Rpb25FbmQgPSBlbmQ7XG4gICAgZmllbGQuZm9jdXMoKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi91eGNvcmUtZm9ybS9+L3V4Y29yZS1kYXRlLWZvcm0tZmllbGQvfi91eGNvcmUtY2FsZW5kYXIvfi9yYy10aW1lLXBpY2tlci9saWIvdXRpbC9zZWxlY3Rpb24uanNcbiAqKiBtb2R1bGUgaWQgPSA0ODZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxudmFyIF9yZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5cbnZhciBfcmVhY3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmVhY3QpO1xuXG52YXIgX1NlbGVjdCA9IHJlcXVpcmUoJy4vU2VsZWN0Jyk7XG5cbnZhciBfU2VsZWN0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1NlbGVjdCk7XG5cbnZhciBfZ3JlZ29yaWFuQ2FsZW5kYXIgPSByZXF1aXJlKCdncmVnb3JpYW4tY2FsZW5kYXInKTtcblxudmFyIF9ncmVnb3JpYW5DYWxlbmRhcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9ncmVnb3JpYW5DYWxlbmRhcik7XG5cbnZhciBmb3JtYXRPcHRpb24gPSBmdW5jdGlvbiBmb3JtYXRPcHRpb24ob3B0aW9uLCBkaXNhYmxlZE9wdGlvbnMpIHtcbiAgdmFyIHZhbHVlID0gJycgKyBvcHRpb247XG4gIGlmIChvcHRpb24gPCAxMCkge1xuICAgIHZhbHVlID0gJzAnICsgb3B0aW9uO1xuICB9XG5cbiAgdmFyIGRpc2FibGVkID0gZmFsc2U7XG4gIGlmIChkaXNhYmxlZE9wdGlvbnMgJiYgZGlzYWJsZWRPcHRpb25zLmluZGV4T2Yob3B0aW9uKSA+PSAwKSB7XG4gICAgZGlzYWJsZWQgPSB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB2YWx1ZTogdmFsdWUsXG4gICAgZGlzYWJsZWQ6IGRpc2FibGVkXG4gIH07XG59O1xuXG52YXIgQ29tYm9ib3ggPSBfcmVhY3QyWydkZWZhdWx0J10uY3JlYXRlQ2xhc3Moe1xuICBkaXNwbGF5TmFtZTogJ0NvbWJvYm94JyxcblxuICBwcm9wVHlwZXM6IHtcbiAgICBmb3JtYXR0ZXI6IF9yZWFjdC5Qcm9wVHlwZXMub2JqZWN0LFxuICAgIHByZWZpeENsczogX3JlYWN0LlByb3BUeXBlcy5zdHJpbmcsXG4gICAgdmFsdWU6IF9yZWFjdC5Qcm9wVHlwZXMub2JqZWN0LFxuICAgIG9uQ2hhbmdlOiBfcmVhY3QuUHJvcFR5cGVzLmZ1bmMsXG4gICAgc2hvd0hvdXI6IF9yZWFjdC5Qcm9wVHlwZXMuYm9vbCxcbiAgICBncmVnb3JpYW5DYWxlbmRhckxvY2FsZTogX3JlYWN0LlByb3BUeXBlcy5vYmplY3QsXG4gICAgc2hvd1NlY29uZDogX3JlYWN0LlByb3BUeXBlcy5ib29sLFxuICAgIGhvdXJPcHRpb25zOiBfcmVhY3QuUHJvcFR5cGVzLmFycmF5LFxuICAgIG1pbnV0ZU9wdGlvbnM6IF9yZWFjdC5Qcm9wVHlwZXMuYXJyYXksXG4gICAgc2Vjb25kT3B0aW9uczogX3JlYWN0LlByb3BUeXBlcy5hcnJheSxcbiAgICBkaXNhYmxlZEhvdXJzOiBfcmVhY3QuUHJvcFR5cGVzLmZ1bmMsXG4gICAgZGlzYWJsZWRNaW51dGVzOiBfcmVhY3QuUHJvcFR5cGVzLmZ1bmMsXG4gICAgZGlzYWJsZWRTZWNvbmRzOiBfcmVhY3QuUHJvcFR5cGVzLmZ1bmMsXG4gICAgb25DdXJyZW50U2VsZWN0UGFuZWxDaGFuZ2U6IF9yZWFjdC5Qcm9wVHlwZXMuZnVuY1xuICB9LFxuXG4gIG9uSXRlbUNoYW5nZTogZnVuY3Rpb24gb25JdGVtQ2hhbmdlKHR5cGUsIGl0ZW1WYWx1ZSkge1xuICAgIHZhciBvbkNoYW5nZSA9IHRoaXMucHJvcHMub25DaGFuZ2U7XG5cbiAgICB2YXIgdmFsdWUgPSB0aGlzLnByb3BzLnZhbHVlO1xuICAgIGlmICh2YWx1ZSkge1xuICAgICAgdmFsdWUgPSB2YWx1ZS5jbG9uZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZSA9IHRoaXMuZ2V0Tm93KCkuY2xvbmUoKTtcbiAgICB9XG4gICAgaWYgKHR5cGUgPT09ICdob3VyJykge1xuICAgICAgdmFsdWUuc2V0SG91ck9mRGF5KGl0ZW1WYWx1ZSk7XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAnbWludXRlJykge1xuICAgICAgdmFsdWUuc2V0TWludXRlcyhpdGVtVmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZS5zZXRTZWNvbmRzKGl0ZW1WYWx1ZSk7XG4gICAgfVxuICAgIG9uQ2hhbmdlKHZhbHVlKTtcbiAgfSxcblxuICBvbkVudGVyU2VsZWN0UGFuZWw6IGZ1bmN0aW9uIG9uRW50ZXJTZWxlY3RQYW5lbChyYW5nZSkge1xuICAgIHRoaXMucHJvcHMub25DdXJyZW50U2VsZWN0UGFuZWxDaGFuZ2UocmFuZ2UpO1xuICB9LFxuXG4gIGdldEhvdXJTZWxlY3Q6IGZ1bmN0aW9uIGdldEhvdXJTZWxlY3QoaG91cikge1xuICAgIHZhciBfcHJvcHMgPSB0aGlzLnByb3BzO1xuICAgIHZhciBwcmVmaXhDbHMgPSBfcHJvcHMucHJlZml4Q2xzO1xuICAgIHZhciBob3VyT3B0aW9ucyA9IF9wcm9wcy5ob3VyT3B0aW9ucztcbiAgICB2YXIgZGlzYWJsZWRIb3VycyA9IF9wcm9wcy5kaXNhYmxlZEhvdXJzO1xuICAgIHZhciBzaG93SG91ciA9IF9wcm9wcy5zaG93SG91cjtcblxuICAgIGlmICghc2hvd0hvdXIpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB2YXIgZGlzYWJsZWRPcHRpb25zID0gZGlzYWJsZWRIb3VycygpO1xuXG4gICAgcmV0dXJuIF9yZWFjdDJbJ2RlZmF1bHQnXS5jcmVhdGVFbGVtZW50KF9TZWxlY3QyWydkZWZhdWx0J10sIHtcbiAgICAgIHByZWZpeENsczogcHJlZml4Q2xzLFxuICAgICAgb3B0aW9uczogaG91ck9wdGlvbnMubWFwKGZ1bmN0aW9uIChvcHRpb24pIHtcbiAgICAgICAgcmV0dXJuIGZvcm1hdE9wdGlvbihvcHRpb24sIGRpc2FibGVkT3B0aW9ucyk7XG4gICAgICB9KSxcbiAgICAgIHNlbGVjdGVkSW5kZXg6IGhvdXJPcHRpb25zLmluZGV4T2YoaG91ciksXG4gICAgICB0eXBlOiAnaG91cicsXG4gICAgICBvblNlbGVjdDogdGhpcy5vbkl0ZW1DaGFuZ2UsXG4gICAgICBvbk1vdXNlRW50ZXI6IHRoaXMub25FbnRlclNlbGVjdFBhbmVsLmJpbmQodGhpcywgJ2hvdXInKVxuICAgIH0pO1xuICB9LFxuXG4gIGdldE1pbnV0ZVNlbGVjdDogZnVuY3Rpb24gZ2V0TWludXRlU2VsZWN0KG1pbnV0ZSkge1xuICAgIHZhciBfcHJvcHMyID0gdGhpcy5wcm9wcztcbiAgICB2YXIgcHJlZml4Q2xzID0gX3Byb3BzMi5wcmVmaXhDbHM7XG4gICAgdmFyIG1pbnV0ZU9wdGlvbnMgPSBfcHJvcHMyLm1pbnV0ZU9wdGlvbnM7XG4gICAgdmFyIGRpc2FibGVkTWludXRlcyA9IF9wcm9wczIuZGlzYWJsZWRNaW51dGVzO1xuXG4gICAgdmFyIHZhbHVlID0gdGhpcy5wcm9wcy52YWx1ZSB8fCB0aGlzLmdldE5vdygpO1xuICAgIHZhciBkaXNhYmxlZE9wdGlvbnMgPSBkaXNhYmxlZE1pbnV0ZXModmFsdWUuZ2V0SG91ck9mRGF5KCkpO1xuXG4gICAgcmV0dXJuIF9yZWFjdDJbJ2RlZmF1bHQnXS5jcmVhdGVFbGVtZW50KF9TZWxlY3QyWydkZWZhdWx0J10sIHtcbiAgICAgIHByZWZpeENsczogcHJlZml4Q2xzLFxuICAgICAgb3B0aW9uczogbWludXRlT3B0aW9ucy5tYXAoZnVuY3Rpb24gKG9wdGlvbikge1xuICAgICAgICByZXR1cm4gZm9ybWF0T3B0aW9uKG9wdGlvbiwgZGlzYWJsZWRPcHRpb25zKTtcbiAgICAgIH0pLFxuICAgICAgc2VsZWN0ZWRJbmRleDogbWludXRlT3B0aW9ucy5pbmRleE9mKG1pbnV0ZSksXG4gICAgICB0eXBlOiAnbWludXRlJyxcbiAgICAgIG9uU2VsZWN0OiB0aGlzLm9uSXRlbUNoYW5nZSxcbiAgICAgIG9uTW91c2VFbnRlcjogdGhpcy5vbkVudGVyU2VsZWN0UGFuZWwuYmluZCh0aGlzLCAnbWludXRlJylcbiAgICB9KTtcbiAgfSxcblxuICBnZXRTZWNvbmRTZWxlY3Q6IGZ1bmN0aW9uIGdldFNlY29uZFNlbGVjdChzZWNvbmQpIHtcbiAgICB2YXIgX3Byb3BzMyA9IHRoaXMucHJvcHM7XG4gICAgdmFyIHByZWZpeENscyA9IF9wcm9wczMucHJlZml4Q2xzO1xuICAgIHZhciBzZWNvbmRPcHRpb25zID0gX3Byb3BzMy5zZWNvbmRPcHRpb25zO1xuICAgIHZhciBkaXNhYmxlZFNlY29uZHMgPSBfcHJvcHMzLmRpc2FibGVkU2Vjb25kcztcbiAgICB2YXIgc2hvd1NlY29uZCA9IF9wcm9wczMuc2hvd1NlY29uZDtcblxuICAgIGlmICghc2hvd1NlY29uZCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHZhciB2YWx1ZSA9IHRoaXMucHJvcHMudmFsdWUgfHwgdGhpcy5nZXROb3coKTtcbiAgICB2YXIgZGlzYWJsZWRPcHRpb25zID0gZGlzYWJsZWRTZWNvbmRzKHZhbHVlLmdldEhvdXJPZkRheSgpLCB2YWx1ZS5nZXRNaW51dGVzKCkpO1xuXG4gICAgcmV0dXJuIF9yZWFjdDJbJ2RlZmF1bHQnXS5jcmVhdGVFbGVtZW50KF9TZWxlY3QyWydkZWZhdWx0J10sIHtcbiAgICAgIHByZWZpeENsczogcHJlZml4Q2xzLFxuICAgICAgb3B0aW9uczogc2Vjb25kT3B0aW9ucy5tYXAoZnVuY3Rpb24gKG9wdGlvbikge1xuICAgICAgICByZXR1cm4gZm9ybWF0T3B0aW9uKG9wdGlvbiwgZGlzYWJsZWRPcHRpb25zKTtcbiAgICAgIH0pLFxuICAgICAgc2VsZWN0ZWRJbmRleDogc2Vjb25kT3B0aW9ucy5pbmRleE9mKHNlY29uZCksXG4gICAgICB0eXBlOiAnc2Vjb25kJyxcbiAgICAgIG9uU2VsZWN0OiB0aGlzLm9uSXRlbUNoYW5nZSxcbiAgICAgIG9uTW91c2VFbnRlcjogdGhpcy5vbkVudGVyU2VsZWN0UGFuZWwuYmluZCh0aGlzLCAnc2Vjb25kJylcbiAgICB9KTtcbiAgfSxcblxuICBnZXROb3c6IGZ1bmN0aW9uIGdldE5vdygpIHtcbiAgICBpZiAodGhpcy5zaG93Tm93KSB7XG4gICAgICByZXR1cm4gdGhpcy5zaG93Tm93O1xuICAgIH1cbiAgICB2YXIgdmFsdWUgPSBuZXcgX2dyZWdvcmlhbkNhbGVuZGFyMlsnZGVmYXVsdCddKHRoaXMucHJvcHMuZ3JlZ29yaWFuQ2FsZW5kYXJMb2NhbGUpO1xuICAgIHZhbHVlLnNldFRpbWUoRGF0ZS5ub3coKSk7XG4gICAgdGhpcy5zaG93Tm93ID0gdmFsdWU7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9LFxuXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgIHZhciBwcmVmaXhDbHMgPSB0aGlzLnByb3BzLnByZWZpeENscztcblxuICAgIHZhciB2YWx1ZSA9IHRoaXMucHJvcHMudmFsdWUgfHwgdGhpcy5nZXROb3coKTtcbiAgICByZXR1cm4gX3JlYWN0MlsnZGVmYXVsdCddLmNyZWF0ZUVsZW1lbnQoXG4gICAgICAnZGl2JyxcbiAgICAgIHsgY2xhc3NOYW1lOiBwcmVmaXhDbHMgKyAnLWNvbWJvYm94JyB9LFxuICAgICAgdGhpcy5nZXRIb3VyU2VsZWN0KHZhbHVlLmdldEhvdXJPZkRheSgpKSxcbiAgICAgIHRoaXMuZ2V0TWludXRlU2VsZWN0KHZhbHVlLmdldE1pbnV0ZXMoKSksXG4gICAgICB0aGlzLmdldFNlY29uZFNlbGVjdCh2YWx1ZS5nZXRTZWNvbmRzKCkpXG4gICAgKTtcbiAgfVxufSk7XG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IENvbWJvYm94O1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vdXhjb3JlLWZvcm0vfi91eGNvcmUtZGF0ZS1mb3JtLWZpZWxkL34vdXhjb3JlLWNhbGVuZGFyL34vcmMtdGltZS1waWNrZXIvbGliL21vZHVsZS9Db21ib2JveC5qc1xuICoqIG1vZHVsZSBpZCA9IDQ4N1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxuXG52YXIgX3JlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxudmFyIF9yZWFjdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yZWFjdCk7XG5cbnZhciBfcmVhY3REb20gPSByZXF1aXJlKCdyZWFjdC1kb20nKTtcblxudmFyIF9yZWFjdERvbTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yZWFjdERvbSk7XG5cbnZhciBfY2xhc3NuYW1lczIgPSByZXF1aXJlKCdjbGFzc25hbWVzJyk7XG5cbnZhciBfY2xhc3NuYW1lczMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jbGFzc25hbWVzMik7XG5cbnZhciBzY3JvbGxUbyA9IGZ1bmN0aW9uIHNjcm9sbFRvKGVsZW1lbnQsIHRvLCBkdXJhdGlvbikge1xuICB2YXIgcmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSB8fCBmdW5jdGlvbiByZXF1ZXN0QW5pbWF0aW9uRnJhbWVUaW1lb3V0KCkge1xuICAgIHJldHVybiBzZXRUaW1lb3V0KGFyZ3VtZW50c1swXSwgMTApO1xuICB9O1xuICAvLyBqdW1wIHRvIHRhcmdldCBpZiBkdXJhdGlvbiB6ZXJvXG4gIGlmIChkdXJhdGlvbiA8PSAwKSB7XG4gICAgZWxlbWVudC5zY3JvbGxUb3AgPSB0bztcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIGRpZmZlcmVuY2UgPSB0byAtIGVsZW1lbnQuc2Nyb2xsVG9wO1xuICB2YXIgcGVyVGljayA9IGRpZmZlcmVuY2UgLyBkdXJhdGlvbiAqIDEwO1xuXG4gIHJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbiAoKSB7XG4gICAgZWxlbWVudC5zY3JvbGxUb3AgPSBlbGVtZW50LnNjcm9sbFRvcCArIHBlclRpY2s7XG4gICAgaWYgKGVsZW1lbnQuc2Nyb2xsVG9wID09PSB0bykgcmV0dXJuO1xuICAgIHNjcm9sbFRvKGVsZW1lbnQsIHRvLCBkdXJhdGlvbiAtIDEwKTtcbiAgfSk7XG59O1xuXG52YXIgU2VsZWN0ID0gX3JlYWN0MlsnZGVmYXVsdCddLmNyZWF0ZUNsYXNzKHtcbiAgZGlzcGxheU5hbWU6ICdTZWxlY3QnLFxuXG4gIHByb3BUeXBlczoge1xuICAgIHByZWZpeENsczogX3JlYWN0LlByb3BUeXBlcy5zdHJpbmcsXG4gICAgb3B0aW9uczogX3JlYWN0LlByb3BUeXBlcy5hcnJheSxcbiAgICBncmVnb3JpYW5DYWxlbmRhckxvY2FsZTogX3JlYWN0LlByb3BUeXBlcy5vYmplY3QsXG4gICAgc2VsZWN0ZWRJbmRleDogX3JlYWN0LlByb3BUeXBlcy5udW1iZXIsXG4gICAgdHlwZTogX3JlYWN0LlByb3BUeXBlcy5zdHJpbmcsXG4gICAgb25TZWxlY3Q6IF9yZWFjdC5Qcm9wVHlwZXMuZnVuYyxcbiAgICBvbk1vdXNlRW50ZXI6IF9yZWFjdC5Qcm9wVHlwZXMuZnVuY1xuICB9LFxuXG4gIGNvbXBvbmVudERpZE1vdW50OiBmdW5jdGlvbiBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICAvLyBqdW1wIHRvIHNlbGVjdGVkIG9wdGlvblxuICAgIHRoaXMuc2Nyb2xsVG9TZWxlY3RlZCgwKTtcbiAgfSxcblxuICBjb21wb25lbnREaWRVcGRhdGU6IGZ1bmN0aW9uIGNvbXBvbmVudERpZFVwZGF0ZShwcmV2UHJvcHMpIHtcbiAgICAvLyBzbW9vdGggc2Nyb2xsIHRvIHNlbGVjdGVkIG9wdGlvblxuICAgIGlmIChwcmV2UHJvcHMuc2VsZWN0ZWRJbmRleCAhPT0gdGhpcy5wcm9wcy5zZWxlY3RlZEluZGV4KSB7XG4gICAgICB0aGlzLnNjcm9sbFRvU2VsZWN0ZWQoMTIwKTtcbiAgICB9XG4gIH0sXG5cbiAgb25TZWxlY3Q6IGZ1bmN0aW9uIG9uU2VsZWN0KHZhbHVlKSB7XG4gICAgdmFyIF9wcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgdmFyIG9uU2VsZWN0ID0gX3Byb3BzLm9uU2VsZWN0O1xuICAgIHZhciB0eXBlID0gX3Byb3BzLnR5cGU7XG5cbiAgICBvblNlbGVjdCh0eXBlLCB2YWx1ZSk7XG4gIH0sXG5cbiAgZ2V0T3B0aW9uczogZnVuY3Rpb24gZ2V0T3B0aW9ucygpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgdmFyIF9wcm9wczIgPSB0aGlzLnByb3BzO1xuICAgIHZhciBvcHRpb25zID0gX3Byb3BzMi5vcHRpb25zO1xuICAgIHZhciBzZWxlY3RlZEluZGV4ID0gX3Byb3BzMi5zZWxlY3RlZEluZGV4O1xuICAgIHZhciBwcmVmaXhDbHMgPSBfcHJvcHMyLnByZWZpeENscztcblxuICAgIHJldHVybiBvcHRpb25zLm1hcChmdW5jdGlvbiAoaXRlbSwgaW5kZXgpIHtcbiAgICAgIHZhciBfY2xhc3NuYW1lcztcblxuICAgICAgdmFyIGNscyA9ICgwLCBfY2xhc3NuYW1lczNbJ2RlZmF1bHQnXSkoKF9jbGFzc25hbWVzID0ge30sIF9kZWZpbmVQcm9wZXJ0eShfY2xhc3NuYW1lcywgcHJlZml4Q2xzICsgJy1zZWxlY3Qtb3B0aW9uLXNlbGVjdGVkJywgc2VsZWN0ZWRJbmRleCA9PT0gaW5kZXgpLCBfZGVmaW5lUHJvcGVydHkoX2NsYXNzbmFtZXMsIHByZWZpeENscyArICctc2VsZWN0LW9wdGlvbi1kaXNhYmxlZCcsIGl0ZW0uZGlzYWJsZWQpLCBfY2xhc3NuYW1lcykpO1xuICAgICAgdmFyIG9uY2xpY2sgPSBudWxsO1xuICAgICAgaWYgKCFpdGVtLmRpc2FibGVkKSB7XG4gICAgICAgIG9uY2xpY2sgPSBfdGhpcy5vblNlbGVjdC5iaW5kKF90aGlzLCAraXRlbS52YWx1ZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gX3JlYWN0MlsnZGVmYXVsdCddLmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICdsaScsXG4gICAgICAgIHsgY2xhc3NOYW1lOiBjbHMsIGtleTogaW5kZXgsIG9uQ2xpY2s6IG9uY2xpY2ssIGRpc2FibGVkOiBpdGVtLmRpc2FibGVkIH0sXG4gICAgICAgIGl0ZW0udmFsdWVcbiAgICAgICk7XG4gICAgfSk7XG4gIH0sXG5cbiAgc2Nyb2xsVG9TZWxlY3RlZDogZnVuY3Rpb24gc2Nyb2xsVG9TZWxlY3RlZChkdXJhdGlvbikge1xuICAgIC8vIG1vdmUgdG8gc2VsZWN0ZWQgaXRlbVxuICAgIHZhciBzZWxlY3QgPSBfcmVhY3REb20yWydkZWZhdWx0J10uZmluZERPTU5vZGUodGhpcyk7XG4gICAgdmFyIGxpc3QgPSBfcmVhY3REb20yWydkZWZhdWx0J10uZmluZERPTU5vZGUodGhpcy5yZWZzLmxpc3QpO1xuICAgIHZhciBpbmRleCA9IHRoaXMucHJvcHMuc2VsZWN0ZWRJbmRleDtcbiAgICBpZiAoaW5kZXggPCAwKSB7XG4gICAgICBpbmRleCA9IDA7XG4gICAgfVxuICAgIHZhciB0b3BPcHRpb24gPSBsaXN0LmNoaWxkcmVuW2luZGV4XTtcbiAgICB2YXIgdG8gPSB0b3BPcHRpb24ub2Zmc2V0VG9wO1xuICAgIHNjcm9sbFRvKHNlbGVjdCwgdG8sIGR1cmF0aW9uKTtcbiAgfSxcblxuICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICBpZiAodGhpcy5wcm9wcy5vcHRpb25zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgdmFyIHByZWZpeENscyA9IHRoaXMucHJvcHMucHJlZml4Q2xzO1xuXG4gICAgcmV0dXJuIF9yZWFjdDJbJ2RlZmF1bHQnXS5jcmVhdGVFbGVtZW50KFxuICAgICAgJ2RpdicsXG4gICAgICB7IGNsYXNzTmFtZTogcHJlZml4Q2xzICsgJy1zZWxlY3QnLFxuICAgICAgICBvbk1vdXNlRW50ZXI6IHRoaXMucHJvcHMub25Nb3VzZUVudGVyIH0sXG4gICAgICBfcmVhY3QyWydkZWZhdWx0J10uY3JlYXRlRWxlbWVudChcbiAgICAgICAgJ3VsJyxcbiAgICAgICAgeyByZWY6ICdsaXN0JyB9LFxuICAgICAgICB0aGlzLmdldE9wdGlvbnMoKVxuICAgICAgKVxuICAgICk7XG4gIH1cbn0pO1xuXG5leHBvcnRzWydkZWZhdWx0J10gPSBTZWxlY3Q7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi91eGNvcmUtZm9ybS9+L3V4Y29yZS1kYXRlLWZvcm0tZmllbGQvfi91eGNvcmUtY2FsZW5kYXIvfi9yYy10aW1lLXBpY2tlci9saWIvbW9kdWxlL1NlbGVjdC5qc1xuICoqIG1vZHVsZSBpZCA9IDQ4OFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbnZhciBhdXRvQWRqdXN0T3ZlcmZsb3cgPSB7XG4gIGFkanVzdFg6IDEsXG4gIGFkanVzdFk6IDFcbn07XG5cbnZhciB0YXJnZXRPZmZzZXQgPSBbMCwgMF07XG5cbnZhciBwbGFjZW1lbnRzID0ge1xuICBib3R0b21MZWZ0OiB7XG4gICAgcG9pbnRzOiBbJ3RsJywgJ3RsJ10sXG4gICAgb3ZlcmZsb3c6IGF1dG9BZGp1c3RPdmVyZmxvdyxcbiAgICBvZmZzZXQ6IFswLCAtM10sXG4gICAgdGFyZ2V0T2Zmc2V0OiB0YXJnZXRPZmZzZXRcbiAgfSxcbiAgYm90dG9tUmlnaHQ6IHtcbiAgICBwb2ludHM6IFsndHInLCAndHInXSxcbiAgICBvdmVyZmxvdzogYXV0b0FkanVzdE92ZXJmbG93LFxuICAgIG9mZnNldDogWzAsIC0zXSxcbiAgICB0YXJnZXRPZmZzZXQ6IHRhcmdldE9mZnNldFxuICB9LFxuICB0b3BSaWdodDoge1xuICAgIHBvaW50czogWydicicsICdiciddLFxuICAgIG92ZXJmbG93OiBhdXRvQWRqdXN0T3ZlcmZsb3csXG4gICAgb2Zmc2V0OiBbMCwgM10sXG4gICAgdGFyZ2V0T2Zmc2V0OiB0YXJnZXRPZmZzZXRcbiAgfSxcbiAgdG9wTGVmdDoge1xuICAgIHBvaW50czogWydibCcsICdibCddLFxuICAgIG92ZXJmbG93OiBhdXRvQWRqdXN0T3ZlcmZsb3csXG4gICAgb2Zmc2V0OiBbMCwgM10sXG4gICAgdGFyZ2V0T2Zmc2V0OiB0YXJnZXRPZmZzZXRcbiAgfVxufTtcblxuZXhwb3J0c1snZGVmYXVsdCddID0gcGxhY2VtZW50cztcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3V4Y29yZS1mb3JtL34vdXhjb3JlLWRhdGUtZm9ybS1maWVsZC9+L3V4Y29yZS1jYWxlbmRhci9+L3JjLXRpbWUtcGlja2VyL2xpYi91dGlsL3BsYWNlbWVudHMuanNcbiAqKiBtb2R1bGUgaWQgPSA0ODlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmdldEZvcm1hdHRlciA9IGdldEZvcm1hdHRlcjtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG52YXIgX2dyZWdvcmlhbkNhbGVuZGFyRm9ybWF0ID0gcmVxdWlyZSgnZ3JlZ29yaWFuLWNhbGVuZGFyLWZvcm1hdCcpO1xuXG52YXIgX2dyZWdvcmlhbkNhbGVuZGFyRm9ybWF0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2dyZWdvcmlhbkNhbGVuZGFyRm9ybWF0KTtcblxuZnVuY3Rpb24gZ2V0Rm9ybWF0dGVyKGZvcm1hdCwgbG9jYWxlKSB7XG4gIGlmICh0eXBlb2YgZm9ybWF0ID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBuZXcgX2dyZWdvcmlhbkNhbGVuZGFyRm9ybWF0MlsnZGVmYXVsdCddKGZvcm1hdCwgbG9jYWxlLmZvcm1hdCk7XG4gIH1cbiAgcmV0dXJuIGZvcm1hdDtcbn1cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi91eGNvcmUtZm9ybS9+L3V4Y29yZS1kYXRlLWZvcm0tZmllbGQvfi91eGNvcmUtY2FsZW5kYXIvfi9yYy10aW1lLXBpY2tlci9saWIvdXRpbC9pbmRleC5qc1xuICoqIG1vZHVsZSBpZCA9IDQ5MFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgRm9ybWF0dGVyID0gcmVxdWlyZSgndXhjb3JlLWZvcm1hdHRlcicpO1xudmFyIFRvb2x0aXAgPSByZXF1aXJlKCd1eGNvcmUtdG9vbHRpcCcpO1xudmFyIGNsYXNzbmFtZXMgPSByZXF1aXJlKCdjbGFzc25hbWVzJyk7XG52YXIgaTE4biA9IHJlcXVpcmUoJy4vbG9jYWxlJyk7XG5cbi8qKlxuICogY29kZSBzaG91bGQgYmUgYW4gb2JqZWN0IGxpa2UgdGhpcyB7J3h4eHgteHgteHgnOiAnd29yay9sZWF2ZS9zY2hlZHVsZSd9XG4gKi9cbnZhciBnZW5lcmF0ZUNvbnRlbnRSZW5kZXIgPSBmdW5jdGlvbiBnZW5lcmF0ZUNvbnRlbnRSZW5kZXIoY29kZSkge1xuICAgIHZhciBsb2NhbGUgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDEgfHwgYXJndW1lbnRzWzFdID09PSB1bmRlZmluZWQgPyAnemgtY24nIDogYXJndW1lbnRzWzFdO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIGNvbnRlbnRSZW5kZXIoY29kZSwgbG9jYWxlLCBjdXJyZW50LCB2YWx1ZSkge1xuICAgICAgICAvLyBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3lpbWluZ2hlL2dyZWdvcmlhbi1jYWxlbmRhciB0byBnZXQgZGV0YWlscyBhYm91dCBgY3VycmVudGAgQVBJXG4gICAgICAgIHZhciB0aW1lID0gY3VycmVudC5nZXRUaW1lKCk7XG4gICAgICAgIHZhciBkYXRlID0gRm9ybWF0dGVyLmRhdGUodGltZSwgJ1lZWVktTU0tREQnKTtcbiAgICAgICAgdmFyIHR5cGUgPSBjb2RlW2RhdGVdO1xuICAgICAgICBpZiAodHlwZW9mIHR5cGUgPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHR5cGUgPSBbdHlwZV07XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHR5cGUgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdGlwTWFwID0gaTE4bltsb2NhbGVdO1xuICAgICAgICB2YXIgY29udGVudCA9IFtdO1xuICAgICAgICB2YXIgaXNXb3JrID0gdHlwZS5pbmRleE9mKCd3b3JrJykgIT09IC0xO1xuICAgICAgICB2YXIgaXNMZWF2ZSA9IHR5cGUuaW5kZXhPZignbGVhdmUnKSAhPT0gLTE7XG4gICAgICAgIHZhciBpc1NjaGVkdWxlID0gdHlwZS5pbmRleE9mKCdzY2hlZHVsZScpICE9PSAtMTtcbiAgICAgICAgY29udGVudC5wdXNoKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgICAnc3BhbicsXG4gICAgICAgICAgICB7IGtleTogJ2RhdGUnLCBjbGFzc05hbWU6IGNsYXNzbmFtZXMoe1xuICAgICAgICAgICAgICAgICAgICAna3VtYS1jYWxlbmRhci1kYXRlLWNvbnRlbnQnOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAnd29yayc6IGlzV29yayxcbiAgICAgICAgICAgICAgICAgICAgJ2xlYXZlJzogaXNMZWF2ZSxcbiAgICAgICAgICAgICAgICAgICAgJ3NjaGVkdWxlJzogaXNTY2hlZHVsZVxuICAgICAgICAgICAgICAgIH0pIH0sXG4gICAgICAgICAgICBjdXJyZW50LmdldERheU9mTW9udGgoKVxuICAgICAgICApKTtcbiAgICAgICAgaWYgKGlzU2NoZWR1bGUpIHtcbiAgICAgICAgICAgIGNvbnRlbnQucHVzaChSZWFjdC5jcmVhdGVFbGVtZW50KCdzcGFuJywgeyBrZXk6ICdib3R0b20tbGluZScsIGNsYXNzTmFtZTogJ2t1bWEtY2FsZW5kYXItZGF0ZS1kZWNvcmF0aW9uJyB9KSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNXb3JrIHx8IGlzTGVhdmUpIHtcbiAgICAgICAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICAgICAgIFRvb2x0aXAsXG4gICAgICAgICAgICAgICAgeyBwbGFjZW1lbnQ6ICdyaWdodCcsIHRyaWdnZXI6IFtcImhvdmVyXCJdLCBvdmVybGF5OiB0aXBNYXBbaXNXb3JrID8gJ3dvcmsnIDogJ2xlYXZlJ10gfSxcbiAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICAgICAgICAgICAnZGl2JyxcbiAgICAgICAgICAgICAgICAgICAgeyBjbGFzc05hbWU6ICdrdW1hLWNhbGVuZGFyLWRhdGUtY29udGVudC1ib3gnIH0sXG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnRcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gb25seSBvbmUgY2hpbGQgY2FuIGJlIHBhc3NlZC5cbiAgICAgICAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICAgICAgICdkaXYnLFxuICAgICAgICAgICAgICAgIHsgY2xhc3NOYW1lOiAna3VtYS1jYWxlbmRhci1kYXRlLWNvbnRlbnQtYm94JyB9LFxuICAgICAgICAgICAgICAgIGNvbnRlbnRcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICB9LmJpbmQobnVsbCwgY29kZSwgbG9jYWxlKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIGdlbmVyYXRlQ29udGVudFJlbmRlcjogZ2VuZXJhdGVDb250ZW50UmVuZGVyXG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3V4Y29yZS1mb3JtL34vdXhjb3JlLWRhdGUtZm9ybS1maWVsZC9+L3V4Y29yZS1jYWxlbmRhci9idWlsZC91dGlsLmpzXG4gKiogbW9kdWxlIGlkID0gNDkxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbnZhciBsb2NhbGUgPSB7XG4gICAgJ3poLWNuJzoge1xuICAgICAgICAnd29yayc6ICfkuIrnj60nLFxuICAgICAgICAnbGVhdmUnOiAn5LyR5YGHJ1xuICAgIH0sXG4gICAgJ2VuLXVzJzoge1xuICAgICAgICAnd29yayc6ICd3b3JrJyxcbiAgICAgICAgJ2xlYXZlJzogJ2xlYXZlJ1xuICAgIH1cbn07XG5cbmxvY2FsZVsnZW4nXSA9IGxvY2FsZVsnZW4tdXMnXTtcblxubW9kdWxlLmV4cG9ydHMgPSBsb2NhbGU7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vdXhjb3JlLWZvcm0vfi91eGNvcmUtZGF0ZS1mb3JtLWZpZWxkL34vdXhjb3JlLWNhbGVuZGFyL2J1aWxkL2xvY2FsZS5qc1xuICoqIG1vZHVsZSBpZCA9IDUyM1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLypcbiAqIHpoLWNuIGxvY2FsZVxuICogQGlnbm9yZVxuICogQGF1dGhvciB5aW1pbmdoZUBnbWFpbC5jb21cbiAqL1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAvLyBpbiBtaW51dGVzXG4gIHRpbWV6b25lT2Zmc2V0OiA4ICogNjAsXG4gIGZpcnN0RGF5T2ZXZWVrOiAxLFxuICBtaW5pbWFsRGF5c0luRmlyc3RXZWVrOiAxXG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3V4Y29yZS1mb3JtL34vdXhjb3JlLWRhdGUtZm9ybS1maWVsZC9+L3V4Y29yZS1jYWxlbmRhci9+L2dyZWdvcmlhbi1jYWxlbmRhci9saWIvbG9jYWxlL3poX0NOLmpzXG4gKiogbW9kdWxlIGlkID0gNTI0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfemhfQ04gPSByZXF1aXJlKCdncmVnb3JpYW4tY2FsZW5kYXItZm9ybWF0L2xpYi9sb2NhbGUvemhfQ04nKTtcblxudmFyIF96aF9DTjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF96aF9DTik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IFwiZGVmYXVsdFwiOiBvYmogfTsgfVxuXG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IHtcbiAgdG9kYXk6ICfku4rlpKknLFxuICBub3c6ICfmraTliLsnLFxuICBiYWNrVG9Ub2RheTogJ+i/lOWbnuS7iuWkqScsXG4gIG9rOiAn56Gu5a6aJyxcbiAgY2xlYXI6ICfmuIXpmaQnLFxuICBtb250aDogJ+aciCcsXG4gIHllYXI6ICflubQnLFxuICBwcmV2aW91c01vbnRoOiAn5LiK5Liq5pyIICjnv7vpobXkuIrplK4pJyxcbiAgbmV4dE1vbnRoOiAn5LiL5Liq5pyIICjnv7vpobXkuIvplK4pJyxcbiAgbW9udGhTZWxlY3Q6ICfpgInmi6nmnIjku70nLFxuICB5ZWFyU2VsZWN0OiAn6YCJ5oup5bm05Lu9JyxcbiAgZGVjYWRlU2VsZWN0OiAn6YCJ5oup5bm05LujJyxcbiAgeWVhckZvcm1hdDogJ3l5eXlcXCflubRcXCcnLFxuICBtb250aEZvcm1hdDogJ01cXCfmnIhcXCcnLFxuICBkYXRlRm9ybWF0OiAneXl5eVxcJ+W5tFxcJ01cXCfmnIhcXCdkXFwn5pelXFwnJyxcbiAgcHJldmlvdXNZZWFyOiAn5LiK5LiA5bm0IChDb250cm9s6ZSu5Yqg5bem5pa55ZCR6ZSuKScsXG4gIG5leHRZZWFyOiAn5LiL5LiA5bm0IChDb250cm9s6ZSu5Yqg5Y+z5pa55ZCR6ZSuKScsXG4gIHByZXZpb3VzRGVjYWRlOiAn5LiK5LiA5bm05LujJyxcbiAgbmV4dERlY2FkZTogJ+S4i+S4gOW5tOS7oycsXG4gIHByZXZpb3VzQ2VudHVyeTogJ+S4iuS4gOS4lue6qicsXG4gIG5leHRDZW50dXJ5OiAn5LiL5LiA5LiW57qqJyxcbiAgZm9ybWF0OiBfemhfQ04yW1wiZGVmYXVsdFwiXVxufTtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3V4Y29yZS1mb3JtL34vdXhjb3JlLWRhdGUtZm9ybS1maWVsZC9+L3V4Y29yZS1jYWxlbmRhci9+L3JjLWNhbGVuZGFyL2xpYi9sb2NhbGUvemhfQ04uanNcbiAqKiBtb2R1bGUgaWQgPSA1MjVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGVyYXM6IFsn5YWs5YWD5YmNJywgJ+WFrOWFgyddLFxuICBtb250aHM6IFsn5LiA5pyIJywgJ+S6jOaciCcsICfkuInmnIgnLCAn5Zub5pyIJywgJ+S6lOaciCcsICflha3mnIgnLCAn5LiD5pyIJywgJ+WFq+aciCcsICfkuZ3mnIgnLCAn5Y2B5pyIJywgJ+WNgeS4gOaciCcsICfljYHkuozmnIgnXSxcbiAgc2hvcnRNb250aHM6IFsn5LiA5pyIJywgJ+S6jOaciCcsICfkuInmnIgnLCAn5Zub5pyIJywgJ+S6lOaciCcsICflha3mnIgnLCAn5LiD5pyIJywgJ+WFq+aciCcsICfkuZ3mnIgnLCAn5Y2B5pyIJywgJ+WNgeS4gOaciCcsICfljYHkuozmnIgnXSxcbiAgd2Vla2RheXM6IFsn5pif5pyf5aSpJywgJ+aYn+acn+S4gCcsICfmmJ/mnJ/kuownLCAn5pif5pyf5LiJJywgJ+aYn+acn+WbmycsICfmmJ/mnJ/kupQnLCAn5pif5pyf5YWtJ10sXG4gIHNob3J0V2Vla2RheXM6IFsn5ZGo5pelJywgJ+WRqOS4gCcsICflkajkuownLCAn5ZGo5LiJJywgJ+WRqOWbmycsICflkajkupQnLCAn5ZGo5YWtJ10sXG4gIHZlcnlTaG9ydFdlZWtkYXlzOiBbJ+aXpScsICfkuIAnLCAn5LqMJywgJ+S4iScsICflm5snLCAn5LqUJywgJ+WFrSddLFxuICBhbXBtczogWyfkuIrljYgnLCAn5LiL5Y2IJ10sXG4gIGRhdGVQYXR0ZXJuczogWyd5eXl5XFwn5bm0XFwnTVxcJ+aciFxcJ2RcXCfml6VcXCcgRUVFRScsICd5eXl5XFwn5bm0XFwnTVxcJ+aciFxcJ2RcXCfml6VcXCcnLCAneXl5eS1NLWQnLCAneXktTS1kJ10sXG4gIHRpbWVQYXR0ZXJuczogWydhaGhcXCfml7ZcXCdtbVxcJ+WIhlxcJ3NzXFwn56eSXFwnIFxcJ0dNVFxcJ1onLCAnYWhoXFwn5pe2XFwnbW1cXCfliIZcXCdzc1xcJ+enklxcJycsICdIOm1tOnNzJywgJ2FoOm1tJ10sXG4gIGRhdGVUaW1lUGF0dGVybjogJ3tkYXRlfSB7dGltZX0nXG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3V4Y29yZS1mb3JtL34vdXhjb3JlLWRhdGUtZm9ybS1maWVsZC9+L3V4Y29yZS1jYWxlbmRhci9+L2dyZWdvcmlhbi1jYWxlbmRhci1mb3JtYXQvbGliL2xvY2FsZS96aF9DTi5qc1xuICoqIG1vZHVsZSBpZCA9IDUyNlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG52YXIgX2dyZWdvcmlhbkNhbGVuZGFyRm9ybWF0TGliTG9jYWxlWmhfQ04gPSByZXF1aXJlKCdncmVnb3JpYW4tY2FsZW5kYXItZm9ybWF0L2xpYi9sb2NhbGUvemhfQ04nKTtcblxudmFyIF9ncmVnb3JpYW5DYWxlbmRhckZvcm1hdExpYkxvY2FsZVpoX0NOMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2dyZWdvcmlhbkNhbGVuZGFyRm9ybWF0TGliTG9jYWxlWmhfQ04pO1xuXG52YXIgX2dyZWdvcmlhbkNhbGVuZGFyTGliTG9jYWxlWmhfQ04gPSByZXF1aXJlKCdncmVnb3JpYW4tY2FsZW5kYXIvbGliL2xvY2FsZS96aF9DTicpO1xuXG52YXIgX2dyZWdvcmlhbkNhbGVuZGFyTGliTG9jYWxlWmhfQ04yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZ3JlZ29yaWFuQ2FsZW5kYXJMaWJMb2NhbGVaaF9DTik7XG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IHtcbiAgY2xlYXI6ICfmuIXpmaQnLFxuICBmb3JtYXQ6IF9ncmVnb3JpYW5DYWxlbmRhckZvcm1hdExpYkxvY2FsZVpoX0NOMlsnZGVmYXVsdCddLFxuICBjYWxlbmRhcjogX2dyZWdvcmlhbkNhbGVuZGFyTGliTG9jYWxlWmhfQ04yWydkZWZhdWx0J11cbn07XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi91eGNvcmUtZm9ybS9+L3V4Y29yZS1kYXRlLWZvcm0tZmllbGQvfi91eGNvcmUtY2FsZW5kYXIvfi9yYy10aW1lLXBpY2tlci9saWIvbG9jYWxlL3poX0NOLmpzXG4gKiogbW9kdWxlIGlkID0gNTI3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcInVzZSBzdHJpY3RcIjtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgRm9ybUZpZWxkID0gcmVxdWlyZSgndXhjb3JlLWZvcm0tZmllbGQnKTtcbnZhciBDb25zdGFudHMgPSByZXF1aXJlKFwidXhjb3JlLWNvbnN0XCIpO1xudmFyIENoZWNrYm94R3JvdXAgPSByZXF1aXJlKFwidXhjb3JlLWNoZWNrYm94LWdyb3VwXCIpO1xudmFyIEl0ZW0gPSBDaGVja2JveEdyb3VwLkl0ZW07XG5cbnZhciBDaGVja2JveEdyb3VwRm9ybUZpZWxkID0gZnVuY3Rpb24gKF9Gb3JtRmllbGQpIHtcbiAgICBfaW5oZXJpdHMoQ2hlY2tib3hHcm91cEZvcm1GaWVsZCwgX0Zvcm1GaWVsZCk7XG5cbiAgICBmdW5jdGlvbiBDaGVja2JveEdyb3VwRm9ybUZpZWxkKHByb3BzKSB7XG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDaGVja2JveEdyb3VwRm9ybUZpZWxkKTtcblxuICAgICAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX0Zvcm1GaWVsZC5jYWxsKHRoaXMsIHByb3BzKSk7XG4gICAgfVxuXG4gICAgQ2hlY2tib3hHcm91cEZvcm1GaWVsZC5wcm90b3R5cGUuaGFuZGxlQ2hhbmdlID0gZnVuY3Rpb24gaGFuZGxlQ2hhbmdlKHZhbHVlKSB7XG4gICAgICAgIHZhciBtZSA9IHRoaXM7XG4gICAgICAgIG1lLmhhbmRsZURhdGFDaGFuZ2UodmFsdWUpO1xuICAgIH07XG5cbiAgICBDaGVja2JveEdyb3VwRm9ybUZpZWxkLnByb3RvdHlwZS5hZGRTcGVjaWZpY0NsYXNzID0gZnVuY3Rpb24gYWRkU3BlY2lmaWNDbGFzcygpIHtcbiAgICAgICAgdmFyIG1lID0gdGhpcztcbiAgICAgICAgaWYgKG1lLnByb3BzLmpzeHByZWZpeENscyA9PSBcImt1bWEtdXhmb3JtLWZpZWxkXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBtZS5wcm9wcy5qc3hwcmVmaXhDbHMgKyBcIiBrdW1hLWNoZWNrYm94LWdyb3VwLXV4Zm9ybS1maWVsZFwiO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG1lLnByb3BzLmpzeHByZWZpeENscztcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBDaGVja2JveEdyb3VwRm9ybUZpZWxkLnByb3RvdHlwZS5yZW5kZXJGaWVsZCA9IGZ1bmN0aW9uIHJlbmRlckZpZWxkKCkge1xuICAgICAgICB2YXIgbWUgPSB0aGlzO1xuICAgICAgICB2YXIgbW9kZSA9IG1lLnByb3BzLmpzeG1vZGUgfHwgbWUucHJvcHMubW9kZTtcbiAgICAgICAgaWYgKG1vZGUgPT0gQ29uc3RhbnRzLk1PREUuRURJVCkge1xuICAgICAgICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgICAgICAgQ2hlY2tib3hHcm91cCxcbiAgICAgICAgICAgICAgICB7IGRpc2FibGVkOiAhIW1lLnByb3BzLmpzeGRpc2FibGVkLCBvbkNoYW5nZTogbWUuaGFuZGxlQ2hhbmdlLmJpbmQobWUpLCB2YWx1ZTogbWUuc3RhdGUudmFsdWUgfHwgW10gfSxcbiAgICAgICAgICAgICAgICBtZS5wcm9wcy5jaGlsZHJlblxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChtZS5zdGF0ZS52YWx1ZSBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgICAgICAgdmFyIHRleHRBcnIgPSBtZS5wcm9wcy5jaGlsZHJlbi5maWx0ZXIoZnVuY3Rpb24gKGNoaWxkLCBpbmRleCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWUuc3RhdGUudmFsdWUuaW5kZXhPZihjaGlsZC5wcm9wcy52YWx1ZSkgIT0gLTE7XG4gICAgICAgICAgICAgICAgfSkubWFwKGZ1bmN0aW9uIChpdGVtLCBpbmRleCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaXRlbS5wcm9wcy50ZXh0O1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICAgICAgICAgICBcInNwYW5cIixcbiAgICAgICAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgdGV4dEFyci5qb2luKFwiIFwiKVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgcmV0dXJuIENoZWNrYm94R3JvdXBGb3JtRmllbGQ7XG59KEZvcm1GaWVsZCk7XG5cbkNoZWNrYm94R3JvdXBGb3JtRmllbGQuSXRlbSA9IEl0ZW07XG5DaGVja2JveEdyb3VwRm9ybUZpZWxkLnByb3BUeXBlcyA9IEZvcm1GaWVsZC5wcm9wVHlwZXM7XG5DaGVja2JveEdyb3VwRm9ybUZpZWxkLmRlZmF1bHRQcm9wcyA9IEZvcm1GaWVsZC5kZWZhdWx0UHJvcHM7XG5DaGVja2JveEdyb3VwRm9ybUZpZWxkLmRpc3BsYXlOYW1lID0gXCJDaGVja2JveEdyb3VwRm9ybUZpZWxkXCI7XG5cbm1vZHVsZS5leHBvcnRzID0gQ2hlY2tib3hHcm91cEZvcm1GaWVsZDtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi91eGNvcmUtZm9ybS9idWlsZC9Gb3JtRmllbGQvQ2hlY2tib3hHcm91cEZvcm1GaWVsZC5qc1xuICoqIG1vZHVsZSBpZCA9IDUyOFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIENoZWNrYm94R3JvdXAgQ29tcG9uZW50IGZvciB1eGNvcmVcbiAqIEBhdXRob3IgZXRlcm5hbHNreVxuICpcbiAqIENvcHlyaWdodCAyMDE0LTIwMTUsIFV4Y29yZSBUZWFtLCBBbGludy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL0NoZWNrYm94R3JvdXAnKTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi91eGNvcmUtZm9ybS9+L3V4Y29yZS1jaGVja2JveC1ncm91cC9idWlsZC9pbmRleC5qc1xuICoqIG1vZHVsZSBpZCA9IDUyOVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxuLyoqXG4gKiBDaGVja2JveEdyb3VwIENvbXBvbmVudCBmb3IgdXhjb3JlXG4gKiBAYXV0aG9yIGV0ZXJuYWxza3lcbiAqXG4gKiBDb3B5cmlnaHQgMjAxNC0yMDE1LCBVeGNvcmUgVGVhbSwgQWxpbncuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICovXG5cbnZhciBJdGVtID0gcmVxdWlyZShcIi4vQ2hlY2tib3hJdGVtXCIpO1xudmFyIGFzc2lnbiA9IHJlcXVpcmUoXCJvYmplY3QtYXNzaWduXCIpO1xudmFyIFJlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcbnZhciBSZWFjdERPTSA9IHJlcXVpcmUoJ3JlYWN0LWRvbScpO1xuXG52YXIgQ2hlY2tib3hHcm91cCA9IGZ1bmN0aW9uIChfUmVhY3QkQ29tcG9uZW50KSB7XG4gICAgX2luaGVyaXRzKENoZWNrYm94R3JvdXAsIF9SZWFjdCRDb21wb25lbnQpO1xuXG4gICAgZnVuY3Rpb24gQ2hlY2tib3hHcm91cChwcm9wcykge1xuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQ2hlY2tib3hHcm91cCk7XG5cbiAgICAgICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9SZWFjdCRDb21wb25lbnQuY2FsbCh0aGlzLCBwcm9wcykpO1xuICAgIH1cblxuICAgIENoZWNrYm94R3JvdXAucHJvdG90eXBlLmNvbXBvbmVudFdpbGxNb3VudCA9IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxNb3VudCgpIHtcbiAgICAgICAgdmFyIG1lID0gdGhpcztcbiAgICAgICAgbWUuc2VsZWN0ZWQgPSBtZS5fY29weShtZS5wcm9wcy52YWx1ZSkgfHwgW107XG4gICAgfTtcblxuICAgIENoZWNrYm94R3JvdXAucHJvdG90eXBlLmNvbXBvbmVudERpZFVwZGF0ZSA9IGZ1bmN0aW9uIGNvbXBvbmVudERpZFVwZGF0ZSgpIHtcbiAgICAgICAgdmFyIG1lID0gdGhpcztcbiAgICAgICAgbWUuc2VsZWN0ZWQgPSBtZS5fY29weShtZS5wcm9wcy52YWx1ZSkgfHwgW107XG4gICAgfTtcblxuICAgIENoZWNrYm94R3JvdXAucHJvdG90eXBlLl9jb3B5ID0gZnVuY3Rpb24gX2NvcHkoYSkge1xuICAgICAgICByZXR1cm4gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShhKSk7XG4gICAgfTtcblxuICAgIENoZWNrYm94R3JvdXAucHJvdG90eXBlLl9wcm9jZXNzQ2hpbGQgPSBmdW5jdGlvbiBfcHJvY2Vzc0NoaWxkKCkge1xuICAgICAgICB2YXIgbWUgPSB0aGlzO1xuICAgICAgICB2YXIgbGVuZ3RoID0gUmVhY3QuQ2hpbGRyZW4uY291bnQobWUucHJvcHMuY2hpbGRyZW4pO1xuICAgICAgICBpZiAoIWxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuICAgICAgICB2YXIgZWxlbWVudHMgPSBSZWFjdC5DaGlsZHJlbi5tYXAobWUucHJvcHMuY2hpbGRyZW4sIGZ1bmN0aW9uIChjaGlsZCwgaW5kZXgpIHtcbiAgICAgICAgICAgIGlmICghIWNoaWxkLnR5cGUgJiYgY2hpbGQudHlwZS5kaXNwbGF5TmFtZSA9PSBcIkNoZWNrYm94SXRlbVwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFJlYWN0LmNsb25lRWxlbWVudChjaGlsZCwge1xuICAgICAgICAgICAgICAgICAgICBqc3hkaXNhYmxlZDogbWUucHJvcHMuZGlzYWJsZWQsXG4gICAgICAgICAgICAgICAgICAgIG9uQ2hhbmdlOiBtZS5faGFuZGxlQ2hhbmdlLmJpbmQobWUpLFxuICAgICAgICAgICAgICAgICAgICBrZXk6IGluZGV4LFxuICAgICAgICAgICAgICAgICAgICBjaGVja2VkOiBtZS5wcm9wcy52YWx1ZS5pbmRleE9mKGNoaWxkLnByb3BzLnZhbHVlKSAhPSAtMVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGVsZW1lbnRzO1xuICAgIH07XG5cbiAgICBDaGVja2JveEdyb3VwLnByb3RvdHlwZS5faGFuZGxlQ2hhbmdlID0gZnVuY3Rpb24gX2hhbmRsZUNoYW5nZShjaGVja2VkLCB2YWx1ZSkge1xuICAgICAgICB2YXIgbWUgPSB0aGlzO1xuICAgICAgICBpZiAoY2hlY2tlZCkge1xuICAgICAgICAgICAgLy8gbWUuc2VsZWN0ZWQgPSBtZS5zZWxlY3RlZC5jb25jYXQoW3ZhbHVlXSk7XG4gICAgICAgICAgICBtZS5zZWxlY3RlZC5wdXNoKHZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1lLnNlbGVjdGVkID0gbWUuc2VsZWN0ZWQuZmlsdGVyKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW0gIT0gdmFsdWU7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBtZS5wcm9wcy5vbkNoYW5nZShKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KG1lLnNlbGVjdGVkKSkpO1xuICAgIH07XG5cbiAgICBDaGVja2JveEdyb3VwLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgICAgIHZhciBtZSA9IHRoaXM7XG4gICAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICAgXCJkaXZcIixcbiAgICAgICAgICAgIHsgY2xhc3NOYW1lOiBtZS5wcm9wcy5jbGFzc05hbWUgfSxcbiAgICAgICAgICAgIG1lLl9wcm9jZXNzQ2hpbGQoKVxuICAgICAgICApO1xuICAgIH07XG5cbiAgICByZXR1cm4gQ2hlY2tib3hHcm91cDtcbn0oUmVhY3QuQ29tcG9uZW50KTtcblxuQ2hlY2tib3hHcm91cC5JdGVtID0gSXRlbTtcblxuQ2hlY2tib3hHcm91cC5kZWZhdWx0UHJvcHMgPSB7XG4gICAgdmFsdWU6IFtdLFxuICAgIG9uQ2hhbmdlOiBmdW5jdGlvbiBvbkNoYW5nZSgpIHt9LFxuICAgIGRpc2FibGVkOiBmYWxzZSxcbiAgICBjbGFzc05hbWU6ICdrdW1hLWNoZWNrYm94LWdyb3VwJ1xufTtcblxuLy8gaHR0cDovL2ZhY2Vib29rLmdpdGh1Yi5pby9yZWFjdC9kb2NzL3JldXNhYmxlLWNvbXBvbmVudHMuaHRtbFxuQ2hlY2tib3hHcm91cC5wcm9wVHlwZXMgPSB7XG4gICAgdmFsdWU6IFJlYWN0LlByb3BUeXBlcy5hcnJheSxcbiAgICBvbkNoYW5nZTogUmVhY3QuUHJvcFR5cGVzLmZ1bmMsXG4gICAgZGlzYWJsZWQ6IFJlYWN0LlByb3BUeXBlcy5ib29sLFxuICAgIGNsYXNzTmFtZTogUmVhY3QuUHJvcFR5cGVzLnN0cmluZ1xufTtcblxuQ2hlY2tib3hHcm91cC5kaXNwbGF5TmFtZSA9IFwiQ2hlY2tib3hHcm91cFwiO1xuXG5tb2R1bGUuZXhwb3J0cyA9IENoZWNrYm94R3JvdXA7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vdXhjb3JlLWZvcm0vfi91eGNvcmUtY2hlY2tib3gtZ3JvdXAvYnVpbGQvQ2hlY2tib3hHcm91cC5qc1xuICoqIG1vZHVsZSBpZCA9IDUzMFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG52YXIgUmVhY3RET00gPSByZXF1aXJlKCdyZWFjdC1kb20nKTtcbnZhciBjbGFzc25hbWVzID0gcmVxdWlyZSgnY2xhc3NuYW1lcycpO1xuXG52YXIgQ2hlY2tib3hJdGVtID0gZnVuY3Rpb24gKF9SZWFjdCRDb21wb25lbnQpIHtcbiAgICBfaW5oZXJpdHMoQ2hlY2tib3hJdGVtLCBfUmVhY3QkQ29tcG9uZW50KTtcblxuICAgIGZ1bmN0aW9uIENoZWNrYm94SXRlbShwcm9wcykge1xuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQ2hlY2tib3hJdGVtKTtcblxuICAgICAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX1JlYWN0JENvbXBvbmVudC5jYWxsKHRoaXMsIHByb3BzKSk7XG4gICAgfVxuXG4gICAgQ2hlY2tib3hJdGVtLnByb3RvdHlwZS5faGFuZGxlQ2hhbmdlID0gZnVuY3Rpb24gX2hhbmRsZUNoYW5nZShlKSB7XG4gICAgICAgIHZhciBtZSA9IHRoaXM7XG4gICAgICAgIG1lLnByb3BzLm9uQ2hhbmdlKGUuY3VycmVudFRhcmdldC5jaGVja2VkLCBtZS5wcm9wcy52YWx1ZSk7XG4gICAgfTtcblxuICAgIENoZWNrYm94SXRlbS5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgICAgICB2YXIgbWUgPSB0aGlzO1xuICAgICAgICB2YXIgcHJlZml4Q2xzID0gbWUucHJvcHMucHJlZml4Q2xzO1xuXG4gICAgICAgIHZhciBkaXNhYmxlZCA9IGZhbHNlO1xuICAgICAgICBpZiAoJ2Rpc2FibGVkJyBpbiBtZS5wcm9wcykge1xuICAgICAgICAgICAgZGlzYWJsZWQgPSBtZS5wcm9wcy5kaXNhYmxlZDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRpc2FibGVkID0gbWUucHJvcHMuanN4ZGlzYWJsZWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgICAnbGFiZWwnLFxuICAgICAgICAgICAgeyBjbGFzc05hbWU6ICcnICsgcHJlZml4Q2xzIH0sXG4gICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KCdpbnB1dCcsIHsgdHlwZTogJ2NoZWNrYm94JywgZGlzYWJsZWQ6IGRpc2FibGVkLCByZWY6ICdjaGVja2JveCcsIGNoZWNrZWQ6IG1lLnByb3BzLmNoZWNrZWQsIGNsYXNzTmFtZTogJ2t1bWEtY2hlY2tib3gnLCBvbkNoYW5nZTogbWUuX2hhbmRsZUNoYW5nZS5iaW5kKG1lKSB9KSxcbiAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoJ3MnLCBudWxsKSxcbiAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nLCB7IGNsYXNzTmFtZTogcHJlZml4Q2xzICsgJy1jb250ZW50JywgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUw6IHsgX19odG1sOiBtZS5wcm9wcy50ZXh0IH0gfSlcbiAgICAgICAgKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIENoZWNrYm94SXRlbTtcbn0oUmVhY3QuQ29tcG9uZW50KTtcblxuQ2hlY2tib3hJdGVtLmRlZmF1bHRQcm9wcyA9IHtcbiAgICB2YWx1ZTogXCJcIixcbiAgICBwcmVmaXhDbHM6IFwia3VtYS1jaGVja2JveC1ncm91cC1pdGVtXCIsXG4gICAgb25DaGFuZ2U6IGZ1bmN0aW9uIG9uQ2hhbmdlKCkge31cbn07XG5cbkNoZWNrYm94SXRlbS5wcm9wVHlwZXMgPSB7XG4gICAgdmFsdWU6IFJlYWN0LlByb3BUeXBlcy5zdHJpbmcsXG4gICAgZGlzYWJsZWQ6IFJlYWN0LlByb3BUeXBlcy5ib29sLFxuICAgIHByZWZpeENsczogUmVhY3QuUHJvcFR5cGVzLnN0cmluZyxcbiAgICBvbkNoYW5nZTogUmVhY3QuUHJvcFR5cGVzLmZ1bmNcbn07XG5cbkNoZWNrYm94SXRlbS5kaXNwbGF5TmFtZSA9IFwiQ2hlY2tib3hJdGVtXCI7XG5cbm1vZHVsZS5leHBvcnRzID0gQ2hlY2tib3hJdGVtO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3V4Y29yZS1mb3JtL34vdXhjb3JlLWNoZWNrYm94LWdyb3VwL2J1aWxkL0NoZWNrYm94SXRlbS5qc1xuICoqIG1vZHVsZSBpZCA9IDUzMVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgRm9ybUZpZWxkID0gcmVxdWlyZSgndXhjb3JlLWZvcm0tZmllbGQnKTtcbnZhciBDb25zdGFudHMgPSByZXF1aXJlKFwidXhjb3JlLWNvbnN0XCIpO1xudmFyIFNlbGVjdCA9IHJlcXVpcmUoJ3V4Y29yZS1zZWxlY3QyJyk7XG52YXIgT3B0aW9uID0gU2VsZWN0Lk9wdGlvbjtcblxudmFyIGFzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcbnZhciB1cGRhdGUgPSBSZWFjdC5hZGRvbnMudXBkYXRlO1xuXG52YXIgQ2FzY2FkZVNlbGVjdEZvcm1GaWVsZCA9IGZ1bmN0aW9uIChfRm9ybUZpZWxkKSB7XG4gICAgX2luaGVyaXRzKENhc2NhZGVTZWxlY3RGb3JtRmllbGQsIF9Gb3JtRmllbGQpO1xuXG4gICAgZnVuY3Rpb24gQ2FzY2FkZVNlbGVjdEZvcm1GaWVsZChwcm9wcykge1xuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQ2FzY2FkZVNlbGVjdEZvcm1GaWVsZCk7XG5cbiAgICAgICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9Gb3JtRmllbGQuY2FsbCh0aGlzLCBwcm9wcykpO1xuICAgIH1cblxuICAgIENhc2NhZGVTZWxlY3RGb3JtRmllbGQucHJvdG90eXBlLmdldERhdGFMZW5ndGggPSBmdW5jdGlvbiBnZXREYXRhTGVuZ3RoKCkge1xuICAgICAgICB2YXIgbWUgPSB0aGlzO1xuICAgICAgICByZXR1cm4gbWUucHJvcHMuanN4ZGF0YS5sZW5ndGg7XG4gICAgfTtcblxuICAgIENhc2NhZGVTZWxlY3RGb3JtRmllbGQucHJvdG90eXBlLmhhbmRsZUNoYW5nZSA9IGZ1bmN0aW9uIGhhbmRsZUNoYW5nZShpLCB2YWx1ZSkge1xuICAgICAgICB2YXIgbWUgPSB0aGlzO1xuICAgICAgICB2YXIgdmFsdWVzID0gdXBkYXRlKG1lLnN0YXRlLnZhbHVlLCB7fSkgfHwgW107XG4gICAgICAgIGlmICghIXZhbHVlc1tpXSkge1xuICAgICAgICAgICAgdmFsdWVzID0gdmFsdWVzLnNsaWNlKDAsIGkpO1xuICAgICAgICAgICAgdmFsdWVzLnB1c2godmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFsdWVzW2ldID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgbWUuaGFuZGxlRGF0YUNoYW5nZSh2YWx1ZXMpO1xuICAgIH07XG5cbiAgICBDYXNjYWRlU2VsZWN0Rm9ybUZpZWxkLnByb3RvdHlwZS5hZGRTcGVjaWZpY0NsYXNzID0gZnVuY3Rpb24gYWRkU3BlY2lmaWNDbGFzcygpIHtcbiAgICAgICAgdmFyIG1lID0gdGhpcztcbiAgICAgICAgaWYgKG1lLnByb3BzLmpzeHByZWZpeENscyA9PSBcImt1bWEtdXhmb3JtLWZpZWxkXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBtZS5wcm9wcy5qc3hwcmVmaXhDbHMgKyBcIiBrdW1hLWNhc2NhZGUtc2VsZWN0LXV4Zm9ybS1maWVsZFwiO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG1lLnByb3BzLmpzeHByZWZpeENscztcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBDYXNjYWRlU2VsZWN0Rm9ybUZpZWxkLnByb3RvdHlwZS5yZW5kZXJGaWVsZCA9IGZ1bmN0aW9uIHJlbmRlckZpZWxkKCkge1xuICAgICAgICB2YXIgbWUgPSB0aGlzO1xuICAgICAgICB2YXIgbGVuZ3RoID0gbWUuZ2V0RGF0YUxlbmd0aCgpO1xuICAgICAgICB2YXIgYXJyID0gW107XG4gICAgICAgIHZhciBkYXRhID0ge307XG4gICAgICAgIHZhciBtb2RlID0gbWUucHJvcHMuanN4bW9kZSB8fCBtZS5wcm9wcy5tb2RlO1xuICAgICAgICBpZiAobW9kZSA9PSBDb25zdGFudHMuTU9ERS5FRElUKSB7XG4gICAgICAgICAgICB2YXIgX3JldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBkYXRhID0gbWUucHJvcHMuanN4ZGF0YS5jb250ZW50cztcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihlLm1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdjogdm9pZCAwXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgICAgKiDlpoLmnpwgdmFsdWUg5a2Y5Zyo55u45bqU55qE5YC877yM5YiZ5aGr5YWF5LiL5LiA57qn55qE6YCJ5oup77yMXG4gICAgICAgICAgICAgICAgICog5aaC5p6cIHZhbHVlIOS4jeWtmOWcqO+8jOWImeWhq+WFheepuuaVsOe7hO+8jFxuICAgICAgICAgICAgICAgICAqIOWmguaenCBkYXRhIOS4reS4jeWMheWQqyBjb250ZW50c++8jOWImeivgeaYjue6p+iBlOmAieaLqeeUn+aIkOW3sue7k+adn++8jOWImei3s+WHuuW+queOr1xuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIHZhciBzdGF0ZVZhbHVlID0gbWUuc3RhdGUudmFsdWUgfHwgW107IC8vIOmihOmYsiB2YWx1ZSDmmK8gdW5kZWZpbmVkIOeahOaDheWGtVxuXG4gICAgICAgICAgICAgICAgdmFyIF9sb29wID0gZnVuY3Rpb24gX2xvb3AoaSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgb3B0aW9ucyA9IGRhdGEubWFwKGZ1bmN0aW9uIChpdGVtLCBpbmRleCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgT3B0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsga2V5OiBpbmRleCwgdmFsdWU6IGl0ZW0udmFsdWUgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtLnRleHRcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciBzZWxlY3RPcHRpb25zID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVmOiBcImVsXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBrZXk6IFwic2VsZWN0XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25MYWJlbFByb3A6IFwiY2hpbGRyZW5cIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlOiBtZS5wcm9wcy5qc3hzdHlsZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNob3dTZWFyY2g6IG1lLnByb3BzLmpzeHNob3dTZWFyY2gsXG4gICAgICAgICAgICAgICAgICAgICAgICBwbGFjZWhvbGRlcjogbWUucHJvcHMuanN4cGxhY2Vob2xkZXJcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0T3B0aW9ucy5vbkNoYW5nZSA9IG1lLmhhbmRsZUNoYW5nZS5iaW5kKG1lLCBpKTtcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0T3B0aW9ucy52YWx1ZSA9IHN0YXRlVmFsdWVbaV0gfHwgbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGkgIT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXJyLnB1c2goUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnc3BhbicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeyBrZXk6IFwic3BsaXRcIiArIGksIGNsYXNzTmFtZTogJ2t1bWEtdXhmb3JtLXNwbGl0JyB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICctJ1xuICAgICAgICAgICAgICAgICAgICAgICAgKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYXJyLnB1c2goUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAgICAgICAgICAgICAgIFNlbGVjdCxcbiAgICAgICAgICAgICAgICAgICAgICAgIF9leHRlbmRzKHt9LCBzZWxlY3RPcHRpb25zLCB7IGtleTogaSB9KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnNcbiAgICAgICAgICAgICAgICAgICAgKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghIXN0YXRlVmFsdWVbaV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEgPSBkYXRhLmZpbHRlcihmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpdGVtLnZhbHVlID09IHN0YXRlVmFsdWVbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9KVswXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEgPSBkYXRhLmNvbnRlbnRzO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFkYXRhKSByZXR1cm4gJ2JyZWFrJztcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfcmV0MiA9IF9sb29wKGkpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChfcmV0MiA9PT0gJ2JyZWFrJykgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSgpO1xuXG4gICAgICAgICAgICBpZiAoKHR5cGVvZiBfcmV0ID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihfcmV0KSkgPT09IFwib2JqZWN0XCIpIHJldHVybiBfcmV0LnY7XG4gICAgICAgIH0gZWxzZSBpZiAobW9kZSA9PSBDb25zdGFudHMuTU9ERS5WSUVXKSB7XG4gICAgICAgICAgICBpZiAobWUuc3RhdGUudmFsdWUgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICAgICAgICAgIChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkYXRhID0gbWUucHJvcHMuanN4ZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRleHRBcnIgPSBtZS5zdGF0ZS52YWx1ZS5tYXAoZnVuY3Rpb24gKGl0ZW0sIGluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhID0gZGF0YS5jb250ZW50cy5maWx0ZXIoZnVuY3Rpb24gKGVsZSwgaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlbGUudmFsdWUgPT0gaXRlbTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRhdGEudGV4dDtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGFyci5wdXNoKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgICAgICAgICAgICAgICAnc3BhbicsXG4gICAgICAgICAgICAgICAgICAgICAgICB7IGtleTogJ2Nhc2NhZGUnIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0QXJyLmpvaW4oXCIgXCIpXG4gICAgICAgICAgICAgICAgICAgICkpO1xuICAgICAgICAgICAgICAgIH0pKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXJyO1xuICAgIH07XG5cbiAgICByZXR1cm4gQ2FzY2FkZVNlbGVjdEZvcm1GaWVsZDtcbn0oRm9ybUZpZWxkKTtcblxuQ2FzY2FkZVNlbGVjdEZvcm1GaWVsZC5wcm9wVHlwZXMgPSBhc3NpZ24oe30sIEZvcm1GaWVsZC5wcm9wVHlwZXMsIHtcbiAgICBqc3hzdHlsZTogUmVhY3QuUHJvcFR5cGVzLm9iamVjdCxcbiAgICBqc3hzaG93U2VhcmNoOiBSZWFjdC5Qcm9wVHlwZXMuYm9vbCxcbiAgICBqc3hwbGFjZWhvbGRlcjogUmVhY3QuUHJvcFR5cGVzLnN0cmluZyxcbiAgICBqc3hkYXRhOiBSZWFjdC5Qcm9wVHlwZXMub2JqZWN0XG59KTtcbkNhc2NhZGVTZWxlY3RGb3JtRmllbGQuZGVmYXVsdFByb3BzID0gYXNzaWduKHt9LCBGb3JtRmllbGQuZGVmYXVsdFByb3BzLCB7XG4gICAganN4c2hvd1NlYXJjaDogZmFsc2UsXG4gICAganN4cGxhY2Vob2xkZXI6IFwi6K+35LiL5ouJ6YCJ5oupXCJcbn0pO1xuQ2FzY2FkZVNlbGVjdEZvcm1GaWVsZC5kaXNwbGF5TmFtZSA9IFwiQ2FzY2FkZVNlbGVjdEZvcm1GaWVsZFwiO1xuXG5tb2R1bGUuZXhwb3J0cyA9IENhc2NhZGVTZWxlY3RGb3JtRmllbGQ7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vdXhjb3JlLWZvcm0vYnVpbGQvRm9ybUZpZWxkL0Nhc2NhZGVTZWxlY3RGb3JtRmllbGQuanNcbiAqKiBtb2R1bGUgaWQgPSA1MzJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBPdGhlckZvcm1GaWVsZCBDb21wb25lbnQgZm9yIHV4Y29yZVxuICogQGF1dGhvciBldGVybmFsc2t5XG4gKlxuICogQ29weXJpZ2h0IDIwMTQtMjAxNSwgVXhjb3JlIFRlYW0sIEFsaW53LlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vT3RoZXJGb3JtRmllbGQnKTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi91eGNvcmUtZm9ybS9+L3V4Y29yZS1vdGhlci1mb3JtLWZpZWxkL2J1aWxkL2luZGV4LmpzXG4gKiogbW9kdWxlIGlkID0gNTMzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxuLyoqXG4gKiBPdGhlckZvcm1GaWVsZCBDb21wb25lbnQgZm9yIHV4Y29yZVxuICogQGF1dGhvciBldGVybmFsc2t5XG4gKlxuICogQ29weXJpZ2h0IDIwMTQtMjAxNSwgVXhjb3JlIFRlYW0sIEFsaW53LlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqL1xuXG52YXIgUmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xudmFyIFJlYWN0RE9NID0gcmVxdWlyZSgncmVhY3QtZG9tJyk7XG52YXIgY2xhc3NuYW1lcyA9IHJlcXVpcmUoJ2NsYXNzbmFtZXMnKTtcbnZhciBhc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG5cbnZhciBPdGhlckZvcm1GaWVsZCA9IGZ1bmN0aW9uIChfUmVhY3QkQ29tcG9uZW50KSB7XG4gICAgX2luaGVyaXRzKE90aGVyRm9ybUZpZWxkLCBfUmVhY3QkQ29tcG9uZW50KTtcblxuICAgIGZ1bmN0aW9uIE90aGVyRm9ybUZpZWxkKHByb3BzKSB7XG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBPdGhlckZvcm1GaWVsZCk7XG5cbiAgICAgICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9SZWFjdCRDb21wb25lbnQuY2FsbCh0aGlzLCBwcm9wcykpO1xuICAgIH1cblxuICAgIE90aGVyRm9ybUZpZWxkLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgICAgIHZhciBfY2xhc3NuYW1lcztcblxuICAgICAgICB2YXIgbWUgPSB0aGlzO1xuICAgICAgICB2YXIgc3R5bGUgPSB7XG4gICAgICAgICAgICB3aWR0aDogbWUucHJvcHMuanN4ZmxleCAvIG1lLnByb3BzLnRvdGFsRmxleCAqIDEwMCArICclJ1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAgICdkaXYnLFxuICAgICAgICAgICAgeyBjbGFzc05hbWU6IGNsYXNzbmFtZXMoKF9jbGFzc25hbWVzID0ge30sIF9jbGFzc25hbWVzW21lLnByb3BzLmpzeHByZWZpeENsc10gPSB0cnVlLCBfY2xhc3NuYW1lc1ttZS5wcm9wcy5jbGFzc05hbWVdID0gISFtZS5wcm9wcy5jbGFzc05hbWUsIF9jbGFzc25hbWVzKSksIHN0eWxlOiBhc3NpZ24oe30sIHN0eWxlLCB7XG4gICAgICAgICAgICAgICAgICAgIGRpc3BsYXk6IG1lLnByb3BzLmpzeHNob3cgPyBcInRhYmxlXCIgOiBcIm5vbmVcIlxuICAgICAgICAgICAgICAgIH0pIH0sXG4gICAgICAgICAgICBtZS5wcm9wcy5jaGlsZHJlblxuICAgICAgICApO1xuICAgIH07XG5cbiAgICByZXR1cm4gT3RoZXJGb3JtRmllbGQ7XG59KFJlYWN0LkNvbXBvbmVudCk7XG5cbk90aGVyRm9ybUZpZWxkLmRlZmF1bHRQcm9wcyA9IHtcbiAgICBqc3hwcmVmaXhDbHM6IFwia3VtYS11eGZvcm0tZmllbGQga3VtYS1vdGhlci11eGZvcm0tZmllbGRcIiwgLy8g6buY6K6k57G75ZCNXG4gICAganN4ZmxleDogMSwgLy8g5Y2gIEZvcm0g55qE5q+U5L6L77yM57G75Ly85LqOIGNzczMg5Lit55qEIGZsZXgtYm94XG4gICAganN4c2hvdzogdHJ1ZVxufTtcblxuT3RoZXJGb3JtRmllbGQucHJvcFR5cGVzID0ge1xuICAgIC8qKlxuICAgICAqIEB0aXRsZSDnsbvlkI3liY3nvIBcbiAgICAgKiBAdmVJZ25vcmVcbiAgICAgKi9cbiAgICBqc3hwcmVmaXhDbHM6IFJlYWN0LlByb3BUeXBlcy5zdHJpbmcsXG4gICAgLyoqXG4gICAgICogQHRpdGxlIOW8ueaAp+avlOS+i1xuICAgICAqL1xuICAgIGpzeGZsZXg6IFJlYWN0LlByb3BUeXBlcy5udW1iZXIsXG4gICAgLyoqXG4gICAgICogQHRpdGxlIOaYr+WQpuaYvuekulxuICAgICAqIEB2ZUlnbm9yZVxuICAgICAqL1xuICAgIGpzeHNob3c6IFJlYWN0LlByb3BUeXBlcy5ib29sXG59O1xuXG5PdGhlckZvcm1GaWVsZC5kaXNwbGF5TmFtZSA9IFwiT3RoZXJGb3JtRmllbGRcIjtcblxubW9kdWxlLmV4cG9ydHMgPSBPdGhlckZvcm1GaWVsZDtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi91eGNvcmUtZm9ybS9+L3V4Y29yZS1vdGhlci1mb3JtLWZpZWxkL2J1aWxkL090aGVyRm9ybUZpZWxkLmpzXG4gKiogbW9kdWxlIGlkID0gNTM0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIFJlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcbnZhciBSZWFjdERPTSA9IHJlcXVpcmUoJ3JlYWN0LWRvbScpO1xudmFyIGNsYXNzbmFtZXMgPSByZXF1aXJlKCdjbGFzc25hbWVzJyk7XG52YXIgYXNzaWduID0gcmVxdWlyZShcIm9iamVjdC1hc3NpZ25cIik7XG5cbnZhciBCdXR0b25Hcm91cEZvcm1GaWVsZCA9IGZ1bmN0aW9uIChfUmVhY3QkQ29tcG9uZW50KSB7XG4gICAgX2luaGVyaXRzKEJ1dHRvbkdyb3VwRm9ybUZpZWxkLCBfUmVhY3QkQ29tcG9uZW50KTtcblxuICAgIGZ1bmN0aW9uIEJ1dHRvbkdyb3VwRm9ybUZpZWxkKHByb3BzKSB7XG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBCdXR0b25Hcm91cEZvcm1GaWVsZCk7XG5cbiAgICAgICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9SZWFjdCRDb21wb25lbnQuY2FsbCh0aGlzLCBwcm9wcykpO1xuICAgIH1cblxuICAgIEJ1dHRvbkdyb3VwRm9ybUZpZWxkLnByb3RvdHlwZS5fcHJvY2Vzc0NoaWxkID0gZnVuY3Rpb24gX3Byb2Nlc3NDaGlsZCgpIHtcbiAgICAgICAgdmFyIG1lID0gdGhpcztcbiAgICAgICAgdmFyIGxlbmd0aCA9IFJlYWN0LkNoaWxkcmVuLmNvdW50KG1lLnByb3BzLmNoaWxkcmVuKTtcbiAgICAgICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZWxlbWVudHMgPSBSZWFjdC5DaGlsZHJlbi5tYXAobWUucHJvcHMuY2hpbGRyZW4sIGZ1bmN0aW9uIChjaGlsZCwgaW5kZXgpIHtcbiAgICAgICAgICAgIHZhciBwcm9wcyA9IHt9O1xuICAgICAgICAgICAgaWYgKGNoaWxkLnByb3BzLmFjdGlvbiA9PSBcInN1Ym1pdFwiKSB7XG4gICAgICAgICAgICAgICAgcHJvcHMub25DbGljayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRhdGEgPSBtZS5wcm9wcy5nZXRWYWx1ZXMoKTtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGQucHJvcHMub25DbGljayhkYXRhKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNoaWxkLnByb3BzLmFjdGlvbiA9PSBcInJlc2V0XCIpIHtcbiAgICAgICAgICAgICAgICBwcm9wcy5vbkNsaWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBtZS5wcm9wcy5yZXNldFZhbHVlcygpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gUmVhY3QuY2xvbmVFbGVtZW50KGNoaWxkLCBwcm9wcyk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBlbGVtZW50cztcbiAgICB9O1xuXG4gICAgQnV0dG9uR3JvdXBGb3JtRmllbGQucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICAgICAgdmFyIF9jbGFzc25hbWVzO1xuXG4gICAgICAgIHZhciBtZSA9IHRoaXM7XG4gICAgICAgIHZhciBlbGVtZW50cyA9IG1lLl9wcm9jZXNzQ2hpbGQoKTtcbiAgICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgICAnZGl2JyxcbiAgICAgICAgICAgIHsgY2xhc3NOYW1lOiBjbGFzc25hbWVzKChfY2xhc3NuYW1lcyA9IHt9LCBfY2xhc3NuYW1lc1ttZS5wcm9wcy5qc3hwcmVmaXhDbHNdID0gdHJ1ZSwgX2NsYXNzbmFtZXNbbWUucHJvcHMuY2xhc3NOYW1lXSA9ICEhbWUucHJvcHMuY2xhc3NOYW1lLCBfY2xhc3NuYW1lcykpLCBzdHlsZTogYXNzaWduKHt9LCBtZS5wcm9wcy5zdHlsZSwge1xuICAgICAgICAgICAgICAgICAgICBkaXNwbGF5OiBtZS5wcm9wcy5qc3hzaG93ID8gXCJ0YWJsZVwiIDogXCJub25lXCJcbiAgICAgICAgICAgICAgICB9KSB9LFxuICAgICAgICAgICAgISFlbGVtZW50cyAmJiBlbGVtZW50c1xuICAgICAgICApO1xuICAgIH07XG5cbiAgICByZXR1cm4gQnV0dG9uR3JvdXBGb3JtRmllbGQ7XG59KFJlYWN0LkNvbXBvbmVudCk7XG5cbkJ1dHRvbkdyb3VwRm9ybUZpZWxkLnByb3BUeXBlcyA9IHtcbiAgICBqc3hwcmVmaXhDbHM6IFJlYWN0LlByb3BUeXBlcy5zdHJpbmcsXG4gICAganN4ZmxleDogUmVhY3QuUHJvcFR5cGVzLm51bWJlcixcbiAgICBqc3hzaG93OiBSZWFjdC5Qcm9wVHlwZXMuYm9vbFxufTtcbkJ1dHRvbkdyb3VwRm9ybUZpZWxkLmRlZmF1bHRQcm9wcyA9IHtcbiAgICBqc3hwcmVmaXhDbHM6IFwia3VtYS11eGZvcm0tZmllbGQga3VtYS1idXR0b24tZ3JvdXAtdXhmb3JtLWZpZWxkXCIsIC8vIOm7mOiupOexu+WQjVxuICAgIGpzeGZsZXg6IDEsIC8vIOWNoCBGb3JtIOeahOavlOS+i++8jOexu+S8vOS6jiBjc3MzIOS4reeahCBmbGV4LWJveFxuICAgIGpzeHNob3c6IHRydWVcbn07XG5CdXR0b25Hcm91cEZvcm1GaWVsZC5kaXNwbGF5TmFtZSA9IFwiQnV0dG9uR3JvdXBGb3JtRmllbGRcIjtcblxubW9kdWxlLmV4cG9ydHMgPSBCdXR0b25Hcm91cEZvcm1GaWVsZDtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi91eGNvcmUtZm9ybS9idWlsZC9Gb3JtRmllbGQvQnV0dG9uR3JvdXBGb3JtRmllbGQuanNcbiAqKiBtb2R1bGUgaWQgPSA1MzVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlwidXNlIHN0cmljdFwiO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBGb3JtRmllbGQgPSByZXF1aXJlKCd1eGNvcmUtZm9ybS1maWVsZCcpO1xudmFyIENvbnN0YW50cyA9IHJlcXVpcmUoXCJ1eGNvcmUtY29uc3RcIik7XG52YXIgVGlueW1jZSA9IHJlcXVpcmUoXCJ1eGNvcmUtdGlueW1jZVwiKTtcbnZhciBhc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG5cbnZhciBFZGl0b3JGb3JtRmllbGQgPSBmdW5jdGlvbiAoX0Zvcm1GaWVsZCkge1xuICAgIF9pbmhlcml0cyhFZGl0b3JGb3JtRmllbGQsIF9Gb3JtRmllbGQpO1xuXG4gICAgZnVuY3Rpb24gRWRpdG9yRm9ybUZpZWxkKHByb3BzKSB7XG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBFZGl0b3JGb3JtRmllbGQpO1xuXG4gICAgICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfRm9ybUZpZWxkLmNhbGwodGhpcywgcHJvcHMpKTtcbiAgICB9XG5cbiAgICBFZGl0b3JGb3JtRmllbGQucHJvdG90eXBlLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgPSBmdW5jdGlvbiBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKG5leHRQcm9wcykge1xuICAgICAgICB2YXIgbWUgPSB0aGlzO1xuICAgICAgICBpZiAoIW1lLl9pc0VxdWFsKG5leHRQcm9wcy52YWx1ZSwgbWUucHJvcHMudmFsdWUpKSB7XG4gICAgICAgICAgICBtZS5oYW5kbGVEYXRhQ2hhbmdlKG5leHRQcm9wcy52YWx1ZSwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgRWRpdG9yRm9ybUZpZWxkLnByb3RvdHlwZS5jb21wb25lbnREaWRVcGRhdGUgPSBmdW5jdGlvbiBjb21wb25lbnREaWRVcGRhdGUocHJldlByb3BzKSB7XG4gICAgICAgIHZhciBtZSA9IHRoaXM7XG4gICAgICAgIHZhciBwcmV2TW9kZSA9IHByZXZQcm9wcy5qc3htb2RlIHx8IHByZXZQcm9wcy5tb2RlO1xuICAgICAgICB2YXIgbW9kZSA9IG1lLnByb3BzLmpzeG1vZGUgfHwgbWUucHJvcHMubW9kZTtcbiAgICAgICAgaWYgKHByZXZNb2RlID09IENvbnN0YW50cy5NT0RFLlZJRVcgJiYgbW9kZSA9PSBDb25zdGFudHMuTU9ERS5FRElUKSB7XG4gICAgICAgICAgICBtZS5yZWZzLnRpbnltY2UucmVzZXRWYWx1ZShtZS5zdGF0ZS52YWx1ZSA9PSB1bmRlZmluZWQgfHwgbWUuc3RhdGUudmFsdWUgPT0gbnVsbCA/IFwiXCIgOiBtZS5zdGF0ZS52YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgRWRpdG9yRm9ybUZpZWxkLnByb3RvdHlwZS5faXNFcXVhbCA9IGZ1bmN0aW9uIF9pc0VxdWFsKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGEpID09IEpTT04uc3RyaW5naWZ5KGIpO1xuICAgIH07XG5cbiAgICBFZGl0b3JGb3JtRmllbGQucHJvdG90eXBlLmhhbmRsZUNoYW5nZSA9IGZ1bmN0aW9uIGhhbmRsZUNoYW5nZShlLCBlZGl0b3IpIHtcbiAgICAgICAgdmFyIG1lID0gdGhpcztcbiAgICAgICAgbWUuaGFuZGxlRGF0YUNoYW5nZShlZGl0b3IuZ2V0Q29udGVudCgpKTtcbiAgICB9O1xuXG4gICAgRWRpdG9yRm9ybUZpZWxkLnByb3RvdHlwZS5oYW5kbGVLZXl1cCA9IGZ1bmN0aW9uIGhhbmRsZUtleXVwKGUsIGVkaXRvcikge1xuICAgICAgICB2YXIgbWUgPSB0aGlzO1xuICAgICAgICBtZS5oYW5kbGVEYXRhQ2hhbmdlKGVkaXRvci5nZXRDb250ZW50KCkpO1xuICAgIH07XG5cbiAgICBFZGl0b3JGb3JtRmllbGQucHJvdG90eXBlLmFkZFNwZWNpZmljQ2xhc3MgPSBmdW5jdGlvbiBhZGRTcGVjaWZpY0NsYXNzKCkge1xuICAgICAgICB2YXIgbWUgPSB0aGlzO1xuICAgICAgICBpZiAobWUucHJvcHMuanN4cHJlZml4Q2xzID09IFwia3VtYS11eGZvcm0tZmllbGRcIikge1xuICAgICAgICAgICAgcmV0dXJuIG1lLnByb3BzLmpzeHByZWZpeENscyArIFwiIGt1bWEtZWRpdG9yLXV4Zm9ybS1maWVsZFwiO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG1lLnByb3BzLmpzeHByZWZpeENscztcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBFZGl0b3JGb3JtRmllbGQucHJvdG90eXBlLnJlbmRlckZpZWxkID0gZnVuY3Rpb24gcmVuZGVyRmllbGQoKSB7XG4gICAgICAgIHZhciBtZSA9IHRoaXM7XG4gICAgICAgIHZhciBtb2RlID0gbWUucHJvcHMuanN4bW9kZSB8fCBtZS5wcm9wcy5tb2RlO1xuICAgICAgICBpZiAobWUuc3RhdGUuZnJvbVJlc2V0ICYmIG1vZGUgPT0gQ29uc3RhbnRzLk1PREUuRURJVCkge1xuICAgICAgICAgICAgbWUucmVmcy50aW55bWNlLnJlc2V0VmFsdWUobWUucHJvcHMuanN4Y29udGVudCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1vZGUgPT0gQ29uc3RhbnRzLk1PREUuRURJVCkge1xuICAgICAgICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoVGlueW1jZSwgeyByZWY6IFwidGlueW1jZVwiLFxuICAgICAgICAgICAgICAgIHBsYWNlaG9sZGVyOiBtZS5wcm9wcy5wbGFjZWhvbGRlcixcbiAgICAgICAgICAgICAgICBjb25maWc6IG1lLnByb3BzLmpzeGNvbmZpZyxcbiAgICAgICAgICAgICAgICBjb250ZW50OiBtZS5zdGF0ZS52YWx1ZSB8fCBcIlwiLFxuICAgICAgICAgICAgICAgIG9uQ2hhbmdlOiBtZS5oYW5kbGVDaGFuZ2UuYmluZChtZSksXG4gICAgICAgICAgICAgICAgb25LZXl1cDogbWUuaGFuZGxlS2V5dXAuYmluZChtZSkgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcInNwYW5cIiwgeyBrZXk6IFwidGV4dFwiLCBkYW5nZXJvdXNseVNldElubmVySFRNTDogeyBfX2h0bWw6IG1lLnN0YXRlLnZhbHVlIH0gfSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgcmV0dXJuIEVkaXRvckZvcm1GaWVsZDtcbn0oRm9ybUZpZWxkKTtcblxuRWRpdG9yRm9ybUZpZWxkLnByb3BUeXBlcyA9IGFzc2lnbih7fSwgRm9ybUZpZWxkLnByb3BUeXBlcyk7XG5FZGl0b3JGb3JtRmllbGQuZGVmYXVsdFByb3BzID0gYXNzaWduKHt9LCBGb3JtRmllbGQuZGVmYXVsdFByb3BzLCB7XG4gICAganN4Y29uZmlnOiB7fSxcbiAgICBqc3hjb250ZW50OiBcIlwiXG59KTtcbkVkaXRvckZvcm1GaWVsZC5kaXNwbGF5TmFtZSA9IFwiRWRpdG9yRm9ybUZpZWxkXCI7XG5cbm1vZHVsZS5leHBvcnRzID0gRWRpdG9yRm9ybUZpZWxkO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3V4Y29yZS1mb3JtL2J1aWxkL0Zvcm1GaWVsZC9FZGl0b3JGb3JtRmllbGQuanNcbiAqKiBtb2R1bGUgaWQgPSA1MzZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBUaW55bWNlIENvbXBvbmVudCBmb3IgdXhjb3JlXG4gKiBAYXV0aG9yIGV0ZXJuYWxza3lcbiAqXG4gKiBDb3B5cmlnaHQgMjAxNC0yMDE1LCBVeGNvcmUgVGVhbSwgQWxpbncuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9UaW55bWNlJyk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vdXhjb3JlLWZvcm0vfi91eGNvcmUtdGlueW1jZS9idWlsZC9pbmRleC5qc1xuICoqIG1vZHVsZSBpZCA9IDUzN1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblxuZnVuY3Rpb24gX2RlZmF1bHRzKG9iaiwgZGVmYXVsdHMpIHsgdmFyIGtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhkZWZhdWx0cyk7IGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykgeyB2YXIga2V5ID0ga2V5c1tpXTsgdmFyIHZhbHVlID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihkZWZhdWx0cywga2V5KTsgaWYgKHZhbHVlICYmIHZhbHVlLmNvbmZpZ3VyYWJsZSAmJiBvYmpba2V5XSA9PT0gdW5kZWZpbmVkKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpOyB9IH0gcmV0dXJuIG9iajsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBfZGVmYXVsdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpOyB9XG5cbi8qKlxuICogVGlueW1jZSBDb21wb25lbnQgZm9yIHV4Y29yZVxuICogSW5zcGlyZWQgYnkgcmVhY3QtdGlueW1jZTogaHR0cHM6Ly9naXRodWIuY29tL216YWJyaXNraWUvcmVhY3QtdGlueW1jZVxuICogQGF1dGhvciBldGVybmFsc2t5XG4gKlxuICogQ29weXJpZ2h0IDIwMTQtMjAxNSwgVXhjb3JlIFRlYW0sIEFsaW53LlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqL1xuXG52YXIgUmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xudmFyIFJlYWN0RE9NID0gcmVxdWlyZSgncmVhY3QtZG9tJyk7XG52YXIgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xudmFyIEVkaXRvckNvbmZpZyA9IHJlcXVpcmUoJy4vZWRpdG9yQ29uZmlnJyk7XG52YXIgYXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xuLy8gSW5jbHVkZSBhbGwgb2YgdGhlIE5hdGl2ZSBET00gYW5kIGN1c3RvbSBldmVudHMgZnJvbTpcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS90aW55bWNlL3RpbnltY2UvYmxvYi9tYXN0ZXIvdG9vbHMvZG9jcy90aW55bWNlLkVkaXRvci5qcyNMNS1MMTJcbnZhciBFVkVOVFMgPSBbJ2ZvY3VzaW4nLCAnZm9jdXNvdXQnLCAnY2xpY2snLCAnZGJsY2xpY2snLCAnbW91c2Vkb3duJywgJ21vdXNldXAnLCAnbW91c2Vtb3ZlJywgJ21vdXNlb3ZlcicsICdiZWZvcmVwYXN0ZScsICdwYXN0ZScsICdjdXQnLCAnY29weScsICdzZWxlY3Rpb25jaGFuZ2UnLCAnbW91c2VvdXQnLCAnbW91c2VlbnRlcicsICdtb3VzZWxlYXZlJywgJ2tleWRvd24nLCAna2V5cHJlc3MnLCAna2V5dXAnLCAnY29udGV4dG1lbnUnLCAnZHJhZ2VuZCcsICdkcmFnb3ZlcicsICdkcmFnZ2VzdHVyZScsICdkcmFnZHJvcCcsICdkcm9wJywgJ2RyYWcnLCAnQmVmb3JlUmVuZGVyVUknLCAnU2V0QXR0cmliJywgJ1ByZUluaXQnLCAnUG9zdFJlbmRlcicsICdpbml0JywgJ2RlYWN0aXZhdGUnLCAnYWN0aXZhdGUnLCAnTm9kZUNoYW5nZScsICdCZWZvcmVFeGVjQ29tbWFuZCcsICdFeGVjQ29tbWFuZCcsICdzaG93JywgJ2hpZGUnLCAnUHJvZ3Jlc3NTdGF0ZScsICdMb2FkQ29udGVudCcsICdTYXZlQ29udGVudCcsICdCZWZvcmVTZXRDb250ZW50JywgJ1NldENvbnRlbnQnLCAnQmVmb3JlR2V0Q29udGVudCcsICdHZXRDb250ZW50JywgJ1Zpc3VhbEFpZCcsICdyZW1vdmUnLCAnc3VibWl0JywgJ3Jlc2V0JywgJ0JlZm9yZUFkZFVuZG8nLCAnQWRkVW5kbycsICdjaGFuZ2UnLCAndW5kbycsICdyZWRvJywgJ0NsZWFyVW5kb3MnLCAnT2JqZWN0U2VsZWN0ZWQnLCAnT2JqZWN0UmVzaXplU3RhcnQnLCAnT2JqZWN0UmVzaXplZCcsICdQcmVQcm9jZXNzJywgJ1Bvc3RQcm9jZXNzJywgJ2ZvY3VzJywgJ2JsdXInXTtcblxuLy8gTm90ZTogYmVjYXVzZSB0aGUgY2FwaXRhbGl6YXRpb24gb2YgdGhlIGV2ZW50cyBpcyB3ZWlyZCwgd2UncmUgZ29pbmcgdG8gZ2V0XG4vLyBzb21lIGluY29uc2lzdGVudGx5LW5hbWVkIGhhbmRsZXJzLCBmb3IgZXhhbXBsZSBjb21wYXJlOlxuLy8gJ29uTW91c2VsZWF2ZScgYW5kICdvbk5vZGVDaGFuZ2UnXG52YXIgSEFORExFUl9OQU1FUyA9IEVWRU5UUy5tYXAoZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgcmV0dXJuICdvbicgKyB1dGlsLnVjX2ZpcnN0KGV2ZW50KTtcbn0pO1xuXG52YXIgVGlueW1jZSA9IGZ1bmN0aW9uIChfUmVhY3QkQ29tcG9uZW50KSB7XG4gICAgX2luaGVyaXRzKFRpbnltY2UsIF9SZWFjdCRDb21wb25lbnQpO1xuXG4gICAgZnVuY3Rpb24gVGlueW1jZShwcm9wcykge1xuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgVGlueW1jZSk7XG5cbiAgICAgICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9SZWFjdCRDb21wb25lbnQuY2FsbCh0aGlzLCBwcm9wcykpO1xuICAgIH1cblxuICAgIFRpbnltY2UucHJvdG90eXBlLmNvbXBvbmVudFdpbGxNb3VudCA9IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxNb3VudCgpIHtcbiAgICAgICAgaWYgKCh0eXBlb2YgdGlueW1jZSA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YodGlueW1jZSkpICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKFwiVGlueU1DRSBpcyBub3QgZm91bmQgaW4gZ2xvYmFsLCBpbml0IGZhaWxlZFwiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmlkID0gdGhpcy5pZCB8fCB1dGlsLnV1aWQoKTtcbiAgICB9O1xuXG4gICAgVGlueW1jZS5wcm90b3R5cGUuY29tcG9uZW50RGlkTW91bnQgPSBmdW5jdGlvbiBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICAgICAgdGhpcy5faW5pdCh0aGlzLnByb3BzLmNvbmZpZyk7XG4gICAgfTtcblxuICAgIFRpbnltY2UucHJvdG90eXBlLmNvbXBvbmVudFdpbGxVbm1vdW50ID0gZnVuY3Rpb24gY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgICAgIHRoaXMuX3JlbW92ZSgpO1xuICAgIH07XG5cbiAgICBUaW55bWNlLnByb3RvdHlwZS5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzID0gZnVuY3Rpb24gY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhuZXh0UHJvcHMpIHtcbiAgICAgICAgaWYgKCF1dGlsLmlzRXF1YWwobmV4dFByb3BzLmNvbmZpZywgdGhpcy5wcm9wcy5jb25maWcpKSB7XG4gICAgICAgICAgICB0aGlzLl9pbml0KG5leHRQcm9wcy5jb25maWcsIG5leHRQcm9wcy5jb250ZW50KTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBUaW55bWNlLnByb3RvdHlwZS5zaG91bGRDb21wb25lbnRVcGRhdGUgPSBmdW5jdGlvbiBzaG91bGRDb21wb25lbnRVcGRhdGUobmV4dFByb3BzKSB7XG4gICAgICAgIHJldHVybiAhdXRpbC5pc0VxdWFsKHRoaXMucHJvcHMuY29udGVudCwgbmV4dFByb3BzLmNvbnRlbnQpIHx8ICF1dGlsLmlzRXF1YWwodGhpcy5wcm9wcy5jb25maWcsIG5leHRQcm9wcy5jb25maWcpO1xuICAgIH07XG5cbiAgICBUaW55bWNlLnByb3RvdHlwZS5yZXNldFZhbHVlID0gZnVuY3Rpb24gcmVzZXRWYWx1ZSh2YWx1ZSkge1xuICAgICAgICB0aW55bWNlLmdldCh0aGlzLmlkKS5zZXRDb250ZW50KHZhbHVlKTtcbiAgICB9O1xuXG4gICAgVGlueW1jZS5wcm90b3R5cGUuX2luaXQgPSBmdW5jdGlvbiBfaW5pdChjb25maWcsIGNvbnRlbnQpIHtcbiAgICAgICAgdmFyIG1lID0gdGhpcztcbiAgICAgICAgaWYgKG1lLl9pc0luaXQpIHtcbiAgICAgICAgICAgIG1lLl9yZW1vdmUoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBoaWRlIHRoZSB0ZXh0YXJlYSB1bnRpbCBpbml0IGZpbmlzaGVkXG4gICAgICAgIFJlYWN0RE9NLmZpbmRET01Ob2RlKG1lKS5zdHlsZS52aXNpYmlsaXR5ID0gJ2hpZGRlbic7XG4gICAgICAgIGNvbmZpZy5zZWxlY3RvciA9ICcjJyArIG1lLmlkO1xuICAgICAgICBjb25maWcgPSBhc3NpZ24oe30sIEVkaXRvckNvbmZpZywgY29uZmlnKTtcbiAgICAgICAgaWYgKCFjb25maWcubGFuZ3VhZ2UpIHtcbiAgICAgICAgICAgIGNvbmZpZy5sYW5ndWFnZSA9ICd6aF9DTic7XG4gICAgICAgIH1cbiAgICAgICAgY29uZmlnLnNldHVwID0gZnVuY3Rpb24gKGVkaXRvcikge1xuICAgICAgICAgICAgRVZFTlRTLmZvckVhY2goZnVuY3Rpb24gKGV2ZW50LCBpbmRleCkge1xuICAgICAgICAgICAgICAgIHZhciBoYW5kbGVyID0gbWUucHJvcHNbSEFORExFUl9OQU1FU1tpbmRleF1dO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgaGFuZGxlciAhPT0gJ2Z1bmN0aW9uJykgcmV0dXJuO1xuICAgICAgICAgICAgICAgIGVkaXRvci5vbihldmVudCwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gbmF0aXZlIERPTSBldmVudHMgZG9uJ3QgaGF2ZSBhY2Nlc3MgdG8gdGhlIGVkaXRvciBzbyB3ZSBwYXNzIGl0IGhlcmVcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlcihlLCBlZGl0b3IpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBuZWVkIHRvIHNldCBjb250ZW50IGhlcmUgYmVjYXVzZSB0aGUgdGV4dGFyZWEgd2lsbCBzdGlsbCBoYXZlIHRoZVxuICAgICAgICAgICAgLy8gb2xkIGB0aGlzLnByb3BzLmNvbnRlbnRgXG4gICAgICAgICAgICBpZiAoY29udGVudCkge1xuICAgICAgICAgICAgICAgIGVkaXRvci5vbignaW5pdCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgZWRpdG9yLnNldENvbnRlbnQoY29udGVudCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRpbnltY2UuYmFzZVVSTCA9ICcvL2cuYWxpY2RuLmNvbS91eGNvcmUvdXhjb3JlLWxpYi90aW55bWNlLzQuMi41Lyc7XG4gICAgICAgIHRpbnltY2UuaW5pdChjb25maWcpO1xuICAgICAgICBSZWFjdERPTS5maW5kRE9NTm9kZShtZSkuc3R5bGUudmlzaWJpbGl0eSA9IFwiXCI7XG4gICAgICAgIG1lLl9pc0luaXQgPSB0cnVlO1xuICAgIH07XG5cbiAgICBUaW55bWNlLnByb3RvdHlwZS5fcmVtb3ZlID0gZnVuY3Rpb24gX3JlbW92ZSgpIHtcbiAgICAgICAgdGlueW1jZS5FZGl0b3JNYW5hZ2VyLmV4ZWNDb21tYW5kKFwibWNlUmVtb3ZlRWRpdG9yXCIsIHRydWUsIHRoaXMuaWQpO1xuICAgICAgICB0aGlzLl9pc0luaXQgPSBmYWxzZTtcbiAgICB9O1xuXG4gICAgVGlueW1jZS5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgICAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudCgndGV4dGFyZWEnLCB7IGlkOiB0aGlzLmlkLCBkZWZhdWx0VmFsdWU6IHRoaXMucHJvcHMuY29udGVudCwgcGxhY2Vob2xkZXI6IHRoaXMucHJvcHMucGxhY2Vob2xkZXIgfSk7XG4gICAgfTtcblxuICAgIHJldHVybiBUaW55bWNlO1xufShSZWFjdC5Db21wb25lbnQpO1xuXG5UaW55bWNlLmRlZmF1bHRQcm9wcyA9IHtcbiAgICBjb25maWc6IHt9XG59O1xuXG4vLyBodHRwOi8vZmFjZWJvb2suZ2l0aHViLmlvL3JlYWN0L2RvY3MvcmV1c2FibGUtY29tcG9uZW50cy5odG1sXG5UaW55bWNlLnByb3BUeXBlcyA9IHtcbiAgICBjb25maWc6IFJlYWN0LlByb3BUeXBlcy5vYmplY3QsXG4gICAgY29udGVudDogUmVhY3QuUHJvcFR5cGVzLnN0cmluZ1xufTtcblxuLy9hZGQgaGFuZGxlciBwcm9wVHlwZXNcbkhBTkRMRVJfTkFNRVMuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgIFRpbnltY2UucHJvcFR5cGVzW25hbWVdID0gUmVhY3QuUHJvcFR5cGVzLmZ1bmM7XG59KTtcblxuVGlueW1jZS5kaXNwbGF5TmFtZSA9IFwiVGlueW1jZVwiO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFRpbnltY2U7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vdXhjb3JlLWZvcm0vfi91eGNvcmUtdGlueW1jZS9idWlsZC9UaW55bWNlLmpzXG4gKiogbW9kdWxlIGlkID0gNTM4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbnZhciBjb3VudCA9IDA7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIHVjX2ZpcnN0OiBmdW5jdGlvbiB1Y19maXJzdChzdHIpIHtcbiAgICAgICAgcmV0dXJuIHN0ci5zdWJzdHJpbmcoMCwgMSkudG9VcHBlckNhc2UoKSArIHN0ci5zdWJzdHJpbmcoMSk7XG4gICAgfSxcbiAgICB1dWlkOiBmdW5jdGlvbiB1dWlkKCkge1xuICAgICAgICByZXR1cm4gJ3V4Y29yZS10aW55bWNlLScgKyBjb3VudCsrO1xuICAgIH0sXG4gICAgaXNFcXVhbDogZnVuY3Rpb24gaXNFcXVhbChhLCBiKSB7XG4gICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShhKSA9PSBKU09OLnN0cmluZ2lmeShiKTtcbiAgICB9XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3V4Y29yZS1mb3JtL34vdXhjb3JlLXRpbnltY2UvYnVpbGQvdXRpbC5qc1xuICoqIG1vZHVsZSBpZCA9IDUzOVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xudmFyIHBsdWdpbnMgPSBbJ2xpc3RzJywgJ2hyJywgJ2Vtb3RpY29ucycsICd0ZXh0Y29sb3InLCAnaW5zZXJ0ZGF0ZXRpbWUnLCAnbGluaycsICd0YWJsZScsICdwYXN0ZScsICdwcmV2aWV3JywgJ3dvcmRjb3VudCcsICdpbWFnZScsICd1cGxvYWQnLCAncGxhY2Vob2xkZXInLCAndmFyaWFibGUnLCAnbm9uZWRpdGFibGUnXTtcblxuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSB7XG4gIHRoZW1lOiAnbW9kZXJuJyxcbiAgaGVpZ2h0OiA0MDAsXG4gIGV4dGVybmFsX3BsdWdpbnM6IHtcbiAgICAnZW1vdGljb25zJzogJy8vZy5hbGljZG4uY29tL3V4Y29yZS91eGNvcmUtbGliL3RpbnltY2UvNC4yLjUvcGx1Z2lucy9lbW90aWNvbnMvcGx1Z2luLm1pbi5qcycsXG4gICAgJ3VwbG9hZCc6ICcvL2cuYWxpY2RuLmNvbS91eGNvcmUvdXhjb3JlLWxpYi90aW55bWNlLzQuMi41L3BsdWdpbnMvdXBsb2FkL3BsdWdpbi5taW4uanMnLFxuICAgICd0ZXh0Y29sb3InOiAnLy9nLmFsaWNkbi5jb20vdXhjb3JlL3V4Y29yZS1saWIvdGlueW1jZS80LjIuNS9wbHVnaW5zL3RleHRjb2xvci9wbHVnaW4ubWluLmpzJyxcbiAgICAnaHInOiAnLy9nLmFsaWNkbi5jb20vdXhjb3JlL3V4Y29yZS1saWIvdGlueW1jZS80LjIuNS9wbHVnaW5zL2hyL3BsdWdpbi5taW4uanMnLFxuICAgICdwbGFjZWhvbGRlcic6ICcvL2cuYWxpY2RuLmNvbS91eGNvcmUvdXhjb3JlLWxpYi90aW55bWNlLzQuMi41L3BsdWdpbnMvcGxhY2Vob2xkZXIvcGx1Z2luLm1pbi5qcycsXG4gICAgJ3ZhcmlhYmxlJzogJy8vZy5hbGljZG4uY29tL3V4Y29yZS91eGNvcmUtbGliL3RpbnltY2UvNC4yLjUvcGx1Z2lucy92YXJpYWJsZS9wbHVnaW4ubWluLmpzJ1xuICB9LFxuICByZXNpemU6IHRydWUsIC8vIOaYr+WQpuWPr+S7pem8oOagh+aLluWKqOe8lui+keWZqOaUueWPmOWkp+Wwj1xuICBib3JkZXJfd2lkdGg6IDEsIC8vIOe8lui+keWZqOeahOi+ueahhuWuveW6plxuICBjb252ZXJ0X3VybHM6IGZhbHNlLCAvLyDlvZPkvaBpbnNlcnRDb250ZW5055qE5pe25YCZ77yM5Y+W5raI5LiA5Lqb6IqC54K5c3Jj55qE6L2s5o2iXG4gIHZpc3VhbDogdHJ1ZSwgLy8gdGFibGXnmoTomZrmoYbmmK/lkKbmmL7npLrvvIznlLHkuo7lpKfmlofmnKzorr7nva7omZrmoYblvojogJfmgKfog73vvIzmiYDku6Xlj5bmtojmjolcbiAga2VlcF92YWx1ZXM6IGZhbHNlLCAvLyDlv4Xpobvorr7nva5mYWxzZeeUqOadpeaPkOmrmOaAp+iDvVxuICBmb3JjZWRfcm9vdF9ibG9jazogJ2RpdicsIC8vIOW9k+epuuaWh+acrOeahOaXtuWAme+8jHRpbnltY2XkvJrorr7nva7kuIDkuKrmoLnoioLngrnvvIzpu5jorqTmmK9Q77yM5oiR5Lus6KaB5pS55oiQZGl25q+U6L6D5ZCI55CGXG4gIHNob3dfc3lzdGVtX2RlZmF1bHRfZm9udDogdHJ1ZSwgLy8g5piv5ZCm5byA5ZCv57O757uf5a2X5L2T55qE5o6i5rWL44CCXG4gIGxpbmtfdGl0bGU6IHRydWUsIC8vIGxpbmsgcGx1Z2lucyBlbmFibGUgdGl0bGUgZWRpdFxuICBwbHVnaW5zOiBwbHVnaW5zLFxuICBjc3NGaWxlczogWydzdHlsZXMvc2tpbi5jc3MnLCAnc3R5bGVzL3NraW4tZXh0LmNzcyddLFxuICB0b29sYmFyMTogJ3ByZXZpZXcgdW5kbyByZWRvIHwgZm9udHNlbGVjdCBmb250c2l6ZXNlbGVjdCB8IGJvbGQgaXRhbGljIHVuZGVybGluZSBzdHJpa2V0aHJvdWdoIHJlbW92ZWZvcm1hdCB8IGZvcmVjb2xvciBiYWNrY29sb3IgfCBsaW5rIHwgZW1vdGljb25zIHVwbG9hZCcsXG4gIHRvb2xiYXIyOiAnYWxpZ25sZWZ0IGFsaWduY2VudGVyIGFsaWducmlnaHQgYWxpZ25qdXN0aWZ5IHwgYnVsbGlzdCBudW1saXN0IG91dGRlbnQgaW5kZW50IHwgdGFibGUgaHIgaW5zZXJ0dGltZScsXG4gIHVwbG9hZENvbmZpZzoge1xuICAgIFwiaW5wdXROYW1lXCI6IFwiaW1hZ2VVcGxvYWRJbnB1dFwiLFxuICAgIFwiYWN0aW9uVXJsXCI6IFwiaHR0cDovL3Rlc3QuYWxpYmFiYS1pbmMuY29tL3dvcmsveHNlcnZpY2UvaHR0cC91cGxvYWRpbWFnZS5qc29uXCIsXG4gICAgXCJlcnJvckNhbGxiYWNrXCI6IGZ1bmN0aW9uIGVycm9yQ2FsbGJhY2soKSB7XG4gICAgICBjb25zb2xlLmxvZygnZXJyb3JDYWxsYmFjaycsIGFyZ3VtZW50cyk7XG4gICAgfSxcbiAgICBcInByb2dyZXNzQ2FsbGJhY2tcIjogZnVuY3Rpb24gcHJvZ3Jlc3NDYWxsYmFjaygpIHtcbiAgICAgIGNvbnNvbGUubG9nKCdwcm9ncmVzc0NhbGxiYWNrJywgYXJndW1lbnRzKTtcbiAgICB9XG4gIH0sXG4gIHdvcmRjb3VudF9jb3VudHJlZ2V4OiAvW15cXHgwMC1cXHhmZl0rL2dcbn07XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi91eGNvcmUtZm9ybS9+L3V4Y29yZS10aW55bWNlL2J1aWxkL2VkaXRvckNvbmZpZy5qc1xuICoqIG1vZHVsZSBpZCA9IDU0MFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMob2JqLCBrZXlzKSB7IHZhciB0YXJnZXQgPSB7fTsgZm9yICh2YXIgaSBpbiBvYmopIHsgaWYgKGtleXMuaW5kZXhPZihpKSA+PSAwKSBjb250aW51ZTsgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBpKSkgY29udGludWU7IHRhcmdldFtpXSA9IG9ialtpXTsgfSByZXR1cm4gdGFyZ2V0OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxuLyoqXG4gKiBDcmVhdGVkIGJ5IHh5IG9uIDE1LzQvMTMuXG4gKi9cbnZhciBTZWxlY3RGb3JtRmllbGQgPSByZXF1aXJlKCd1eGNvcmUtc2VsZWN0LWZvcm0tZmllbGQnKTtcbnZhciBDb25zdGFudHMgPSByZXF1aXJlKFwidXhjb3JlLWNvbnN0XCIpO1xudmFyIFNlbGVjdCA9IHJlcXVpcmUoJ3V4Y29yZS1zZWxlY3QyJyk7XG52YXIgYXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xudmFyIGRlZXBjb3B5ID0gcmVxdWlyZSgnZGVlcGNvcHknKTtcbnZhciBjbGFzc25hbWVzID0gcmVxdWlyZSgnY2xhc3NuYW1lcycpO1xudmFyIE9wdGlvbiA9IFNlbGVjdC5PcHRpb247XG5cbnZhciBzZWxlY3RPcHRpb25zID0gWydvblNlbGVjdCcsICdvbkRlc2VsZWN0JywgJ2dldFBvcHVwQ29udGFpbmVyJywgJ2ZpbHRlck9wdGlvbicsICdhbGxvd0NsZWFyJywgJ3NlYXJjaFBsYWNlaG9sZGVyJywgJ3RhZ3MnLCAnZGlzYWJsZWQnLCAnc2hvd1NlYXJjaCcsICdwbGFjZWhvbGRlcicsICdvcHRpb25MYWJlbFByb3AnLCAnbWF4VGFnVGV4dExlbmd0aCcsICdkcm9wZG93bk1hdGNoU2VsZWN0V2lkdGgnLCAnZHJvcGRvd25DbGFzc05hbWUnLCAnbm90Rm91bmRDb250ZW50J107XG5cbnZhciBTZWFyY2hGb3JtRmllbGQgPSBmdW5jdGlvbiAoX1NlbGVjdEZvcm1GaWVsZCkge1xuICAgIF9pbmhlcml0cyhTZWFyY2hGb3JtRmllbGQsIF9TZWxlY3RGb3JtRmllbGQpO1xuXG4gICAgZnVuY3Rpb24gU2VhcmNoRm9ybUZpZWxkKHByb3BzKSB7XG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBTZWFyY2hGb3JtRmllbGQpO1xuXG4gICAgICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfU2VsZWN0Rm9ybUZpZWxkLmNhbGwodGhpcywgcHJvcHMpKTtcbiAgICB9XG5cbiAgICBTZWFyY2hGb3JtRmllbGQucHJvdG90eXBlLmFkZFNwZWNpZmljQ2xhc3MgPSBmdW5jdGlvbiBhZGRTcGVjaWZpY0NsYXNzKCkge1xuICAgICAgICB2YXIgbWUgPSB0aGlzO1xuICAgICAgICBpZiAobWUucHJvcHMuanN4cHJlZml4Q2xzID09IFwia3VtYS11eGZvcm0tZmllbGRcIikge1xuICAgICAgICAgICAgcmV0dXJuIG1lLnByb3BzLmpzeHByZWZpeENscyArIFwiIGt1bWEtc2VhcmNoLXV4Zm9ybS1maWVsZFwiO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG1lLnByb3BzLmpzeHByZWZpeENscztcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBTZWFyY2hGb3JtRmllbGQucHJvdG90eXBlLl9wcm9jZXNzQWR2YW5jZWQgPSBmdW5jdGlvbiBfcHJvY2Vzc0FkdmFuY2VkKCkge1xuICAgICAgICB2YXIgbWUgPSB0aGlzO1xuICAgICAgICB2YXIgYWR2YW5jZWRPcHRpb25zID0gbWUucHJvcHMuYWR2YW5jZWRPcHRpb25zO1xuXG4gICAgICAgIHJldHVybiBhZHZhbmNlZE9wdGlvbnMubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAgICAgICBPcHRpb24sXG4gICAgICAgICAgICAgICAgeyBrZXk6IGl0ZW0udmFsdWUsIHRpdGxlOiBpdGVtLnRleHQgfSxcbiAgICAgICAgICAgICAgICBpdGVtLnRleHRcbiAgICAgICAgICAgICk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICBTZWFyY2hGb3JtRmllbGQucHJvdG90eXBlLl9wcm9jZXNzQ2xhc3NPcHRpb25zID0gZnVuY3Rpb24gX3Byb2Nlc3NDbGFzc09wdGlvbnMoKSB7XG4gICAgICAgIHZhciBtZSA9IHRoaXM7XG4gICAgICAgIHZhciBjbGFzc09wdGlvbnMgPSBtZS5wcm9wcy5jbGFzc09wdGlvbnM7XG5cbiAgICAgICAgcmV0dXJuIGNsYXNzT3B0aW9ucy5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICAgICAgIE9wdGlvbixcbiAgICAgICAgICAgICAgICB7IGtleTogaXRlbS52YWx1ZSwgdGl0bGU6IGl0ZW0udGV4dCB9LFxuICAgICAgICAgICAgICAgIGl0ZW0udGV4dFxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIFNlYXJjaEZvcm1GaWVsZC5wcm90b3R5cGUuaGFuZGxlQ2hhbmdlID0gZnVuY3Rpb24gaGFuZGxlQ2hhbmdlKHZhbHVlLCBsYWJlbCkge1xuICAgICAgICB2YXIgbWUgPSB0aGlzO1xuICAgICAgICB2YXIgc3RhdGVWYWx1ZSA9IGRlZXBjb3B5KG1lLnN0YXRlLnZhbHVlKSB8fCB7fTtcbiAgICAgICAgc3RhdGVWYWx1ZS5tYWluID0gdmFsdWU7XG4gICAgICAgIG1lLmhhbmRsZURhdGFDaGFuZ2Uoc3RhdGVWYWx1ZSwgZmFsc2UsIGxhYmVsKTtcbiAgICB9O1xuXG4gICAgU2VhcmNoRm9ybUZpZWxkLnByb3RvdHlwZS5oYW5kbGVDbGFzc0NoYW5nZSA9IGZ1bmN0aW9uIGhhbmRsZUNsYXNzQ2hhbmdlKHZhbHVlKSB7XG4gICAgICAgIHZhciBtZSA9IHRoaXM7XG4gICAgICAgIHZhciBzdGF0ZVZhbHVlID0gZGVlcGNvcHkobWUuc3RhdGUudmFsdWUpIHx8IHt9O1xuICAgICAgICB2YXIgbGFiZWwgPSBtZS5zdGF0ZS5sYWJlbDtcbiAgICAgICAgc3RhdGVWYWx1ZVtcImNsYXNzXCJdID0gdmFsdWU7XG4gICAgICAgIG1lLmhhbmRsZURhdGFDaGFuZ2Uoc3RhdGVWYWx1ZSwgZmFsc2UsIGxhYmVsKTtcbiAgICB9O1xuXG4gICAgU2VhcmNoRm9ybUZpZWxkLnByb3RvdHlwZS5oYW5kbGVBZHZhbmNlZENoYW5nZSA9IGZ1bmN0aW9uIGhhbmRsZUFkdmFuY2VkQ2hhbmdlKHZhbHVlKSB7XG4gICAgICAgIHZhciBtZSA9IHRoaXM7XG4gICAgICAgIHZhciBzdGF0ZVZhbHVlID0gZGVlcGNvcHkobWUuc3RhdGUudmFsdWUpIHx8IHt9O1xuICAgICAgICB2YXIgbGFiZWwgPSBtZS5zdGF0ZS5sYWJlbDtcbiAgICAgICAgc3RhdGVWYWx1ZS5hZHZhbmNlZCA9IHZhbHVlO1xuICAgICAgICBtZS5oYW5kbGVEYXRhQ2hhbmdlKHN0YXRlVmFsdWUsIGZhbHNlLCBsYWJlbCk7XG4gICAgfTtcblxuICAgIFNlYXJjaEZvcm1GaWVsZC5wcm90b3R5cGUuaGFuZGxlSWNvbkNsaWNrID0gZnVuY3Rpb24gaGFuZGxlSWNvbkNsaWNrKGUpIHtcbiAgICAgICAgdmFyIG1lID0gdGhpcztcbiAgICAgICAgbWUucHJvcHMub25JY29uQ2xpY2soZSk7XG4gICAgfTtcblxuICAgIFNlYXJjaEZvcm1GaWVsZC5wcm90b3R5cGUucmVuZGVyRmllbGQgPSBmdW5jdGlvbiByZW5kZXJGaWVsZCgpIHtcbiAgICAgICAgdmFyIF9vcHRpb25zO1xuXG4gICAgICAgIHZhciBtZSA9IHRoaXM7XG4gICAgICAgIHZhciBhcnIgPSBbXTtcbiAgICAgICAgdmFyIG1vZGUgPSBtZS5wcm9wcy5qc3htb2RlIHx8IG1lLnByb3BzLm1vZGU7XG4gICAgICAgIHZhciBoYXNDbGFzcyA9IG1lLnByb3BzLmNsYXNzT3B0aW9ucyBpbnN0YW5jZW9mIEFycmF5ICYmIG1lLnByb3BzLmNsYXNzT3B0aW9ucy5sZW5ndGggPiAwO1xuICAgICAgICB2YXIgaGFzQWR2YW5jZSA9IG1lLnByb3BzLmFkdmFuY2VkT3B0aW9ucyBpbnN0YW5jZW9mIEFycmF5ICYmIG1lLnByb3BzLmFkdmFuY2VkT3B0aW9ucy5sZW5ndGggPiAwO1xuXG4gICAgICAgIHZhciBvcHRpb25zID0gKF9vcHRpb25zID0ge1xuICAgICAgICAgICAgcmVmOiBcImVsXCIsXG4gICAgICAgICAgICBrZXk6IFwic2VsZWN0XCIsXG4gICAgICAgICAgICBjbGFzc05hbWU6IGNsYXNzbmFtZXMoe1xuICAgICAgICAgICAgICAgICdoYXMtY2xhc3MnOiBoYXNDbGFzcyxcbiAgICAgICAgICAgICAgICAnaGFzLWFkdmFuY2UnOiBoYXNBZHZhbmNlLFxuICAgICAgICAgICAgICAgICdrdW1hLXV4Zm9ybS1tYWluLXNlYXJjaCc6IHRydWVcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgb3B0aW9uRmlsdGVyUHJvcDogbWUucHJvcHMub3B0aW9uRmlsdGVyUHJvcCxcbiAgICAgICAgICAgIGNvbWJvYm94OiBtZS5wcm9wcy5jb21ib2JveCxcbiAgICAgICAgICAgIG9uQ2hhbmdlOiBtZS5oYW5kbGVDaGFuZ2UuYmluZChtZSksXG4gICAgICAgICAgICBvblNlYXJjaDogbWUuaGFuZGxlU2VhcmNoLmJpbmQobWUpXG4gICAgICAgIH0sIF9vcHRpb25zWydrZXknXSA9ICdzZWFyY2gnLCBfb3B0aW9ucyk7XG5cbiAgICAgICAgc2VsZWN0T3B0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtLCBpbmRleCkge1xuICAgICAgICAgICAgaWYgKGl0ZW0gaW4gbWUucHJvcHMpIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zW2l0ZW1dID0gbWUucHJvcHNbaXRlbV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChPYmplY3Qua2V5cyhtZS5wcm9wcy5qc3hkYXRhKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBvcHRpb25zLm9wdGlvbkZpbHRlclByb3AgPSAndGl0bGUnO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gb25seSBqc3hmZXRjaFVybCBtb2RlIG5lZWQgcGFzcyBsYWJlbCwgZm9yIHRoZSBvcHRpb25zIGFsd2F5cyBjaGFuZ2UuXG4gICAgICAgIC8vIHdoZW4gbW91bnRlZCwgc3RhdGUubGFiZWwgaXMgdW5kZWZpbmVkLCB3aGljaCBjYXVzZSBkZWZhbHV0VmFsdWUgY2Fubm90IGJlIHVzZWQuXG4gICAgICAgIGlmICghIW1lLnByb3BzLmpzeGZldGNoVXJsICYmICEhbWUuc3RhdGUubGFiZWwgJiYgbWUuc3RhdGUubGFiZWwubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICBvcHRpb25zLmxhYmVsID0gbWUuc3RhdGUubGFiZWwgfHwgW107XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIW1lLnByb3BzLmNvbWJvYm94IHx8IG1lLnN0YXRlLmZyb21SZXNldCkge1xuICAgICAgICAgICAgb3B0aW9ucy52YWx1ZSA9IG1lLnN0YXRlLnZhbHVlLm1haW4gfHwgW107XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoISFtZS5wcm9wcy5qc3hmZXRjaFVybCkge1xuICAgICAgICAgICAgb3B0aW9ucy5maWx0ZXJPcHRpb24gPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIW1lLnByb3BzLnRpZHkgJiYgaGFzQ2xhc3MpIHtcbiAgICAgICAgICAgIGFyci5wdXNoKG1lLnJlbmRlckNsYXNzT3B0aW9ucygpKTtcbiAgICAgICAgfVxuICAgICAgICBhcnIucHVzaChSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICAgU2VsZWN0LFxuICAgICAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgICAgIG1lLl9nZW5lcmF0ZU9wdGlvbnNGcm9tRGF0YSgpXG4gICAgICAgICkpO1xuXG4gICAgICAgIGlmICghbWUucHJvcHMudGlkeSAmJiBoYXNBZHZhbmNlKSB7XG4gICAgICAgICAgICBhcnIucHVzaChtZS5yZW5kZXJBZHZhbmNlZE9wdGlvbnMoKSk7XG4gICAgICAgIH1cbiAgICAgICAgYXJyLnB1c2goUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAgICdzcGFuJyxcbiAgICAgICAgICAgIHsgY2xhc3NOYW1lOiBjbGFzc25hbWVzKHtcbiAgICAgICAgICAgICAgICAgICAgXCJrdW1hLXNlYXJjaC11eGZvcm0tZmllbGQtaWNvblwiOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBcInRpZHktcGF0dGVyblwiOiBtZS5wcm9wcy50aWR5XG4gICAgICAgICAgICAgICAgfSksIGtleTogJ2ljb24nLCBvbkNsaWNrOiBtZS5oYW5kbGVJY29uQ2xpY2suYmluZChtZSkgfSxcbiAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoJ2knLCB7IGNsYXNzTmFtZTogJ2t1bWEtaWNvbiBrdW1hLWljb24tc2VhcmNoJyB9KVxuICAgICAgICApKTtcbiAgICAgICAgcmV0dXJuIGFycjtcbiAgICB9O1xuXG4gICAgU2VhcmNoRm9ybUZpZWxkLnByb3RvdHlwZS5yZW5kZXJDbGFzc09wdGlvbnMgPSBmdW5jdGlvbiByZW5kZXJDbGFzc09wdGlvbnMoKSB7XG4gICAgICAgIHZhciBfY2xhc3NuYW1lcywgX2NsYXNzbmFtZXMyO1xuXG4gICAgICAgIHZhciBtZSA9IHRoaXM7XG4gICAgICAgIHZhciBfbWUkcHJvcHMkY2xhc3NDb25maWcgPSBtZS5wcm9wcy5jbGFzc0NvbmZpZztcbiAgICAgICAgdmFyIGNsYXNzTmFtZSA9IF9tZSRwcm9wcyRjbGFzc0NvbmZpZy5jbGFzc05hbWU7XG4gICAgICAgIHZhciBkcm9wZG93bkNsYXNzTmFtZSA9IF9tZSRwcm9wcyRjbGFzc0NvbmZpZy5kcm9wZG93bkNsYXNzTmFtZTtcbiAgICAgICAgdmFyIG9uQ2hhbmdlID0gX21lJHByb3BzJGNsYXNzQ29uZmlnLm9uQ2hhbmdlO1xuXG4gICAgICAgIHZhciBvdGhlck9wdGlvbnMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX21lJHByb3BzJGNsYXNzQ29uZmlnLCBbJ2NsYXNzTmFtZScsICdkcm9wZG93bkNsYXNzTmFtZScsICdvbkNoYW5nZSddKTtcblxuICAgICAgICB2YXIgb3B0aW9ucyA9IGFzc2lnbih7fSwge1xuICAgICAgICAgICAgc2hvd1NlYXJjaDogZmFsc2UsXG4gICAgICAgICAgICBrZXk6ICdjbGFzcycsXG4gICAgICAgICAgICBkcm9wZG93bkFsaWduOiB7XG4gICAgICAgICAgICAgICAgb2Zmc2V0OiBbMCwgMF1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkcm9wZG93bkNsYXNzTmFtZTogY2xhc3NuYW1lcygoX2NsYXNzbmFtZXMgPSB7XG4gICAgICAgICAgICAgICAgXCJrdW1hLXV4Zm9ybS1jbGFzcy1kcm9wZG93blwiOiB0cnVlXG4gICAgICAgICAgICB9LCBfY2xhc3NuYW1lc1tkcm9wZG93bkNsYXNzTmFtZV0gPSAhIWRyb3Bkb3duQ2xhc3NOYW1lLCBfY2xhc3NuYW1lcykpLFxuICAgICAgICAgICAgY2xhc3NOYW1lOiBjbGFzc25hbWVzKChfY2xhc3NuYW1lczIgPSB7XG4gICAgICAgICAgICAgICAgXCJrdW1hLXV4Zm9ybS1jbGFzcy1zZWFyY2hcIjogdHJ1ZVxuICAgICAgICAgICAgfSwgX2NsYXNzbmFtZXMyW2NsYXNzTmFtZV0gPSAhIWNsYXNzTmFtZSwgX2NsYXNzbmFtZXMyKSksXG4gICAgICAgICAgICBvbkNoYW5nZTogbWUuaGFuZGxlQ2xhc3NDaGFuZ2UuYmluZChtZSlcbiAgICAgICAgfSwgb3RoZXJPcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgICBTZWxlY3QsXG4gICAgICAgICAgICBvcHRpb25zLFxuICAgICAgICAgICAgbWUuX3Byb2Nlc3NDbGFzc09wdGlvbnMoKVxuICAgICAgICApO1xuICAgIH07XG5cbiAgICBTZWFyY2hGb3JtRmllbGQucHJvdG90eXBlLnJlbmRlckFkdmFuY2VkT3B0aW9ucyA9IGZ1bmN0aW9uIHJlbmRlckFkdmFuY2VkT3B0aW9ucygpIHtcbiAgICAgICAgdmFyIF9jbGFzc25hbWVzMywgX2NsYXNzbmFtZXM0O1xuXG4gICAgICAgIHZhciBtZSA9IHRoaXM7XG4gICAgICAgIHZhciBfbWUkcHJvcHMkYWR2YW5jZWRDb24gPSBtZS5wcm9wcy5hZHZhbmNlZENvbmZpZztcbiAgICAgICAgdmFyIGNsYXNzTmFtZSA9IF9tZSRwcm9wcyRhZHZhbmNlZENvbi5jbGFzc05hbWU7XG4gICAgICAgIHZhciBkcm9wZG93bkNsYXNzTmFtZSA9IF9tZSRwcm9wcyRhZHZhbmNlZENvbi5kcm9wZG93bkNsYXNzTmFtZTtcbiAgICAgICAgdmFyIG9uQ2hhbmdlID0gX21lJHByb3BzJGFkdmFuY2VkQ29uLm9uQ2hhbmdlO1xuXG4gICAgICAgIHZhciBvdGhlck9wdGlvbnMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX21lJHByb3BzJGFkdmFuY2VkQ29uLCBbJ2NsYXNzTmFtZScsICdkcm9wZG93bkNsYXNzTmFtZScsICdvbkNoYW5nZSddKTtcblxuICAgICAgICB2YXIgb3B0aW9ucyA9IGFzc2lnbih7fSwge1xuICAgICAgICAgICAgc2hvd1NlYXJjaDogZmFsc2UsXG4gICAgICAgICAgICBrZXk6ICdhZHZhbmNlZCcsXG4gICAgICAgICAgICBjbGFzc05hbWU6IGNsYXNzbmFtZXMoKF9jbGFzc25hbWVzMyA9IHtcbiAgICAgICAgICAgICAgICAna3VtYS11eGZvcm0tYWR2YW5jZWQtc2VhcmNoJzogdHJ1ZVxuICAgICAgICAgICAgfSwgX2NsYXNzbmFtZXMzW2NsYXNzTmFtZV0gPSAhIWNsYXNzTmFtZSwgX2NsYXNzbmFtZXMzKSksXG4gICAgICAgICAgICBkcm9wZG93bkNsYXNzTmFtZTogY2xhc3NuYW1lcygoX2NsYXNzbmFtZXM0ID0ge1xuICAgICAgICAgICAgICAgIFwia3VtYS11eGZvcm0tYWR2YW5jZWQtZHJvcGRvd25cIjogdHJ1ZVxuICAgICAgICAgICAgfSwgX2NsYXNzbmFtZXM0W2Ryb3Bkb3duQ2xhc3NOYW1lXSA9ICEhZHJvcGRvd25DbGFzc05hbWUsIF9jbGFzc25hbWVzNCkpLFxuICAgICAgICAgICAgZHJvcGRvd25BbGlnbjoge1xuICAgICAgICAgICAgICAgIG9mZnNldDogWzAsIDBdXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb25DaGFuZ2U6IG1lLmhhbmRsZUFkdmFuY2VkQ2hhbmdlLmJpbmQobWUpXG4gICAgICAgIH0sIG90aGVyT3B0aW9ucyk7XG4gICAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICAgU2VsZWN0LFxuICAgICAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgICAgIG1lLl9wcm9jZXNzQWR2YW5jZWQoKVxuICAgICAgICApO1xuICAgIH07XG5cbiAgICByZXR1cm4gU2VhcmNoRm9ybUZpZWxkO1xufShTZWxlY3RGb3JtRmllbGQpO1xuXG5TZWFyY2hGb3JtRmllbGQuT3B0aW9uID0gT3B0aW9uO1xuU2VhcmNoRm9ybUZpZWxkLmRpc3BsYXlOYW1lID0gXCJTZWFyY2hGb3JtRmllbGRcIjtcblNlYXJjaEZvcm1GaWVsZC5wcm9wVHlwZXMgPSBhc3NpZ24oe30sIFNlbGVjdEZvcm1GaWVsZC5wcm9wVHlwZXMsIHtcbiAgICBhZHZhbmNlZE9wdGlvbnM6IFJlYWN0LlByb3BUeXBlcy5hcnJheSxcbiAgICBhZHZhbmNlZENvbmZpZzogUmVhY3QuUHJvcFR5cGVzLm9iamVjdCxcbiAgICBjbGFzc09wdGlvbnM6IFJlYWN0LlByb3BUeXBlcy5hcnJheSxcbiAgICBjbGFzc0NvbmZpZzogUmVhY3QuUHJvcFR5cGVzLm9iamVjdCxcbiAgICB0aWR5OiBSZWFjdC5Qcm9wVHlwZXMuYm9vbCxcbiAgICBvbkljb25DbGljazogUmVhY3QuUHJvcFR5cGVzLmZ1bmNcbn0pO1xuU2VhcmNoRm9ybUZpZWxkLmRlZmF1bHRQcm9wcyA9IGFzc2lnbih7fSwgU2VsZWN0Rm9ybUZpZWxkLmRlZmF1bHRQcm9wcywge1xuICAgIGpzeHNob3dMYWJlbDogZmFsc2UsXG4gICAgY29tYm9ib3g6IHRydWUsXG4gICAgYWR2YW5jZWRDb25maWc6IHt9LFxuICAgIGNsYXNzQ29uZmlnOiB7fSxcbiAgICB0aWR5OiBmYWxzZSxcbiAgICBvbkljb25DbGljazogZnVuY3Rpb24gb25JY29uQ2xpY2soKSB7fVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gU2VhcmNoRm9ybUZpZWxkO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3V4Y29yZS1mb3JtL2J1aWxkL0Zvcm1GaWVsZC9TZWFyY2hGb3JtRmllbGQuanNcbiAqKiBtb2R1bGUgaWQgPSA1NDFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBDb25zdCBDb21wb25lbnQgZm9yIHV4Y29yZVxuICogQGF1dGhvciB6aG91cXVhbi55ZXpxXG4gKlxuICogQ29weXJpZ2h0IDIwMTQtMjAxNSwgVXhjb3JlIFRlYW0sIEFsaW53LlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vQ29uc3QnKTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi91eGNvcmUtdGFibGUvfi91eGNvcmUtY29uc3QvYnVpbGQvaW5kZXguanNcbiAqKiBtb2R1bGUgaWQgPSA1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBndWlkOiByZXF1aXJlKCcuL2d1aWQnKSxcbiAgY2xhc3NTZXQ6IHJlcXVpcmUoJy4vY2xhc3NTZXQnKSxcbiAgam9pbkNsYXNzZXM6IHJlcXVpcmUoJy4vam9pbkNsYXNzZXMnKSxcbiAgS2V5Q29kZTogcmVxdWlyZSgnLi9LZXlDb2RlJyksXG4gIFB1cmVSZW5kZXJNaXhpbjogcmVxdWlyZSgnLi9QdXJlUmVuZGVyTWl4aW4nKSxcbiAgc2hhbGxvd0VxdWFsOiByZXF1aXJlKCdzaGFsbG93ZXF1YWwnKSxcbiAgY3JlYXRlQ2hhaW5lZEZ1bmN0aW9uOiByZXF1aXJlKCcuL2NyZWF0ZUNoYWluZWRGdW5jdGlvbicpLFxuICBEb206IHtcbiAgICBhZGRFdmVudExpc3RlbmVyOiByZXF1aXJlKCcuL0RvbS9hZGRFdmVudExpc3RlbmVyJyksXG4gICAgY29udGFpbnM6IHJlcXVpcmUoJy4vRG9tL2NvbnRhaW5zJylcbiAgfSxcbiAgQ2hpbGRyZW46IHtcbiAgICB0b0FycmF5OiByZXF1aXJlKCcuL0NoaWxkcmVuL3RvQXJyYXknKSxcbiAgICBtYXBTZWxmOiByZXF1aXJlKCcuL0NoaWxkcmVuL21hcFNlbGYnKVxuICB9XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3V4Y29yZS10YWJsZS9+L3V4Y29yZS1tZW51L34vcmMtbWVudS9+L3JjLXV0aWwvbGliL2luZGV4LmpzXG4gKiogbW9kdWxlIGlkID0gMTVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxudmFyIGRlcHJlY2F0ZSA9IHJlcXVpcmUoJ3V0aWwtZGVwcmVjYXRlJyk7XG52YXIgY2xhc3NOYW1lcyA9IHJlcXVpcmUoJ2NsYXNzbmFtZXMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBkZXByZWNhdGUoY2xhc3NOYW1lcywgJ2ByY1V0aWwuY2xhc3NTZXQoKWAgaXMgZGVwcmVjYXRlZCwgdXNlIGBjbGFzc05hbWVzKClgIGJ5IGByZXF1aXJlKFxcJ2NsYXNzbmFtZXNcXCcpYCBpbnN0ZWFkJyk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vdXhjb3JlLXRhYmxlL34vdXhjb3JlLW1lbnUvfi9yYy1tZW51L34vcmMtdXRpbC9saWIvY2xhc3NTZXQuanNcbiAqKiBtb2R1bGUgaWQgPSAxN1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZGVwcmVjYXRlID0gcmVxdWlyZSgndXRpbC1kZXByZWNhdGUnKTtcbnZhciBjbGFzc05hbWVzID0gcmVxdWlyZSgnY2xhc3NuYW1lcycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGRlcHJlY2F0ZShjbGFzc05hbWVzLCAnYHJjVXRpbC5qb2luQ2xhc3NlcygpYCBpcyBkZXByZWNhdGVkLCB1c2UgYGNsYXNzTmFtZXMoKWAgYnkgYHJlcXVpcmUoXFwnY2xhc3NuYW1lc1xcJylgIGluc3RlYWQnKTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi91eGNvcmUtdGFibGUvfi91eGNvcmUtbWVudS9+L3JjLW1lbnUvfi9yYy11dGlsL2xpYi9qb2luQ2xhc3Nlcy5qc1xuICoqIG1vZHVsZSBpZCA9IDIwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbnZhciBzaGFsbG93RXF1YWwgPSByZXF1aXJlKCdzaGFsbG93ZXF1YWwnKTtcblxuLyoqXG4gKiBJZiB5b3VyIFJlYWN0IGNvbXBvbmVudCdzIHJlbmRlciBmdW5jdGlvbiBpcyBcInB1cmVcIiwgZS5nLiBpdCB3aWxsIHJlbmRlciB0aGVcbiAqIHNhbWUgcmVzdWx0IGdpdmVuIHRoZSBzYW1lIHByb3BzIGFuZCBzdGF0ZSwgcHJvdmlkZSB0aGlzIE1peGluIGZvciBhXG4gKiBjb25zaWRlcmFibGUgcGVyZm9ybWFuY2UgYm9vc3QuXG4gKlxuICogTW9zdCBSZWFjdCBjb21wb25lbnRzIGhhdmUgcHVyZSByZW5kZXIgZnVuY3Rpb25zLlxuICpcbiAqIEV4YW1wbGU6XG4gKlxuICogICBjb25zdCBSZWFjdENvbXBvbmVudFdpdGhQdXJlUmVuZGVyTWl4aW4gPVxuICogICAgIHJlcXVpcmUoJ1JlYWN0Q29tcG9uZW50V2l0aFB1cmVSZW5kZXJNaXhpbicpO1xuICogICBSZWFjdC5jcmVhdGVDbGFzcyh7XG4gKiAgICAgbWl4aW5zOiBbUmVhY3RDb21wb25lbnRXaXRoUHVyZVJlbmRlck1peGluXSxcbiAqXG4gKiAgICAgcmVuZGVyOiBmdW5jdGlvbigpIHtcbiAqICAgICAgIHJldHVybiA8ZGl2IGNsYXNzTmFtZT17dGhpcy5wcm9wcy5jbGFzc05hbWV9PmZvbzwvZGl2PjtcbiAqICAgICB9XG4gKiAgIH0pO1xuICpcbiAqIE5vdGU6IFRoaXMgb25seSBjaGVja3Mgc2hhbGxvdyBlcXVhbGl0eSBmb3IgcHJvcHMgYW5kIHN0YXRlLiBJZiB0aGVzZSBjb250YWluXG4gKiBjb21wbGV4IGRhdGEgc3RydWN0dXJlcyB0aGlzIG1peGluIG1heSBoYXZlIGZhbHNlLW5lZ2F0aXZlcyBmb3IgZGVlcGVyXG4gKiBkaWZmZXJlbmNlcy4gT25seSBtaXhpbiB0byBjb21wb25lbnRzIHdoaWNoIGhhdmUgc2ltcGxlIHByb3BzIGFuZCBzdGF0ZSwgb3JcbiAqIHVzZSBgZm9yY2VVcGRhdGUoKWAgd2hlbiB5b3Uga25vdyBkZWVwIGRhdGEgc3RydWN0dXJlcyBoYXZlIGNoYW5nZWQuXG4gKi9cbnZhciBSZWFjdENvbXBvbmVudFdpdGhQdXJlUmVuZGVyTWl4aW4gPSB7XG4gIHNob3VsZENvbXBvbmVudFVwZGF0ZTogZnVuY3Rpb24gc2hvdWxkQ29tcG9uZW50VXBkYXRlKG5leHRQcm9wcywgbmV4dFN0YXRlKSB7XG4gICAgcmV0dXJuICFzaGFsbG93RXF1YWwodGhpcy5wcm9wcywgbmV4dFByb3BzKSB8fCAhc2hhbGxvd0VxdWFsKHRoaXMuc3RhdGUsIG5leHRTdGF0ZSk7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RDb21wb25lbnRXaXRoUHVyZVJlbmRlck1peGluO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3V4Y29yZS10YWJsZS9+L3V4Y29yZS1tZW51L34vcmMtbWVudS9+L3JjLXV0aWwvbGliL1B1cmVSZW5kZXJNaXhpbi5qc1xuICoqIG1vZHVsZSBpZCA9IDIyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbnZhciBmZXRjaEtleXMgPSByZXF1aXJlKCdsb2Rhc2gua2V5cycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHNoYWxsb3dFcXVhbChvYmpBLCBvYmpCLCBjb21wYXJlLCBjb21wYXJlQ29udGV4dCkge1xuXG4gICAgdmFyIHJldCA9IGNvbXBhcmUgPyBjb21wYXJlLmNhbGwoY29tcGFyZUNvbnRleHQsIG9iakEsIG9iakIpIDogdm9pZCAwO1xuXG4gICAgaWYgKHJldCAhPT0gdm9pZCAwKSB7XG4gICAgICAgIHJldHVybiAhIXJldDtcbiAgICB9XG5cbiAgICBpZiAob2JqQSA9PT0gb2JqQikge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIG9iakEgIT09ICdvYmplY3QnIHx8IG9iakEgPT09IG51bGwgfHwgdHlwZW9mIG9iakIgIT09ICdvYmplY3QnIHx8IG9iakIgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBrZXlzQSA9IGZldGNoS2V5cyhvYmpBKTtcbiAgICB2YXIga2V5c0IgPSBmZXRjaEtleXMob2JqQik7XG5cbiAgICB2YXIgbGVuID0ga2V5c0EubGVuZ3RoO1xuICAgIGlmIChsZW4gIT09IGtleXNCLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgY29tcGFyZUNvbnRleHQgPSBjb21wYXJlQ29udGV4dCB8fCBudWxsO1xuXG4gICAgLy8gVGVzdCBmb3IgQSdzIGtleXMgZGlmZmVyZW50IGZyb20gQi5cbiAgICB2YXIgYkhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5iaW5kKG9iakIpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgdmFyIGtleSA9IGtleXNBW2ldO1xuICAgICAgICBpZiAoIWJIYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHZhbHVlQSA9IG9iakFba2V5XTtcbiAgICAgICAgdmFyIHZhbHVlQiA9IG9iakJba2V5XTtcblxuICAgICAgICB2YXIgX3JldCA9IGNvbXBhcmUgPyBjb21wYXJlLmNhbGwoY29tcGFyZUNvbnRleHQsIHZhbHVlQSwgdmFsdWVCLCBrZXkpIDogdm9pZCAwO1xuICAgICAgICBpZiAoX3JldCA9PT0gZmFsc2UgfHwgX3JldCA9PT0gdm9pZCAwICYmIHZhbHVlQSAhPT0gdmFsdWVCKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vdXhjb3JlLXRhYmxlL34vdXhjb3JlLW1lbnUvfi9yYy1tZW51L34vcmMtdXRpbC9+L3NoYWxsb3dlcXVhbC9tb2R1bGVzL2luZGV4LmpzXG4gKiogbW9kdWxlIGlkID0gMjNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogbG9kYXNoIDMuMS4yIChDdXN0b20gQnVpbGQpIDxodHRwczovL2xvZGFzaC5jb20vPlxuICogQnVpbGQ6IGBsb2Rhc2ggbW9kZXJuIG1vZHVsYXJpemUgZXhwb3J0cz1cIm5wbVwiIC1vIC4vYFxuICogQ29weXJpZ2h0IDIwMTItMjAxNSBUaGUgRG9qbyBGb3VuZGF0aW9uIDxodHRwOi8vZG9qb2ZvdW5kYXRpb24ub3JnLz5cbiAqIEJhc2VkIG9uIFVuZGVyc2NvcmUuanMgMS44LjMgPGh0dHA6Ly91bmRlcnNjb3JlanMub3JnL0xJQ0VOU0U+XG4gKiBDb3B5cmlnaHQgMjAwOS0yMDE1IEplcmVteSBBc2hrZW5hcywgRG9jdW1lbnRDbG91ZCBhbmQgSW52ZXN0aWdhdGl2ZSBSZXBvcnRlcnMgJiBFZGl0b3JzXG4gKiBBdmFpbGFibGUgdW5kZXIgTUlUIGxpY2Vuc2UgPGh0dHBzOi8vbG9kYXNoLmNvbS9saWNlbnNlPlxuICovXG52YXIgZ2V0TmF0aXZlID0gcmVxdWlyZSgnbG9kYXNoLl9nZXRuYXRpdmUnKSxcbiAgICBpc0FyZ3VtZW50cyA9IHJlcXVpcmUoJ2xvZGFzaC5pc2FyZ3VtZW50cycpLFxuICAgIGlzQXJyYXkgPSByZXF1aXJlKCdsb2Rhc2guaXNhcnJheScpO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgdW5zaWduZWQgaW50ZWdlciB2YWx1ZXMuICovXG52YXIgcmVJc1VpbnQgPSAvXlxcZCskLztcblxuLyoqIFVzZWQgZm9yIG5hdGl2ZSBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qIE5hdGl2ZSBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlS2V5cyA9IGdldE5hdGl2ZShPYmplY3QsICdrZXlzJyk7XG5cbi8qKlxuICogVXNlZCBhcyB0aGUgW21heGltdW0gbGVuZ3RoXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvI3NlYy1udW1iZXIubWF4X3NhZmVfaW50ZWdlcilcbiAqIG9mIGFuIGFycmF5LWxpa2UgdmFsdWUuXG4gKi9cbnZhciBNQVhfU0FGRV9JTlRFR0VSID0gOTAwNzE5OTI1NDc0MDk5MTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5wcm9wZXJ0eWAgd2l0aG91dCBzdXBwb3J0IGZvciBkZWVwIHBhdGhzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBiYXNlUHJvcGVydHkoa2V5KSB7XG4gIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQgOiBvYmplY3Rba2V5XTtcbiAgfTtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBcImxlbmd0aFwiIHByb3BlcnR5IHZhbHVlIG9mIGBvYmplY3RgLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgdG8gYXZvaWQgYSBbSklUIGJ1Z10oaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTE0Mjc5MilcbiAqIHRoYXQgYWZmZWN0cyBTYWZhcmkgb24gYXQgbGVhc3QgaU9TIDguMS04LjMgQVJNNjQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBcImxlbmd0aFwiIHZhbHVlLlxuICovXG52YXIgZ2V0TGVuZ3RoID0gYmFzZVByb3BlcnR5KCdsZW5ndGgnKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhcnJheS1saWtlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFycmF5LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNBcnJheUxpa2UodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgaXNMZW5ndGgoZ2V0TGVuZ3RoKHZhbHVlKSk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBhcnJheS1saWtlIGluZGV4LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoPU1BWF9TQUZFX0lOVEVHRVJdIFRoZSB1cHBlciBib3VuZHMgb2YgYSB2YWxpZCBpbmRleC5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgaW5kZXgsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNJbmRleCh2YWx1ZSwgbGVuZ3RoKSB7XG4gIHZhbHVlID0gKHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJyB8fCByZUlzVWludC50ZXN0KHZhbHVlKSkgPyArdmFsdWUgOiAtMTtcbiAgbGVuZ3RoID0gbGVuZ3RoID09IG51bGwgPyBNQVhfU0FGRV9JTlRFR0VSIDogbGVuZ3RoO1xuICByZXR1cm4gdmFsdWUgPiAtMSAmJiB2YWx1ZSAlIDEgPT0gMCAmJiB2YWx1ZSA8IGxlbmd0aDtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGFycmF5LWxpa2UgbGVuZ3RoLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIGZ1bmN0aW9uIGlzIGJhc2VkIG9uIFtgVG9MZW5ndGhgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvI3NlYy10b2xlbmd0aCkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBsZW5ndGgsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNMZW5ndGgodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJyAmJiB2YWx1ZSA+IC0xICYmIHZhbHVlICUgMSA9PSAwICYmIHZhbHVlIDw9IE1BWF9TQUZFX0lOVEVHRVI7XG59XG5cbi8qKlxuICogQSBmYWxsYmFjayBpbXBsZW1lbnRhdGlvbiBvZiBgT2JqZWN0LmtleXNgIHdoaWNoIGNyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlXG4gKiBvd24gZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqL1xuZnVuY3Rpb24gc2hpbUtleXMob2JqZWN0KSB7XG4gIHZhciBwcm9wcyA9IGtleXNJbihvYmplY3QpLFxuICAgICAgcHJvcHNMZW5ndGggPSBwcm9wcy5sZW5ndGgsXG4gICAgICBsZW5ndGggPSBwcm9wc0xlbmd0aCAmJiBvYmplY3QubGVuZ3RoO1xuXG4gIHZhciBhbGxvd0luZGV4ZXMgPSAhIWxlbmd0aCAmJiBpc0xlbmd0aChsZW5ndGgpICYmXG4gICAgKGlzQXJyYXkob2JqZWN0KSB8fCBpc0FyZ3VtZW50cyhvYmplY3QpKTtcblxuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIHJlc3VsdCA9IFtdO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgcHJvcHNMZW5ndGgpIHtcbiAgICB2YXIga2V5ID0gcHJvcHNbaW5kZXhdO1xuICAgIGlmICgoYWxsb3dJbmRleGVzICYmIGlzSW5kZXgoa2V5LCBsZW5ndGgpKSB8fCBoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSkge1xuICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyB0aGUgW2xhbmd1YWdlIHR5cGVdKGh0dHBzOi8vZXM1LmdpdGh1Yi5pby8jeDgpIG9mIGBPYmplY3RgLlxuICogKGUuZy4gYXJyYXlzLCBmdW5jdGlvbnMsIG9iamVjdHMsIHJlZ2V4ZXMsIGBuZXcgTnVtYmVyKDApYCwgYW5kIGBuZXcgU3RyaW5nKCcnKWApXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzT2JqZWN0KHt9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdCgxKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG4gIC8vIEF2b2lkIGEgVjggSklUIGJ1ZyBpbiBDaHJvbWUgMTktMjAuXG4gIC8vIFNlZSBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MjI5MSBmb3IgbW9yZSBkZXRhaWxzLlxuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgcmV0dXJuICEhdmFsdWUgJiYgKHR5cGUgPT0gJ29iamVjdCcgfHwgdHlwZSA9PSAnZnVuY3Rpb24nKTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBvZiBgb2JqZWN0YC5cbiAqXG4gKiAqKk5vdGU6KiogTm9uLW9iamVjdCB2YWx1ZXMgYXJlIGNvZXJjZWQgdG8gb2JqZWN0cy4gU2VlIHRoZVxuICogW0VTIHNwZWNdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC8jc2VjLW9iamVjdC5rZXlzKVxuICogZm9yIG1vcmUgZGV0YWlscy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gRm9vKCkge1xuICogICB0aGlzLmEgPSAxO1xuICogICB0aGlzLmIgPSAyO1xuICogfVxuICpcbiAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gKlxuICogXy5rZXlzKG5ldyBGb28pO1xuICogLy8gPT4gWydhJywgJ2InXSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICpcbiAqIF8ua2V5cygnaGknKTtcbiAqIC8vID0+IFsnMCcsICcxJ11cbiAqL1xudmFyIGtleXMgPSAhbmF0aXZlS2V5cyA/IHNoaW1LZXlzIDogZnVuY3Rpb24ob2JqZWN0KSB7XG4gIHZhciBDdG9yID0gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQgOiBvYmplY3QuY29uc3RydWN0b3I7XG4gIGlmICgodHlwZW9mIEN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBDdG9yLnByb3RvdHlwZSA9PT0gb2JqZWN0KSB8fFxuICAgICAgKHR5cGVvZiBvYmplY3QgIT0gJ2Z1bmN0aW9uJyAmJiBpc0FycmF5TGlrZShvYmplY3QpKSkge1xuICAgIHJldHVybiBzaGltS2V5cyhvYmplY3QpO1xuICB9XG4gIHJldHVybiBpc09iamVjdChvYmplY3QpID8gbmF0aXZlS2V5cyhvYmplY3QpIDogW107XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBhbmQgaW5oZXJpdGVkIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgb2YgYG9iamVjdGAuXG4gKlxuICogKipOb3RlOioqIE5vbi1vYmplY3QgdmFsdWVzIGFyZSBjb2VyY2VkIHRvIG9iamVjdHMuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKiBAZXhhbXBsZVxuICpcbiAqIGZ1bmN0aW9uIEZvbygpIHtcbiAqICAgdGhpcy5hID0gMTtcbiAqICAgdGhpcy5iID0gMjtcbiAqIH1cbiAqXG4gKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICpcbiAqIF8ua2V5c0luKG5ldyBGb28pO1xuICogLy8gPT4gWydhJywgJ2InLCAnYyddIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gKi9cbmZ1bmN0aW9uIGtleXNJbihvYmplY3QpIHtcbiAgaWYgKG9iamVjdCA9PSBudWxsKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIGlmICghaXNPYmplY3Qob2JqZWN0KSkge1xuICAgIG9iamVjdCA9IE9iamVjdChvYmplY3QpO1xuICB9XG4gIHZhciBsZW5ndGggPSBvYmplY3QubGVuZ3RoO1xuICBsZW5ndGggPSAobGVuZ3RoICYmIGlzTGVuZ3RoKGxlbmd0aCkgJiZcbiAgICAoaXNBcnJheShvYmplY3QpIHx8IGlzQXJndW1lbnRzKG9iamVjdCkpICYmIGxlbmd0aCkgfHwgMDtcblxuICB2YXIgQ3RvciA9IG9iamVjdC5jb25zdHJ1Y3RvcixcbiAgICAgIGluZGV4ID0gLTEsXG4gICAgICBpc1Byb3RvID0gdHlwZW9mIEN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBDdG9yLnByb3RvdHlwZSA9PT0gb2JqZWN0LFxuICAgICAgcmVzdWx0ID0gQXJyYXkobGVuZ3RoKSxcbiAgICAgIHNraXBJbmRleGVzID0gbGVuZ3RoID4gMDtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHJlc3VsdFtpbmRleF0gPSAoaW5kZXggKyAnJyk7XG4gIH1cbiAgZm9yICh2YXIga2V5IGluIG9iamVjdCkge1xuICAgIGlmICghKHNraXBJbmRleGVzICYmIGlzSW5kZXgoa2V5LCBsZW5ndGgpKSAmJlxuICAgICAgICAhKGtleSA9PSAnY29uc3RydWN0b3InICYmIChpc1Byb3RvIHx8ICFoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSkpKSB7XG4gICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGtleXM7XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi91eGNvcmUtdGFibGUvfi91eGNvcmUtbWVudS9+L3JjLW1lbnUvfi9yYy11dGlsL34vc2hhbGxvd2VxdWFsL34vbG9kYXNoLmtleXMvaW5kZXguanNcbiAqKiBtb2R1bGUgaWQgPSAyNFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IGFkZEV2ZW50TGlzdGVuZXJXcmFwO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbnZhciBfYWRkRG9tRXZlbnRMaXN0ZW5lciA9IHJlcXVpcmUoJ2FkZC1kb20tZXZlbnQtbGlzdGVuZXInKTtcblxudmFyIF9hZGREb21FdmVudExpc3RlbmVyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2FkZERvbUV2ZW50TGlzdGVuZXIpO1xuXG52YXIgX3JlYWN0RG9tID0gcmVxdWlyZSgncmVhY3QtZG9tJyk7XG5cbnZhciBfcmVhY3REb20yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmVhY3REb20pO1xuXG5mdW5jdGlvbiBhZGRFdmVudExpc3RlbmVyV3JhcCh0YXJnZXQsIGV2ZW50VHlwZSwgY2IpIHtcbiAgLyogZXNsaW50IGNhbWVsY2FzZTogMiAqL1xuICB2YXIgY2FsbGJhY2sgPSBfcmVhY3REb20yWydkZWZhdWx0J10udW5zdGFibGVfYmF0Y2hlZFVwZGF0ZXMgPyBmdW5jdGlvbiBydW4oZSkge1xuICAgIF9yZWFjdERvbTJbJ2RlZmF1bHQnXS51bnN0YWJsZV9iYXRjaGVkVXBkYXRlcyhjYiwgZSk7XG4gIH0gOiBjYjtcbiAgcmV0dXJuICgwLCBfYWRkRG9tRXZlbnRMaXN0ZW5lcjJbJ2RlZmF1bHQnXSkodGFyZ2V0LCBldmVudFR5cGUsIGNhbGxiYWNrKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vdXhjb3JlLXRhYmxlL34vdXhjb3JlLW1lbnUvfi9yYy1tZW51L34vcmMtdXRpbC9saWIvRG9tL2FkZEV2ZW50TGlzdGVuZXIuanNcbiAqKiBtb2R1bGUgaWQgPSAyOVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IGFkZEV2ZW50TGlzdGVuZXI7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxudmFyIF9FdmVudE9iamVjdCA9IHJlcXVpcmUoJy4vRXZlbnRPYmplY3QnKTtcblxudmFyIF9FdmVudE9iamVjdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9FdmVudE9iamVjdCk7XG5cbmZ1bmN0aW9uIGFkZEV2ZW50TGlzdGVuZXIodGFyZ2V0LCBldmVudFR5cGUsIGNhbGxiYWNrKSB7XG4gIGZ1bmN0aW9uIHdyYXBDYWxsYmFjayhlKSB7XG4gICAgdmFyIG5lID0gbmV3IF9FdmVudE9iamVjdDJbJ2RlZmF1bHQnXShlKTtcbiAgICBjYWxsYmFjay5jYWxsKHRhcmdldCwgbmUpO1xuICB9XG5cbiAgaWYgKHRhcmdldC5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnRUeXBlLCB3cmFwQ2FsbGJhY2ssIGZhbHNlKTtcbiAgICByZXR1cm4ge1xuICAgICAgcmVtb3ZlOiBmdW5jdGlvbiByZW1vdmUoKSB7XG4gICAgICAgIHRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50VHlwZSwgd3JhcENhbGxiYWNrLCBmYWxzZSk7XG4gICAgICB9XG4gICAgfTtcbiAgfSBlbHNlIGlmICh0YXJnZXQuYXR0YWNoRXZlbnQpIHtcbiAgICB0YXJnZXQuYXR0YWNoRXZlbnQoJ29uJyArIGV2ZW50VHlwZSwgd3JhcENhbGxiYWNrKTtcbiAgICByZXR1cm4ge1xuICAgICAgcmVtb3ZlOiBmdW5jdGlvbiByZW1vdmUoKSB7XG4gICAgICAgIHRhcmdldC5kZXRhY2hFdmVudCgnb24nICsgZXZlbnRUeXBlLCB3cmFwQ2FsbGJhY2spO1xuICAgICAgfVxuICAgIH07XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vdXhjb3JlLXRhYmxlL34vdXhjb3JlLW1lbnUvfi9yYy1tZW51L34vcmMtdXRpbC9+L2FkZC1kb20tZXZlbnQtbGlzdGVuZXIvbGliL2luZGV4LmpzXG4gKiogbW9kdWxlIGlkID0gMzBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQGlnbm9yZVxuICogZXZlbnQgb2JqZWN0IGZvciBkb21cbiAqIEBhdXRob3IgeWltaW5naGVAZ21haWwuY29tXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG52YXIgX0V2ZW50QmFzZU9iamVjdCA9IHJlcXVpcmUoJy4vRXZlbnRCYXNlT2JqZWN0Jyk7XG5cbnZhciBfRXZlbnRCYXNlT2JqZWN0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0V2ZW50QmFzZU9iamVjdCk7XG5cbnZhciBfb2JqZWN0QXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xuXG52YXIgX29iamVjdEFzc2lnbjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9vYmplY3RBc3NpZ24pO1xuXG52YXIgVFJVRSA9IHRydWU7XG52YXIgRkFMU0UgPSBmYWxzZTtcbnZhciBjb21tb25Qcm9wcyA9IFsnYWx0S2V5JywgJ2J1YmJsZXMnLCAnY2FuY2VsYWJsZScsICdjdHJsS2V5JywgJ2N1cnJlbnRUYXJnZXQnLCAnZXZlbnRQaGFzZScsICdtZXRhS2V5JywgJ3NoaWZ0S2V5JywgJ3RhcmdldCcsICd0aW1lU3RhbXAnLCAndmlldycsICd0eXBlJ107XG5cbmZ1bmN0aW9uIGlzTnVsbE9yVW5kZWZpbmVkKHcpIHtcbiAgcmV0dXJuIHcgPT09IG51bGwgfHwgdyA9PT0gdW5kZWZpbmVkO1xufVxuXG52YXIgZXZlbnROb3JtYWxpemVycyA9IFt7XG4gIHJlZzogL15rZXkvLFxuICBwcm9wczogWydjaGFyJywgJ2NoYXJDb2RlJywgJ2tleScsICdrZXlDb2RlJywgJ3doaWNoJ10sXG4gIGZpeDogZnVuY3Rpb24gZml4KGV2ZW50LCBuYXRpdmVFdmVudCkge1xuICAgIGlmIChpc051bGxPclVuZGVmaW5lZChldmVudC53aGljaCkpIHtcbiAgICAgIGV2ZW50LndoaWNoID0gIWlzTnVsbE9yVW5kZWZpbmVkKG5hdGl2ZUV2ZW50LmNoYXJDb2RlKSA/IG5hdGl2ZUV2ZW50LmNoYXJDb2RlIDogbmF0aXZlRXZlbnQua2V5Q29kZTtcbiAgICB9XG5cbiAgICAvLyBhZGQgbWV0YUtleSB0byBub24tTWFjIGJyb3dzZXJzICh1c2UgY3RybCBmb3IgUEMgJ3MgYW5kIE1ldGEgZm9yIE1hY3MpXG4gICAgaWYgKGV2ZW50Lm1ldGFLZXkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgZXZlbnQubWV0YUtleSA9IGV2ZW50LmN0cmxLZXk7XG4gICAgfVxuICB9XG59LCB7XG4gIHJlZzogL150b3VjaC8sXG4gIHByb3BzOiBbJ3RvdWNoZXMnLCAnY2hhbmdlZFRvdWNoZXMnLCAndGFyZ2V0VG91Y2hlcyddXG59LCB7XG4gIHJlZzogL15oYXNoY2hhbmdlJC8sXG4gIHByb3BzOiBbJ25ld1VSTCcsICdvbGRVUkwnXVxufSwge1xuICByZWc6IC9eZ2VzdHVyZWNoYW5nZSQvaSxcbiAgcHJvcHM6IFsncm90YXRpb24nLCAnc2NhbGUnXVxufSwge1xuICByZWc6IC9eKG1vdXNld2hlZWx8RE9NTW91c2VTY3JvbGwpJC8sXG4gIHByb3BzOiBbXSxcbiAgZml4OiBmdW5jdGlvbiBmaXgoZXZlbnQsIG5hdGl2ZUV2ZW50KSB7XG4gICAgdmFyIGRlbHRhWCA9IHVuZGVmaW5lZDtcbiAgICB2YXIgZGVsdGFZID0gdW5kZWZpbmVkO1xuICAgIHZhciBkZWx0YSA9IHVuZGVmaW5lZDtcbiAgICB2YXIgd2hlZWxEZWx0YSA9IG5hdGl2ZUV2ZW50LndoZWVsRGVsdGE7XG4gICAgdmFyIGF4aXMgPSBuYXRpdmVFdmVudC5heGlzO1xuICAgIHZhciB3aGVlbERlbHRhWSA9IG5hdGl2ZUV2ZW50LndoZWVsRGVsdGFZO1xuICAgIHZhciB3aGVlbERlbHRhWCA9IG5hdGl2ZUV2ZW50LndoZWVsRGVsdGFYO1xuICAgIHZhciBkZXRhaWwgPSBuYXRpdmVFdmVudC5kZXRhaWw7XG5cbiAgICAvLyBpZS93ZWJraXRcbiAgICBpZiAod2hlZWxEZWx0YSkge1xuICAgICAgZGVsdGEgPSB3aGVlbERlbHRhIC8gMTIwO1xuICAgIH1cblxuICAgIC8vIGdlY2tvXG4gICAgaWYgKGRldGFpbCkge1xuICAgICAgLy8gcHJlc3MgY29udHJvbCBlLmRldGFpbCA9PSAxIGVsc2UgZS5kZXRhaWwgPT0gM1xuICAgICAgZGVsdGEgPSAwIC0gKGRldGFpbCAlIDMgPT09IDAgPyBkZXRhaWwgLyAzIDogZGV0YWlsKTtcbiAgICB9XG5cbiAgICAvLyBHZWNrb1xuICAgIGlmIChheGlzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmIChheGlzID09PSBldmVudC5IT1JJWk9OVEFMX0FYSVMpIHtcbiAgICAgICAgZGVsdGFZID0gMDtcbiAgICAgICAgZGVsdGFYID0gMCAtIGRlbHRhO1xuICAgICAgfSBlbHNlIGlmIChheGlzID09PSBldmVudC5WRVJUSUNBTF9BWElTKSB7XG4gICAgICAgIGRlbHRhWCA9IDA7XG4gICAgICAgIGRlbHRhWSA9IGRlbHRhO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFdlYmtpdFxuICAgIGlmICh3aGVlbERlbHRhWSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBkZWx0YVkgPSB3aGVlbERlbHRhWSAvIDEyMDtcbiAgICB9XG4gICAgaWYgKHdoZWVsRGVsdGFYICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGRlbHRhWCA9IC0xICogd2hlZWxEZWx0YVggLyAxMjA7XG4gICAgfVxuXG4gICAgLy8g6buY6K6kIGRlbHRhWSAoaWUpXG4gICAgaWYgKCFkZWx0YVggJiYgIWRlbHRhWSkge1xuICAgICAgZGVsdGFZID0gZGVsdGE7XG4gICAgfVxuXG4gICAgaWYgKGRlbHRhWCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAvKipcbiAgICAgICAqIGRlbHRhWCBvZiBtb3VzZXdoZWVsIGV2ZW50XG4gICAgICAgKiBAcHJvcGVydHkgZGVsdGFYXG4gICAgICAgKiBAbWVtYmVyIEV2ZW50LkRvbUV2ZW50Lk9iamVjdFxuICAgICAgICovXG4gICAgICBldmVudC5kZWx0YVggPSBkZWx0YVg7XG4gICAgfVxuXG4gICAgaWYgKGRlbHRhWSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAvKipcbiAgICAgICAqIGRlbHRhWSBvZiBtb3VzZXdoZWVsIGV2ZW50XG4gICAgICAgKiBAcHJvcGVydHkgZGVsdGFZXG4gICAgICAgKiBAbWVtYmVyIEV2ZW50LkRvbUV2ZW50Lk9iamVjdFxuICAgICAgICovXG4gICAgICBldmVudC5kZWx0YVkgPSBkZWx0YVk7XG4gICAgfVxuXG4gICAgaWYgKGRlbHRhICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIC8qKlxuICAgICAgICogZGVsdGEgb2YgbW91c2V3aGVlbCBldmVudFxuICAgICAgICogQHByb3BlcnR5IGRlbHRhXG4gICAgICAgKiBAbWVtYmVyIEV2ZW50LkRvbUV2ZW50Lk9iamVjdFxuICAgICAgICovXG4gICAgICBldmVudC5kZWx0YSA9IGRlbHRhO1xuICAgIH1cbiAgfVxufSwge1xuICByZWc6IC9ebW91c2V8Y29udGV4dG1lbnV8Y2xpY2t8bXNwb2ludGVyfCheRE9NTW91c2VTY3JvbGwkKS9pLFxuICBwcm9wczogWydidXR0b25zJywgJ2NsaWVudFgnLCAnY2xpZW50WScsICdidXR0b24nLCAnb2Zmc2V0WCcsICdyZWxhdGVkVGFyZ2V0JywgJ3doaWNoJywgJ2Zyb21FbGVtZW50JywgJ3RvRWxlbWVudCcsICdvZmZzZXRZJywgJ3BhZ2VYJywgJ3BhZ2VZJywgJ3NjcmVlblgnLCAnc2NyZWVuWSddLFxuICBmaXg6IGZ1bmN0aW9uIGZpeChldmVudCwgbmF0aXZlRXZlbnQpIHtcbiAgICB2YXIgZXZlbnREb2MgPSB1bmRlZmluZWQ7XG4gICAgdmFyIGRvYyA9IHVuZGVmaW5lZDtcbiAgICB2YXIgYm9keSA9IHVuZGVmaW5lZDtcbiAgICB2YXIgdGFyZ2V0ID0gZXZlbnQudGFyZ2V0O1xuICAgIHZhciBidXR0b24gPSBuYXRpdmVFdmVudC5idXR0b247XG5cbiAgICAvLyBDYWxjdWxhdGUgcGFnZVgvWSBpZiBtaXNzaW5nIGFuZCBjbGllbnRYL1kgYXZhaWxhYmxlXG4gICAgaWYgKHRhcmdldCAmJiBpc051bGxPclVuZGVmaW5lZChldmVudC5wYWdlWCkgJiYgIWlzTnVsbE9yVW5kZWZpbmVkKG5hdGl2ZUV2ZW50LmNsaWVudFgpKSB7XG4gICAgICBldmVudERvYyA9IHRhcmdldC5vd25lckRvY3VtZW50IHx8IGRvY3VtZW50O1xuICAgICAgZG9jID0gZXZlbnREb2MuZG9jdW1lbnRFbGVtZW50O1xuICAgICAgYm9keSA9IGV2ZW50RG9jLmJvZHk7XG4gICAgICBldmVudC5wYWdlWCA9IG5hdGl2ZUV2ZW50LmNsaWVudFggKyAoZG9jICYmIGRvYy5zY3JvbGxMZWZ0IHx8IGJvZHkgJiYgYm9keS5zY3JvbGxMZWZ0IHx8IDApIC0gKGRvYyAmJiBkb2MuY2xpZW50TGVmdCB8fCBib2R5ICYmIGJvZHkuY2xpZW50TGVmdCB8fCAwKTtcbiAgICAgIGV2ZW50LnBhZ2VZID0gbmF0aXZlRXZlbnQuY2xpZW50WSArIChkb2MgJiYgZG9jLnNjcm9sbFRvcCB8fCBib2R5ICYmIGJvZHkuc2Nyb2xsVG9wIHx8IDApIC0gKGRvYyAmJiBkb2MuY2xpZW50VG9wIHx8IGJvZHkgJiYgYm9keS5jbGllbnRUb3AgfHwgMCk7XG4gICAgfVxuXG4gICAgLy8gd2hpY2ggZm9yIGNsaWNrOiAxID09PSBsZWZ0OyAyID09PSBtaWRkbGU7IDMgPT09IHJpZ2h0XG4gICAgLy8gZG8gbm90IHVzZSBidXR0b25cbiAgICBpZiAoIWV2ZW50LndoaWNoICYmIGJ1dHRvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAoYnV0dG9uICYgMSkge1xuICAgICAgICBldmVudC53aGljaCA9IDE7XG4gICAgICB9IGVsc2UgaWYgKGJ1dHRvbiAmIDIpIHtcbiAgICAgICAgZXZlbnQud2hpY2ggPSAzO1xuICAgICAgfSBlbHNlIGlmIChidXR0b24gJiA0KSB7XG4gICAgICAgIGV2ZW50LndoaWNoID0gMjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGV2ZW50LndoaWNoID0gMDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBhZGQgcmVsYXRlZFRhcmdldCwgaWYgbmVjZXNzYXJ5XG4gICAgaWYgKCFldmVudC5yZWxhdGVkVGFyZ2V0ICYmIGV2ZW50LmZyb21FbGVtZW50KSB7XG4gICAgICBldmVudC5yZWxhdGVkVGFyZ2V0ID0gZXZlbnQuZnJvbUVsZW1lbnQgPT09IHRhcmdldCA/IGV2ZW50LnRvRWxlbWVudCA6IGV2ZW50LmZyb21FbGVtZW50O1xuICAgIH1cblxuICAgIHJldHVybiBldmVudDtcbiAgfVxufV07XG5cbmZ1bmN0aW9uIHJldFRydWUoKSB7XG4gIHJldHVybiBUUlVFO1xufVxuXG5mdW5jdGlvbiByZXRGYWxzZSgpIHtcbiAgcmV0dXJuIEZBTFNFO1xufVxuXG5mdW5jdGlvbiBEb21FdmVudE9iamVjdChuYXRpdmVFdmVudCkge1xuICB2YXIgdHlwZSA9IG5hdGl2ZUV2ZW50LnR5cGU7XG5cbiAgdmFyIGlzTmF0aXZlID0gdHlwZW9mIG5hdGl2ZUV2ZW50LnN0b3BQcm9wYWdhdGlvbiA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgbmF0aXZlRXZlbnQuY2FuY2VsQnViYmxlID09PSAnYm9vbGVhbic7XG5cbiAgX0V2ZW50QmFzZU9iamVjdDJbJ2RlZmF1bHQnXS5jYWxsKHRoaXMpO1xuXG4gIHRoaXMubmF0aXZlRXZlbnQgPSBuYXRpdmVFdmVudDtcblxuICAvLyBpbiBjYXNlIGRvbSBldmVudCBoYXMgYmVlbiBtYXJrIGFzIGRlZmF1bHQgcHJldmVudGVkIGJ5IGxvd2VyIGRvbSBub2RlXG4gIHZhciBpc0RlZmF1bHRQcmV2ZW50ZWQgPSByZXRGYWxzZTtcbiAgaWYgKCdkZWZhdWx0UHJldmVudGVkJyBpbiBuYXRpdmVFdmVudCkge1xuICAgIGlzRGVmYXVsdFByZXZlbnRlZCA9IG5hdGl2ZUV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQgPyByZXRUcnVlIDogcmV0RmFsc2U7XG4gIH0gZWxzZSBpZiAoJ2dldFByZXZlbnREZWZhdWx0JyBpbiBuYXRpdmVFdmVudCkge1xuICAgIC8vIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTY5MTE1MVxuICAgIGlzRGVmYXVsdFByZXZlbnRlZCA9IG5hdGl2ZUV2ZW50LmdldFByZXZlbnREZWZhdWx0KCkgPyByZXRUcnVlIDogcmV0RmFsc2U7XG4gIH0gZWxzZSBpZiAoJ3JldHVyblZhbHVlJyBpbiBuYXRpdmVFdmVudCkge1xuICAgIGlzRGVmYXVsdFByZXZlbnRlZCA9IG5hdGl2ZUV2ZW50LnJldHVyblZhbHVlID09PSBGQUxTRSA/IHJldFRydWUgOiByZXRGYWxzZTtcbiAgfVxuXG4gIHRoaXMuaXNEZWZhdWx0UHJldmVudGVkID0gaXNEZWZhdWx0UHJldmVudGVkO1xuXG4gIHZhciBmaXhGbnMgPSBbXTtcbiAgdmFyIGZpeEZuID0gdW5kZWZpbmVkO1xuICB2YXIgbCA9IHVuZGVmaW5lZDtcbiAgdmFyIHByb3AgPSB1bmRlZmluZWQ7XG4gIHZhciBwcm9wcyA9IGNvbW1vblByb3BzLmNvbmNhdCgpO1xuXG4gIGV2ZW50Tm9ybWFsaXplcnMuZm9yRWFjaChmdW5jdGlvbiAobm9ybWFsaXplcikge1xuICAgIGlmICh0eXBlLm1hdGNoKG5vcm1hbGl6ZXIucmVnKSkge1xuICAgICAgcHJvcHMgPSBwcm9wcy5jb25jYXQobm9ybWFsaXplci5wcm9wcyk7XG4gICAgICBpZiAobm9ybWFsaXplci5maXgpIHtcbiAgICAgICAgZml4Rm5zLnB1c2gobm9ybWFsaXplci5maXgpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG5cbiAgbCA9IHByb3BzLmxlbmd0aDtcblxuICAvLyBjbG9uZSBwcm9wZXJ0aWVzIG9mIHRoZSBvcmlnaW5hbCBldmVudCBvYmplY3RcbiAgd2hpbGUgKGwpIHtcbiAgICBwcm9wID0gcHJvcHNbLS1sXTtcbiAgICB0aGlzW3Byb3BdID0gbmF0aXZlRXZlbnRbcHJvcF07XG4gIH1cblxuICAvLyBmaXggdGFyZ2V0IHByb3BlcnR5LCBpZiBuZWNlc3NhcnlcbiAgaWYgKCF0aGlzLnRhcmdldCAmJiBpc05hdGl2ZSkge1xuICAgIHRoaXMudGFyZ2V0ID0gbmF0aXZlRXZlbnQuc3JjRWxlbWVudCB8fCBkb2N1bWVudDsgLy8gc3JjRWxlbWVudCBtaWdodCBub3QgYmUgZGVmaW5lZCBlaXRoZXJcbiAgfVxuXG4gIC8vIGNoZWNrIGlmIHRhcmdldCBpcyBhIHRleHQgbm9kZSAoc2FmYXJpKVxuICBpZiAodGhpcy50YXJnZXQgJiYgdGhpcy50YXJnZXQubm9kZVR5cGUgPT09IDMpIHtcbiAgICB0aGlzLnRhcmdldCA9IHRoaXMudGFyZ2V0LnBhcmVudE5vZGU7XG4gIH1cblxuICBsID0gZml4Rm5zLmxlbmd0aDtcblxuICB3aGlsZSAobCkge1xuICAgIGZpeEZuID0gZml4Rm5zWy0tbF07XG4gICAgZml4Rm4odGhpcywgbmF0aXZlRXZlbnQpO1xuICB9XG5cbiAgdGhpcy50aW1lU3RhbXAgPSBuYXRpdmVFdmVudC50aW1lU3RhbXAgfHwgRGF0ZS5ub3coKTtcbn1cblxudmFyIEV2ZW50QmFzZU9iamVjdFByb3RvID0gX0V2ZW50QmFzZU9iamVjdDJbJ2RlZmF1bHQnXS5wcm90b3R5cGU7XG5cbigwLCBfb2JqZWN0QXNzaWduMlsnZGVmYXVsdCddKShEb21FdmVudE9iamVjdC5wcm90b3R5cGUsIEV2ZW50QmFzZU9iamVjdFByb3RvLCB7XG4gIGNvbnN0cnVjdG9yOiBEb21FdmVudE9iamVjdCxcblxuICBwcmV2ZW50RGVmYXVsdDogZnVuY3Rpb24gcHJldmVudERlZmF1bHQoKSB7XG4gICAgdmFyIGUgPSB0aGlzLm5hdGl2ZUV2ZW50O1xuXG4gICAgLy8gaWYgcHJldmVudERlZmF1bHQgZXhpc3RzIHJ1biBpdCBvbiB0aGUgb3JpZ2luYWwgZXZlbnRcbiAgICBpZiAoZS5wcmV2ZW50RGVmYXVsdCkge1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBvdGhlcndpc2Ugc2V0IHRoZSByZXR1cm5WYWx1ZSBwcm9wZXJ0eSBvZiB0aGUgb3JpZ2luYWwgZXZlbnQgdG8gRkFMU0UgKElFKVxuICAgICAgZS5yZXR1cm5WYWx1ZSA9IEZBTFNFO1xuICAgIH1cblxuICAgIEV2ZW50QmFzZU9iamVjdFByb3RvLnByZXZlbnREZWZhdWx0LmNhbGwodGhpcyk7XG4gIH0sXG5cbiAgc3RvcFByb3BhZ2F0aW9uOiBmdW5jdGlvbiBzdG9wUHJvcGFnYXRpb24oKSB7XG4gICAgdmFyIGUgPSB0aGlzLm5hdGl2ZUV2ZW50O1xuXG4gICAgLy8gaWYgc3RvcFByb3BhZ2F0aW9uIGV4aXN0cyBydW4gaXQgb24gdGhlIG9yaWdpbmFsIGV2ZW50XG4gICAgaWYgKGUuc3RvcFByb3BhZ2F0aW9uKSB7XG4gICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBvdGhlcndpc2Ugc2V0IHRoZSBjYW5jZWxCdWJibGUgcHJvcGVydHkgb2YgdGhlIG9yaWdpbmFsIGV2ZW50IHRvIFRSVUUgKElFKVxuICAgICAgZS5jYW5jZWxCdWJibGUgPSBUUlVFO1xuICAgIH1cblxuICAgIEV2ZW50QmFzZU9iamVjdFByb3RvLnN0b3BQcm9wYWdhdGlvbi5jYWxsKHRoaXMpO1xuICB9XG59KTtcblxuZXhwb3J0c1snZGVmYXVsdCddID0gRG9tRXZlbnRPYmplY3Q7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi91eGNvcmUtdGFibGUvfi91eGNvcmUtbWVudS9+L3JjLW1lbnUvfi9yYy11dGlsL34vYWRkLWRvbS1ldmVudC1saXN0ZW5lci9saWIvRXZlbnRPYmplY3QuanNcbiAqKiBtb2R1bGUgaWQgPSAzMVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vZG9tLXNjcm9sbC1pbnRvLXZpZXcnKTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi91eGNvcmUtdGFibGUvfi91eGNvcmUtbWVudS9+L3JjLW1lbnUvfi9kb20tc2Nyb2xsLWludG8tdmlldy9saWIvaW5kZXguanNcbiAqKiBtb2R1bGUgaWQgPSAzNlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xuXG5mdW5jdGlvbiBzY3JvbGxJbnRvVmlldyhlbGVtLCBjb250YWluZXIsIGNvbmZpZykge1xuICBjb25maWcgPSBjb25maWcgfHwge307XG4gIC8vIGRvY3VtZW50IOW9kuS4gOWMluWIsCB3aW5kb3dcbiAgaWYgKGNvbnRhaW5lci5ub2RlVHlwZSA9PT0gOSkge1xuICAgIGNvbnRhaW5lciA9IHV0aWwuZ2V0V2luZG93KGNvbnRhaW5lcik7XG4gIH1cblxuICB2YXIgYWxsb3dIb3Jpem9udGFsU2Nyb2xsID0gY29uZmlnLmFsbG93SG9yaXpvbnRhbFNjcm9sbDtcbiAgdmFyIG9ubHlTY3JvbGxJZk5lZWRlZCA9IGNvbmZpZy5vbmx5U2Nyb2xsSWZOZWVkZWQ7XG4gIHZhciBhbGlnbldpdGhUb3AgPSBjb25maWcuYWxpZ25XaXRoVG9wO1xuICB2YXIgYWxpZ25XaXRoTGVmdCA9IGNvbmZpZy5hbGlnbldpdGhMZWZ0O1xuICB2YXIgb2Zmc2V0VG9wID0gY29uZmlnLm9mZnNldFRvcCB8fCAwO1xuICB2YXIgb2Zmc2V0TGVmdCA9IGNvbmZpZy5vZmZzZXRMZWZ0IHx8IDA7XG4gIHZhciBvZmZzZXRCb3R0b20gPSBjb25maWcub2Zmc2V0Qm90dG9tIHx8IDA7XG4gIHZhciBvZmZzZXRSaWdodCA9IGNvbmZpZy5vZmZzZXRSaWdodCB8fCAwO1xuXG4gIGFsbG93SG9yaXpvbnRhbFNjcm9sbCA9IGFsbG93SG9yaXpvbnRhbFNjcm9sbCA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IGFsbG93SG9yaXpvbnRhbFNjcm9sbDtcblxuICB2YXIgaXNXaW4gPSB1dGlsLmlzV2luZG93KGNvbnRhaW5lcik7XG4gIHZhciBlbGVtT2Zmc2V0ID0gdXRpbC5vZmZzZXQoZWxlbSk7XG4gIHZhciBlaCA9IHV0aWwub3V0ZXJIZWlnaHQoZWxlbSk7XG4gIHZhciBldyA9IHV0aWwub3V0ZXJXaWR0aChlbGVtKTtcbiAgdmFyIGNvbnRhaW5lck9mZnNldCA9IHVuZGVmaW5lZDtcbiAgdmFyIGNoID0gdW5kZWZpbmVkO1xuICB2YXIgY3cgPSB1bmRlZmluZWQ7XG4gIHZhciBjb250YWluZXJTY3JvbGwgPSB1bmRlZmluZWQ7XG4gIHZhciBkaWZmVG9wID0gdW5kZWZpbmVkO1xuICB2YXIgZGlmZkJvdHRvbSA9IHVuZGVmaW5lZDtcbiAgdmFyIHdpbiA9IHVuZGVmaW5lZDtcbiAgdmFyIHdpblNjcm9sbCA9IHVuZGVmaW5lZDtcbiAgdmFyIHd3ID0gdW5kZWZpbmVkO1xuICB2YXIgd2ggPSB1bmRlZmluZWQ7XG5cbiAgaWYgKGlzV2luKSB7XG4gICAgd2luID0gY29udGFpbmVyO1xuICAgIHdoID0gdXRpbC5oZWlnaHQod2luKTtcbiAgICB3dyA9IHV0aWwud2lkdGgod2luKTtcbiAgICB3aW5TY3JvbGwgPSB7XG4gICAgICBsZWZ0OiB1dGlsLnNjcm9sbExlZnQod2luKSxcbiAgICAgIHRvcDogdXRpbC5zY3JvbGxUb3Aod2luKVxuICAgIH07XG4gICAgLy8gZWxlbSDnm7jlr7kgY29udGFpbmVyIOWPr+inhuinhueql+eahOi3neemu1xuICAgIGRpZmZUb3AgPSB7XG4gICAgICBsZWZ0OiBlbGVtT2Zmc2V0LmxlZnQgLSB3aW5TY3JvbGwubGVmdCAtIG9mZnNldExlZnQsXG4gICAgICB0b3A6IGVsZW1PZmZzZXQudG9wIC0gd2luU2Nyb2xsLnRvcCAtIG9mZnNldFRvcFxuICAgIH07XG4gICAgZGlmZkJvdHRvbSA9IHtcbiAgICAgIGxlZnQ6IGVsZW1PZmZzZXQubGVmdCArIGV3IC0gKHdpblNjcm9sbC5sZWZ0ICsgd3cpICsgb2Zmc2V0UmlnaHQsXG4gICAgICB0b3A6IGVsZW1PZmZzZXQudG9wICsgZWggLSAod2luU2Nyb2xsLnRvcCArIHdoKSArIG9mZnNldEJvdHRvbVxuICAgIH07XG4gICAgY29udGFpbmVyU2Nyb2xsID0gd2luU2Nyb2xsO1xuICB9IGVsc2Uge1xuICAgIGNvbnRhaW5lck9mZnNldCA9IHV0aWwub2Zmc2V0KGNvbnRhaW5lcik7XG4gICAgY2ggPSBjb250YWluZXIuY2xpZW50SGVpZ2h0O1xuICAgIGN3ID0gY29udGFpbmVyLmNsaWVudFdpZHRoO1xuICAgIGNvbnRhaW5lclNjcm9sbCA9IHtcbiAgICAgIGxlZnQ6IGNvbnRhaW5lci5zY3JvbGxMZWZ0LFxuICAgICAgdG9wOiBjb250YWluZXIuc2Nyb2xsVG9wXG4gICAgfTtcbiAgICAvLyBlbGVtIOebuOWvuSBjb250YWluZXIg5Y+v6KeG6KeG56qX55qE6Led56a7XG4gICAgLy8g5rOo5oSP6L655qGGLCBvZmZzZXQg5piv6L655qGG5Yiw5qC56IqC54K5XG4gICAgZGlmZlRvcCA9IHtcbiAgICAgIGxlZnQ6IGVsZW1PZmZzZXQubGVmdCAtIChjb250YWluZXJPZmZzZXQubGVmdCArIChwYXJzZUZsb2F0KHV0aWwuY3NzKGNvbnRhaW5lciwgJ2JvcmRlckxlZnRXaWR0aCcpKSB8fCAwKSkgLSBvZmZzZXRMZWZ0LFxuICAgICAgdG9wOiBlbGVtT2Zmc2V0LnRvcCAtIChjb250YWluZXJPZmZzZXQudG9wICsgKHBhcnNlRmxvYXQodXRpbC5jc3MoY29udGFpbmVyLCAnYm9yZGVyVG9wV2lkdGgnKSkgfHwgMCkpIC0gb2Zmc2V0VG9wXG4gICAgfTtcbiAgICBkaWZmQm90dG9tID0ge1xuICAgICAgbGVmdDogZWxlbU9mZnNldC5sZWZ0ICsgZXcgLSAoY29udGFpbmVyT2Zmc2V0LmxlZnQgKyBjdyArIChwYXJzZUZsb2F0KHV0aWwuY3NzKGNvbnRhaW5lciwgJ2JvcmRlclJpZ2h0V2lkdGgnKSkgfHwgMCkpICsgb2Zmc2V0UmlnaHQsXG4gICAgICB0b3A6IGVsZW1PZmZzZXQudG9wICsgZWggLSAoY29udGFpbmVyT2Zmc2V0LnRvcCArIGNoICsgKHBhcnNlRmxvYXQodXRpbC5jc3MoY29udGFpbmVyLCAnYm9yZGVyQm90dG9tV2lkdGgnKSkgfHwgMCkpICsgb2Zmc2V0Qm90dG9tXG4gICAgfTtcbiAgfVxuXG4gIGlmIChkaWZmVG9wLnRvcCA8IDAgfHwgZGlmZkJvdHRvbS50b3AgPiAwKSB7XG4gICAgLy8g5by65Yi25ZCR5LiKXG4gICAgaWYgKGFsaWduV2l0aFRvcCA9PT0gdHJ1ZSkge1xuICAgICAgdXRpbC5zY3JvbGxUb3AoY29udGFpbmVyLCBjb250YWluZXJTY3JvbGwudG9wICsgZGlmZlRvcC50b3ApO1xuICAgIH0gZWxzZSBpZiAoYWxpZ25XaXRoVG9wID09PSBmYWxzZSkge1xuICAgICAgdXRpbC5zY3JvbGxUb3AoY29udGFpbmVyLCBjb250YWluZXJTY3JvbGwudG9wICsgZGlmZkJvdHRvbS50b3ApO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyDoh6rliqjosIPmlbRcbiAgICAgIGlmIChkaWZmVG9wLnRvcCA8IDApIHtcbiAgICAgICAgdXRpbC5zY3JvbGxUb3AoY29udGFpbmVyLCBjb250YWluZXJTY3JvbGwudG9wICsgZGlmZlRvcC50b3ApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdXRpbC5zY3JvbGxUb3AoY29udGFpbmVyLCBjb250YWluZXJTY3JvbGwudG9wICsgZGlmZkJvdHRvbS50b3ApO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoIW9ubHlTY3JvbGxJZk5lZWRlZCkge1xuICAgICAgYWxpZ25XaXRoVG9wID0gYWxpZ25XaXRoVG9wID09PSB1bmRlZmluZWQgPyB0cnVlIDogISFhbGlnbldpdGhUb3A7XG4gICAgICBpZiAoYWxpZ25XaXRoVG9wKSB7XG4gICAgICAgIHV0aWwuc2Nyb2xsVG9wKGNvbnRhaW5lciwgY29udGFpbmVyU2Nyb2xsLnRvcCArIGRpZmZUb3AudG9wKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHV0aWwuc2Nyb2xsVG9wKGNvbnRhaW5lciwgY29udGFpbmVyU2Nyb2xsLnRvcCArIGRpZmZCb3R0b20udG9wKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoYWxsb3dIb3Jpem9udGFsU2Nyb2xsKSB7XG4gICAgaWYgKGRpZmZUb3AubGVmdCA8IDAgfHwgZGlmZkJvdHRvbS5sZWZ0ID4gMCkge1xuICAgICAgLy8g5by65Yi25ZCR5LiKXG4gICAgICBpZiAoYWxpZ25XaXRoTGVmdCA9PT0gdHJ1ZSkge1xuICAgICAgICB1dGlsLnNjcm9sbExlZnQoY29udGFpbmVyLCBjb250YWluZXJTY3JvbGwubGVmdCArIGRpZmZUb3AubGVmdCk7XG4gICAgICB9IGVsc2UgaWYgKGFsaWduV2l0aExlZnQgPT09IGZhbHNlKSB7XG4gICAgICAgIHV0aWwuc2Nyb2xsTGVmdChjb250YWluZXIsIGNvbnRhaW5lclNjcm9sbC5sZWZ0ICsgZGlmZkJvdHRvbS5sZWZ0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIOiHquWKqOiwg+aVtFxuICAgICAgICBpZiAoZGlmZlRvcC5sZWZ0IDwgMCkge1xuICAgICAgICAgIHV0aWwuc2Nyb2xsTGVmdChjb250YWluZXIsIGNvbnRhaW5lclNjcm9sbC5sZWZ0ICsgZGlmZlRvcC5sZWZ0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB1dGlsLnNjcm9sbExlZnQoY29udGFpbmVyLCBjb250YWluZXJTY3JvbGwubGVmdCArIGRpZmZCb3R0b20ubGVmdCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKCFvbmx5U2Nyb2xsSWZOZWVkZWQpIHtcbiAgICAgICAgYWxpZ25XaXRoTGVmdCA9IGFsaWduV2l0aExlZnQgPT09IHVuZGVmaW5lZCA/IHRydWUgOiAhIWFsaWduV2l0aExlZnQ7XG4gICAgICAgIGlmIChhbGlnbldpdGhMZWZ0KSB7XG4gICAgICAgICAgdXRpbC5zY3JvbGxMZWZ0KGNvbnRhaW5lciwgY29udGFpbmVyU2Nyb2xsLmxlZnQgKyBkaWZmVG9wLmxlZnQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHV0aWwuc2Nyb2xsTGVmdChjb250YWluZXIsIGNvbnRhaW5lclNjcm9sbC5sZWZ0ICsgZGlmZkJvdHRvbS5sZWZ0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNjcm9sbEludG9WaWV3O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3V4Y29yZS10YWJsZS9+L3V4Y29yZS1tZW51L34vcmMtbWVudS9+L2RvbS1zY3JvbGwtaW50by12aWV3L2xpYi9kb20tc2Nyb2xsLWludG8tdmlldy5qc1xuICoqIG1vZHVsZSBpZCA9IDM3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyBleHBvcnQgdGhpcyBwYWNrYWdlJ3MgYXBpXG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9BbmltYXRlJyk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vdXhjb3JlLXRhYmxlL34vdXhjb3JlLW1lbnUvfi9yYy1tZW51L34vcmMtYW5pbWF0ZS9saWIvaW5kZXguanNcbiAqKiBtb2R1bGUgaWQgPSA0M1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxuXG52YXIgX3JlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxudmFyIF9yZWFjdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yZWFjdCk7XG5cbnZhciBfQ2hpbGRyZW5VdGlscyA9IHJlcXVpcmUoJy4vQ2hpbGRyZW5VdGlscycpO1xuXG52YXIgX0FuaW1hdGVDaGlsZCA9IHJlcXVpcmUoJy4vQW5pbWF0ZUNoaWxkJyk7XG5cbnZhciBfQW5pbWF0ZUNoaWxkMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0FuaW1hdGVDaGlsZCk7XG5cbnZhciBfdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xuXG52YXIgX3V0aWwyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdXRpbCk7XG5cbnZhciBkZWZhdWx0S2V5ID0gJ3JjX2FuaW1hdGVfJyArIERhdGUubm93KCk7XG5cbmZ1bmN0aW9uIGdldENoaWxkcmVuRnJvbVByb3BzKHByb3BzKSB7XG4gIHZhciBjaGlsZHJlbiA9IHByb3BzLmNoaWxkcmVuO1xuICBpZiAoX3JlYWN0MlsnZGVmYXVsdCddLmlzVmFsaWRFbGVtZW50KGNoaWxkcmVuKSkge1xuICAgIGlmICghY2hpbGRyZW4ua2V5KSB7XG4gICAgICByZXR1cm4gX3JlYWN0MlsnZGVmYXVsdCddLmNsb25lRWxlbWVudChjaGlsZHJlbiwge1xuICAgICAgICBrZXk6IGRlZmF1bHRLZXlcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gY2hpbGRyZW47XG59XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG52YXIgQW5pbWF0ZSA9IF9yZWFjdDJbJ2RlZmF1bHQnXS5jcmVhdGVDbGFzcyh7XG4gIGRpc3BsYXlOYW1lOiAnQW5pbWF0ZScsXG5cbiAgcHJvcFR5cGVzOiB7XG4gICAgY29tcG9uZW50OiBfcmVhY3QyWydkZWZhdWx0J10uUHJvcFR5cGVzLmFueSxcbiAgICBhbmltYXRpb246IF9yZWFjdDJbJ2RlZmF1bHQnXS5Qcm9wVHlwZXMub2JqZWN0LFxuICAgIHRyYW5zaXRpb25OYW1lOiBfcmVhY3QyWydkZWZhdWx0J10uUHJvcFR5cGVzLnN0cmluZyxcbiAgICB0cmFuc2l0aW9uRW50ZXI6IF9yZWFjdDJbJ2RlZmF1bHQnXS5Qcm9wVHlwZXMuYm9vbCxcbiAgICB0cmFuc2l0aW9uQXBwZWFyOiBfcmVhY3QyWydkZWZhdWx0J10uUHJvcFR5cGVzLmJvb2wsXG4gICAgZXhjbHVzaXZlOiBfcmVhY3QyWydkZWZhdWx0J10uUHJvcFR5cGVzLmJvb2wsXG4gICAgdHJhbnNpdGlvbkxlYXZlOiBfcmVhY3QyWydkZWZhdWx0J10uUHJvcFR5cGVzLmJvb2wsXG4gICAgb25FbmQ6IF9yZWFjdDJbJ2RlZmF1bHQnXS5Qcm9wVHlwZXMuZnVuYyxcbiAgICBvbkVudGVyOiBfcmVhY3QyWydkZWZhdWx0J10uUHJvcFR5cGVzLmZ1bmMsXG4gICAgb25MZWF2ZTogX3JlYWN0MlsnZGVmYXVsdCddLlByb3BUeXBlcy5mdW5jLFxuICAgIG9uQXBwZWFyOiBfcmVhY3QyWydkZWZhdWx0J10uUHJvcFR5cGVzLmZ1bmMsXG4gICAgc2hvd1Byb3A6IF9yZWFjdDJbJ2RlZmF1bHQnXS5Qcm9wVHlwZXMuc3RyaW5nXG4gIH0sXG5cbiAgZ2V0RGVmYXVsdFByb3BzOiBmdW5jdGlvbiBnZXREZWZhdWx0UHJvcHMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGFuaW1hdGlvbjoge30sXG4gICAgICBjb21wb25lbnQ6ICdzcGFuJyxcbiAgICAgIHRyYW5zaXRpb25FbnRlcjogdHJ1ZSxcbiAgICAgIHRyYW5zaXRpb25MZWF2ZTogdHJ1ZSxcbiAgICAgIHRyYW5zaXRpb25BcHBlYXI6IGZhbHNlLFxuICAgICAgb25FbmQ6IG5vb3AsXG4gICAgICBvbkVudGVyOiBub29wLFxuICAgICAgb25MZWF2ZTogbm9vcCxcbiAgICAgIG9uQXBwZWFyOiBub29wXG4gICAgfTtcbiAgfSxcblxuICBnZXRJbml0aWFsU3RhdGU6IGZ1bmN0aW9uIGdldEluaXRpYWxTdGF0ZSgpIHtcbiAgICB0aGlzLmN1cnJlbnRseUFuaW1hdGluZ0tleXMgPSB7fTtcbiAgICB0aGlzLmtleXNUb0VudGVyID0gW107XG4gICAgdGhpcy5rZXlzVG9MZWF2ZSA9IFtdO1xuICAgIHJldHVybiB7XG4gICAgICBjaGlsZHJlbjogKDAsIF9DaGlsZHJlblV0aWxzLnRvQXJyYXlDaGlsZHJlbikoZ2V0Q2hpbGRyZW5Gcm9tUHJvcHModGhpcy5wcm9wcykpXG4gICAgfTtcbiAgfSxcblxuICBjb21wb25lbnREaWRNb3VudDogZnVuY3Rpb24gY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIHZhciBzaG93UHJvcCA9IHRoaXMucHJvcHMuc2hvd1Byb3A7XG4gICAgdmFyIGNoaWxkcmVuID0gdGhpcy5zdGF0ZS5jaGlsZHJlbjtcbiAgICBpZiAoc2hvd1Byb3ApIHtcbiAgICAgIGNoaWxkcmVuID0gY2hpbGRyZW4uZmlsdGVyKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICByZXR1cm4gISFjaGlsZC5wcm9wc1tzaG93UHJvcF07XG4gICAgICB9KTtcbiAgICB9XG4gICAgY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgIF90aGlzLnBlcmZvcm1BcHBlYXIoY2hpbGQua2V5KTtcbiAgICB9KTtcbiAgfSxcblxuICBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzOiBmdW5jdGlvbiBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKG5leHRQcm9wcykge1xuICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgdGhpcy5uZXh0UHJvcHMgPSBuZXh0UHJvcHM7XG4gICAgdmFyIG5leHRDaGlsZHJlbiA9ICgwLCBfQ2hpbGRyZW5VdGlscy50b0FycmF5Q2hpbGRyZW4pKGdldENoaWxkcmVuRnJvbVByb3BzKG5leHRQcm9wcykpO1xuICAgIHZhciBwcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgLy8gZXhjbHVzaXZlIG5lZWRzIGltbWVkaWF0ZSByZXNwb25zZVxuICAgIGlmIChwcm9wcy5leGNsdXNpdmUpIHtcbiAgICAgIE9iamVjdC5rZXlzKHRoaXMuY3VycmVudGx5QW5pbWF0aW5nS2V5cykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIF90aGlzMi5zdG9wKGtleSk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgdmFyIHNob3dQcm9wID0gcHJvcHMuc2hvd1Byb3A7XG4gICAgdmFyIGN1cnJlbnRseUFuaW1hdGluZ0tleXMgPSB0aGlzLmN1cnJlbnRseUFuaW1hdGluZ0tleXM7XG4gICAgLy8gbGFzdCBwcm9wcyBjaGlsZHJlbiBpZiBleGNsdXNpdmVcbiAgICB2YXIgY3VycmVudENoaWxkcmVuID0gcHJvcHMuZXhjbHVzaXZlID8gKDAsIF9DaGlsZHJlblV0aWxzLnRvQXJyYXlDaGlsZHJlbikoZ2V0Q2hpbGRyZW5Gcm9tUHJvcHMocHJvcHMpKSA6IHRoaXMuc3RhdGUuY2hpbGRyZW47XG4gICAgLy8gaW4gY2FzZSBkZXN0cm95IGluIHNob3dQcm9wIG1vZGVcbiAgICB2YXIgbmV3Q2hpbGRyZW4gPSBbXTtcbiAgICBpZiAoc2hvd1Byb3ApIHtcbiAgICAgIGN1cnJlbnRDaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjdXJyZW50Q2hpbGQpIHtcbiAgICAgICAgdmFyIG5leHRDaGlsZCA9ICgwLCBfQ2hpbGRyZW5VdGlscy5maW5kQ2hpbGRJbkNoaWxkcmVuQnlLZXkpKG5leHRDaGlsZHJlbiwgY3VycmVudENoaWxkLmtleSk7XG4gICAgICAgIHZhciBuZXdDaGlsZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKCghbmV4dENoaWxkIHx8ICFuZXh0Q2hpbGQucHJvcHNbc2hvd1Byb3BdKSAmJiBjdXJyZW50Q2hpbGQucHJvcHNbc2hvd1Byb3BdKSB7XG4gICAgICAgICAgbmV3Q2hpbGQgPSBfcmVhY3QyWydkZWZhdWx0J10uY2xvbmVFbGVtZW50KG5leHRDaGlsZCB8fCBjdXJyZW50Q2hpbGQsIF9kZWZpbmVQcm9wZXJ0eSh7fSwgc2hvd1Byb3AsIHRydWUpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBuZXdDaGlsZCA9IG5leHRDaGlsZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAobmV3Q2hpbGQpIHtcbiAgICAgICAgICBuZXdDaGlsZHJlbi5wdXNoKG5ld0NoaWxkKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBuZXh0Q2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAobmV4dENoaWxkKSB7XG4gICAgICAgIGlmICghKDAsIF9DaGlsZHJlblV0aWxzLmZpbmRDaGlsZEluQ2hpbGRyZW5CeUtleSkoY3VycmVudENoaWxkcmVuLCBuZXh0Q2hpbGQua2V5KSkge1xuICAgICAgICAgIG5ld0NoaWxkcmVuLnB1c2gobmV4dENoaWxkKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5ld0NoaWxkcmVuID0gKDAsIF9DaGlsZHJlblV0aWxzLm1lcmdlQ2hpbGRyZW4pKGN1cnJlbnRDaGlsZHJlbiwgbmV4dENoaWxkcmVuKTtcbiAgICB9XG5cbiAgICAvLyBuZWVkIHJlbmRlciB0byBhdm9pZCB1cGRhdGVcbiAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgIGNoaWxkcmVuOiBuZXdDaGlsZHJlblxuICAgIH0pO1xuXG4gICAgbmV4dENoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICB2YXIga2V5ID0gY2hpbGQua2V5O1xuICAgICAgaWYgKGN1cnJlbnRseUFuaW1hdGluZ0tleXNba2V5XSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgaGFzUHJldiA9ICgwLCBfQ2hpbGRyZW5VdGlscy5maW5kQ2hpbGRJbkNoaWxkcmVuQnlLZXkpKGN1cnJlbnRDaGlsZHJlbiwga2V5KTtcbiAgICAgIGlmIChzaG93UHJvcCkge1xuICAgICAgICB2YXIgc2hvd0luTmV4dCA9IGNoaWxkLnByb3BzW3Nob3dQcm9wXTtcbiAgICAgICAgaWYgKGhhc1ByZXYpIHtcbiAgICAgICAgICB2YXIgc2hvd0luTm93ID0gKDAsIF9DaGlsZHJlblV0aWxzLmZpbmRTaG93bkNoaWxkSW5DaGlsZHJlbkJ5S2V5KShjdXJyZW50Q2hpbGRyZW4sIGtleSwgc2hvd1Byb3ApO1xuICAgICAgICAgIGlmICghc2hvd0luTm93ICYmIHNob3dJbk5leHQpIHtcbiAgICAgICAgICAgIF90aGlzMi5rZXlzVG9FbnRlci5wdXNoKGtleSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHNob3dJbk5leHQpIHtcbiAgICAgICAgICBfdGhpczIua2V5c1RvRW50ZXIucHVzaChrZXkpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKCFoYXNQcmV2KSB7XG4gICAgICAgIF90aGlzMi5rZXlzVG9FbnRlci5wdXNoKGtleSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBjdXJyZW50Q2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgIHZhciBrZXkgPSBjaGlsZC5rZXk7XG4gICAgICBpZiAoY3VycmVudGx5QW5pbWF0aW5nS2V5c1trZXldKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBoYXNOZXh0ID0gKDAsIF9DaGlsZHJlblV0aWxzLmZpbmRDaGlsZEluQ2hpbGRyZW5CeUtleSkobmV4dENoaWxkcmVuLCBrZXkpO1xuICAgICAgaWYgKHNob3dQcm9wKSB7XG4gICAgICAgIHZhciBzaG93SW5Ob3cgPSBjaGlsZC5wcm9wc1tzaG93UHJvcF07XG4gICAgICAgIGlmIChoYXNOZXh0KSB7XG4gICAgICAgICAgdmFyIHNob3dJbk5leHQgPSAoMCwgX0NoaWxkcmVuVXRpbHMuZmluZFNob3duQ2hpbGRJbkNoaWxkcmVuQnlLZXkpKG5leHRDaGlsZHJlbiwga2V5LCBzaG93UHJvcCk7XG4gICAgICAgICAgaWYgKCFzaG93SW5OZXh0ICYmIHNob3dJbk5vdykge1xuICAgICAgICAgICAgX3RoaXMyLmtleXNUb0xlYXZlLnB1c2goa2V5KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoc2hvd0luTm93KSB7XG4gICAgICAgICAgX3RoaXMyLmtleXNUb0xlYXZlLnB1c2goa2V5KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICghaGFzTmV4dCkge1xuICAgICAgICBfdGhpczIua2V5c1RvTGVhdmUucHVzaChrZXkpO1xuICAgICAgfVxuICAgIH0pO1xuICB9LFxuXG4gIGNvbXBvbmVudERpZFVwZGF0ZTogZnVuY3Rpb24gY29tcG9uZW50RGlkVXBkYXRlKCkge1xuICAgIGlmICh0aGlzLmlzTW91bnRlZCgpKSB7XG4gICAgICB2YXIga2V5c1RvRW50ZXIgPSB0aGlzLmtleXNUb0VudGVyO1xuICAgICAgdGhpcy5rZXlzVG9FbnRlciA9IFtdO1xuICAgICAga2V5c1RvRW50ZXIuZm9yRWFjaCh0aGlzLnBlcmZvcm1FbnRlcik7XG4gICAgICB2YXIga2V5c1RvTGVhdmUgPSB0aGlzLmtleXNUb0xlYXZlO1xuICAgICAgdGhpcy5rZXlzVG9MZWF2ZSA9IFtdO1xuICAgICAga2V5c1RvTGVhdmUuZm9yRWFjaCh0aGlzLnBlcmZvcm1MZWF2ZSk7XG4gICAgfVxuICB9LFxuXG4gIHBlcmZvcm1FbnRlcjogZnVuY3Rpb24gcGVyZm9ybUVudGVyKGtleSkge1xuICAgIC8vIG1heSBhbHJlYWR5IHJlbW92ZSBieSBleGNsdXNpdmVcbiAgICBpZiAodGhpcy5yZWZzW2tleV0pIHtcbiAgICAgIHRoaXMuY3VycmVudGx5QW5pbWF0aW5nS2V5c1trZXldID0gdHJ1ZTtcbiAgICAgIHRoaXMucmVmc1trZXldLmNvbXBvbmVudFdpbGxFbnRlcih0aGlzLmhhbmRsZURvbmVBZGRpbmcuYmluZCh0aGlzLCBrZXksICdlbnRlcicpKTtcbiAgICB9XG4gIH0sXG5cbiAgcGVyZm9ybUFwcGVhcjogZnVuY3Rpb24gcGVyZm9ybUFwcGVhcihrZXkpIHtcbiAgICBpZiAodGhpcy5yZWZzW2tleV0pIHtcbiAgICAgIHRoaXMuY3VycmVudGx5QW5pbWF0aW5nS2V5c1trZXldID0gdHJ1ZTtcbiAgICAgIHRoaXMucmVmc1trZXldLmNvbXBvbmVudFdpbGxBcHBlYXIodGhpcy5oYW5kbGVEb25lQWRkaW5nLmJpbmQodGhpcywga2V5LCAnYXBwZWFyJykpO1xuICAgIH1cbiAgfSxcblxuICBoYW5kbGVEb25lQWRkaW5nOiBmdW5jdGlvbiBoYW5kbGVEb25lQWRkaW5nKGtleSwgdHlwZSkge1xuICAgIHZhciBwcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgZGVsZXRlIHRoaXMuY3VycmVudGx5QW5pbWF0aW5nS2V5c1trZXldO1xuICAgIC8vIGlmIHVwZGF0ZSBvbiBleGNsdXNpdmUgbW9kZSwgc2tpcCBjaGVja1xuICAgIGlmIChwcm9wcy5leGNsdXNpdmUgJiYgcHJvcHMgIT09IHRoaXMubmV4dFByb3BzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBjdXJyZW50Q2hpbGRyZW4gPSAoMCwgX0NoaWxkcmVuVXRpbHMudG9BcnJheUNoaWxkcmVuKShnZXRDaGlsZHJlbkZyb21Qcm9wcyhwcm9wcykpO1xuICAgIGlmICghdGhpcy5pc1ZhbGlkQ2hpbGRCeUtleShjdXJyZW50Q2hpbGRyZW4sIGtleSkpIHtcbiAgICAgIC8vIGV4Y2x1c2l2ZSB3aWxsIG5vdCBuZWVkIHRoaXNcbiAgICAgIHRoaXMucGVyZm9ybUxlYXZlKGtleSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0eXBlID09PSAnYXBwZWFyJykge1xuICAgICAgICBpZiAoX3V0aWwyWydkZWZhdWx0J10uYWxsb3dBcHBlYXJDYWxsYmFjayhwcm9wcykpIHtcbiAgICAgICAgICBwcm9wcy5vbkFwcGVhcihrZXkpO1xuICAgICAgICAgIHByb3BzLm9uRW5kKGtleSwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChfdXRpbDJbJ2RlZmF1bHQnXS5hbGxvd0VudGVyQ2FsbGJhY2socHJvcHMpKSB7XG4gICAgICAgICAgcHJvcHMub25FbnRlcihrZXkpO1xuICAgICAgICAgIHByb3BzLm9uRW5kKGtleSwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgcGVyZm9ybUxlYXZlOiBmdW5jdGlvbiBwZXJmb3JtTGVhdmUoa2V5KSB7XG4gICAgLy8gbWF5IGFscmVhZHkgcmVtb3ZlIGJ5IGV4Y2x1c2l2ZVxuICAgIGlmICh0aGlzLnJlZnNba2V5XSkge1xuICAgICAgdGhpcy5jdXJyZW50bHlBbmltYXRpbmdLZXlzW2tleV0gPSB0cnVlO1xuICAgICAgdGhpcy5yZWZzW2tleV0uY29tcG9uZW50V2lsbExlYXZlKHRoaXMuaGFuZGxlRG9uZUxlYXZpbmcuYmluZCh0aGlzLCBrZXkpKTtcbiAgICB9XG4gIH0sXG5cbiAgaGFuZGxlRG9uZUxlYXZpbmc6IGZ1bmN0aW9uIGhhbmRsZURvbmVMZWF2aW5nKGtleSkge1xuICAgIHZhciBwcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgZGVsZXRlIHRoaXMuY3VycmVudGx5QW5pbWF0aW5nS2V5c1trZXldO1xuICAgIC8vIGlmIHVwZGF0ZSBvbiBleGNsdXNpdmUgbW9kZSwgc2tpcCBjaGVja1xuICAgIGlmIChwcm9wcy5leGNsdXNpdmUgJiYgcHJvcHMgIT09IHRoaXMubmV4dFByb3BzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBjdXJyZW50Q2hpbGRyZW4gPSAoMCwgX0NoaWxkcmVuVXRpbHMudG9BcnJheUNoaWxkcmVuKShnZXRDaGlsZHJlbkZyb21Qcm9wcyhwcm9wcykpO1xuICAgIC8vIGluIGNhc2Ugc3RhdGUgY2hhbmdlIGlzIHRvbyBmYXN0XG4gICAgaWYgKHRoaXMuaXNWYWxpZENoaWxkQnlLZXkoY3VycmVudENoaWxkcmVuLCBrZXkpKSB7XG4gICAgICB0aGlzLnBlcmZvcm1FbnRlcihrZXkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodGhpcy5pc01vdW50ZWQoKSAmJiAhKDAsIF9DaGlsZHJlblV0aWxzLmlzU2FtZUNoaWxkcmVuKSh0aGlzLnN0YXRlLmNoaWxkcmVuLCBjdXJyZW50Q2hpbGRyZW4sIHByb3BzLnNob3dQcm9wKSkge1xuICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICBjaGlsZHJlbjogY3VycmVudENoaWxkcmVuXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKF91dGlsMlsnZGVmYXVsdCddLmFsbG93TGVhdmVDYWxsYmFjayhwcm9wcykpIHtcbiAgICAgICAgcHJvcHMub25MZWF2ZShrZXkpO1xuICAgICAgICBwcm9wcy5vbkVuZChrZXksIGZhbHNlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgaXNWYWxpZENoaWxkQnlLZXk6IGZ1bmN0aW9uIGlzVmFsaWRDaGlsZEJ5S2V5KGN1cnJlbnRDaGlsZHJlbiwga2V5KSB7XG4gICAgdmFyIHNob3dQcm9wID0gdGhpcy5wcm9wcy5zaG93UHJvcDtcbiAgICBpZiAoc2hvd1Byb3ApIHtcbiAgICAgIHJldHVybiAoMCwgX0NoaWxkcmVuVXRpbHMuZmluZFNob3duQ2hpbGRJbkNoaWxkcmVuQnlLZXkpKGN1cnJlbnRDaGlsZHJlbiwga2V5LCBzaG93UHJvcCk7XG4gICAgfVxuICAgIHJldHVybiAoMCwgX0NoaWxkcmVuVXRpbHMuZmluZENoaWxkSW5DaGlsZHJlbkJ5S2V5KShjdXJyZW50Q2hpbGRyZW4sIGtleSk7XG4gIH0sXG5cbiAgc3RvcDogZnVuY3Rpb24gc3RvcChrZXkpIHtcbiAgICBkZWxldGUgdGhpcy5jdXJyZW50bHlBbmltYXRpbmdLZXlzW2tleV07XG4gICAgdmFyIGNvbXBvbmVudCA9IHRoaXMucmVmc1trZXldO1xuICAgIGlmIChjb21wb25lbnQpIHtcbiAgICAgIGNvbXBvbmVudC5zdG9wKCk7XG4gICAgfVxuICB9LFxuXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgIHZhciBwcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgdGhpcy5uZXh0UHJvcHMgPSBwcm9wcztcbiAgICB2YXIgc3RhdGVDaGlsZHJlbiA9IHRoaXMuc3RhdGUuY2hpbGRyZW47XG4gICAgdmFyIGNoaWxkcmVuID0gbnVsbDtcbiAgICBpZiAoc3RhdGVDaGlsZHJlbikge1xuICAgICAgY2hpbGRyZW4gPSBzdGF0ZUNoaWxkcmVuLm1hcChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgaWYgKGNoaWxkID09PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIGNoaWxkO1xuICAgICAgICB9XG4gICAgICAgIGlmICghY2hpbGQua2V5KSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdtdXN0IHNldCBrZXkgZm9yIDxyYy1hbmltYXRlPiBjaGlsZHJlbicpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfcmVhY3QyWydkZWZhdWx0J10uY3JlYXRlRWxlbWVudChcbiAgICAgICAgICBfQW5pbWF0ZUNoaWxkMlsnZGVmYXVsdCddLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGtleTogY2hpbGQua2V5LFxuICAgICAgICAgICAgcmVmOiBjaGlsZC5rZXksXG4gICAgICAgICAgICBhbmltYXRpb246IHByb3BzLmFuaW1hdGlvbixcbiAgICAgICAgICAgIHRyYW5zaXRpb25OYW1lOiBwcm9wcy50cmFuc2l0aW9uTmFtZSxcbiAgICAgICAgICAgIHRyYW5zaXRpb25FbnRlcjogcHJvcHMudHJhbnNpdGlvbkVudGVyLFxuICAgICAgICAgICAgdHJhbnNpdGlvbkFwcGVhcjogcHJvcHMudHJhbnNpdGlvbkFwcGVhcixcbiAgICAgICAgICAgIHRyYW5zaXRpb25MZWF2ZTogcHJvcHMudHJhbnNpdGlvbkxlYXZlIH0sXG4gICAgICAgICAgY2hpbGRcbiAgICAgICAgKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICB2YXIgQ29tcG9uZW50ID0gcHJvcHMuY29tcG9uZW50O1xuICAgIGlmIChDb21wb25lbnQpIHtcbiAgICAgIHJldHVybiBfcmVhY3QyWydkZWZhdWx0J10uY3JlYXRlRWxlbWVudChcbiAgICAgICAgQ29tcG9uZW50LFxuICAgICAgICB0aGlzLnByb3BzLFxuICAgICAgICBjaGlsZHJlblxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIGNoaWxkcmVuWzBdIHx8IG51bGw7XG4gIH1cbn0pO1xuXG5leHBvcnRzWydkZWZhdWx0J10gPSBBbmltYXRlO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vdXhjb3JlLXRhYmxlL34vdXhjb3JlLW1lbnUvfi9yYy1tZW51L34vcmMtYW5pbWF0ZS9saWIvQW5pbWF0ZS5qc1xuICoqIG1vZHVsZSBpZCA9IDQ0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbnZhciBfcmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xuXG52YXIgX3JlYWN0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JlYWN0KTtcblxudmFyIF9yZWFjdERvbSA9IHJlcXVpcmUoJ3JlYWN0LWRvbScpO1xuXG52YXIgX3JlYWN0RG9tMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JlYWN0RG9tKTtcblxudmFyIF9jc3NBbmltYXRpb24gPSByZXF1aXJlKCdjc3MtYW5pbWF0aW9uJyk7XG5cbnZhciBfY3NzQW5pbWF0aW9uMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2Nzc0FuaW1hdGlvbik7XG5cbnZhciBfdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xuXG52YXIgX3V0aWwyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdXRpbCk7XG5cbnZhciB0cmFuc2l0aW9uTWFwID0ge1xuICBlbnRlcjogJ3RyYW5zaXRpb25FbnRlcicsXG4gIGFwcGVhcjogJ3RyYW5zaXRpb25BcHBlYXInLFxuICBsZWF2ZTogJ3RyYW5zaXRpb25MZWF2ZSdcbn07XG5cbnZhciBBbmltYXRlQ2hpbGQgPSBfcmVhY3QyWydkZWZhdWx0J10uY3JlYXRlQ2xhc3Moe1xuICBkaXNwbGF5TmFtZTogJ0FuaW1hdGVDaGlsZCcsXG5cbiAgcHJvcFR5cGVzOiB7XG4gICAgY2hpbGRyZW46IF9yZWFjdDJbJ2RlZmF1bHQnXS5Qcm9wVHlwZXMuYW55XG4gIH0sXG5cbiAgY29tcG9uZW50V2lsbFVubW91bnQ6IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgIHRoaXMuc3RvcCgpO1xuICB9LFxuXG4gIGNvbXBvbmVudFdpbGxFbnRlcjogZnVuY3Rpb24gY29tcG9uZW50V2lsbEVudGVyKGRvbmUpIHtcbiAgICBpZiAoX3V0aWwyWydkZWZhdWx0J10uaXNFbnRlclN1cHBvcnRlZCh0aGlzLnByb3BzKSkge1xuICAgICAgdGhpcy50cmFuc2l0aW9uKCdlbnRlcicsIGRvbmUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBkb25lKCk7XG4gICAgfVxuICB9LFxuXG4gIGNvbXBvbmVudFdpbGxBcHBlYXI6IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxBcHBlYXIoZG9uZSkge1xuICAgIGlmIChfdXRpbDJbJ2RlZmF1bHQnXS5pc0FwcGVhclN1cHBvcnRlZCh0aGlzLnByb3BzKSkge1xuICAgICAgdGhpcy50cmFuc2l0aW9uKCdhcHBlYXInLCBkb25lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZG9uZSgpO1xuICAgIH1cbiAgfSxcblxuICBjb21wb25lbnRXaWxsTGVhdmU6IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxMZWF2ZShkb25lKSB7XG4gICAgaWYgKF91dGlsMlsnZGVmYXVsdCddLmlzTGVhdmVTdXBwb3J0ZWQodGhpcy5wcm9wcykpIHtcbiAgICAgIHRoaXMudHJhbnNpdGlvbignbGVhdmUnLCBkb25lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZG9uZSgpO1xuICAgIH1cbiAgfSxcblxuICB0cmFuc2l0aW9uOiBmdW5jdGlvbiB0cmFuc2l0aW9uKGFuaW1hdGlvblR5cGUsIGZpbmlzaENhbGxiYWNrKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIHZhciBub2RlID0gX3JlYWN0RG9tMlsnZGVmYXVsdCddLmZpbmRET01Ob2RlKHRoaXMpO1xuICAgIHZhciBwcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgdmFyIHRyYW5zaXRpb25OYW1lID0gcHJvcHMudHJhbnNpdGlvbk5hbWU7XG4gICAgdGhpcy5zdG9wKCk7XG4gICAgdmFyIGVuZCA9IGZ1bmN0aW9uIGVuZCgpIHtcbiAgICAgIF90aGlzLnN0b3BwZXIgPSBudWxsO1xuICAgICAgZmluaXNoQ2FsbGJhY2soKTtcbiAgICB9O1xuICAgIGlmICgoX2Nzc0FuaW1hdGlvbi5pc0Nzc0FuaW1hdGlvblN1cHBvcnRlZCB8fCAhcHJvcHMuYW5pbWF0aW9uW2FuaW1hdGlvblR5cGVdKSAmJiB0cmFuc2l0aW9uTmFtZSAmJiBwcm9wc1t0cmFuc2l0aW9uTWFwW2FuaW1hdGlvblR5cGVdXSkge1xuICAgICAgdGhpcy5zdG9wcGVyID0gKDAsIF9jc3NBbmltYXRpb24yWydkZWZhdWx0J10pKG5vZGUsIHRyYW5zaXRpb25OYW1lICsgJy0nICsgYW5pbWF0aW9uVHlwZSwgZW5kKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zdG9wcGVyID0gcHJvcHMuYW5pbWF0aW9uW2FuaW1hdGlvblR5cGVdKG5vZGUsIGVuZCk7XG4gICAgfVxuICB9LFxuXG4gIHN0b3A6IGZ1bmN0aW9uIHN0b3AoKSB7XG4gICAgdmFyIHN0b3BwZXIgPSB0aGlzLnN0b3BwZXI7XG4gICAgaWYgKHN0b3BwZXIpIHtcbiAgICAgIHRoaXMuc3RvcHBlciA9IG51bGw7XG4gICAgICBzdG9wcGVyLnN0b3AoKTtcbiAgICB9XG4gIH0sXG5cbiAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMucHJvcHMuY2hpbGRyZW47XG4gIH1cbn0pO1xuXG5leHBvcnRzWydkZWZhdWx0J10gPSBBbmltYXRlQ2hpbGQ7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi91eGNvcmUtdGFibGUvfi91eGNvcmUtbWVudS9+L3JjLW1lbnUvfi9yYy1hbmltYXRlL2xpYi9BbmltYXRlQ2hpbGQuanNcbiAqKiBtb2R1bGUgaWQgPSA0NlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX0V2ZW50ID0gcmVxdWlyZSgnLi9FdmVudCcpO1xuXG52YXIgX0V2ZW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0V2ZW50KTtcblxudmFyIF9jb21wb25lbnRDbGFzc2VzID0gcmVxdWlyZSgnY29tcG9uZW50LWNsYXNzZXMnKTtcblxudmFyIF9jb21wb25lbnRDbGFzc2VzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NvbXBvbmVudENsYXNzZXMpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBcImRlZmF1bHRcIjogb2JqIH07IH1cblxudmFyIGlzQ3NzQW5pbWF0aW9uU3VwcG9ydGVkID0gX0V2ZW50MltcImRlZmF1bHRcIl0uZW5kRXZlbnRzLmxlbmd0aCAhPT0gMDtcblxuXG52YXIgY2FwaXRhbFByZWZpeGVzID0gWydXZWJraXQnLCAnTW96JywgJ08nLFxuLy8gbXMgaXMgc3BlY2lhbCAuLi4uICFcbidtcyddO1xudmFyIHByZWZpeGVzID0gWyctd2Via2l0LScsICctbW96LScsICctby0nLCAnbXMtJywgJyddO1xuXG5mdW5jdGlvbiBnZXREdXJhdGlvbihub2RlLCBuYW1lKSB7XG4gIHZhciBzdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKG5vZGUpO1xuXG4gIHZhciByZXQgPSAnJztcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcmVmaXhlcy5sZW5ndGg7IGkrKykge1xuICAgIHJldCA9IHN0eWxlLmdldFByb3BlcnR5VmFsdWUocHJlZml4ZXNbaV0gKyBuYW1lKTtcbiAgICBpZiAocmV0KSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gZml4QnJvd3NlckJ5VGltZW91dChub2RlKSB7XG4gIGlmIChpc0Nzc0FuaW1hdGlvblN1cHBvcnRlZCkge1xuICAgIHZhciB0cmFuc2l0aW9uRHVyYXRpb24gPSBwYXJzZUZsb2F0KGdldER1cmF0aW9uKG5vZGUsICd0cmFuc2l0aW9uLWR1cmF0aW9uJykpIHx8IDA7XG4gICAgdmFyIGFuaW1hdGlvbkR1cmF0aW9uID0gcGFyc2VGbG9hdChnZXREdXJhdGlvbihub2RlLCAnYW5pbWF0aW9uLWR1cmF0aW9uJykpIHx8IDA7XG4gICAgdmFyIHRpbWUgPSBNYXRoLm1heCh0cmFuc2l0aW9uRHVyYXRpb24sIGFuaW1hdGlvbkR1cmF0aW9uKTtcbiAgICAvLyBzb21ldGltZXMsIGJyb3dzZXIgYnVnXG4gICAgbm9kZS5yY0VuZEFuaW1UaW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICBub2RlLnJjRW5kQW5pbVRpbWVvdXQgPSBudWxsO1xuICAgICAgaWYgKG5vZGUucmNFbmRMaXN0ZW5lcikge1xuICAgICAgICBub2RlLnJjRW5kTGlzdGVuZXIoKTtcbiAgICAgIH1cbiAgICB9LCB0aW1lICogMTAwMCArIDIwMCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY2xlYXJCcm93c2VyQnVnVGltZW91dChub2RlKSB7XG4gIGlmIChub2RlLnJjRW5kQW5pbVRpbWVvdXQpIHtcbiAgICBjbGVhclRpbWVvdXQobm9kZS5yY0VuZEFuaW1UaW1lb3V0KTtcbiAgICBub2RlLnJjRW5kQW5pbVRpbWVvdXQgPSBudWxsO1xuICB9XG59XG5cbnZhciBjc3NBbmltYXRpb24gPSBmdW5jdGlvbiBjc3NBbmltYXRpb24obm9kZSwgdHJhbnNpdGlvbk5hbWUsIGVuZENhbGxiYWNrKSB7XG4gIHZhciBjbGFzc05hbWUgPSB0cmFuc2l0aW9uTmFtZTtcbiAgdmFyIGFjdGl2ZUNsYXNzTmFtZSA9IGNsYXNzTmFtZSArICctYWN0aXZlJztcbiAgdmFyIGVuZCA9IGVuZENhbGxiYWNrO1xuICB2YXIgc3RhcnQgPSB2b2lkIDA7XG4gIHZhciBhY3RpdmUgPSB2b2lkIDA7XG4gIHZhciBub2RlQ2xhc3NlcyA9ICgwLCBfY29tcG9uZW50Q2xhc3NlczJbXCJkZWZhdWx0XCJdKShub2RlKTtcblxuICBpZiAoZW5kQ2FsbGJhY2sgJiYgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGVuZENhbGxiYWNrKSA9PT0gJ1tvYmplY3QgT2JqZWN0XScpIHtcbiAgICBlbmQgPSBlbmRDYWxsYmFjay5lbmQ7XG4gICAgc3RhcnQgPSBlbmRDYWxsYmFjay5zdGFydDtcbiAgICBhY3RpdmUgPSBlbmRDYWxsYmFjay5hY3RpdmU7XG4gIH1cblxuICBpZiAobm9kZS5yY0VuZExpc3RlbmVyKSB7XG4gICAgbm9kZS5yY0VuZExpc3RlbmVyKCk7XG4gIH1cblxuICBub2RlLnJjRW5kTGlzdGVuZXIgPSBmdW5jdGlvbiAoZSkge1xuICAgIGlmIChlICYmIGUudGFyZ2V0ICE9PSBub2RlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKG5vZGUucmNBbmltVGltZW91dCkge1xuICAgICAgY2xlYXJUaW1lb3V0KG5vZGUucmNBbmltVGltZW91dCk7XG4gICAgICBub2RlLnJjQW5pbVRpbWVvdXQgPSBudWxsO1xuICAgIH1cblxuICAgIGNsZWFyQnJvd3NlckJ1Z1RpbWVvdXQobm9kZSk7XG5cbiAgICBub2RlQ2xhc3Nlcy5yZW1vdmUoY2xhc3NOYW1lKTtcbiAgICBub2RlQ2xhc3Nlcy5yZW1vdmUoYWN0aXZlQ2xhc3NOYW1lKTtcblxuICAgIF9FdmVudDJbXCJkZWZhdWx0XCJdLnJlbW92ZUVuZEV2ZW50TGlzdGVuZXIobm9kZSwgbm9kZS5yY0VuZExpc3RlbmVyKTtcbiAgICBub2RlLnJjRW5kTGlzdGVuZXIgPSBudWxsO1xuXG4gICAgLy8gVXN1YWxseSB0aGlzIG9wdGlvbmFsIGVuZCBpcyB1c2VkIGZvciBpbmZvcm1pbmcgYW4gb3duZXIgb2ZcbiAgICAvLyBhIGxlYXZlIGFuaW1hdGlvbiBhbmQgdGVsbGluZyBpdCB0byByZW1vdmUgdGhlIGNoaWxkLlxuICAgIGlmIChlbmQpIHtcbiAgICAgIGVuZCgpO1xuICAgIH1cbiAgfTtcblxuICBfRXZlbnQyW1wiZGVmYXVsdFwiXS5hZGRFbmRFdmVudExpc3RlbmVyKG5vZGUsIG5vZGUucmNFbmRMaXN0ZW5lcik7XG5cbiAgaWYgKHN0YXJ0KSB7XG4gICAgc3RhcnQoKTtcbiAgfVxuICBub2RlQ2xhc3Nlcy5hZGQoY2xhc3NOYW1lKTtcblxuICBub2RlLnJjQW5pbVRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICBub2RlLnJjQW5pbVRpbWVvdXQgPSBudWxsO1xuICAgIG5vZGVDbGFzc2VzLmFkZChhY3RpdmVDbGFzc05hbWUpO1xuICAgIGlmIChhY3RpdmUpIHtcbiAgICAgIHNldFRpbWVvdXQoYWN0aXZlLCAwKTtcbiAgICB9XG4gICAgZml4QnJvd3NlckJ5VGltZW91dChub2RlKTtcbiAgICAvLyAzMG1zIGZvciBmaXJlZm94XG4gIH0sIDMwKTtcblxuICByZXR1cm4ge1xuICAgIHN0b3A6IGZ1bmN0aW9uIHN0b3AoKSB7XG4gICAgICBpZiAobm9kZS5yY0VuZExpc3RlbmVyKSB7XG4gICAgICAgIG5vZGUucmNFbmRMaXN0ZW5lcigpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbn07XG5cbmNzc0FuaW1hdGlvbi5zdHlsZSA9IGZ1bmN0aW9uIChub2RlLCBzdHlsZSwgY2FsbGJhY2spIHtcbiAgaWYgKG5vZGUucmNFbmRMaXN0ZW5lcikge1xuICAgIG5vZGUucmNFbmRMaXN0ZW5lcigpO1xuICB9XG5cbiAgbm9kZS5yY0VuZExpc3RlbmVyID0gZnVuY3Rpb24gKGUpIHtcbiAgICBpZiAoZSAmJiBlLnRhcmdldCAhPT0gbm9kZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChub2RlLnJjQW5pbVRpbWVvdXQpIHtcbiAgICAgIGNsZWFyVGltZW91dChub2RlLnJjQW5pbVRpbWVvdXQpO1xuICAgICAgbm9kZS5yY0FuaW1UaW1lb3V0ID0gbnVsbDtcbiAgICB9XG5cbiAgICBjbGVhckJyb3dzZXJCdWdUaW1lb3V0KG5vZGUpO1xuXG4gICAgX0V2ZW50MltcImRlZmF1bHRcIl0ucmVtb3ZlRW5kRXZlbnRMaXN0ZW5lcihub2RlLCBub2RlLnJjRW5kTGlzdGVuZXIpO1xuICAgIG5vZGUucmNFbmRMaXN0ZW5lciA9IG51bGw7XG5cbiAgICAvLyBVc3VhbGx5IHRoaXMgb3B0aW9uYWwgY2FsbGJhY2sgaXMgdXNlZCBmb3IgaW5mb3JtaW5nIGFuIG93bmVyIG9mXG4gICAgLy8gYSBsZWF2ZSBhbmltYXRpb24gYW5kIHRlbGxpbmcgaXQgdG8gcmVtb3ZlIHRoZSBjaGlsZC5cbiAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgIGNhbGxiYWNrKCk7XG4gICAgfVxuICB9O1xuXG4gIF9FdmVudDJbXCJkZWZhdWx0XCJdLmFkZEVuZEV2ZW50TGlzdGVuZXIobm9kZSwgbm9kZS5yY0VuZExpc3RlbmVyKTtcblxuICBub2RlLnJjQW5pbVRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICBmb3IgKHZhciBzIGluIHN0eWxlKSB7XG4gICAgICBpZiAoc3R5bGUuaGFzT3duUHJvcGVydHkocykpIHtcbiAgICAgICAgbm9kZS5zdHlsZVtzXSA9IHN0eWxlW3NdO1xuICAgICAgfVxuICAgIH1cbiAgICBub2RlLnJjQW5pbVRpbWVvdXQgPSBudWxsO1xuICAgIGZpeEJyb3dzZXJCeVRpbWVvdXQobm9kZSk7XG4gIH0sIDApO1xufTtcblxuY3NzQW5pbWF0aW9uLnNldFRyYW5zaXRpb24gPSBmdW5jdGlvbiAobm9kZSwgcCwgdmFsdWUpIHtcbiAgdmFyIHByb3BlcnR5ID0gcDtcbiAgdmFyIHYgPSB2YWx1ZTtcbiAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICB2ID0gcHJvcGVydHk7XG4gICAgcHJvcGVydHkgPSAnJztcbiAgfVxuICBwcm9wZXJ0eSA9IHByb3BlcnR5IHx8ICcnO1xuICBjYXBpdGFsUHJlZml4ZXMuZm9yRWFjaChmdW5jdGlvbiAocHJlZml4KSB7XG4gICAgbm9kZS5zdHlsZVtwcmVmaXggKyAnVHJhbnNpdGlvbicgKyBwcm9wZXJ0eV0gPSB2O1xuICB9KTtcbn07XG5cbmNzc0FuaW1hdGlvbi5pc0Nzc0FuaW1hdGlvblN1cHBvcnRlZCA9IGlzQ3NzQW5pbWF0aW9uU3VwcG9ydGVkO1xuXG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IGNzc0FuaW1hdGlvbjtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3V4Y29yZS10YWJsZS9+L3V4Y29yZS1tZW51L34vcmMtbWVudS9+L3JjLWFuaW1hdGUvfi9jc3MtYW5pbWF0aW9uL2xpYi9pbmRleC5qc1xuICoqIG1vZHVsZSBpZCA9IDQ3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxudHJ5IHtcbiAgdmFyIGluZGV4ID0gcmVxdWlyZSgnaW5kZXhvZicpO1xufSBjYXRjaCAoZXJyKSB7XG4gIHZhciBpbmRleCA9IHJlcXVpcmUoJ2NvbXBvbmVudC1pbmRleG9mJyk7XG59XG5cbi8qKlxuICogV2hpdGVzcGFjZSByZWdleHAuXG4gKi9cblxudmFyIHJlID0gL1xccysvO1xuXG4vKipcbiAqIHRvU3RyaW5nIHJlZmVyZW5jZS5cbiAqL1xuXG52YXIgdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXG4vKipcbiAqIFdyYXAgYGVsYCBpbiBhIGBDbGFzc0xpc3RgLlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAqIEByZXR1cm4ge0NsYXNzTGlzdH1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihlbCl7XG4gIHJldHVybiBuZXcgQ2xhc3NMaXN0KGVsKTtcbn07XG5cbi8qKlxuICogSW5pdGlhbGl6ZSBhIG5ldyBDbGFzc0xpc3QgZm9yIGBlbGAuXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gQ2xhc3NMaXN0KGVsKSB7XG4gIGlmICghZWwgfHwgIWVsLm5vZGVUeXBlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdBIERPTSBlbGVtZW50IHJlZmVyZW5jZSBpcyByZXF1aXJlZCcpO1xuICB9XG4gIHRoaXMuZWwgPSBlbDtcbiAgdGhpcy5saXN0ID0gZWwuY2xhc3NMaXN0O1xufVxuXG4vKipcbiAqIEFkZCBjbGFzcyBgbmFtZWAgaWYgbm90IGFscmVhZHkgcHJlc2VudC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICogQHJldHVybiB7Q2xhc3NMaXN0fVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5DbGFzc0xpc3QucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uKG5hbWUpe1xuICAvLyBjbGFzc0xpc3RcbiAgaWYgKHRoaXMubGlzdCkge1xuICAgIHRoaXMubGlzdC5hZGQobmFtZSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyBmYWxsYmFja1xuICB2YXIgYXJyID0gdGhpcy5hcnJheSgpO1xuICB2YXIgaSA9IGluZGV4KGFyciwgbmFtZSk7XG4gIGlmICghfmkpIGFyci5wdXNoKG5hbWUpO1xuICB0aGlzLmVsLmNsYXNzTmFtZSA9IGFyci5qb2luKCcgJyk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBSZW1vdmUgY2xhc3MgYG5hbWVgIHdoZW4gcHJlc2VudCwgb3JcbiAqIHBhc3MgYSByZWd1bGFyIGV4cHJlc3Npb24gdG8gcmVtb3ZlXG4gKiBhbnkgd2hpY2ggbWF0Y2guXG4gKlxuICogQHBhcmFtIHtTdHJpbmd8UmVnRXhwfSBuYW1lXG4gKiBAcmV0dXJuIHtDbGFzc0xpc3R9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkNsYXNzTGlzdC5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24obmFtZSl7XG4gIGlmICgnW29iamVjdCBSZWdFeHBdJyA9PSB0b1N0cmluZy5jYWxsKG5hbWUpKSB7XG4gICAgcmV0dXJuIHRoaXMucmVtb3ZlTWF0Y2hpbmcobmFtZSk7XG4gIH1cblxuICAvLyBjbGFzc0xpc3RcbiAgaWYgKHRoaXMubGlzdCkge1xuICAgIHRoaXMubGlzdC5yZW1vdmUobmFtZSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyBmYWxsYmFja1xuICB2YXIgYXJyID0gdGhpcy5hcnJheSgpO1xuICB2YXIgaSA9IGluZGV4KGFyciwgbmFtZSk7XG4gIGlmICh+aSkgYXJyLnNwbGljZShpLCAxKTtcbiAgdGhpcy5lbC5jbGFzc05hbWUgPSBhcnIuam9pbignICcpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUmVtb3ZlIGFsbCBjbGFzc2VzIG1hdGNoaW5nIGByZWAuXG4gKlxuICogQHBhcmFtIHtSZWdFeHB9IHJlXG4gKiBAcmV0dXJuIHtDbGFzc0xpc3R9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5DbGFzc0xpc3QucHJvdG90eXBlLnJlbW92ZU1hdGNoaW5nID0gZnVuY3Rpb24ocmUpe1xuICB2YXIgYXJyID0gdGhpcy5hcnJheSgpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgIGlmIChyZS50ZXN0KGFycltpXSkpIHtcbiAgICAgIHRoaXMucmVtb3ZlKGFycltpXSk7XG4gICAgfVxuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBUb2dnbGUgY2xhc3MgYG5hbWVgLCBjYW4gZm9yY2Ugc3RhdGUgdmlhIGBmb3JjZWAuXG4gKlxuICogRm9yIGJyb3dzZXJzIHRoYXQgc3VwcG9ydCBjbGFzc0xpc3QsIGJ1dCBkbyBub3Qgc3VwcG9ydCBgZm9yY2VgIHlldCxcbiAqIHRoZSBtaXN0YWtlIHdpbGwgYmUgZGV0ZWN0ZWQgYW5kIGNvcnJlY3RlZC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICogQHBhcmFtIHtCb29sZWFufSBmb3JjZVxuICogQHJldHVybiB7Q2xhc3NMaXN0fVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5DbGFzc0xpc3QucHJvdG90eXBlLnRvZ2dsZSA9IGZ1bmN0aW9uKG5hbWUsIGZvcmNlKXtcbiAgLy8gY2xhc3NMaXN0XG4gIGlmICh0aGlzLmxpc3QpIHtcbiAgICBpZiAoXCJ1bmRlZmluZWRcIiAhPT0gdHlwZW9mIGZvcmNlKSB7XG4gICAgICBpZiAoZm9yY2UgIT09IHRoaXMubGlzdC50b2dnbGUobmFtZSwgZm9yY2UpKSB7XG4gICAgICAgIHRoaXMubGlzdC50b2dnbGUobmFtZSk7IC8vIHRvZ2dsZSBhZ2FpbiB0byBjb3JyZWN0XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMubGlzdC50b2dnbGUobmFtZSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gZmFsbGJhY2tcbiAgaWYgKFwidW5kZWZpbmVkXCIgIT09IHR5cGVvZiBmb3JjZSkge1xuICAgIGlmICghZm9yY2UpIHtcbiAgICAgIHRoaXMucmVtb3ZlKG5hbWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmFkZChuYW1lKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKHRoaXMuaGFzKG5hbWUpKSB7XG4gICAgICB0aGlzLnJlbW92ZShuYW1lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5hZGQobmFtZSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFJldHVybiBhbiBhcnJheSBvZiBjbGFzc2VzLlxuICpcbiAqIEByZXR1cm4ge0FycmF5fVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5DbGFzc0xpc3QucHJvdG90eXBlLmFycmF5ID0gZnVuY3Rpb24oKXtcbiAgdmFyIGNsYXNzTmFtZSA9IHRoaXMuZWwuZ2V0QXR0cmlidXRlKCdjbGFzcycpIHx8ICcnO1xuICB2YXIgc3RyID0gY2xhc3NOYW1lLnJlcGxhY2UoL15cXHMrfFxccyskL2csICcnKTtcbiAgdmFyIGFyciA9IHN0ci5zcGxpdChyZSk7XG4gIGlmICgnJyA9PT0gYXJyWzBdKSBhcnIuc2hpZnQoKTtcbiAgcmV0dXJuIGFycjtcbn07XG5cbi8qKlxuICogQ2hlY2sgaWYgY2xhc3MgYG5hbWVgIGlzIHByZXNlbnQuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAqIEByZXR1cm4ge0NsYXNzTGlzdH1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuQ2xhc3NMaXN0LnByb3RvdHlwZS5oYXMgPVxuQ2xhc3NMaXN0LnByb3RvdHlwZS5jb250YWlucyA9IGZ1bmN0aW9uKG5hbWUpe1xuICByZXR1cm4gdGhpcy5saXN0XG4gICAgPyB0aGlzLmxpc3QuY29udGFpbnMobmFtZSlcbiAgICA6ICEhIH5pbmRleCh0aGlzLmFycmF5KCksIG5hbWUpO1xufTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3V4Y29yZS10YWJsZS9+L3V4Y29yZS1tZW51L34vcmMtbWVudS9+L3JjLWFuaW1hdGUvfi9jc3MtYW5pbWF0aW9uL34vY29tcG9uZW50LWNsYXNzZXMvaW5kZXguanNcbiAqKiBtb2R1bGUgaWQgPSA0OVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vVHJpZ2dlcicpO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3V4Y29yZS10YWJsZS9+L3V4Y29yZS1kcm9wZG93bi9+L3JjLWRyb3Bkb3duL34vcmMtdHJpZ2dlci9saWIvaW5kZXguanNcbiAqKiBtb2R1bGUgaWQgPSA2MFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG52YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblxudmFyIF9yZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5cbnZhciBfcmVhY3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmVhY3QpO1xuXG52YXIgX3JlYWN0RG9tID0gcmVxdWlyZSgncmVhY3QtZG9tJyk7XG5cbnZhciBfcmVhY3REb20yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmVhY3REb20pO1xuXG52YXIgX3JjVXRpbCA9IHJlcXVpcmUoJ3JjLXV0aWwnKTtcblxudmFyIF9Qb3B1cCA9IHJlcXVpcmUoJy4vUG9wdXAnKTtcblxudmFyIF9Qb3B1cDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9Qb3B1cCk7XG5cbnZhciBfdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IFwiZGVmYXVsdFwiOiBvYmogfTsgfVxuXG5mdW5jdGlvbiBub29wKCkge31cblxuZnVuY3Rpb24gcmV0dXJuRW1wdHlTdHJpbmcoKSB7XG4gIHJldHVybiAnJztcbn1cblxudmFyIEFMTF9IQU5ETEVSUyA9IFsnb25DbGljaycsICdvbk1vdXNlRG93bicsICdvblRvdWNoU3RhcnQnLCAnb25Nb3VzZUVudGVyJywgJ29uTW91c2VMZWF2ZScsICdvbkZvY3VzJywgJ29uQmx1ciddO1xuXG52YXIgVHJpZ2dlciA9IF9yZWFjdDJbXCJkZWZhdWx0XCJdLmNyZWF0ZUNsYXNzKHtcbiAgZGlzcGxheU5hbWU6ICdUcmlnZ2VyJyxcblxuICBwcm9wVHlwZXM6IHtcbiAgICBhY3Rpb246IF9yZWFjdC5Qcm9wVHlwZXMuYW55LFxuICAgIHNob3dBY3Rpb246IF9yZWFjdC5Qcm9wVHlwZXMuYW55LFxuICAgIGhpZGVBY3Rpb246IF9yZWFjdC5Qcm9wVHlwZXMuYW55LFxuICAgIGdldFBvcHVwQ2xhc3NOYW1lRnJvbUFsaWduOiBfcmVhY3QuUHJvcFR5cGVzLmFueSxcbiAgICBvblBvcHVwVmlzaWJsZUNoYW5nZTogX3JlYWN0LlByb3BUeXBlcy5mdW5jLFxuICAgIGFmdGVyUG9wdXBWaXNpYmxlQ2hhbmdlOiBfcmVhY3QuUHJvcFR5cGVzLmZ1bmMsXG4gICAgcG9wdXA6IF9yZWFjdC5Qcm9wVHlwZXMubm9kZS5pc1JlcXVpcmVkLFxuICAgIHBvcHVwU3R5bGU6IF9yZWFjdC5Qcm9wVHlwZXMub2JqZWN0LFxuICAgIHByZWZpeENsczogX3JlYWN0LlByb3BUeXBlcy5zdHJpbmcsXG4gICAgcG9wdXBDbGFzc05hbWU6IF9yZWFjdC5Qcm9wVHlwZXMuc3RyaW5nLFxuICAgIHBvcHVwUGxhY2VtZW50OiBfcmVhY3QuUHJvcFR5cGVzLnN0cmluZyxcbiAgICBidWlsdGluUGxhY2VtZW50czogX3JlYWN0LlByb3BUeXBlcy5vYmplY3QsXG4gICAgcG9wdXBUcmFuc2l0aW9uTmFtZTogX3JlYWN0LlByb3BUeXBlcy5zdHJpbmcsXG4gICAgcG9wdXBBbmltYXRpb246IF9yZWFjdC5Qcm9wVHlwZXMuYW55LFxuICAgIG1vdXNlRW50ZXJEZWxheTogX3JlYWN0LlByb3BUeXBlcy5udW1iZXIsXG4gICAgbW91c2VMZWF2ZURlbGF5OiBfcmVhY3QuUHJvcFR5cGVzLm51bWJlcixcbiAgICB6SW5kZXg6IF9yZWFjdC5Qcm9wVHlwZXMubnVtYmVyLFxuICAgIGZvY3VzRGVsYXk6IF9yZWFjdC5Qcm9wVHlwZXMubnVtYmVyLFxuICAgIGJsdXJEZWxheTogX3JlYWN0LlByb3BUeXBlcy5udW1iZXIsXG4gICAgZ2V0UG9wdXBDb250YWluZXI6IF9yZWFjdC5Qcm9wVHlwZXMuZnVuYyxcbiAgICBkZXN0cm95UG9wdXBPbkhpZGU6IF9yZWFjdC5Qcm9wVHlwZXMuYm9vbCxcbiAgICBtYXNrOiBfcmVhY3QuUHJvcFR5cGVzLmJvb2wsXG4gICAgb25Qb3B1cEFsaWduOiBfcmVhY3QuUHJvcFR5cGVzLmZ1bmMsXG4gICAgcG9wdXBBbGlnbjogX3JlYWN0LlByb3BUeXBlcy5vYmplY3QsXG4gICAgcG9wdXBWaXNpYmxlOiBfcmVhY3QuUHJvcFR5cGVzLmJvb2wsXG4gICAgbWFza1RyYW5zaXRpb25OYW1lOiBfcmVhY3QuUHJvcFR5cGVzLnN0cmluZyxcbiAgICBtYXNrQW5pbWF0aW9uOiBfcmVhY3QuUHJvcFR5cGVzLnN0cmluZ1xuICB9LFxuXG4gIGdldERlZmF1bHRQcm9wczogZnVuY3Rpb24gZ2V0RGVmYXVsdFByb3BzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBwcmVmaXhDbHM6ICdyYy10cmlnZ2VyLXBvcHVwJyxcbiAgICAgIGdldFBvcHVwQ2xhc3NOYW1lRnJvbUFsaWduOiByZXR1cm5FbXB0eVN0cmluZyxcbiAgICAgIG9uUG9wdXBWaXNpYmxlQ2hhbmdlOiBub29wLFxuICAgICAgYWZ0ZXJQb3B1cFZpc2libGVDaGFuZ2U6IG5vb3AsXG4gICAgICBvblBvcHVwQWxpZ246IG5vb3AsXG4gICAgICBwb3B1cENsYXNzTmFtZTogJycsXG4gICAgICBtb3VzZUVudGVyRGVsYXk6IDAsXG4gICAgICBtb3VzZUxlYXZlRGVsYXk6IDAuMSxcbiAgICAgIGZvY3VzRGVsYXk6IDAsXG4gICAgICBibHVyRGVsYXk6IDAuMTUsXG4gICAgICBwb3B1cFN0eWxlOiB7fSxcbiAgICAgIGRlc3Ryb3lQb3B1cE9uSGlkZTogZmFsc2UsXG4gICAgICBwb3B1cEFsaWduOiB7fSxcbiAgICAgIGRlZmF1bHRQb3B1cFZpc2libGU6IGZhbHNlLFxuICAgICAgbWFzazogZmFsc2UsXG4gICAgICBhY3Rpb246IFtdLFxuICAgICAgc2hvd0FjdGlvbjogW10sXG4gICAgICBoaWRlQWN0aW9uOiBbXVxuICAgIH07XG4gIH0sXG4gIGdldEluaXRpYWxTdGF0ZTogZnVuY3Rpb24gZ2V0SW5pdGlhbFN0YXRlKCkge1xuICAgIHZhciBwcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgdmFyIHBvcHVwVmlzaWJsZSA9IHZvaWQgMDtcbiAgICBpZiAoJ3BvcHVwVmlzaWJsZScgaW4gcHJvcHMpIHtcbiAgICAgIHBvcHVwVmlzaWJsZSA9ICEhcHJvcHMucG9wdXBWaXNpYmxlO1xuICAgIH0gZWxzZSB7XG4gICAgICBwb3B1cFZpc2libGUgPSAhIXByb3BzLmRlZmF1bHRQb3B1cFZpc2libGU7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBwb3B1cFZpc2libGU6IHBvcHVwVmlzaWJsZVxuICAgIH07XG4gIH0sXG4gIGNvbXBvbmVudERpZE1vdW50OiBmdW5jdGlvbiBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICB0aGlzLmNvbXBvbmVudERpZFVwZGF0ZSh7fSwge1xuICAgICAgcG9wdXBWaXNpYmxlOiB0aGlzLnN0YXRlLnBvcHVwVmlzaWJsZVxuICAgIH0pO1xuICB9LFxuICBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzOiBmdW5jdGlvbiBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKG5leHRQcm9wcykge1xuICAgIGlmICgncG9wdXBWaXNpYmxlJyBpbiBuZXh0UHJvcHMpIHtcbiAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICBwb3B1cFZpc2libGU6ICEhbmV4dFByb3BzLnBvcHVwVmlzaWJsZVxuICAgICAgfSk7XG4gICAgfVxuICB9LFxuICBjb21wb25lbnREaWRVcGRhdGU6IGZ1bmN0aW9uIGNvbXBvbmVudERpZFVwZGF0ZShwcmV2UHJvcHMsIHByZXZTdGF0ZSkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICB2YXIgcHJvcHMgPSB0aGlzLnByb3BzO1xuICAgIHZhciBzdGF0ZSA9IHRoaXMuc3RhdGU7XG4gICAgaWYgKHRoaXMucG9wdXBSZW5kZXJlZCkge1xuICAgICAgdmFyIF9yZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBzZWxmID0gX3RoaXM7XG4gICAgICAgIHNlbGYucG9wdXBJbnN0YW5jZSA9IF9yZWFjdERvbTJbXCJkZWZhdWx0XCJdLnVuc3RhYmxlX3JlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyKF90aGlzLCBfdGhpcy5nZXRQb3B1cEVsZW1lbnQoKSwgX3RoaXMuZ2V0UG9wdXBDb250YWluZXIoKSwgZnVuY3Rpb24gcmVuZGVyUG9wdXAoKSB7XG4gICAgICAgICAgLyogZXNsaW50IHJlYWN0L25vLWlzLW1vdW50ZWQ6MCAqL1xuICAgICAgICAgIGlmICh0aGlzLmlzTW91bnRlZCgpKSB7XG4gICAgICAgICAgICBzZWxmLnBvcHVwRG9tTm9kZSA9IHRoaXMuZ2V0UG9wdXBEb21Ob2RlKCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNlbGYucG9wdXBEb21Ob2RlID0gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHByZXZTdGF0ZS5wb3B1cFZpc2libGUgIT09IHN0YXRlLnBvcHVwVmlzaWJsZSkge1xuICAgICAgICAgICAgcHJvcHMuYWZ0ZXJQb3B1cFZpc2libGVDaGFuZ2Uoc3RhdGUucG9wdXBWaXNpYmxlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoX3RoaXMuaXNDbGlja1RvSGlkZSgpKSB7XG4gICAgICAgICAgaWYgKHN0YXRlLnBvcHVwVmlzaWJsZSkge1xuICAgICAgICAgICAgaWYgKCFfdGhpcy5jbGlja091dHNpZGVIYW5kbGVyKSB7XG4gICAgICAgICAgICAgIF90aGlzLmNsaWNrT3V0c2lkZUhhbmRsZXIgPSBfcmNVdGlsLkRvbS5hZGRFdmVudExpc3RlbmVyKGRvY3VtZW50LCAnbW91c2Vkb3duJywgX3RoaXMub25Eb2N1bWVudENsaWNrKTtcbiAgICAgICAgICAgICAgX3RoaXMudG91Y2hPdXRzaWRlSGFuZGxlciA9IF9yY1V0aWwuRG9tLmFkZEV2ZW50TGlzdGVuZXIoZG9jdW1lbnQsICd0b3VjaHN0YXJ0JywgX3RoaXMub25Eb2N1bWVudENsaWNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIHY6IHZvaWQgMFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKF90aGlzLmNsaWNrT3V0c2lkZUhhbmRsZXIpIHtcbiAgICAgICAgICBfdGhpcy5jbGlja091dHNpZGVIYW5kbGVyLnJlbW92ZSgpO1xuICAgICAgICAgIF90aGlzLnRvdWNoT3V0c2lkZUhhbmRsZXIucmVtb3ZlKCk7XG4gICAgICAgICAgX3RoaXMuY2xpY2tPdXRzaWRlSGFuZGxlciA9IG51bGw7XG4gICAgICAgICAgX3RoaXMudG91Y2hPdXRzaWRlSGFuZGxlciA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH0oKTtcblxuICAgICAgaWYgKCh0eXBlb2YgX3JldCA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YoX3JldCkpID09PSBcIm9iamVjdFwiKSByZXR1cm4gX3JldC52O1xuICAgIH1cbiAgfSxcbiAgY29tcG9uZW50V2lsbFVubW91bnQ6IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgIHZhciBwb3B1cENvbnRhaW5lciA9IHRoaXMucG9wdXBDb250YWluZXI7XG4gICAgaWYgKHBvcHVwQ29udGFpbmVyKSB7XG4gICAgICBfcmVhY3REb20yW1wiZGVmYXVsdFwiXS51bm1vdW50Q29tcG9uZW50QXROb2RlKHBvcHVwQ29udGFpbmVyKTtcbiAgICAgIHBvcHVwQ29udGFpbmVyLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQocG9wdXBDb250YWluZXIpO1xuICAgICAgdGhpcy5wb3B1cENvbnRhaW5lciA9IG51bGw7XG4gICAgfVxuICAgIHRoaXMuY2xlYXJEZWxheVRpbWVyKCk7XG4gICAgaWYgKHRoaXMuY2xpY2tPdXRzaWRlSGFuZGxlcikge1xuICAgICAgdGhpcy5jbGlja091dHNpZGVIYW5kbGVyLnJlbW92ZSgpO1xuICAgICAgdGhpcy50b3VjaE91dHNpZGVIYW5kbGVyLnJlbW92ZSgpO1xuICAgICAgdGhpcy5jbGlja091dHNpZGVIYW5kbGVyID0gbnVsbDtcbiAgICAgIHRoaXMudG91Y2hPdXRzaWRlSGFuZGxlciA9IG51bGw7XG4gICAgfVxuICB9LFxuICBvbk1vdXNlRW50ZXI6IGZ1bmN0aW9uIG9uTW91c2VFbnRlcigpIHtcbiAgICB0aGlzLmRlbGF5U2V0UG9wdXBWaXNpYmxlKHRydWUsIHRoaXMucHJvcHMubW91c2VFbnRlckRlbGF5KTtcbiAgfSxcbiAgb25Nb3VzZUxlYXZlOiBmdW5jdGlvbiBvbk1vdXNlTGVhdmUoZSkge1xuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9yZWFjdC1jb21wb25lbnQvdHJpZ2dlci9wdWxsLzEzXG4gICAgLy8gcmVhY3QgYnVnP1xuICAgIGlmIChlLnJlbGF0ZWRUYXJnZXQgJiYgIWUucmVsYXRlZFRhcmdldC5zZXRUaW1lb3V0ICYmIF9yY1V0aWwuRG9tLmNvbnRhaW5zKHRoaXMucG9wdXBDb250YWluZXIsIGUucmVsYXRlZFRhcmdldCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5kZWxheVNldFBvcHVwVmlzaWJsZShmYWxzZSwgdGhpcy5wcm9wcy5tb3VzZUxlYXZlRGVsYXkpO1xuICB9LFxuICBvbkZvY3VzOiBmdW5jdGlvbiBvbkZvY3VzKCkge1xuICAgIC8vIGluY2FzZSBmb2N1c2luIGFuZCBmb2N1c291dFxuICAgIHRoaXMuY2xlYXJEZWxheVRpbWVyKCk7XG4gICAgaWYgKHRoaXMuaXNGb2N1c1RvU2hvdygpKSB7XG4gICAgICB0aGlzLmZvY3VzVGltZSA9IERhdGUubm93KCk7XG4gICAgICB0aGlzLmRlbGF5U2V0UG9wdXBWaXNpYmxlKHRydWUsIHRoaXMucHJvcHMuZm9jdXNEZWxheSk7XG4gICAgfVxuICB9LFxuICBvbk1vdXNlRG93bjogZnVuY3Rpb24gb25Nb3VzZURvd24oKSB7XG4gICAgdGhpcy5wcmVDbGlja1RpbWUgPSBEYXRlLm5vdygpO1xuICB9LFxuICBvblRvdWNoU3RhcnQ6IGZ1bmN0aW9uIG9uVG91Y2hTdGFydCgpIHtcbiAgICB0aGlzLnByZVRvdWNoVGltZSA9IERhdGUubm93KCk7XG4gIH0sXG4gIG9uQmx1cjogZnVuY3Rpb24gb25CbHVyKCkge1xuICAgIHRoaXMuY2xlYXJEZWxheVRpbWVyKCk7XG4gICAgaWYgKHRoaXMuaXNCbHVyVG9IaWRlKCkpIHtcbiAgICAgIHRoaXMuZGVsYXlTZXRQb3B1cFZpc2libGUoZmFsc2UsIHRoaXMucHJvcHMuYmx1ckRlbGF5KTtcbiAgICB9XG4gIH0sXG4gIG9uQ2xpY2s6IGZ1bmN0aW9uIG9uQ2xpY2soZXZlbnQpIHtcbiAgICAvLyBmb2N1cyB3aWxsIHRyaWdnZXIgY2xpY2tcbiAgICBpZiAodGhpcy5mb2N1c1RpbWUpIHtcbiAgICAgIHZhciBwcmVUaW1lID0gdm9pZCAwO1xuICAgICAgaWYgKHRoaXMucHJlQ2xpY2tUaW1lICYmIHRoaXMucHJlVG91Y2hUaW1lKSB7XG4gICAgICAgIHByZVRpbWUgPSBNYXRoLm1pbih0aGlzLnByZUNsaWNrVGltZSwgdGhpcy5wcmVUb3VjaFRpbWUpO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLnByZUNsaWNrVGltZSkge1xuICAgICAgICBwcmVUaW1lID0gdGhpcy5wcmVDbGlja1RpbWU7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMucHJlVG91Y2hUaW1lKSB7XG4gICAgICAgIHByZVRpbWUgPSB0aGlzLnByZVRvdWNoVGltZTtcbiAgICAgIH1cbiAgICAgIGlmIChNYXRoLmFicyhwcmVUaW1lIC0gdGhpcy5mb2N1c1RpbWUpIDwgMjApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5mb2N1c1RpbWUgPSAwO1xuICAgIH1cbiAgICB0aGlzLnByZUNsaWNrVGltZSA9IDA7XG4gICAgdGhpcy5wcmVUb3VjaFRpbWUgPSAwO1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgdmFyIG5leHRWaXNpYmxlID0gIXRoaXMuc3RhdGUucG9wdXBWaXNpYmxlO1xuICAgIGlmICh0aGlzLmlzQ2xpY2tUb0hpZGUoKSAmJiAhbmV4dFZpc2libGUgfHwgbmV4dFZpc2libGUgJiYgdGhpcy5pc0NsaWNrVG9TaG93KCkpIHtcbiAgICAgIHRoaXMuc2V0UG9wdXBWaXNpYmxlKCF0aGlzLnN0YXRlLnBvcHVwVmlzaWJsZSk7XG4gICAgfVxuICB9LFxuICBvbkRvY3VtZW50Q2xpY2s6IGZ1bmN0aW9uIG9uRG9jdW1lbnRDbGljayhldmVudCkge1xuICAgIHZhciB0YXJnZXQgPSBldmVudC50YXJnZXQ7XG4gICAgdmFyIHJvb3QgPSAoMCwgX3JlYWN0RG9tLmZpbmRET01Ob2RlKSh0aGlzKTtcbiAgICB2YXIgcG9wdXBOb2RlID0gdGhpcy5nZXRQb3B1cERvbU5vZGUoKTtcbiAgICBpZiAoIV9yY1V0aWwuRG9tLmNvbnRhaW5zKHJvb3QsIHRhcmdldCkgJiYgIV9yY1V0aWwuRG9tLmNvbnRhaW5zKHBvcHVwTm9kZSwgdGFyZ2V0KSkge1xuICAgICAgdGhpcy5zZXRQb3B1cFZpc2libGUoZmFsc2UpO1xuICAgIH1cbiAgfSxcbiAgZ2V0UG9wdXBEb21Ob2RlOiBmdW5jdGlvbiBnZXRQb3B1cERvbU5vZGUoKSB7XG4gICAgLy8gZm9yIHRlc3RcbiAgICByZXR1cm4gdGhpcy5wb3B1cERvbU5vZGU7XG4gIH0sXG4gIGdldFJvb3REb21Ob2RlOiBmdW5jdGlvbiBnZXRSb290RG9tTm9kZSgpIHtcbiAgICByZXR1cm4gX3JlYWN0RG9tMltcImRlZmF1bHRcIl0uZmluZERPTU5vZGUodGhpcyk7XG4gIH0sXG4gIGdldFBvcHVwQ29udGFpbmVyOiBmdW5jdGlvbiBnZXRQb3B1cENvbnRhaW5lcigpIHtcbiAgICBpZiAoIXRoaXMucG9wdXBDb250YWluZXIpIHtcbiAgICAgIHRoaXMucG9wdXBDb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIHZhciBtb3VudE5vZGUgPSB0aGlzLnByb3BzLmdldFBvcHVwQ29udGFpbmVyID8gdGhpcy5wcm9wcy5nZXRQb3B1cENvbnRhaW5lcigoMCwgX3JlYWN0RG9tLmZpbmRET01Ob2RlKSh0aGlzKSkgOiBkb2N1bWVudC5ib2R5O1xuICAgICAgbW91bnROb2RlLmFwcGVuZENoaWxkKHRoaXMucG9wdXBDb250YWluZXIpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5wb3B1cENvbnRhaW5lcjtcbiAgfSxcbiAgZ2V0UG9wdXBDbGFzc05hbWVGcm9tQWxpZ246IGZ1bmN0aW9uIGdldFBvcHVwQ2xhc3NOYW1lRnJvbUFsaWduKGFsaWduKSB7XG4gICAgdmFyIGNsYXNzTmFtZSA9IFtdO1xuICAgIHZhciBwcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgdmFyIHBvcHVwUGxhY2VtZW50ID0gcHJvcHMucG9wdXBQbGFjZW1lbnQ7XG4gICAgdmFyIGJ1aWx0aW5QbGFjZW1lbnRzID0gcHJvcHMuYnVpbHRpblBsYWNlbWVudHM7XG4gICAgdmFyIHByZWZpeENscyA9IHByb3BzLnByZWZpeENscztcblxuICAgIGlmIChwb3B1cFBsYWNlbWVudCAmJiBidWlsdGluUGxhY2VtZW50cykge1xuICAgICAgY2xhc3NOYW1lLnB1c2goKDAsIF91dGlscy5nZXRQb3B1cENsYXNzTmFtZUZyb21BbGlnbikoYnVpbHRpblBsYWNlbWVudHMsIHByZWZpeENscywgYWxpZ24pKTtcbiAgICB9XG4gICAgaWYgKHByb3BzLmdldFBvcHVwQ2xhc3NOYW1lRnJvbUFsaWduKSB7XG4gICAgICBjbGFzc05hbWUucHVzaChwcm9wcy5nZXRQb3B1cENsYXNzTmFtZUZyb21BbGlnbihhbGlnbikpO1xuICAgIH1cbiAgICByZXR1cm4gY2xhc3NOYW1lLmpvaW4oJyAnKTtcbiAgfSxcbiAgZ2V0UG9wdXBBbGlnbjogZnVuY3Rpb24gZ2V0UG9wdXBBbGlnbigpIHtcbiAgICB2YXIgcHJvcHMgPSB0aGlzLnByb3BzO1xuICAgIHZhciBwb3B1cFBsYWNlbWVudCA9IHByb3BzLnBvcHVwUGxhY2VtZW50O1xuICAgIHZhciBwb3B1cEFsaWduID0gcHJvcHMucG9wdXBBbGlnbjtcbiAgICB2YXIgYnVpbHRpblBsYWNlbWVudHMgPSBwcm9wcy5idWlsdGluUGxhY2VtZW50cztcblxuICAgIGlmIChwb3B1cFBsYWNlbWVudCAmJiBidWlsdGluUGxhY2VtZW50cykge1xuICAgICAgcmV0dXJuICgwLCBfdXRpbHMuZ2V0QWxpZ25Gcm9tUGxhY2VtZW50KShidWlsdGluUGxhY2VtZW50cywgcG9wdXBQbGFjZW1lbnQsIHBvcHVwQWxpZ24pO1xuICAgIH1cbiAgICByZXR1cm4gcG9wdXBBbGlnbjtcbiAgfSxcbiAgZ2V0UG9wdXBFbGVtZW50OiBmdW5jdGlvbiBnZXRQb3B1cEVsZW1lbnQoKSB7XG4gICAgdmFyIHByb3BzID0gdGhpcy5wcm9wcztcbiAgICB2YXIgc3RhdGUgPSB0aGlzLnN0YXRlO1xuXG4gICAgdmFyIG1vdXNlUHJvcHMgPSB7fTtcbiAgICBpZiAodGhpcy5pc01vdXNlRW50ZXJUb1Nob3coKSkge1xuICAgICAgbW91c2VQcm9wcy5vbk1vdXNlRW50ZXIgPSB0aGlzLm9uTW91c2VFbnRlcjtcbiAgICB9XG4gICAgaWYgKHRoaXMuaXNNb3VzZUxlYXZlVG9IaWRlKCkpIHtcbiAgICAgIG1vdXNlUHJvcHMub25Nb3VzZUxlYXZlID0gdGhpcy5vbk1vdXNlTGVhdmU7XG4gICAgfVxuICAgIHJldHVybiBfcmVhY3QyW1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFxuICAgICAgX1BvcHVwMltcImRlZmF1bHRcIl0sXG4gICAgICBfZXh0ZW5kcyh7XG4gICAgICAgIHByZWZpeENsczogcHJvcHMucHJlZml4Q2xzLFxuICAgICAgICBkZXN0cm95UG9wdXBPbkhpZGU6IHByb3BzLmRlc3Ryb3lQb3B1cE9uSGlkZSxcbiAgICAgICAgdmlzaWJsZTogc3RhdGUucG9wdXBWaXNpYmxlLFxuICAgICAgICBjbGFzc05hbWU6IHByb3BzLnBvcHVwQ2xhc3NOYW1lLFxuICAgICAgICBhY3Rpb246IHByb3BzLmFjdGlvbixcbiAgICAgICAgYWxpZ246IHRoaXMuZ2V0UG9wdXBBbGlnbigpLFxuICAgICAgICBvbkFsaWduOiBwcm9wcy5vblBvcHVwQWxpZ24sXG4gICAgICAgIGFuaW1hdGlvbjogcHJvcHMucG9wdXBBbmltYXRpb24sXG4gICAgICAgIGdldENsYXNzTmFtZUZyb21BbGlnbjogdGhpcy5nZXRQb3B1cENsYXNzTmFtZUZyb21BbGlnblxuICAgICAgfSwgbW91c2VQcm9wcywge1xuICAgICAgICBnZXRSb290RG9tTm9kZTogdGhpcy5nZXRSb290RG9tTm9kZSxcbiAgICAgICAgc3R5bGU6IHByb3BzLnBvcHVwU3R5bGUsXG4gICAgICAgIG1hc2s6IHByb3BzLm1hc2ssXG4gICAgICAgIHpJbmRleDogcHJvcHMuekluZGV4LFxuICAgICAgICB0cmFuc2l0aW9uTmFtZTogcHJvcHMucG9wdXBUcmFuc2l0aW9uTmFtZSxcbiAgICAgICAgbWFza0FuaW1hdGlvbjogcHJvcHMubWFza0FuaW1hdGlvbixcbiAgICAgICAgbWFza1RyYW5zaXRpb25OYW1lOiBwcm9wcy5tYXNrVHJhbnNpdGlvbk5hbWVcbiAgICAgIH0pLFxuICAgICAgcHJvcHMucG9wdXBcbiAgICApO1xuICB9LFxuICBzZXRQb3B1cFZpc2libGU6IGZ1bmN0aW9uIHNldFBvcHVwVmlzaWJsZShwb3B1cFZpc2libGUpIHtcbiAgICB0aGlzLmNsZWFyRGVsYXlUaW1lcigpO1xuICAgIGlmICh0aGlzLnN0YXRlLnBvcHVwVmlzaWJsZSAhPT0gcG9wdXBWaXNpYmxlKSB7XG4gICAgICBpZiAoISgncG9wdXBWaXNpYmxlJyBpbiB0aGlzLnByb3BzKSkge1xuICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICBwb3B1cFZpc2libGU6IHBvcHVwVmlzaWJsZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHRoaXMucHJvcHMub25Qb3B1cFZpc2libGVDaGFuZ2UocG9wdXBWaXNpYmxlKTtcbiAgICB9XG4gIH0sXG4gIGRlbGF5U2V0UG9wdXBWaXNpYmxlOiBmdW5jdGlvbiBkZWxheVNldFBvcHVwVmlzaWJsZSh2aXNpYmxlLCBkZWxheVMpIHtcbiAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgIHZhciBkZWxheSA9IGRlbGF5UyAqIDEwMDA7XG4gICAgdGhpcy5jbGVhckRlbGF5VGltZXIoKTtcbiAgICBpZiAoZGVsYXkpIHtcbiAgICAgIHRoaXMuZGVsYXlUaW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpczIuc2V0UG9wdXBWaXNpYmxlKHZpc2libGUpO1xuICAgICAgICBfdGhpczIuY2xlYXJEZWxheVRpbWVyKCk7XG4gICAgICB9LCBkZWxheSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc2V0UG9wdXBWaXNpYmxlKHZpc2libGUpO1xuICAgIH1cbiAgfSxcbiAgY2xlYXJEZWxheVRpbWVyOiBmdW5jdGlvbiBjbGVhckRlbGF5VGltZXIoKSB7XG4gICAgaWYgKHRoaXMuZGVsYXlUaW1lcikge1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuZGVsYXlUaW1lcik7XG4gICAgICB0aGlzLmRlbGF5VGltZXIgPSBudWxsO1xuICAgIH1cbiAgfSxcbiAgaXNDbGlja1RvU2hvdzogZnVuY3Rpb24gaXNDbGlja1RvU2hvdygpIHtcbiAgICB2YXIgX3Byb3BzID0gdGhpcy5wcm9wcztcbiAgICB2YXIgYWN0aW9uID0gX3Byb3BzLmFjdGlvbjtcbiAgICB2YXIgc2hvd0FjdGlvbiA9IF9wcm9wcy5zaG93QWN0aW9uO1xuXG4gICAgcmV0dXJuIGFjdGlvbi5pbmRleE9mKCdjbGljaycpICE9PSAtMSB8fCBzaG93QWN0aW9uLmluZGV4T2YoJ2NsaWNrJykgIT09IC0xO1xuICB9LFxuICBpc0NsaWNrVG9IaWRlOiBmdW5jdGlvbiBpc0NsaWNrVG9IaWRlKCkge1xuICAgIHZhciBfcHJvcHMyID0gdGhpcy5wcm9wcztcbiAgICB2YXIgYWN0aW9uID0gX3Byb3BzMi5hY3Rpb247XG4gICAgdmFyIGhpZGVBY3Rpb24gPSBfcHJvcHMyLmhpZGVBY3Rpb247XG5cbiAgICByZXR1cm4gYWN0aW9uLmluZGV4T2YoJ2NsaWNrJykgIT09IC0xIHx8IGhpZGVBY3Rpb24uaW5kZXhPZignY2xpY2snKSAhPT0gLTE7XG4gIH0sXG4gIGlzTW91c2VFbnRlclRvU2hvdzogZnVuY3Rpb24gaXNNb3VzZUVudGVyVG9TaG93KCkge1xuICAgIHZhciBfcHJvcHMzID0gdGhpcy5wcm9wcztcbiAgICB2YXIgYWN0aW9uID0gX3Byb3BzMy5hY3Rpb247XG4gICAgdmFyIHNob3dBY3Rpb24gPSBfcHJvcHMzLnNob3dBY3Rpb247XG5cbiAgICByZXR1cm4gYWN0aW9uLmluZGV4T2YoJ2hvdmVyJykgIT09IC0xIHx8IHNob3dBY3Rpb24uaW5kZXhPZignbW91c2VFbnRlcicpICE9PSAtMTtcbiAgfSxcbiAgaXNNb3VzZUxlYXZlVG9IaWRlOiBmdW5jdGlvbiBpc01vdXNlTGVhdmVUb0hpZGUoKSB7XG4gICAgdmFyIF9wcm9wczQgPSB0aGlzLnByb3BzO1xuICAgIHZhciBhY3Rpb24gPSBfcHJvcHM0LmFjdGlvbjtcbiAgICB2YXIgaGlkZUFjdGlvbiA9IF9wcm9wczQuaGlkZUFjdGlvbjtcblxuICAgIHJldHVybiBhY3Rpb24uaW5kZXhPZignaG92ZXInKSAhPT0gLTEgfHwgaGlkZUFjdGlvbi5pbmRleE9mKCdtb3VzZUxlYXZlJykgIT09IC0xO1xuICB9LFxuICBpc0ZvY3VzVG9TaG93OiBmdW5jdGlvbiBpc0ZvY3VzVG9TaG93KCkge1xuICAgIHZhciBfcHJvcHM1ID0gdGhpcy5wcm9wcztcbiAgICB2YXIgYWN0aW9uID0gX3Byb3BzNS5hY3Rpb247XG4gICAgdmFyIHNob3dBY3Rpb24gPSBfcHJvcHM1LnNob3dBY3Rpb247XG5cbiAgICByZXR1cm4gYWN0aW9uLmluZGV4T2YoJ2ZvY3VzJykgIT09IC0xIHx8IHNob3dBY3Rpb24uaW5kZXhPZignZm9jdXMnKSAhPT0gLTE7XG4gIH0sXG4gIGlzQmx1clRvSGlkZTogZnVuY3Rpb24gaXNCbHVyVG9IaWRlKCkge1xuICAgIHZhciBfcHJvcHM2ID0gdGhpcy5wcm9wcztcbiAgICB2YXIgYWN0aW9uID0gX3Byb3BzNi5hY3Rpb247XG4gICAgdmFyIGhpZGVBY3Rpb24gPSBfcHJvcHM2LmhpZGVBY3Rpb247XG5cbiAgICByZXR1cm4gYWN0aW9uLmluZGV4T2YoJ2ZvY3VzJykgIT09IC0xIHx8IGhpZGVBY3Rpb24uaW5kZXhPZignYmx1cicpICE9PSAtMTtcbiAgfSxcbiAgZm9yY2VQb3B1cEFsaWduOiBmdW5jdGlvbiBmb3JjZVBvcHVwQWxpZ24oKSB7XG4gICAgaWYgKHRoaXMuc3RhdGUucG9wdXBWaXNpYmxlICYmIHRoaXMucG9wdXBJbnN0YW5jZSAmJiB0aGlzLnBvcHVwSW5zdGFuY2UuYWxpZ25JbnN0YW5jZSkge1xuICAgICAgdGhpcy5wb3B1cEluc3RhbmNlLmFsaWduSW5zdGFuY2UuZm9yY2VBbGlnbigpO1xuICAgIH1cbiAgfSxcbiAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgdGhpcy5wb3B1cFJlbmRlcmVkID0gdGhpcy5wb3B1cFJlbmRlcmVkIHx8IHRoaXMuc3RhdGUucG9wdXBWaXNpYmxlO1xuICAgIHZhciBwcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgdmFyIGNoaWxkcmVuID0gcHJvcHMuY2hpbGRyZW47XG4gICAgdmFyIGNoaWxkID0gX3JlYWN0MltcImRlZmF1bHRcIl0uQ2hpbGRyZW4ub25seShjaGlsZHJlbik7XG4gICAgdmFyIGNoaWxkUHJvcHMgPSBjaGlsZC5wcm9wcyB8fCB7fTtcbiAgICB2YXIgbmV3Q2hpbGRQcm9wcyA9IHt9O1xuXG4gICAgaWYgKHRoaXMuaXNDbGlja1RvSGlkZSgpIHx8IHRoaXMuaXNDbGlja1RvU2hvdygpKSB7XG4gICAgICBuZXdDaGlsZFByb3BzLm9uQ2xpY2sgPSAoMCwgX3JjVXRpbC5jcmVhdGVDaGFpbmVkRnVuY3Rpb24pKHRoaXMub25DbGljaywgY2hpbGRQcm9wcy5vbkNsaWNrKTtcbiAgICAgIG5ld0NoaWxkUHJvcHMub25Nb3VzZURvd24gPSAoMCwgX3JjVXRpbC5jcmVhdGVDaGFpbmVkRnVuY3Rpb24pKHRoaXMub25Nb3VzZURvd24sIGNoaWxkUHJvcHMub25Nb3VzZURvd24pO1xuICAgICAgbmV3Q2hpbGRQcm9wcy5vblRvdWNoU3RhcnQgPSAoMCwgX3JjVXRpbC5jcmVhdGVDaGFpbmVkRnVuY3Rpb24pKHRoaXMub25Ub3VjaFN0YXJ0LCBjaGlsZFByb3BzLm9uVG91Y2hTdGFydCk7XG4gICAgfVxuICAgIGlmICh0aGlzLmlzTW91c2VFbnRlclRvU2hvdygpKSB7XG4gICAgICBuZXdDaGlsZFByb3BzLm9uTW91c2VFbnRlciA9ICgwLCBfcmNVdGlsLmNyZWF0ZUNoYWluZWRGdW5jdGlvbikodGhpcy5vbk1vdXNlRW50ZXIsIGNoaWxkUHJvcHMub25Nb3VzZUVudGVyKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuaXNNb3VzZUxlYXZlVG9IaWRlKCkpIHtcbiAgICAgIG5ld0NoaWxkUHJvcHMub25Nb3VzZUxlYXZlID0gKDAsIF9yY1V0aWwuY3JlYXRlQ2hhaW5lZEZ1bmN0aW9uKSh0aGlzLm9uTW91c2VMZWF2ZSwgY2hpbGRQcm9wcy5vbk1vdXNlTGVhdmUpO1xuICAgIH1cbiAgICBpZiAodGhpcy5pc0ZvY3VzVG9TaG93KCkgfHwgdGhpcy5pc0JsdXJUb0hpZGUoKSkge1xuICAgICAgbmV3Q2hpbGRQcm9wcy5vbkZvY3VzID0gKDAsIF9yY1V0aWwuY3JlYXRlQ2hhaW5lZEZ1bmN0aW9uKSh0aGlzLm9uRm9jdXMsIGNoaWxkUHJvcHMub25Gb2N1cyk7XG4gICAgICBuZXdDaGlsZFByb3BzLm9uQmx1ciA9ICgwLCBfcmNVdGlsLmNyZWF0ZUNoYWluZWRGdW5jdGlvbikodGhpcy5vbkJsdXIsIGNoaWxkUHJvcHMub25CbHVyKTtcbiAgICB9XG5cbiAgICBBTExfSEFORExFUlMuZm9yRWFjaChmdW5jdGlvbiAoaGFuZGxlcikge1xuICAgICAgdmFyIG5ld0ZuID0gdm9pZCAwO1xuICAgICAgaWYgKHByb3BzW2hhbmRsZXJdICYmIG5ld0NoaWxkUHJvcHNbaGFuZGxlcl0pIHtcbiAgICAgICAgbmV3Rm4gPSAoMCwgX3JjVXRpbC5jcmVhdGVDaGFpbmVkRnVuY3Rpb24pKHByb3BzW2hhbmRsZXJdLCBuZXdDaGlsZFByb3BzW2hhbmRsZXJdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5ld0ZuID0gcHJvcHNbaGFuZGxlcl0gfHwgbmV3Q2hpbGRQcm9wc1toYW5kbGVyXTtcbiAgICAgIH1cbiAgICAgIGlmIChuZXdGbikge1xuICAgICAgICBuZXdDaGlsZFByb3BzW2hhbmRsZXJdID0gbmV3Rm47XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gX3JlYWN0MltcImRlZmF1bHRcIl0uY2xvbmVFbGVtZW50KGNoaWxkLCBuZXdDaGlsZFByb3BzKTtcbiAgfVxufSk7XG5cbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gVHJpZ2dlcjtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3V4Y29yZS10YWJsZS9+L3V4Y29yZS1kcm9wZG93bi9+L3JjLWRyb3Bkb3duL34vcmMtdHJpZ2dlci9saWIvVHJpZ2dlci5qc1xuICoqIG1vZHVsZSBpZCA9IDYxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbnZhciBfcmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xuXG52YXIgX3JlYWN0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JlYWN0KTtcblxudmFyIF9yZWFjdERvbSA9IHJlcXVpcmUoJ3JlYWN0LWRvbScpO1xuXG52YXIgX3JlYWN0RG9tMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JlYWN0RG9tKTtcblxudmFyIF9yY0FsaWduID0gcmVxdWlyZSgncmMtYWxpZ24nKTtcblxudmFyIF9yY0FsaWduMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JjQWxpZ24pO1xuXG52YXIgX3JjQW5pbWF0ZSA9IHJlcXVpcmUoJ3JjLWFuaW1hdGUnKTtcblxudmFyIF9yY0FuaW1hdGUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmNBbmltYXRlKTtcblxudmFyIF9Qb3B1cElubmVyID0gcmVxdWlyZSgnLi9Qb3B1cElubmVyJyk7XG5cbnZhciBfUG9wdXBJbm5lcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9Qb3B1cElubmVyKTtcblxudmFyIF9MYXp5UmVuZGVyQm94ID0gcmVxdWlyZSgnLi9MYXp5UmVuZGVyQm94Jyk7XG5cbnZhciBfTGF6eVJlbmRlckJveDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9MYXp5UmVuZGVyQm94KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgXCJkZWZhdWx0XCI6IG9iaiB9OyB9XG5cbnZhciBQb3B1cCA9IF9yZWFjdDJbXCJkZWZhdWx0XCJdLmNyZWF0ZUNsYXNzKHtcbiAgZGlzcGxheU5hbWU6ICdQb3B1cCcsXG5cbiAgcHJvcFR5cGVzOiB7XG4gICAgdmlzaWJsZTogX3JlYWN0LlByb3BUeXBlcy5ib29sLFxuICAgIHN0eWxlOiBfcmVhY3QuUHJvcFR5cGVzLm9iamVjdCxcbiAgICBnZXRDbGFzc05hbWVGcm9tQWxpZ246IF9yZWFjdC5Qcm9wVHlwZXMuZnVuYyxcbiAgICBvbkFsaWduOiBfcmVhY3QuUHJvcFR5cGVzLmZ1bmMsXG4gICAgZ2V0Um9vdERvbU5vZGU6IF9yZWFjdC5Qcm9wVHlwZXMuZnVuYyxcbiAgICBvbk1vdXNlRW50ZXI6IF9yZWFjdC5Qcm9wVHlwZXMuZnVuYyxcbiAgICBhbGlnbjogX3JlYWN0LlByb3BUeXBlcy5hbnksXG4gICAgZGVzdHJveVBvcHVwT25IaWRlOiBfcmVhY3QuUHJvcFR5cGVzLmJvb2wsXG4gICAgY2xhc3NOYW1lOiBfcmVhY3QuUHJvcFR5cGVzLnN0cmluZyxcbiAgICBwcmVmaXhDbHM6IF9yZWFjdC5Qcm9wVHlwZXMuc3RyaW5nLFxuICAgIG9uTW91c2VMZWF2ZTogX3JlYWN0LlByb3BUeXBlcy5mdW5jXG4gIH0sXG5cbiAgY29tcG9uZW50RGlkTW91bnQ6IGZ1bmN0aW9uIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgIHRoaXMucm9vdE5vZGUgPSB0aGlzLmdldFBvcHVwRG9tTm9kZSgpO1xuICB9LFxuICBvbkFsaWduOiBmdW5jdGlvbiBvbkFsaWduKHBvcHVwRG9tTm9kZSwgYWxpZ24pIHtcbiAgICB2YXIgcHJvcHMgPSB0aGlzLnByb3BzO1xuICAgIHZhciBhbGlnbkNsYXNzTmFtZSA9IHByb3BzLmdldENsYXNzTmFtZUZyb21BbGlnbihwcm9wcy5hbGlnbik7XG4gICAgdmFyIGN1cnJlbnRBbGlnbkNsYXNzTmFtZSA9IHByb3BzLmdldENsYXNzTmFtZUZyb21BbGlnbihhbGlnbik7XG4gICAgaWYgKGFsaWduQ2xhc3NOYW1lICE9PSBjdXJyZW50QWxpZ25DbGFzc05hbWUpIHtcbiAgICAgIHRoaXMuY3VycmVudEFsaWduQ2xhc3NOYW1lID0gY3VycmVudEFsaWduQ2xhc3NOYW1lO1xuICAgICAgcG9wdXBEb21Ob2RlLmNsYXNzTmFtZSA9IHRoaXMuZ2V0Q2xhc3NOYW1lKGN1cnJlbnRBbGlnbkNsYXNzTmFtZSk7XG4gICAgfVxuICAgIHByb3BzLm9uQWxpZ24ocG9wdXBEb21Ob2RlLCBhbGlnbik7XG4gIH0sXG4gIGdldFBvcHVwRG9tTm9kZTogZnVuY3Rpb24gZ2V0UG9wdXBEb21Ob2RlKCkge1xuICAgIHJldHVybiBfcmVhY3REb20yW1wiZGVmYXVsdFwiXS5maW5kRE9NTm9kZSh0aGlzLnJlZnMucG9wdXApO1xuICB9LFxuICBnZXRUYXJnZXQ6IGZ1bmN0aW9uIGdldFRhcmdldCgpIHtcbiAgICByZXR1cm4gdGhpcy5wcm9wcy5nZXRSb290RG9tTm9kZSgpO1xuICB9LFxuICBnZXRNYXNrVHJhbnNpdGlvbk5hbWU6IGZ1bmN0aW9uIGdldE1hc2tUcmFuc2l0aW9uTmFtZSgpIHtcbiAgICB2YXIgcHJvcHMgPSB0aGlzLnByb3BzO1xuICAgIHZhciB0cmFuc2l0aW9uTmFtZSA9IHByb3BzLm1hc2tUcmFuc2l0aW9uTmFtZTtcbiAgICB2YXIgYW5pbWF0aW9uID0gcHJvcHMubWFza0FuaW1hdGlvbjtcbiAgICBpZiAoIXRyYW5zaXRpb25OYW1lICYmIGFuaW1hdGlvbikge1xuICAgICAgdHJhbnNpdGlvbk5hbWUgPSBwcm9wcy5wcmVmaXhDbHMgKyAnLScgKyBhbmltYXRpb247XG4gICAgfVxuICAgIHJldHVybiB0cmFuc2l0aW9uTmFtZTtcbiAgfSxcbiAgZ2V0VHJhbnNpdGlvbk5hbWU6IGZ1bmN0aW9uIGdldFRyYW5zaXRpb25OYW1lKCkge1xuICAgIHZhciBwcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgdmFyIHRyYW5zaXRpb25OYW1lID0gcHJvcHMudHJhbnNpdGlvbk5hbWU7XG4gICAgaWYgKCF0cmFuc2l0aW9uTmFtZSAmJiBwcm9wcy5hbmltYXRpb24pIHtcbiAgICAgIHRyYW5zaXRpb25OYW1lID0gcHJvcHMucHJlZml4Q2xzICsgJy0nICsgcHJvcHMuYW5pbWF0aW9uO1xuICAgIH1cbiAgICByZXR1cm4gdHJhbnNpdGlvbk5hbWU7XG4gIH0sXG4gIGdldENsYXNzTmFtZTogZnVuY3Rpb24gZ2V0Q2xhc3NOYW1lKGN1cnJlbnRBbGlnbkNsYXNzTmFtZSkge1xuICAgIHJldHVybiB0aGlzLnByb3BzLnByZWZpeENscyArICcgJyArIHRoaXMucHJvcHMuY2xhc3NOYW1lICsgJyAnICsgY3VycmVudEFsaWduQ2xhc3NOYW1lO1xuICB9LFxuICBnZXRQb3B1cEVsZW1lbnQ6IGZ1bmN0aW9uIGdldFBvcHVwRWxlbWVudCgpIHtcbiAgICB2YXIgcHJvcHMgPSB0aGlzLnByb3BzO1xuICAgIHZhciBhbGlnbiA9IHByb3BzLmFsaWduO1xuICAgIHZhciBzdHlsZSA9IHByb3BzLnN0eWxlO1xuICAgIHZhciB2aXNpYmxlID0gcHJvcHMudmlzaWJsZTtcbiAgICB2YXIgcHJlZml4Q2xzID0gcHJvcHMucHJlZml4Q2xzO1xuICAgIHZhciBkZXN0cm95UG9wdXBPbkhpZGUgPSBwcm9wcy5kZXN0cm95UG9wdXBPbkhpZGU7XG5cbiAgICB2YXIgY2xhc3NOYW1lID0gdGhpcy5nZXRDbGFzc05hbWUodGhpcy5jdXJyZW50QWxpZ25DbGFzc05hbWUgfHwgcHJvcHMuZ2V0Q2xhc3NOYW1lRnJvbUFsaWduKGFsaWduKSk7XG4gICAgdmFyIGhpZGRlbkNsYXNzTmFtZSA9IHByZWZpeENscyArICctaGlkZGVuJztcbiAgICBpZiAoIXZpc2libGUpIHtcbiAgICAgIHRoaXMuY3VycmVudEFsaWduQ2xhc3NOYW1lID0gbnVsbDtcbiAgICB9XG4gICAgdmFyIG5ld1N0eWxlID0gX2V4dGVuZHMoe30sIHN0eWxlLCB0aGlzLmdldFpJbmRleFN0eWxlKCkpO1xuICAgIHZhciBwb3B1cElubmVyUHJvcHMgPSB7XG4gICAgICBjbGFzc05hbWU6IGNsYXNzTmFtZSxcbiAgICAgIHByZWZpeENsczogcHJlZml4Q2xzLFxuICAgICAgcmVmOiAncG9wdXAnLFxuICAgICAgb25Nb3VzZUVudGVyOiBwcm9wcy5vbk1vdXNlRW50ZXIsXG4gICAgICBvbk1vdXNlTGVhdmU6IHByb3BzLm9uTW91c2VMZWF2ZSxcbiAgICAgIHN0eWxlOiBuZXdTdHlsZVxuICAgIH07XG4gICAgaWYgKGRlc3Ryb3lQb3B1cE9uSGlkZSkge1xuICAgICAgcmV0dXJuIF9yZWFjdDJbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgIF9yY0FuaW1hdGUyW1wiZGVmYXVsdFwiXSxcbiAgICAgICAge1xuICAgICAgICAgIGNvbXBvbmVudDogJycsXG4gICAgICAgICAgZXhjbHVzaXZlOiB0cnVlLFxuICAgICAgICAgIHRyYW5zaXRpb25BcHBlYXI6IHRydWUsXG4gICAgICAgICAgdHJhbnNpdGlvbk5hbWU6IHRoaXMuZ2V0VHJhbnNpdGlvbk5hbWUoKVxuICAgICAgICB9LFxuICAgICAgICB2aXNpYmxlID8gX3JlYWN0MltcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChcbiAgICAgICAgICBfcmNBbGlnbjJbXCJkZWZhdWx0XCJdLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHRhcmdldDogdGhpcy5nZXRUYXJnZXQsXG4gICAgICAgICAgICBrZXk6ICdwb3B1cCcsXG4gICAgICAgICAgICByZWY6IHRoaXMuc2F2ZUFsaWduLFxuICAgICAgICAgICAgbW9uaXRvcldpbmRvd1Jlc2l6ZTogdHJ1ZSxcbiAgICAgICAgICAgIGFsaWduOiBhbGlnbixcbiAgICAgICAgICAgIG9uQWxpZ246IHRoaXMub25BbGlnblxuICAgICAgICAgIH0sXG4gICAgICAgICAgX3JlYWN0MltcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAgIF9Qb3B1cElubmVyMltcImRlZmF1bHRcIl0sXG4gICAgICAgICAgICBfZXh0ZW5kcyh7XG4gICAgICAgICAgICAgIHZpc2libGU6IHRydWVcbiAgICAgICAgICAgIH0sIHBvcHVwSW5uZXJQcm9wcyksXG4gICAgICAgICAgICBwcm9wcy5jaGlsZHJlblxuICAgICAgICAgIClcbiAgICAgICAgKSA6IG51bGxcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiBfcmVhY3QyW1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFxuICAgICAgX3JjQW5pbWF0ZTJbXCJkZWZhdWx0XCJdLFxuICAgICAge1xuICAgICAgICBjb21wb25lbnQ6ICcnLFxuICAgICAgICBleGNsdXNpdmU6IHRydWUsXG4gICAgICAgIHRyYW5zaXRpb25BcHBlYXI6IHRydWUsXG4gICAgICAgIHRyYW5zaXRpb25OYW1lOiB0aGlzLmdldFRyYW5zaXRpb25OYW1lKCksXG4gICAgICAgIHNob3dQcm9wOiAneFZpc2libGUnXG4gICAgICB9LFxuICAgICAgX3JlYWN0MltcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChcbiAgICAgICAgX3JjQWxpZ24yW1wiZGVmYXVsdFwiXSxcbiAgICAgICAge1xuICAgICAgICAgIHRhcmdldDogdGhpcy5nZXRUYXJnZXQsXG4gICAgICAgICAga2V5OiAncG9wdXAnLFxuICAgICAgICAgIHJlZjogdGhpcy5zYXZlQWxpZ24sXG4gICAgICAgICAgbW9uaXRvcldpbmRvd1Jlc2l6ZTogdHJ1ZSxcbiAgICAgICAgICB4VmlzaWJsZTogdmlzaWJsZSxcbiAgICAgICAgICBjaGlsZHJlblByb3BzOiB7IHZpc2libGU6ICd4VmlzaWJsZScgfSxcbiAgICAgICAgICBkaXNhYmxlZDogIXZpc2libGUsXG4gICAgICAgICAgYWxpZ246IGFsaWduLFxuICAgICAgICAgIG9uQWxpZ246IHRoaXMub25BbGlnblxuICAgICAgICB9LFxuICAgICAgICBfcmVhY3QyW1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgIF9Qb3B1cElubmVyMltcImRlZmF1bHRcIl0sXG4gICAgICAgICAgX2V4dGVuZHMoe1xuICAgICAgICAgICAgaGlkZGVuQ2xhc3NOYW1lOiBoaWRkZW5DbGFzc05hbWVcbiAgICAgICAgICB9LCBwb3B1cElubmVyUHJvcHMpLFxuICAgICAgICAgIHByb3BzLmNoaWxkcmVuXG4gICAgICAgIClcbiAgICAgIClcbiAgICApO1xuICB9LFxuICBnZXRaSW5kZXhTdHlsZTogZnVuY3Rpb24gZ2V0WkluZGV4U3R5bGUoKSB7XG4gICAgdmFyIHN0eWxlID0ge307XG4gICAgdmFyIHByb3BzID0gdGhpcy5wcm9wcztcbiAgICBpZiAocHJvcHMuekluZGV4ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHN0eWxlLnpJbmRleCA9IHByb3BzLnpJbmRleDtcbiAgICB9XG4gICAgcmV0dXJuIHN0eWxlO1xuICB9LFxuICBnZXRNYXNrRWxlbWVudDogZnVuY3Rpb24gZ2V0TWFza0VsZW1lbnQoKSB7XG4gICAgdmFyIHByb3BzID0gdGhpcy5wcm9wcztcbiAgICB2YXIgbWFza0VsZW1lbnQgPSB2b2lkIDA7XG4gICAgaWYgKHByb3BzLm1hc2spIHtcbiAgICAgIHZhciBtYXNrVHJhbnNpdGlvbiA9IHRoaXMuZ2V0TWFza1RyYW5zaXRpb25OYW1lKCk7XG4gICAgICBtYXNrRWxlbWVudCA9IF9yZWFjdDJbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoX0xhenlSZW5kZXJCb3gyW1wiZGVmYXVsdFwiXSwge1xuICAgICAgICBzdHlsZTogdGhpcy5nZXRaSW5kZXhTdHlsZSgpLFxuICAgICAgICBrZXk6ICdtYXNrJyxcbiAgICAgICAgY2xhc3NOYW1lOiBwcm9wcy5wcmVmaXhDbHMgKyAnLW1hc2snLFxuICAgICAgICBoaWRkZW5DbGFzc05hbWU6IHByb3BzLnByZWZpeENscyArICctbWFzay1oaWRkZW4nLFxuICAgICAgICB2aXNpYmxlOiBwcm9wcy52aXNpYmxlXG4gICAgICB9KTtcbiAgICAgIGlmIChtYXNrVHJhbnNpdGlvbikge1xuICAgICAgICBtYXNrRWxlbWVudCA9IF9yZWFjdDJbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgX3JjQW5pbWF0ZTJbXCJkZWZhdWx0XCJdLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGtleTogJ21hc2snLFxuICAgICAgICAgICAgc2hvd1Byb3A6ICd2aXNpYmxlJyxcbiAgICAgICAgICAgIHRyYW5zaXRpb25BcHBlYXI6IHRydWUsXG4gICAgICAgICAgICBjb21wb25lbnQ6ICcnLFxuICAgICAgICAgICAgdHJhbnNpdGlvbk5hbWU6IG1hc2tUcmFuc2l0aW9uXG4gICAgICAgICAgfSxcbiAgICAgICAgICBtYXNrRWxlbWVudFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbWFza0VsZW1lbnQ7XG4gIH0sXG4gIHNhdmVBbGlnbjogZnVuY3Rpb24gc2F2ZUFsaWduKGFsaWduKSB7XG4gICAgdGhpcy5hbGlnbkluc3RhbmNlID0gYWxpZ247XG4gIH0sXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgIHJldHVybiBfcmVhY3QyW1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFxuICAgICAgJ2RpdicsXG4gICAgICBudWxsLFxuICAgICAgdGhpcy5nZXRNYXNrRWxlbWVudCgpLFxuICAgICAgdGhpcy5nZXRQb3B1cEVsZW1lbnQoKVxuICAgICk7XG4gIH1cbn0pO1xuXG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IFBvcHVwO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vdXhjb3JlLXRhYmxlL34vdXhjb3JlLWRyb3Bkb3duL34vcmMtZHJvcGRvd24vfi9yYy10cmlnZ2VyL2xpYi9Qb3B1cC5qc1xuICoqIG1vZHVsZSBpZCA9IDgyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfQWxpZ24gPSByZXF1aXJlKCcuL0FsaWduJyk7XG5cbnZhciBfQWxpZ24yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfQWxpZ24pO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBcImRlZmF1bHRcIjogb2JqIH07IH1cblxuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBfQWxpZ24yW1wiZGVmYXVsdFwiXTsgLy8gZXhwb3J0IHRoaXMgcGFja2FnZSdzIGFwaVxuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi91eGNvcmUtdGFibGUvfi91eGNvcmUtZHJvcGRvd24vfi9yYy1kcm9wZG93bi9+L3JjLXRyaWdnZXIvfi9yYy1hbGlnbi9saWIvaW5kZXguanNcbiAqKiBtb2R1bGUgaWQgPSA4M1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX3JlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxudmFyIF9yZWFjdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yZWFjdCk7XG5cbnZhciBfcmVhY3REb20gPSByZXF1aXJlKCdyZWFjdC1kb20nKTtcblxudmFyIF9yZWFjdERvbTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yZWFjdERvbSk7XG5cbnZhciBfZG9tQWxpZ24gPSByZXF1aXJlKCdkb20tYWxpZ24nKTtcblxudmFyIF9kb21BbGlnbjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9kb21BbGlnbik7XG5cbnZhciBfcmNVdGlsID0gcmVxdWlyZSgncmMtdXRpbCcpO1xuXG52YXIgX2lzV2luZG93ID0gcmVxdWlyZSgnLi9pc1dpbmRvdycpO1xuXG52YXIgX2lzV2luZG93MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2lzV2luZG93KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgXCJkZWZhdWx0XCI6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIGJ1ZmZlcihmbiwgbXMpIHtcbiAgdmFyIHRpbWVyID0gdm9pZCAwO1xuICByZXR1cm4gZnVuY3Rpb24gYnVmZmVyRm4oKSB7XG4gICAgaWYgKHRpbWVyKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGltZXIpO1xuICAgIH1cbiAgICB0aW1lciA9IHNldFRpbWVvdXQoZm4sIG1zKTtcbiAgfTtcbn1cblxudmFyIEFsaWduID0gX3JlYWN0MltcImRlZmF1bHRcIl0uY3JlYXRlQ2xhc3Moe1xuICBkaXNwbGF5TmFtZTogJ0FsaWduJyxcblxuICBwcm9wVHlwZXM6IHtcbiAgICBjaGlsZHJlblByb3BzOiBfcmVhY3QuUHJvcFR5cGVzLm9iamVjdCxcbiAgICBhbGlnbjogX3JlYWN0LlByb3BUeXBlcy5vYmplY3QuaXNSZXF1aXJlZCxcbiAgICB0YXJnZXQ6IF9yZWFjdC5Qcm9wVHlwZXMuZnVuYyxcbiAgICBvbkFsaWduOiBfcmVhY3QuUHJvcFR5cGVzLmZ1bmMsXG4gICAgbW9uaXRvckJ1ZmZlclRpbWU6IF9yZWFjdC5Qcm9wVHlwZXMubnVtYmVyLFxuICAgIG1vbml0b3JXaW5kb3dSZXNpemU6IF9yZWFjdC5Qcm9wVHlwZXMuYm9vbCxcbiAgICBkaXNhYmxlZDogX3JlYWN0LlByb3BUeXBlcy5ib29sLFxuICAgIGNoaWxkcmVuOiBfcmVhY3QuUHJvcFR5cGVzLmFueVxuICB9LFxuXG4gIGdldERlZmF1bHRQcm9wczogZnVuY3Rpb24gZ2V0RGVmYXVsdFByb3BzKCkge1xuICAgIHJldHVybiB7XG4gICAgICB0YXJnZXQ6IGZ1bmN0aW9uIHRhcmdldCgpIHtcbiAgICAgICAgcmV0dXJuIHdpbmRvdztcbiAgICAgIH0sXG4gICAgICBvbkFsaWduOiBmdW5jdGlvbiBvbkFsaWduKCkge30sXG5cbiAgICAgIG1vbml0b3JCdWZmZXJUaW1lOiA1MCxcbiAgICAgIG1vbml0b3JXaW5kb3dSZXNpemU6IGZhbHNlLFxuICAgICAgZGlzYWJsZWQ6IGZhbHNlXG4gICAgfTtcbiAgfSxcbiAgY29tcG9uZW50RGlkTW91bnQ6IGZ1bmN0aW9uIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgIHZhciBwcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgLy8gaWYgcGFyZW50IHJlZiBub3QgYXR0YWNoZWQgLi4uLiB1c2UgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWRcbiAgICB0aGlzLmZvcmNlQWxpZ24oKTtcbiAgICBpZiAoIXByb3BzLmRpc2FibGVkICYmIHByb3BzLm1vbml0b3JXaW5kb3dSZXNpemUpIHtcbiAgICAgIHRoaXMuc3RhcnRNb25pdG9yV2luZG93UmVzaXplKCk7XG4gICAgfVxuICB9LFxuICBjb21wb25lbnREaWRVcGRhdGU6IGZ1bmN0aW9uIGNvbXBvbmVudERpZFVwZGF0ZShwcmV2UHJvcHMpIHtcbiAgICB2YXIgcmVBbGlnbiA9IGZhbHNlO1xuICAgIHZhciBwcm9wcyA9IHRoaXMucHJvcHM7XG5cbiAgICBpZiAoIXByb3BzLmRpc2FibGVkKSB7XG4gICAgICBpZiAocHJldlByb3BzLmRpc2FibGVkIHx8IHByZXZQcm9wcy5hbGlnbiAhPT0gcHJvcHMuYWxpZ24pIHtcbiAgICAgICAgcmVBbGlnbiA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgbGFzdFRhcmdldCA9IHByZXZQcm9wcy50YXJnZXQoKTtcbiAgICAgICAgdmFyIGN1cnJlbnRUYXJnZXQgPSBwcm9wcy50YXJnZXQoKTtcbiAgICAgICAgaWYgKCgwLCBfaXNXaW5kb3cyW1wiZGVmYXVsdFwiXSkobGFzdFRhcmdldCkgJiYgKDAsIF9pc1dpbmRvdzJbXCJkZWZhdWx0XCJdKShjdXJyZW50VGFyZ2V0KSkge1xuICAgICAgICAgIHJlQWxpZ24gPSBmYWxzZTtcbiAgICAgICAgfSBlbHNlIGlmIChsYXN0VGFyZ2V0ICE9PSBjdXJyZW50VGFyZ2V0KSB7XG4gICAgICAgICAgcmVBbGlnbiA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocmVBbGlnbikge1xuICAgICAgdGhpcy5mb3JjZUFsaWduKCk7XG4gICAgfVxuXG4gICAgaWYgKHByb3BzLm1vbml0b3JXaW5kb3dSZXNpemUgJiYgIXByb3BzLmRpc2FibGVkKSB7XG4gICAgICB0aGlzLnN0YXJ0TW9uaXRvcldpbmRvd1Jlc2l6ZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnN0b3BNb25pdG9yV2luZG93UmVzaXplKCk7XG4gICAgfVxuICB9LFxuICBjb21wb25lbnRXaWxsVW5tb3VudDogZnVuY3Rpb24gY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgdGhpcy5zdG9wTW9uaXRvcldpbmRvd1Jlc2l6ZSgpO1xuICB9LFxuICBzdGFydE1vbml0b3JXaW5kb3dSZXNpemU6IGZ1bmN0aW9uIHN0YXJ0TW9uaXRvcldpbmRvd1Jlc2l6ZSgpIHtcbiAgICBpZiAoIXRoaXMucmVzaXplSGFuZGxlcikge1xuICAgICAgdGhpcy5yZXNpemVIYW5kbGVyID0gX3JjVXRpbC5Eb20uYWRkRXZlbnRMaXN0ZW5lcih3aW5kb3csICdyZXNpemUnLCBidWZmZXIodGhpcy5mb3JjZUFsaWduLCB0aGlzLnByb3BzLm1vbml0b3JCdWZmZXJUaW1lKSk7XG4gICAgfVxuICB9LFxuICBzdG9wTW9uaXRvcldpbmRvd1Jlc2l6ZTogZnVuY3Rpb24gc3RvcE1vbml0b3JXaW5kb3dSZXNpemUoKSB7XG4gICAgaWYgKHRoaXMucmVzaXplSGFuZGxlcikge1xuICAgICAgdGhpcy5yZXNpemVIYW5kbGVyLnJlbW92ZSgpO1xuICAgICAgdGhpcy5yZXNpemVIYW5kbGVyID0gbnVsbDtcbiAgICB9XG4gIH0sXG4gIGZvcmNlQWxpZ246IGZ1bmN0aW9uIGZvcmNlQWxpZ24oKSB7XG4gICAgdmFyIHByb3BzID0gdGhpcy5wcm9wcztcbiAgICBpZiAoIXByb3BzLmRpc2FibGVkKSB7XG4gICAgICB2YXIgc291cmNlID0gX3JlYWN0RG9tMltcImRlZmF1bHRcIl0uZmluZERPTU5vZGUodGhpcyk7XG4gICAgICBwcm9wcy5vbkFsaWduKHNvdXJjZSwgKDAsIF9kb21BbGlnbjJbXCJkZWZhdWx0XCJdKShzb3VyY2UsIHByb3BzLnRhcmdldCgpLCBwcm9wcy5hbGlnbikpO1xuICAgIH1cbiAgfSxcbiAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgdmFyIF9wcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgdmFyIGNoaWxkcmVuUHJvcHMgPSBfcHJvcHMuY2hpbGRyZW5Qcm9wcztcbiAgICB2YXIgY2hpbGRyZW4gPSBfcHJvcHMuY2hpbGRyZW47XG5cbiAgICB2YXIgY2hpbGQgPSBfcmVhY3QyW1wiZGVmYXVsdFwiXS5DaGlsZHJlbi5vbmx5KGNoaWxkcmVuKTtcbiAgICBpZiAoY2hpbGRyZW5Qcm9wcykge1xuICAgICAgdmFyIG5ld1Byb3BzID0ge307XG4gICAgICBmb3IgKHZhciBwcm9wIGluIGNoaWxkcmVuUHJvcHMpIHtcbiAgICAgICAgaWYgKGNoaWxkcmVuUHJvcHMuaGFzT3duUHJvcGVydHkocHJvcCkpIHtcbiAgICAgICAgICBuZXdQcm9wc1twcm9wXSA9IHRoaXMucHJvcHNbY2hpbGRyZW5Qcm9wc1twcm9wXV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBfcmVhY3QyW1wiZGVmYXVsdFwiXS5jbG9uZUVsZW1lbnQoY2hpbGQsIG5ld1Byb3BzKTtcbiAgICB9XG4gICAgcmV0dXJuIGNoaWxkO1xuICB9XG59KTtcblxuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBBbGlnbjtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3V4Y29yZS10YWJsZS9+L3V4Y29yZS1kcm9wZG93bi9+L3JjLWRyb3Bkb3duL34vcmMtdHJpZ2dlci9+L3JjLWFsaWduL2xpYi9BbGlnbi5qc1xuICoqIG1vZHVsZSBpZCA9IDg0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIGFsaWduIGRvbSBub2RlIGZsZXhpYmx5XG4gKiBAYXV0aG9yIHlpbWluZ2hlQGdtYWlsLmNvbVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxudmFyIF91dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcblxudmFyIF91dGlsczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF91dGlscyk7XG5cbnZhciBfZ2V0T2Zmc2V0UGFyZW50ID0gcmVxdWlyZSgnLi9nZXRPZmZzZXRQYXJlbnQnKTtcblxudmFyIF9nZXRPZmZzZXRQYXJlbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZ2V0T2Zmc2V0UGFyZW50KTtcblxudmFyIF9nZXRWaXNpYmxlUmVjdEZvckVsZW1lbnQgPSByZXF1aXJlKCcuL2dldFZpc2libGVSZWN0Rm9yRWxlbWVudCcpO1xuXG52YXIgX2dldFZpc2libGVSZWN0Rm9yRWxlbWVudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9nZXRWaXNpYmxlUmVjdEZvckVsZW1lbnQpO1xuXG52YXIgX2FkanVzdEZvclZpZXdwb3J0ID0gcmVxdWlyZSgnLi9hZGp1c3RGb3JWaWV3cG9ydCcpO1xuXG52YXIgX2FkanVzdEZvclZpZXdwb3J0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2FkanVzdEZvclZpZXdwb3J0KTtcblxudmFyIF9nZXRSZWdpb24gPSByZXF1aXJlKCcuL2dldFJlZ2lvbicpO1xuXG52YXIgX2dldFJlZ2lvbjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9nZXRSZWdpb24pO1xuXG52YXIgX2dldEVsRnV0dXJlUG9zID0gcmVxdWlyZSgnLi9nZXRFbEZ1dHVyZVBvcycpO1xuXG52YXIgX2dldEVsRnV0dXJlUG9zMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2dldEVsRnV0dXJlUG9zKTtcblxuLy8gaHR0cDovL3lpbWluZ2hlLml0ZXllLmNvbS9ibG9nLzExMjQ3MjBcblxuZnVuY3Rpb24gaXNGYWlsWChlbEZ1dHVyZVBvcywgZWxSZWdpb24sIHZpc2libGVSZWN0KSB7XG4gIHJldHVybiBlbEZ1dHVyZVBvcy5sZWZ0IDwgdmlzaWJsZVJlY3QubGVmdCB8fCBlbEZ1dHVyZVBvcy5sZWZ0ICsgZWxSZWdpb24ud2lkdGggPiB2aXNpYmxlUmVjdC5yaWdodDtcbn1cblxuZnVuY3Rpb24gaXNGYWlsWShlbEZ1dHVyZVBvcywgZWxSZWdpb24sIHZpc2libGVSZWN0KSB7XG4gIHJldHVybiBlbEZ1dHVyZVBvcy50b3AgPCB2aXNpYmxlUmVjdC50b3AgfHwgZWxGdXR1cmVQb3MudG9wICsgZWxSZWdpb24uaGVpZ2h0ID4gdmlzaWJsZVJlY3QuYm90dG9tO1xufVxuXG5mdW5jdGlvbiBpc0NvbXBsZXRlRmFpbFgoZWxGdXR1cmVQb3MsIGVsUmVnaW9uLCB2aXNpYmxlUmVjdCkge1xuICByZXR1cm4gZWxGdXR1cmVQb3MubGVmdCA+IHZpc2libGVSZWN0LnJpZ2h0IHx8IGVsRnV0dXJlUG9zLmxlZnQgKyBlbFJlZ2lvbi53aWR0aCA8IHZpc2libGVSZWN0LmxlZnQ7XG59XG5cbmZ1bmN0aW9uIGlzQ29tcGxldGVGYWlsWShlbEZ1dHVyZVBvcywgZWxSZWdpb24sIHZpc2libGVSZWN0KSB7XG4gIHJldHVybiBlbEZ1dHVyZVBvcy50b3AgPiB2aXNpYmxlUmVjdC5ib3R0b20gfHwgZWxGdXR1cmVQb3MudG9wICsgZWxSZWdpb24uaGVpZ2h0IDwgdmlzaWJsZVJlY3QudG9wO1xufVxuXG5mdW5jdGlvbiBmbGlwKHBvaW50cywgcmVnLCBtYXApIHtcbiAgdmFyIHJldCA9IFtdO1xuICBfdXRpbHMyWydkZWZhdWx0J10uZWFjaChwb2ludHMsIGZ1bmN0aW9uIChwKSB7XG4gICAgcmV0LnB1c2gocC5yZXBsYWNlKHJlZywgZnVuY3Rpb24gKG0pIHtcbiAgICAgIHJldHVybiBtYXBbbV07XG4gICAgfSkpO1xuICB9KTtcbiAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gZmxpcE9mZnNldChvZmZzZXQsIGluZGV4KSB7XG4gIG9mZnNldFtpbmRleF0gPSAtb2Zmc2V0W2luZGV4XTtcbiAgcmV0dXJuIG9mZnNldDtcbn1cblxuZnVuY3Rpb24gY29udmVydE9mZnNldChzdHIsIG9mZnNldExlbikge1xuICB2YXIgbiA9IHVuZGVmaW5lZDtcbiAgaWYgKC8lJC8udGVzdChzdHIpKSB7XG4gICAgbiA9IHBhcnNlSW50KHN0ci5zdWJzdHJpbmcoMCwgc3RyLmxlbmd0aCAtIDEpLCAxMCkgLyAxMDAgKiBvZmZzZXRMZW47XG4gIH0gZWxzZSB7XG4gICAgbiA9IHBhcnNlSW50KHN0ciwgMTApO1xuICB9XG4gIHJldHVybiBuIHx8IDA7XG59XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZU9mZnNldChvZmZzZXQsIGVsKSB7XG4gIG9mZnNldFswXSA9IGNvbnZlcnRPZmZzZXQob2Zmc2V0WzBdLCBlbC53aWR0aCk7XG4gIG9mZnNldFsxXSA9IGNvbnZlcnRPZmZzZXQob2Zmc2V0WzFdLCBlbC5oZWlnaHQpO1xufVxuXG5mdW5jdGlvbiBkb21BbGlnbihlbCwgcmVmTm9kZSwgYWxpZ24pIHtcbiAgdmFyIHBvaW50cyA9IGFsaWduLnBvaW50cztcbiAgdmFyIG9mZnNldCA9IGFsaWduLm9mZnNldCB8fCBbMCwgMF07XG4gIHZhciB0YXJnZXRPZmZzZXQgPSBhbGlnbi50YXJnZXRPZmZzZXQgfHwgWzAsIDBdO1xuICB2YXIgb3ZlcmZsb3cgPSBhbGlnbi5vdmVyZmxvdztcbiAgdmFyIHRhcmdldCA9IGFsaWduLnRhcmdldCB8fCByZWZOb2RlO1xuICB2YXIgc291cmNlID0gYWxpZ24uc291cmNlIHx8IGVsO1xuICBvZmZzZXQgPSBbXS5jb25jYXQob2Zmc2V0KTtcbiAgdGFyZ2V0T2Zmc2V0ID0gW10uY29uY2F0KHRhcmdldE9mZnNldCk7XG4gIG92ZXJmbG93ID0gb3ZlcmZsb3cgfHwge307XG4gIHZhciBuZXdPdmVyZmxvd0NmZyA9IHt9O1xuXG4gIHZhciBmYWlsID0gMDtcbiAgLy8g5b2T5YmN6IqC54K55Y+v5Lul6KKr5pS+572u55qE5pi+56S65Yy65Z+fXG4gIHZhciB2aXNpYmxlUmVjdCA9ICgwLCBfZ2V0VmlzaWJsZVJlY3RGb3JFbGVtZW50MlsnZGVmYXVsdCddKShzb3VyY2UpO1xuICAvLyDlvZPliY3oioLngrnmiYDljaDnmoTljLrln58sIGxlZnQvdG9wL3dpZHRoL2hlaWdodFxuICB2YXIgZWxSZWdpb24gPSAoMCwgX2dldFJlZ2lvbjJbJ2RlZmF1bHQnXSkoc291cmNlKTtcbiAgLy8g5Y+C54Wn6IqC54K55omA5Y2g55qE5Yy65Z+fLCBsZWZ0L3RvcC93aWR0aC9oZWlnaHRcbiAgdmFyIHJlZk5vZGVSZWdpb24gPSAoMCwgX2dldFJlZ2lvbjJbJ2RlZmF1bHQnXSkodGFyZ2V0KTtcbiAgLy8g5bCGIG9mZnNldCDovazmjaLmiJDmlbDlgLzvvIzmlK/mjIHnmb7liIbmr5RcbiAgbm9ybWFsaXplT2Zmc2V0KG9mZnNldCwgZWxSZWdpb24pO1xuICBub3JtYWxpemVPZmZzZXQodGFyZ2V0T2Zmc2V0LCByZWZOb2RlUmVnaW9uKTtcbiAgLy8g5b2T5YmN6IqC54K55bCG6KaB6KKr5pS+572u55qE5L2N572uXG4gIHZhciBlbEZ1dHVyZVBvcyA9ICgwLCBfZ2V0RWxGdXR1cmVQb3MyWydkZWZhdWx0J10pKGVsUmVnaW9uLCByZWZOb2RlUmVnaW9uLCBwb2ludHMsIG9mZnNldCwgdGFyZ2V0T2Zmc2V0KTtcbiAgLy8g5b2T5YmN6IqC54K55bCG6KaB5omA5aSE55qE5Yy65Z+fXG4gIHZhciBuZXdFbFJlZ2lvbiA9IF91dGlsczJbJ2RlZmF1bHQnXS5tZXJnZShlbFJlZ2lvbiwgZWxGdXR1cmVQb3MpO1xuXG4gIC8vIOWmguaenOWPr+inhuWMuuWfn+S4jeiDveWujOWFqOaUvue9ruW9k+WJjeiKgueCueaXtuWFgeiuuOiwg+aVtFxuICBpZiAodmlzaWJsZVJlY3QgJiYgKG92ZXJmbG93LmFkanVzdFggfHwgb3ZlcmZsb3cuYWRqdXN0WSkpIHtcbiAgICBpZiAob3ZlcmZsb3cuYWRqdXN0WCkge1xuICAgICAgLy8g5aaC5p6c5qiq5ZCR5LiN6IO95pS+5LiLXG4gICAgICBpZiAoaXNGYWlsWChlbEZ1dHVyZVBvcywgZWxSZWdpb24sIHZpc2libGVSZWN0KSkge1xuICAgICAgICAvLyDlr7npvZDkvY3nva7lj43kuItcbiAgICAgICAgdmFyIG5ld1BvaW50cyA9IGZsaXAocG9pbnRzLCAvW2xyXS9pZywge1xuICAgICAgICAgIGw6ICdyJyxcbiAgICAgICAgICByOiAnbCdcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIOWBj+enu+mHj+S5n+WPjeS4i1xuICAgICAgICB2YXIgbmV3T2Zmc2V0ID0gZmxpcE9mZnNldChvZmZzZXQsIDApO1xuICAgICAgICB2YXIgbmV3VGFyZ2V0T2Zmc2V0ID0gZmxpcE9mZnNldCh0YXJnZXRPZmZzZXQsIDApO1xuICAgICAgICB2YXIgbmV3RWxGdXR1cmVQb3MgPSAoMCwgX2dldEVsRnV0dXJlUG9zMlsnZGVmYXVsdCddKShlbFJlZ2lvbiwgcmVmTm9kZVJlZ2lvbiwgbmV3UG9pbnRzLCBuZXdPZmZzZXQsIG5ld1RhcmdldE9mZnNldCk7XG4gICAgICAgIGlmICghaXNDb21wbGV0ZUZhaWxYKG5ld0VsRnV0dXJlUG9zLCBlbFJlZ2lvbiwgdmlzaWJsZVJlY3QpKSB7XG4gICAgICAgICAgZmFpbCA9IDE7XG4gICAgICAgICAgcG9pbnRzID0gbmV3UG9pbnRzO1xuICAgICAgICAgIG9mZnNldCA9IG5ld09mZnNldDtcbiAgICAgICAgICB0YXJnZXRPZmZzZXQgPSBuZXdUYXJnZXRPZmZzZXQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAob3ZlcmZsb3cuYWRqdXN0WSkge1xuICAgICAgLy8g5aaC5p6c57q15ZCR5LiN6IO95pS+5LiLXG4gICAgICBpZiAoaXNGYWlsWShlbEZ1dHVyZVBvcywgZWxSZWdpb24sIHZpc2libGVSZWN0KSkge1xuICAgICAgICAvLyDlr7npvZDkvY3nva7lj43kuItcbiAgICAgICAgdmFyIG5ld1BvaW50cyA9IGZsaXAocG9pbnRzLCAvW3RiXS9pZywge1xuICAgICAgICAgIHQ6ICdiJyxcbiAgICAgICAgICBiOiAndCdcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIOWBj+enu+mHj+S5n+WPjeS4i1xuICAgICAgICB2YXIgbmV3T2Zmc2V0ID0gZmxpcE9mZnNldChvZmZzZXQsIDEpO1xuICAgICAgICB2YXIgbmV3VGFyZ2V0T2Zmc2V0ID0gZmxpcE9mZnNldCh0YXJnZXRPZmZzZXQsIDEpO1xuICAgICAgICB2YXIgbmV3RWxGdXR1cmVQb3MgPSAoMCwgX2dldEVsRnV0dXJlUG9zMlsnZGVmYXVsdCddKShlbFJlZ2lvbiwgcmVmTm9kZVJlZ2lvbiwgbmV3UG9pbnRzLCBuZXdPZmZzZXQsIG5ld1RhcmdldE9mZnNldCk7XG4gICAgICAgIGlmICghaXNDb21wbGV0ZUZhaWxZKG5ld0VsRnV0dXJlUG9zLCBlbFJlZ2lvbiwgdmlzaWJsZVJlY3QpKSB7XG4gICAgICAgICAgZmFpbCA9IDE7XG4gICAgICAgICAgcG9pbnRzID0gbmV3UG9pbnRzO1xuICAgICAgICAgIG9mZnNldCA9IG5ld09mZnNldDtcbiAgICAgICAgICB0YXJnZXRPZmZzZXQgPSBuZXdUYXJnZXRPZmZzZXQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyDlpoLmnpzlpLHotKXvvIzph43mlrDorqHnrpflvZPliY3oioLngrnlsIbopoHooqvmlL7nva7nmoTkvY3nva5cbiAgICBpZiAoZmFpbCkge1xuICAgICAgZWxGdXR1cmVQb3MgPSAoMCwgX2dldEVsRnV0dXJlUG9zMlsnZGVmYXVsdCddKShlbFJlZ2lvbiwgcmVmTm9kZVJlZ2lvbiwgcG9pbnRzLCBvZmZzZXQsIHRhcmdldE9mZnNldCk7XG4gICAgICBfdXRpbHMyWydkZWZhdWx0J10ubWl4KG5ld0VsUmVnaW9uLCBlbEZ1dHVyZVBvcyk7XG4gICAgfVxuXG4gICAgLy8g5qOA5p+l5Y+N5LiL5ZCO55qE5L2N572u5piv5ZCm5Y+v5Lul5pS+5LiL5LqGXG4gICAgLy8g5aaC5p6c5LuN54S25pS+5LiN5LiL5Y+q5pyJ5oyH5a6a5LqG5Y+v5Lul6LCD5pW05b2T5YmN5pa55ZCR5omN6LCD5pW0XG4gICAgbmV3T3ZlcmZsb3dDZmcuYWRqdXN0WCA9IG92ZXJmbG93LmFkanVzdFggJiYgaXNGYWlsWChlbEZ1dHVyZVBvcywgZWxSZWdpb24sIHZpc2libGVSZWN0KTtcblxuICAgIG5ld092ZXJmbG93Q2ZnLmFkanVzdFkgPSBvdmVyZmxvdy5hZGp1c3RZICYmIGlzRmFpbFkoZWxGdXR1cmVQb3MsIGVsUmVnaW9uLCB2aXNpYmxlUmVjdCk7XG5cbiAgICAvLyDnoa7lrp7opoHosIPmlbTvvIznlJroh7Plj6/og73kvJrosIPmlbTpq5jluqblrr3luqZcbiAgICBpZiAobmV3T3ZlcmZsb3dDZmcuYWRqdXN0WCB8fCBuZXdPdmVyZmxvd0NmZy5hZGp1c3RZKSB7XG4gICAgICBuZXdFbFJlZ2lvbiA9ICgwLCBfYWRqdXN0Rm9yVmlld3BvcnQyWydkZWZhdWx0J10pKGVsRnV0dXJlUG9zLCBlbFJlZ2lvbiwgdmlzaWJsZVJlY3QsIG5ld092ZXJmbG93Q2ZnKTtcbiAgICB9XG4gIH1cblxuICAvLyBuZWVkIGp1ZGdlIHRvIGluIGNhc2Ugc2V0IGZpeGVkIHdpdGggaW4gY3NzIG9uIGhlaWdodCBhdXRvIGVsZW1lbnRcbiAgaWYgKG5ld0VsUmVnaW9uLndpZHRoICE9PSBlbFJlZ2lvbi53aWR0aCkge1xuICAgIF91dGlsczJbJ2RlZmF1bHQnXS5jc3Moc291cmNlLCAnd2lkdGgnLCBzb3VyY2Uud2lkdGgoKSArIG5ld0VsUmVnaW9uLndpZHRoIC0gZWxSZWdpb24ud2lkdGgpO1xuICB9XG5cbiAgaWYgKG5ld0VsUmVnaW9uLmhlaWdodCAhPT0gZWxSZWdpb24uaGVpZ2h0KSB7XG4gICAgX3V0aWxzMlsnZGVmYXVsdCddLmNzcyhzb3VyY2UsICdoZWlnaHQnLCBzb3VyY2UuaGVpZ2h0KCkgKyBuZXdFbFJlZ2lvbi5oZWlnaHQgLSBlbFJlZ2lvbi5oZWlnaHQpO1xuICB9XG5cbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2tpc3N5dGVhbS9raXNzeS9pc3N1ZXMvMTkwXG4gIC8vIGh0dHA6Ly9sb2NhbGhvc3Q6ODg4OC9raXNzeS9zcmMvb3ZlcmxheS9kZW1vL290aGVyL3JlbGF0aXZlX2FsaWduL2FsaWduLmh0bWxcbiAgLy8g55u45a+55LqO5bGP5bmV5L2N572u5rKh5Y+Y77yM6ICMIGxlZnQvdG9wIOWPmOS6hlxuICAvLyDkvovlpoIgPGRpdiAncmVsYXRpdmUnPjxlbCBhYnNvbHV0ZT48L2Rpdj5cbiAgX3V0aWxzMlsnZGVmYXVsdCddLm9mZnNldChzb3VyY2UsIHtcbiAgICBsZWZ0OiBuZXdFbFJlZ2lvbi5sZWZ0LFxuICAgIHRvcDogbmV3RWxSZWdpb24udG9wXG4gIH0sIHtcbiAgICB1c2VDc3NSaWdodDogYWxpZ24udXNlQ3NzUmlnaHQsXG4gICAgdXNlQ3NzQm90dG9tOiBhbGlnbi51c2VDc3NCb3R0b21cbiAgfSk7XG5cbiAgcmV0dXJuIHtcbiAgICBwb2ludHM6IHBvaW50cyxcbiAgICBvZmZzZXQ6IG9mZnNldCxcbiAgICB0YXJnZXRPZmZzZXQ6IHRhcmdldE9mZnNldCxcbiAgICBvdmVyZmxvdzogbmV3T3ZlcmZsb3dDZmdcbiAgfTtcbn1cblxuZG9tQWxpZ24uX19nZXRPZmZzZXRQYXJlbnQgPSBfZ2V0T2Zmc2V0UGFyZW50MlsnZGVmYXVsdCddO1xuXG5kb21BbGlnbi5fX2dldFZpc2libGVSZWN0Rm9yRWxlbWVudCA9IF9nZXRWaXNpYmxlUmVjdEZvckVsZW1lbnQyWydkZWZhdWx0J107XG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IGRvbUFsaWduO1xuXG4vKipcbiAqICAyMDEyLTA0LTI2IHlpbWluZ2hlQGdtYWlsLmNvbVxuICogICAtIOS8mOWMluaZuuiDveWvuem9kOeul+azlVxuICogICAtIOaFjueUqCByZXNpemVYWFxuICpcbiAqICAyMDExLTA3LTEzIHlpbWluZ2hlQGdtYWlsLmNvbSBub3RlOlxuICogICAtIOWinuWKoOaZuuiDveWvuem9kO+8jOS7peWPiuWkp+Wwj+iwg+aVtOmAiemhuVxuICoqL1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vdXhjb3JlLXRhYmxlL34vdXhjb3JlLWRyb3Bkb3duL34vcmMtZHJvcGRvd24vfi9yYy10cmlnZ2VyL34vcmMtYWxpZ24vfi9kb20tYWxpZ24vbGliL2luZGV4LmpzXG4gKiogbW9kdWxlIGlkID0gODVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxudmFyIF91dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcblxudmFyIF91dGlsczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF91dGlscyk7XG5cbi8qKlxuICog5b6X5Yiw5Lya5a+86Ie05YWD57Sg5pi+56S65LiN5YWo55qE56WW5YWI5YWD57SgXG4gKi9cblxuZnVuY3Rpb24gZ2V0T2Zmc2V0UGFyZW50KGVsZW1lbnQpIHtcbiAgLy8gaWUg6L+Z5Liq5Lmf5LiN5piv5a6M5YWo5Y+v6KGMXG4gIC8qXG4gICA8ZGl2IHN0eWxlPVwid2lkdGg6IDUwcHg7aGVpZ2h0OiAxMDBweDtvdmVyZmxvdzogaGlkZGVuXCI+XG4gICA8ZGl2IHN0eWxlPVwid2lkdGg6IDUwcHg7aGVpZ2h0OiAxMDBweDtwb3NpdGlvbjogcmVsYXRpdmU7XCIgaWQ9XCJkNlwiPlxuICAg5YWD57SgIDYg6auYIDEwMHB4IOWuvSA1MHB4PGJyLz5cbiAgIDwvZGl2PlxuICAgPC9kaXY+XG4gICAqL1xuICAvLyBlbGVtZW50Lm9mZnNldFBhcmVudCBkb2VzIHRoZSByaWdodCB0aGluZyBpbiBpZTcgYW5kIGJlbG93LiBSZXR1cm4gcGFyZW50IHdpdGggbGF5b3V0IVxuICAvLyAgSW4gb3RoZXIgYnJvd3NlcnMgaXQgb25seSBpbmNsdWRlcyBlbGVtZW50cyB3aXRoIHBvc2l0aW9uIGFic29sdXRlLCByZWxhdGl2ZSBvclxuICAvLyBmaXhlZCwgbm90IGVsZW1lbnRzIHdpdGggb3ZlcmZsb3cgc2V0IHRvIGF1dG8gb3Igc2Nyb2xsLlxuICAvLyAgICAgICAgaWYgKFVBLmllICYmIGllTW9kZSA8IDgpIHtcbiAgLy8gICAgICAgICAgICByZXR1cm4gZWxlbWVudC5vZmZzZXRQYXJlbnQ7XG4gIC8vICAgICAgICB9XG4gIC8vIOe7n+S4gOeahCBvZmZzZXRQYXJlbnQg5pa55rOVXG4gIHZhciBkb2MgPSBlbGVtZW50Lm93bmVyRG9jdW1lbnQ7XG4gIHZhciBib2R5ID0gZG9jLmJvZHk7XG4gIHZhciBwYXJlbnQgPSB1bmRlZmluZWQ7XG4gIHZhciBwb3NpdGlvblN0eWxlID0gX3V0aWxzMlsnZGVmYXVsdCddLmNzcyhlbGVtZW50LCAncG9zaXRpb24nKTtcbiAgdmFyIHNraXBTdGF0aWMgPSBwb3NpdGlvblN0eWxlID09PSAnZml4ZWQnIHx8IHBvc2l0aW9uU3R5bGUgPT09ICdhYnNvbHV0ZSc7XG5cbiAgaWYgKCFza2lwU3RhdGljKSB7XG4gICAgcmV0dXJuIGVsZW1lbnQubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ2h0bWwnID8gbnVsbCA6IGVsZW1lbnQucGFyZW50Tm9kZTtcbiAgfVxuXG4gIGZvciAocGFyZW50ID0gZWxlbWVudC5wYXJlbnROb2RlOyBwYXJlbnQgJiYgcGFyZW50ICE9PSBib2R5OyBwYXJlbnQgPSBwYXJlbnQucGFyZW50Tm9kZSkge1xuICAgIHBvc2l0aW9uU3R5bGUgPSBfdXRpbHMyWydkZWZhdWx0J10uY3NzKHBhcmVudCwgJ3Bvc2l0aW9uJyk7XG4gICAgaWYgKHBvc2l0aW9uU3R5bGUgIT09ICdzdGF0aWMnKSB7XG4gICAgICByZXR1cm4gcGFyZW50O1xuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuZXhwb3J0c1snZGVmYXVsdCddID0gZ2V0T2Zmc2V0UGFyZW50O1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vdXhjb3JlLXRhYmxlL34vdXhjb3JlLWRyb3Bkb3duL34vcmMtZHJvcGRvd24vfi9yYy10cmlnZ2VyL34vcmMtYWxpZ24vfi9kb20tYWxpZ24vbGliL2dldE9mZnNldFBhcmVudC5qc1xuICoqIG1vZHVsZSBpZCA9IDg3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbnZhciBfdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG5cbnZhciBfdXRpbHMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdXRpbHMpO1xuXG52YXIgX2dldE9mZnNldFBhcmVudCA9IHJlcXVpcmUoJy4vZ2V0T2Zmc2V0UGFyZW50Jyk7XG5cbnZhciBfZ2V0T2Zmc2V0UGFyZW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2dldE9mZnNldFBhcmVudCk7XG5cbi8qKlxuICog6I635b6X5YWD57Sg55qE5pi+56S66YOo5YiG55qE5Yy65Z+fXG4gKi9cbmZ1bmN0aW9uIGdldFZpc2libGVSZWN0Rm9yRWxlbWVudChlbGVtZW50KSB7XG4gIHZhciB2aXNpYmxlUmVjdCA9IHtcbiAgICBsZWZ0OiAwLFxuICAgIHJpZ2h0OiBJbmZpbml0eSxcbiAgICB0b3A6IDAsXG4gICAgYm90dG9tOiBJbmZpbml0eVxuICB9O1xuICB2YXIgZWwgPSAoMCwgX2dldE9mZnNldFBhcmVudDJbJ2RlZmF1bHQnXSkoZWxlbWVudCk7XG4gIHZhciBzY3JvbGxYID0gdW5kZWZpbmVkO1xuICB2YXIgc2Nyb2xsWSA9IHVuZGVmaW5lZDtcbiAgdmFyIHdpblNpemUgPSB1bmRlZmluZWQ7XG4gIHZhciBkb2MgPSBlbGVtZW50Lm93bmVyRG9jdW1lbnQ7XG4gIHZhciB3aW4gPSBkb2MuZGVmYXVsdFZpZXcgfHwgZG9jLnBhcmVudFdpbmRvdztcbiAgdmFyIGJvZHkgPSBkb2MuYm9keTtcbiAgdmFyIGRvY3VtZW50RWxlbWVudCA9IGRvYy5kb2N1bWVudEVsZW1lbnQ7XG5cbiAgLy8gRGV0ZXJtaW5lIHRoZSBzaXplIG9mIHRoZSB2aXNpYmxlIHJlY3QgYnkgY2xpbWJpbmcgdGhlIGRvbSBhY2NvdW50aW5nIGZvclxuICAvLyBhbGwgc2Nyb2xsYWJsZSBjb250YWluZXJzLlxuICB3aGlsZSAoZWwpIHtcbiAgICAvLyBjbGllbnRXaWR0aCBpcyB6ZXJvIGZvciBpbmxpbmUgYmxvY2sgZWxlbWVudHMgaW4gaWUuXG4gICAgaWYgKChuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoJ01TSUUnKSA9PT0gLTEgfHwgZWwuY2xpZW50V2lkdGggIT09IDApICYmXG4gICAgLy8gYm9keSBtYXkgaGF2ZSBvdmVyZmxvdyBzZXQgb24gaXQsIHlldCB3ZSBzdGlsbCBnZXQgdGhlIGVudGlyZVxuICAgIC8vIHZpZXdwb3J0LiBJbiBzb21lIGJyb3dzZXJzLCBlbC5vZmZzZXRQYXJlbnQgbWF5IGJlXG4gICAgLy8gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LCBzbyBjaGVjayBmb3IgdGhhdCB0b28uXG4gICAgZWwgIT09IGJvZHkgJiYgZWwgIT09IGRvY3VtZW50RWxlbWVudCAmJiBfdXRpbHMyWydkZWZhdWx0J10uY3NzKGVsLCAnb3ZlcmZsb3cnKSAhPT0gJ3Zpc2libGUnKSB7XG4gICAgICB2YXIgcG9zID0gX3V0aWxzMlsnZGVmYXVsdCddLm9mZnNldChlbCk7XG4gICAgICAvLyBhZGQgYm9yZGVyXG4gICAgICBwb3MubGVmdCArPSBlbC5jbGllbnRMZWZ0O1xuICAgICAgcG9zLnRvcCArPSBlbC5jbGllbnRUb3A7XG4gICAgICB2aXNpYmxlUmVjdC50b3AgPSBNYXRoLm1heCh2aXNpYmxlUmVjdC50b3AsIHBvcy50b3ApO1xuICAgICAgdmlzaWJsZVJlY3QucmlnaHQgPSBNYXRoLm1pbih2aXNpYmxlUmVjdC5yaWdodCxcbiAgICAgIC8vIGNvbnNpZGVyIGFyZWEgd2l0aG91dCBzY3JvbGxCYXJcbiAgICAgIHBvcy5sZWZ0ICsgZWwuY2xpZW50V2lkdGgpO1xuICAgICAgdmlzaWJsZVJlY3QuYm90dG9tID0gTWF0aC5taW4odmlzaWJsZVJlY3QuYm90dG9tLCBwb3MudG9wICsgZWwuY2xpZW50SGVpZ2h0KTtcbiAgICAgIHZpc2libGVSZWN0LmxlZnQgPSBNYXRoLm1heCh2aXNpYmxlUmVjdC5sZWZ0LCBwb3MubGVmdCk7XG4gICAgfSBlbHNlIGlmIChlbCA9PT0gYm9keSB8fCBlbCA9PT0gZG9jdW1lbnRFbGVtZW50KSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgZWwgPSAoMCwgX2dldE9mZnNldFBhcmVudDJbJ2RlZmF1bHQnXSkoZWwpO1xuICB9XG5cbiAgLy8gQ2xpcCBieSB3aW5kb3cncyB2aWV3cG9ydC5cbiAgc2Nyb2xsWCA9IF91dGlsczJbJ2RlZmF1bHQnXS5nZXRXaW5kb3dTY3JvbGxMZWZ0KHdpbik7XG4gIHNjcm9sbFkgPSBfdXRpbHMyWydkZWZhdWx0J10uZ2V0V2luZG93U2Nyb2xsVG9wKHdpbik7XG4gIHZpc2libGVSZWN0LmxlZnQgPSBNYXRoLm1heCh2aXNpYmxlUmVjdC5sZWZ0LCBzY3JvbGxYKTtcbiAgdmlzaWJsZVJlY3QudG9wID0gTWF0aC5tYXgodmlzaWJsZVJlY3QudG9wLCBzY3JvbGxZKTtcbiAgd2luU2l6ZSA9IHtcbiAgICB3aWR0aDogX3V0aWxzMlsnZGVmYXVsdCddLnZpZXdwb3J0V2lkdGgod2luKSxcbiAgICBoZWlnaHQ6IF91dGlsczJbJ2RlZmF1bHQnXS52aWV3cG9ydEhlaWdodCh3aW4pXG4gIH07XG4gIHZpc2libGVSZWN0LnJpZ2h0ID0gTWF0aC5taW4odmlzaWJsZVJlY3QucmlnaHQsIHNjcm9sbFggKyB3aW5TaXplLndpZHRoKTtcbiAgdmlzaWJsZVJlY3QuYm90dG9tID0gTWF0aC5taW4odmlzaWJsZVJlY3QuYm90dG9tLCBzY3JvbGxZICsgd2luU2l6ZS5oZWlnaHQpO1xuICByZXR1cm4gdmlzaWJsZVJlY3QudG9wID49IDAgJiYgdmlzaWJsZVJlY3QubGVmdCA+PSAwICYmIHZpc2libGVSZWN0LmJvdHRvbSA+IHZpc2libGVSZWN0LnRvcCAmJiB2aXNpYmxlUmVjdC5yaWdodCA+IHZpc2libGVSZWN0LmxlZnQgPyB2aXNpYmxlUmVjdCA6IG51bGw7XG59XG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IGdldFZpc2libGVSZWN0Rm9yRWxlbWVudDtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3V4Y29yZS10YWJsZS9+L3V4Y29yZS1kcm9wZG93bi9+L3JjLWRyb3Bkb3duL34vcmMtdHJpZ2dlci9+L3JjLWFsaWduL34vZG9tLWFsaWduL2xpYi9nZXRWaXNpYmxlUmVjdEZvckVsZW1lbnQuanNcbiAqKiBtb2R1bGUgaWQgPSA4OFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG52YXIgX3V0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xuXG52YXIgX3V0aWxzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3V0aWxzKTtcblxuZnVuY3Rpb24gYWRqdXN0Rm9yVmlld3BvcnQoZWxGdXR1cmVQb3MsIGVsUmVnaW9uLCB2aXNpYmxlUmVjdCwgb3ZlcmZsb3cpIHtcbiAgdmFyIHBvcyA9IF91dGlsczJbJ2RlZmF1bHQnXS5jbG9uZShlbEZ1dHVyZVBvcyk7XG4gIHZhciBzaXplID0ge1xuICAgIHdpZHRoOiBlbFJlZ2lvbi53aWR0aCxcbiAgICBoZWlnaHQ6IGVsUmVnaW9uLmhlaWdodFxuICB9O1xuXG4gIGlmIChvdmVyZmxvdy5hZGp1c3RYICYmIHBvcy5sZWZ0IDwgdmlzaWJsZVJlY3QubGVmdCkge1xuICAgIHBvcy5sZWZ0ID0gdmlzaWJsZVJlY3QubGVmdDtcbiAgfVxuXG4gIC8vIExlZnQgZWRnZSBpbnNpZGUgYW5kIHJpZ2h0IGVkZ2Ugb3V0c2lkZSB2aWV3cG9ydCwgdHJ5IHRvIHJlc2l6ZSBpdC5cbiAgaWYgKG92ZXJmbG93LnJlc2l6ZVdpZHRoICYmIHBvcy5sZWZ0ID49IHZpc2libGVSZWN0LmxlZnQgJiYgcG9zLmxlZnQgKyBzaXplLndpZHRoID4gdmlzaWJsZVJlY3QucmlnaHQpIHtcbiAgICBzaXplLndpZHRoIC09IHBvcy5sZWZ0ICsgc2l6ZS53aWR0aCAtIHZpc2libGVSZWN0LnJpZ2h0O1xuICB9XG5cbiAgLy8gUmlnaHQgZWRnZSBvdXRzaWRlIHZpZXdwb3J0LCB0cnkgdG8gbW92ZSBpdC5cbiAgaWYgKG92ZXJmbG93LmFkanVzdFggJiYgcG9zLmxlZnQgKyBzaXplLndpZHRoID4gdmlzaWJsZVJlY3QucmlnaHQpIHtcbiAgICAvLyDkv53or4Hlt6bovrnnlYzlkozlj6/op4bljLrln5/lt6bovrnnlYzlr7npvZBcbiAgICBwb3MubGVmdCA9IE1hdGgubWF4KHZpc2libGVSZWN0LnJpZ2h0IC0gc2l6ZS53aWR0aCwgdmlzaWJsZVJlY3QubGVmdCk7XG4gIH1cblxuICAvLyBUb3AgZWRnZSBvdXRzaWRlIHZpZXdwb3J0LCB0cnkgdG8gbW92ZSBpdC5cbiAgaWYgKG92ZXJmbG93LmFkanVzdFkgJiYgcG9zLnRvcCA8IHZpc2libGVSZWN0LnRvcCkge1xuICAgIHBvcy50b3AgPSB2aXNpYmxlUmVjdC50b3A7XG4gIH1cblxuICAvLyBUb3AgZWRnZSBpbnNpZGUgYW5kIGJvdHRvbSBlZGdlIG91dHNpZGUgdmlld3BvcnQsIHRyeSB0byByZXNpemUgaXQuXG4gIGlmIChvdmVyZmxvdy5yZXNpemVIZWlnaHQgJiYgcG9zLnRvcCA+PSB2aXNpYmxlUmVjdC50b3AgJiYgcG9zLnRvcCArIHNpemUuaGVpZ2h0ID4gdmlzaWJsZVJlY3QuYm90dG9tKSB7XG4gICAgc2l6ZS5oZWlnaHQgLT0gcG9zLnRvcCArIHNpemUuaGVpZ2h0IC0gdmlzaWJsZVJlY3QuYm90dG9tO1xuICB9XG5cbiAgLy8gQm90dG9tIGVkZ2Ugb3V0c2lkZSB2aWV3cG9ydCwgdHJ5IHRvIG1vdmUgaXQuXG4gIGlmIChvdmVyZmxvdy5hZGp1c3RZICYmIHBvcy50b3AgKyBzaXplLmhlaWdodCA+IHZpc2libGVSZWN0LmJvdHRvbSkge1xuICAgIC8vIOS/neivgeS4iui+ueeVjOWSjOWPr+inhuWMuuWfn+S4iui+ueeVjOWvuem9kFxuICAgIHBvcy50b3AgPSBNYXRoLm1heCh2aXNpYmxlUmVjdC5ib3R0b20gLSBzaXplLmhlaWdodCwgdmlzaWJsZVJlY3QudG9wKTtcbiAgfVxuXG4gIHJldHVybiBfdXRpbHMyWydkZWZhdWx0J10ubWl4KHBvcywgc2l6ZSk7XG59XG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IGFkanVzdEZvclZpZXdwb3J0O1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vdXhjb3JlLXRhYmxlL34vdXhjb3JlLWRyb3Bkb3duL34vcmMtZHJvcGRvd24vfi9yYy10cmlnZ2VyL34vcmMtYWxpZ24vfi9kb20tYWxpZ24vbGliL2FkanVzdEZvclZpZXdwb3J0LmpzXG4gKiogbW9kdWxlIGlkID0gODlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxudmFyIF91dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcblxudmFyIF91dGlsczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF91dGlscyk7XG5cbmZ1bmN0aW9uIGdldFJlZ2lvbihub2RlKSB7XG4gIHZhciBvZmZzZXQgPSB1bmRlZmluZWQ7XG4gIHZhciB3ID0gdW5kZWZpbmVkO1xuICB2YXIgaCA9IHVuZGVmaW5lZDtcbiAgaWYgKCFfdXRpbHMyWydkZWZhdWx0J10uaXNXaW5kb3cobm9kZSkgJiYgbm9kZS5ub2RlVHlwZSAhPT0gOSkge1xuICAgIG9mZnNldCA9IF91dGlsczJbJ2RlZmF1bHQnXS5vZmZzZXQobm9kZSk7XG4gICAgdyA9IF91dGlsczJbJ2RlZmF1bHQnXS5vdXRlcldpZHRoKG5vZGUpO1xuICAgIGggPSBfdXRpbHMyWydkZWZhdWx0J10ub3V0ZXJIZWlnaHQobm9kZSk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIHdpbiA9IF91dGlsczJbJ2RlZmF1bHQnXS5nZXRXaW5kb3cobm9kZSk7XG4gICAgb2Zmc2V0ID0ge1xuICAgICAgbGVmdDogX3V0aWxzMlsnZGVmYXVsdCddLmdldFdpbmRvd1Njcm9sbExlZnQod2luKSxcbiAgICAgIHRvcDogX3V0aWxzMlsnZGVmYXVsdCddLmdldFdpbmRvd1Njcm9sbFRvcCh3aW4pXG4gICAgfTtcbiAgICB3ID0gX3V0aWxzMlsnZGVmYXVsdCddLnZpZXdwb3J0V2lkdGgod2luKTtcbiAgICBoID0gX3V0aWxzMlsnZGVmYXVsdCddLnZpZXdwb3J0SGVpZ2h0KHdpbik7XG4gIH1cbiAgb2Zmc2V0LndpZHRoID0gdztcbiAgb2Zmc2V0LmhlaWdodCA9IGg7XG4gIHJldHVybiBvZmZzZXQ7XG59XG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IGdldFJlZ2lvbjtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3V4Y29yZS10YWJsZS9+L3V4Y29yZS1kcm9wZG93bi9+L3JjLWRyb3Bkb3duL34vcmMtdHJpZ2dlci9+L3JjLWFsaWduL34vZG9tLWFsaWduL2xpYi9nZXRSZWdpb24uanNcbiAqKiBtb2R1bGUgaWQgPSA5MFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG52YXIgX2dldEFsaWduT2Zmc2V0ID0gcmVxdWlyZSgnLi9nZXRBbGlnbk9mZnNldCcpO1xuXG52YXIgX2dldEFsaWduT2Zmc2V0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2dldEFsaWduT2Zmc2V0KTtcblxuZnVuY3Rpb24gZ2V0RWxGdXR1cmVQb3MoZWxSZWdpb24sIHJlZk5vZGVSZWdpb24sIHBvaW50cywgb2Zmc2V0LCB0YXJnZXRPZmZzZXQpIHtcbiAgdmFyIHh5ID0gdW5kZWZpbmVkO1xuICB2YXIgZGlmZiA9IHVuZGVmaW5lZDtcbiAgdmFyIHAxID0gdW5kZWZpbmVkO1xuICB2YXIgcDIgPSB1bmRlZmluZWQ7XG5cbiAgeHkgPSB7XG4gICAgbGVmdDogZWxSZWdpb24ubGVmdCxcbiAgICB0b3A6IGVsUmVnaW9uLnRvcFxuICB9O1xuXG4gIHAxID0gKDAsIF9nZXRBbGlnbk9mZnNldDJbJ2RlZmF1bHQnXSkocmVmTm9kZVJlZ2lvbiwgcG9pbnRzWzFdKTtcbiAgcDIgPSAoMCwgX2dldEFsaWduT2Zmc2V0MlsnZGVmYXVsdCddKShlbFJlZ2lvbiwgcG9pbnRzWzBdKTtcblxuICBkaWZmID0gW3AyLmxlZnQgLSBwMS5sZWZ0LCBwMi50b3AgLSBwMS50b3BdO1xuXG4gIHJldHVybiB7XG4gICAgbGVmdDogeHkubGVmdCAtIGRpZmZbMF0gKyBvZmZzZXRbMF0gLSB0YXJnZXRPZmZzZXRbMF0sXG4gICAgdG9wOiB4eS50b3AgLSBkaWZmWzFdICsgb2Zmc2V0WzFdIC0gdGFyZ2V0T2Zmc2V0WzFdXG4gIH07XG59XG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IGdldEVsRnV0dXJlUG9zO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vdXhjb3JlLXRhYmxlL34vdXhjb3JlLWRyb3Bkb3duL34vcmMtZHJvcGRvd24vfi9yYy10cmlnZ2VyL34vcmMtYWxpZ24vfi9kb20tYWxpZ24vbGliL2dldEVsRnV0dXJlUG9zLmpzXG4gKiogbW9kdWxlIGlkID0gOTFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9yZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5cbnZhciBfcmVhY3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmVhY3QpO1xuXG52YXIgX0xhenlSZW5kZXJCb3ggPSByZXF1aXJlKCcuL0xhenlSZW5kZXJCb3gnKTtcblxudmFyIF9MYXp5UmVuZGVyQm94MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0xhenlSZW5kZXJCb3gpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBcImRlZmF1bHRcIjogb2JqIH07IH1cblxudmFyIFBvcHVwSW5uZXIgPSBfcmVhY3QyW1wiZGVmYXVsdFwiXS5jcmVhdGVDbGFzcyh7XG4gIGRpc3BsYXlOYW1lOiAnUG9wdXBJbm5lcicsXG5cbiAgcHJvcFR5cGVzOiB7XG4gICAgaGlkZGVuQ2xhc3NOYW1lOiBfcmVhY3QuUHJvcFR5cGVzLnN0cmluZyxcbiAgICBjbGFzc05hbWU6IF9yZWFjdC5Qcm9wVHlwZXMuc3RyaW5nLFxuICAgIHByZWZpeENsczogX3JlYWN0LlByb3BUeXBlcy5zdHJpbmcsXG4gICAgb25Nb3VzZUVudGVyOiBfcmVhY3QuUHJvcFR5cGVzLmZ1bmMsXG4gICAgb25Nb3VzZUxlYXZlOiBfcmVhY3QuUHJvcFR5cGVzLmZ1bmMsXG4gICAgY2hpbGRyZW46IF9yZWFjdC5Qcm9wVHlwZXMuYW55XG4gIH0sXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgIHZhciBwcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgdmFyIGNsYXNzTmFtZSA9IHByb3BzLmNsYXNzTmFtZTtcbiAgICBpZiAoIXByb3BzLnZpc2libGUpIHtcbiAgICAgIGNsYXNzTmFtZSArPSAnICcgKyBwcm9wcy5oaWRkZW5DbGFzc05hbWU7XG4gICAgfVxuICAgIHJldHVybiBfcmVhY3QyW1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFxuICAgICAgJ2RpdicsXG4gICAgICB7XG4gICAgICAgIGNsYXNzTmFtZTogY2xhc3NOYW1lLFxuICAgICAgICBvbk1vdXNlRW50ZXI6IHByb3BzLm9uTW91c2VFbnRlcixcbiAgICAgICAgb25Nb3VzZUxlYXZlOiBwcm9wcy5vbk1vdXNlTGVhdmUsXG4gICAgICAgIHN0eWxlOiBwcm9wcy5zdHlsZVxuICAgICAgfSxcbiAgICAgIF9yZWFjdDJbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgIF9MYXp5UmVuZGVyQm94MltcImRlZmF1bHRcIl0sXG4gICAgICAgIHsgY2xhc3NOYW1lOiBwcm9wcy5wcmVmaXhDbHMgKyAnLWNvbnRlbnQnLCB2aXNpYmxlOiBwcm9wcy52aXNpYmxlIH0sXG4gICAgICAgIHByb3BzLmNoaWxkcmVuXG4gICAgICApXG4gICAgKTtcbiAgfVxufSk7XG5cbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gUG9wdXBJbm5lcjtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3V4Y29yZS10YWJsZS9+L3V4Y29yZS1kcm9wZG93bi9+L3JjLWRyb3Bkb3duL34vcmMtdHJpZ2dlci9saWIvUG9wdXBJbm5lci5qc1xuICoqIG1vZHVsZSBpZCA9IDEwM1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIFRvb2x0aXAgQ29tcG9uZW50IGZvciB1eGNvcmVcbiAqIEBhdXRob3IgXG4gKlxuICogQ29weXJpZ2h0IDIwMTQtMjAxNSwgVXhjb3JlIFRlYW0sIEFsaW53LlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vVG9vbHRpcCcpO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3V4Y29yZS10YWJsZS9+L3V4Y29yZS10b29sdGlwL2J1aWxkL2luZGV4LmpzXG4gKiogbW9kdWxlIGlkID0gMTA3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfcmNUb29sdGlwID0gcmVxdWlyZSgncmMtdG9vbHRpcCcpO1xuXG52YXIgX3JjVG9vbHRpcDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yY1Rvb2x0aXApO1xuXG52YXIgX29iamVjdEFzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcblxudmFyIF9vYmplY3RBc3NpZ24yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfb2JqZWN0QXNzaWduKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgXCJkZWZhdWx0XCI6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIFRvb2x0aXAgPSBmdW5jdGlvbiAoX1JjVG9vbHRpcCkge1xuXHRfaW5oZXJpdHMoVG9vbHRpcCwgX1JjVG9vbHRpcCk7XG5cblx0ZnVuY3Rpb24gVG9vbHRpcChwcm9wcykge1xuXHRcdF9jbGFzc0NhbGxDaGVjayh0aGlzLCBUb29sdGlwKTtcblxuXHRcdHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfUmNUb29sdGlwLmNhbGwodGhpcywgcHJvcHMpKTtcblx0fVxuXG5cdHJldHVybiBUb29sdGlwO1xufShfcmNUb29sdGlwMltcImRlZmF1bHRcIl0pO1xuXG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IFRvb2x0aXA7XG5cblRvb2x0aXAuZGlzcGxheU5hbWUgPSAndXhjb3JlLXRvb2x0aXAnO1xuVG9vbHRpcC5wcm9wVHlwZXMgPSBfcmNUb29sdGlwMltcImRlZmF1bHRcIl0ucHJvcFR5cGVzO1xuXG5Ub29sdGlwLmRlZmF1bHRQcm9wcyA9ICgwLCBfb2JqZWN0QXNzaWduMltcImRlZmF1bHRcIl0pKF9yY1Rvb2x0aXAyW1wiZGVmYXVsdFwiXS5kZWZhdWx0UHJvcHMsIHtcblx0cHJlZml4Q2xzOiAna3VtYS10b29sdGlwJyxcblx0dHJhbnNpdGlvbk5hbWU6ICdmbGlwJ1xufSk7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi91eGNvcmUtdGFibGUvfi91eGNvcmUtdG9vbHRpcC9idWlsZC9Ub29sdGlwLmpzXG4gKiogbW9kdWxlIGlkID0gMTA4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9Ub29sdGlwJyk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vdXhjb3JlLXRhYmxlL34vdXhjb3JlLXRvb2x0aXAvfi9yYy10b29sdGlwL2xpYi9pbmRleC5qc1xuICoqIG1vZHVsZSBpZCA9IDEwOVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG52YXIgX3JlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxudmFyIF9yZWFjdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yZWFjdCk7XG5cbnZhciBfcGxhY2VtZW50cyA9IHJlcXVpcmUoJy4vcGxhY2VtZW50cycpO1xuXG52YXIgX3JjVHJpZ2dlciA9IHJlcXVpcmUoJ3JjLXRyaWdnZXInKTtcblxudmFyIF9yY1RyaWdnZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmNUcmlnZ2VyKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgXCJkZWZhdWx0XCI6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhvYmosIGtleXMpIHsgdmFyIHRhcmdldCA9IHt9OyBmb3IgKHZhciBpIGluIG9iaikgeyBpZiAoa2V5cy5pbmRleE9mKGkpID49IDApIGNvbnRpbnVlOyBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGkpKSBjb250aW51ZTsgdGFyZ2V0W2ldID0gb2JqW2ldOyB9IHJldHVybiB0YXJnZXQ7IH1cblxudmFyIFRvb2x0aXAgPSBfcmVhY3QyW1wiZGVmYXVsdFwiXS5jcmVhdGVDbGFzcyh7XG4gIGRpc3BsYXlOYW1lOiAnVG9vbHRpcCcsXG5cbiAgcHJvcFR5cGVzOiB7XG4gICAgdHJpZ2dlcjogX3JlYWN0LlByb3BUeXBlcy5hbnksXG4gICAgY2hpbGRyZW46IF9yZWFjdC5Qcm9wVHlwZXMuYW55LFxuICAgIGRlZmF1bHRWaXNpYmxlOiBfcmVhY3QuUHJvcFR5cGVzLmJvb2wsXG4gICAgdmlzaWJsZTogX3JlYWN0LlByb3BUeXBlcy5ib29sLFxuICAgIHBsYWNlbWVudDogX3JlYWN0LlByb3BUeXBlcy5zdHJpbmcsXG4gICAgdHJhbnNpdGlvbk5hbWU6IF9yZWFjdC5Qcm9wVHlwZXMuc3RyaW5nLFxuICAgIGFuaW1hdGlvbjogX3JlYWN0LlByb3BUeXBlcy5hbnksXG4gICAgb25WaXNpYmxlQ2hhbmdlOiBfcmVhY3QuUHJvcFR5cGVzLmZ1bmMsXG4gICAgYWZ0ZXJWaXNpYmxlQ2hhbmdlOiBfcmVhY3QuUHJvcFR5cGVzLmZ1bmMsXG4gICAgb3ZlcmxheTogX3JlYWN0LlByb3BUeXBlcy5ub2RlLmlzUmVxdWlyZWQsXG4gICAgb3ZlcmxheVN0eWxlOiBfcmVhY3QuUHJvcFR5cGVzLm9iamVjdCxcbiAgICBvdmVybGF5Q2xhc3NOYW1lOiBfcmVhY3QuUHJvcFR5cGVzLnN0cmluZyxcbiAgICBwcmVmaXhDbHM6IF9yZWFjdC5Qcm9wVHlwZXMuc3RyaW5nLFxuICAgIG1vdXNlRW50ZXJEZWxheTogX3JlYWN0LlByb3BUeXBlcy5udW1iZXIsXG4gICAgbW91c2VMZWF2ZURlbGF5OiBfcmVhY3QuUHJvcFR5cGVzLm51bWJlcixcbiAgICBnZXRUb29sdGlwQ29udGFpbmVyOiBfcmVhY3QuUHJvcFR5cGVzLmZ1bmMsXG4gICAgZGVzdHJveVRvb2x0aXBPbkhpZGU6IF9yZWFjdC5Qcm9wVHlwZXMuYm9vbCxcbiAgICBhbGlnbjogX3JlYWN0LlByb3BUeXBlcy5vYmplY3QsXG4gICAgYXJyb3dDb250ZW50OiBfcmVhY3QuUHJvcFR5cGVzLmFueVxuICB9LFxuXG4gIGdldERlZmF1bHRQcm9wczogZnVuY3Rpb24gZ2V0RGVmYXVsdFByb3BzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBwcmVmaXhDbHM6ICdyYy10b29sdGlwJyxcbiAgICAgIG1vdXNlRW50ZXJEZWxheTogMCxcbiAgICAgIGRlc3Ryb3lUb29sdGlwT25IaWRlOiBmYWxzZSxcbiAgICAgIG1vdXNlTGVhdmVEZWxheTogMC4xLFxuICAgICAgYWxpZ246IHt9LFxuICAgICAgcGxhY2VtZW50OiAncmlnaHQnLFxuICAgICAgdHJpZ2dlcjogWydob3ZlciddLFxuICAgICAgYXJyb3dDb250ZW50OiBudWxsXG4gICAgfTtcbiAgfSxcbiAgZ2V0UG9wdXBFbGVtZW50OiBmdW5jdGlvbiBnZXRQb3B1cEVsZW1lbnQoKSB7XG4gICAgdmFyIF9wcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgdmFyIGFycm93Q29udGVudCA9IF9wcm9wcy5hcnJvd0NvbnRlbnQ7XG4gICAgdmFyIG92ZXJsYXkgPSBfcHJvcHMub3ZlcmxheTtcbiAgICB2YXIgcHJlZml4Q2xzID0gX3Byb3BzLnByZWZpeENscztcblxuICAgIHJldHVybiBbX3JlYWN0MltcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChcbiAgICAgICdkaXYnLFxuICAgICAgeyBjbGFzc05hbWU6IHByZWZpeENscyArICctYXJyb3cnLCBrZXk6ICdhcnJvdycgfSxcbiAgICAgIGFycm93Q29udGVudFxuICAgICksIF9yZWFjdDJbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXG4gICAgICAnZGl2JyxcbiAgICAgIHsgY2xhc3NOYW1lOiBwcmVmaXhDbHMgKyAnLWlubmVyJywga2V5OiAnY29udGVudCcgfSxcbiAgICAgIG92ZXJsYXlcbiAgICApXTtcbiAgfSxcbiAgZ2V0UG9wdXBEb21Ob2RlOiBmdW5jdGlvbiBnZXRQb3B1cERvbU5vZGUoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVmcy50cmlnZ2VyLnBvcHVwRG9tTm9kZTtcbiAgfSxcbiAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgdmFyIF9wcm9wczIgPSB0aGlzLnByb3BzO1xuICAgIHZhciBvdmVybGF5Q2xhc3NOYW1lID0gX3Byb3BzMi5vdmVybGF5Q2xhc3NOYW1lO1xuICAgIHZhciB0cmlnZ2VyID0gX3Byb3BzMi50cmlnZ2VyO1xuICAgIHZhciBtb3VzZUVudGVyRGVsYXkgPSBfcHJvcHMyLm1vdXNlRW50ZXJEZWxheTtcbiAgICB2YXIgbW91c2VMZWF2ZURlbGF5ID0gX3Byb3BzMi5tb3VzZUxlYXZlRGVsYXk7XG4gICAgdmFyIG92ZXJsYXlTdHlsZSA9IF9wcm9wczIub3ZlcmxheVN0eWxlO1xuICAgIHZhciBwcmVmaXhDbHMgPSBfcHJvcHMyLnByZWZpeENscztcbiAgICB2YXIgY2hpbGRyZW4gPSBfcHJvcHMyLmNoaWxkcmVuO1xuICAgIHZhciBvblZpc2libGVDaGFuZ2UgPSBfcHJvcHMyLm9uVmlzaWJsZUNoYW5nZTtcbiAgICB2YXIgdHJhbnNpdGlvbk5hbWUgPSBfcHJvcHMyLnRyYW5zaXRpb25OYW1lO1xuICAgIHZhciBhbmltYXRpb24gPSBfcHJvcHMyLmFuaW1hdGlvbjtcbiAgICB2YXIgcGxhY2VtZW50ID0gX3Byb3BzMi5wbGFjZW1lbnQ7XG4gICAgdmFyIGFsaWduID0gX3Byb3BzMi5hbGlnbjtcbiAgICB2YXIgZGVzdHJveVRvb2x0aXBPbkhpZGUgPSBfcHJvcHMyLmRlc3Ryb3lUb29sdGlwT25IaWRlO1xuICAgIHZhciBkZWZhdWx0VmlzaWJsZSA9IF9wcm9wczIuZGVmYXVsdFZpc2libGU7XG4gICAgdmFyIGdldFRvb2x0aXBDb250YWluZXIgPSBfcHJvcHMyLmdldFRvb2x0aXBDb250YWluZXI7XG5cbiAgICB2YXIgcmVzdFByb3BzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9wcm9wczIsIFsnb3ZlcmxheUNsYXNzTmFtZScsICd0cmlnZ2VyJywgJ21vdXNlRW50ZXJEZWxheScsICdtb3VzZUxlYXZlRGVsYXknLCAnb3ZlcmxheVN0eWxlJywgJ3ByZWZpeENscycsICdjaGlsZHJlbicsICdvblZpc2libGVDaGFuZ2UnLCAndHJhbnNpdGlvbk5hbWUnLCAnYW5pbWF0aW9uJywgJ3BsYWNlbWVudCcsICdhbGlnbicsICdkZXN0cm95VG9vbHRpcE9uSGlkZScsICdkZWZhdWx0VmlzaWJsZScsICdnZXRUb29sdGlwQ29udGFpbmVyJ10pO1xuXG4gICAgdmFyIGV4dHJhUHJvcHMgPSBfZXh0ZW5kcyh7fSwgcmVzdFByb3BzKTtcbiAgICBpZiAoJ3Zpc2libGUnIGluIHRoaXMucHJvcHMpIHtcbiAgICAgIGV4dHJhUHJvcHMucG9wdXBWaXNpYmxlID0gdGhpcy5wcm9wcy52aXNpYmxlO1xuICAgIH1cbiAgICByZXR1cm4gX3JlYWN0MltcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChcbiAgICAgIF9yY1RyaWdnZXIyW1wiZGVmYXVsdFwiXSxcbiAgICAgIF9leHRlbmRzKHtcbiAgICAgICAgcG9wdXBDbGFzc05hbWU6IG92ZXJsYXlDbGFzc05hbWUsXG4gICAgICAgIHJlZjogJ3RyaWdnZXInLFxuICAgICAgICBwcmVmaXhDbHM6IHByZWZpeENscyxcbiAgICAgICAgcG9wdXA6IHRoaXMuZ2V0UG9wdXBFbGVtZW50KCksXG4gICAgICAgIGFjdGlvbjogdHJpZ2dlcixcbiAgICAgICAgYnVpbHRpblBsYWNlbWVudHM6IF9wbGFjZW1lbnRzLnBsYWNlbWVudHMsXG4gICAgICAgIHBvcHVwUGxhY2VtZW50OiBwbGFjZW1lbnQsXG4gICAgICAgIHBvcHVwQWxpZ246IGFsaWduLFxuICAgICAgICBnZXRQb3B1cENvbnRhaW5lcjogZ2V0VG9vbHRpcENvbnRhaW5lcixcbiAgICAgICAgb25Qb3B1cFZpc2libGVDaGFuZ2U6IG9uVmlzaWJsZUNoYW5nZSxcbiAgICAgICAgcG9wdXBUcmFuc2l0aW9uTmFtZTogdHJhbnNpdGlvbk5hbWUsXG4gICAgICAgIHBvcHVwQW5pbWF0aW9uOiBhbmltYXRpb24sXG4gICAgICAgIGRlZmF1bHRQb3B1cFZpc2libGU6IGRlZmF1bHRWaXNpYmxlLFxuICAgICAgICBkZXN0cm95UG9wdXBPbkhpZGU6IGRlc3Ryb3lUb29sdGlwT25IaWRlLFxuICAgICAgICBtb3VzZUxlYXZlRGVsYXk6IG1vdXNlTGVhdmVEZWxheSxcbiAgICAgICAgcG9wdXBTdHlsZTogb3ZlcmxheVN0eWxlLFxuICAgICAgICBtb3VzZUVudGVyRGVsYXk6IG1vdXNlRW50ZXJEZWxheVxuICAgICAgfSwgZXh0cmFQcm9wcyksXG4gICAgICBjaGlsZHJlblxuICAgICk7XG4gIH1cbn0pO1xuXG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IFRvb2x0aXA7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi91eGNvcmUtdGFibGUvfi91eGNvcmUtdG9vbHRpcC9+L3JjLXRvb2x0aXAvbGliL1Rvb2x0aXAuanNcbiAqKiBtb2R1bGUgaWQgPSAxMTBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBTZWxlY3QyIENvbXBvbmVudCBmb3IgdXhjb3JlXG4gKiBAYXV0aG9yIFxuICpcbiAqIENvcHlyaWdodCAyMDE0LTIwMTUsIFV4Y29yZSBUZWFtLCBBbGludy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL1NlbGVjdDInKTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi91eGNvcmUtdGFibGUvfi91eGNvcmUtc2VsZWN0Mi9idWlsZC9pbmRleC5qc1xuICoqIG1vZHVsZSBpZCA9IDE2NVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfcmNTZWxlY3QgPSByZXF1aXJlKCdyYy1zZWxlY3QnKTtcblxudmFyIF9yY1NlbGVjdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yY1NlbGVjdCk7XG5cbnZhciBfb2JqZWN0QXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xuXG52YXIgX29iamVjdEFzc2lnbjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9vYmplY3RBc3NpZ24pO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBcImRlZmF1bHRcIjogb2JqIH07IH1cblxuZnVuY3Rpb24gX2RlZmF1bHRzKG9iaiwgZGVmYXVsdHMpIHsgdmFyIGtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhkZWZhdWx0cyk7IGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykgeyB2YXIga2V5ID0ga2V5c1tpXTsgdmFyIHZhbHVlID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihkZWZhdWx0cywga2V5KTsgaWYgKHZhbHVlICYmIHZhbHVlLmNvbmZpZ3VyYWJsZSAmJiBvYmpba2V5XSA9PT0gdW5kZWZpbmVkKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpOyB9IH0gcmV0dXJuIG9iajsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBfZGVmYXVsdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpOyB9XG5cbnZhciBTZWxlY3QyID0gZnVuY3Rpb24gKF9SY1NlbGVjdCkge1xuICAgIF9pbmhlcml0cyhTZWxlY3QyLCBfUmNTZWxlY3QpO1xuXG4gICAgZnVuY3Rpb24gU2VsZWN0Mihwcm9wcykge1xuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgU2VsZWN0Mik7XG5cbiAgICAgICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9SY1NlbGVjdC5jYWxsKHRoaXMsIHByb3BzKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIFNlbGVjdDI7XG59KF9yY1NlbGVjdDJbXCJkZWZhdWx0XCJdKTtcblxuU2VsZWN0Mi5kaXNwbGF5TmFtZSA9ICdTZWxlY3QyJztcblNlbGVjdDIuZGVmYXVsdFByb3BzID0gKDAsIF9vYmplY3RBc3NpZ24yW1wiZGVmYXVsdFwiXSkoe30sIF9yY1NlbGVjdDJbXCJkZWZhdWx0XCJdLmRlZmF1bHRQcm9wcywge1xuICAgIHByZWZpeENsczogJ2t1bWEtc2VsZWN0MicsXG4gICAgb3B0aW9uTGFiZWxQcm9wOiAnY2hpbGRyZW4nLFxuICAgIHRyYW5zaXRpb25OYW1lOiAnc2xpZGVVcCdcbn0pO1xuXG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IFNlbGVjdDI7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi91eGNvcmUtdGFibGUvfi91eGNvcmUtc2VsZWN0Mi9idWlsZC9TZWxlY3QyLmpzXG4gKiogbW9kdWxlIGlkID0gMTY2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLk9wdEdyb3VwID0gZXhwb3J0cy5PcHRpb24gPSB1bmRlZmluZWQ7XG5cbnZhciBfU2VsZWN0ID0gcmVxdWlyZSgnLi9TZWxlY3QnKTtcblxudmFyIF9TZWxlY3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfU2VsZWN0KTtcblxudmFyIF9PcHRpb24gPSByZXF1aXJlKCcuL09wdGlvbicpO1xuXG52YXIgX09wdGlvbjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9PcHRpb24pO1xuXG52YXIgX09wdEdyb3VwID0gcmVxdWlyZSgnLi9PcHRHcm91cCcpO1xuXG52YXIgX09wdEdyb3VwMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX09wdEdyb3VwKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgXCJkZWZhdWx0XCI6IG9iaiB9OyB9XG5cbl9TZWxlY3QyW1wiZGVmYXVsdFwiXS5PcHRpb24gPSBfT3B0aW9uMltcImRlZmF1bHRcIl07XG5fU2VsZWN0MltcImRlZmF1bHRcIl0uT3B0R3JvdXAgPSBfT3B0R3JvdXAyW1wiZGVmYXVsdFwiXTtcbmV4cG9ydHMuT3B0aW9uID0gX09wdGlvbjJbXCJkZWZhdWx0XCJdO1xuZXhwb3J0cy5PcHRHcm91cCA9IF9PcHRHcm91cDJbXCJkZWZhdWx0XCJdO1xuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBfU2VsZWN0MltcImRlZmF1bHRcIl07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vdXhjb3JlLXRhYmxlL34vdXhjb3JlLXNlbGVjdDIvfi9yYy1zZWxlY3QvbGliL2luZGV4LmpzXG4gKiogbW9kdWxlIGlkID0gMTY3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbnZhciBfcmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xuXG52YXIgX3JlYWN0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JlYWN0KTtcblxudmFyIF9yZWFjdERvbSA9IHJlcXVpcmUoJ3JlYWN0LWRvbScpO1xuXG52YXIgX3JlYWN0RG9tMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JlYWN0RG9tKTtcblxudmFyIF9yY1V0aWwgPSByZXF1aXJlKCdyYy11dGlsJyk7XG5cbnZhciBfY2xhc3NuYW1lcyA9IHJlcXVpcmUoJ2NsYXNzbmFtZXMnKTtcblxudmFyIF9jbGFzc25hbWVzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NsYXNzbmFtZXMpO1xuXG52YXIgX09wdEdyb3VwID0gcmVxdWlyZSgnLi9PcHRHcm91cCcpO1xuXG52YXIgX09wdEdyb3VwMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX09wdEdyb3VwKTtcblxudmFyIF9yY0FuaW1hdGUgPSByZXF1aXJlKCdyYy1hbmltYXRlJyk7XG5cbnZhciBfcmNBbmltYXRlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JjQW5pbWF0ZSk7XG5cbnZhciBfY29tcG9uZW50Q2xhc3NlcyA9IHJlcXVpcmUoJ2NvbXBvbmVudC1jbGFzc2VzJyk7XG5cbnZhciBfY29tcG9uZW50Q2xhc3NlczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jb21wb25lbnRDbGFzc2VzKTtcblxudmFyIF91dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG5cbnZhciBfU2VsZWN0VHJpZ2dlciA9IHJlcXVpcmUoJy4vU2VsZWN0VHJpZ2dlcicpO1xuXG52YXIgX1NlbGVjdFRyaWdnZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfU2VsZWN0VHJpZ2dlcik7XG5cbnZhciBfRmlsdGVyTWl4aW4gPSByZXF1aXJlKCcuL0ZpbHRlck1peGluJyk7XG5cbnZhciBfRmlsdGVyTWl4aW4yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfRmlsdGVyTWl4aW4pO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBcImRlZmF1bHRcIjogb2JqIH07IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbmZ1bmN0aW9uIGZpbHRlckZuKGlucHV0LCBjaGlsZCkge1xuICByZXR1cm4gU3RyaW5nKCgwLCBfdXRpbC5nZXRQcm9wVmFsdWUpKGNoaWxkLCB0aGlzLnByb3BzLm9wdGlvbkZpbHRlclByb3ApKS5pbmRleE9mKGlucHV0KSA+IC0xO1xufVxuXG5mdW5jdGlvbiBzYXZlUmVmKG5hbWUsIGNvbXBvbmVudCkge1xuICB0aGlzW25hbWVdID0gY29tcG9uZW50O1xufVxuXG52YXIgU2VsZWN0ID0gX3JlYWN0MltcImRlZmF1bHRcIl0uY3JlYXRlQ2xhc3Moe1xuICBkaXNwbGF5TmFtZTogJ1NlbGVjdCcsXG5cbiAgcHJvcFR5cGVzOiB7XG4gICAgZGVmYXVsdEFjdGl2ZUZpcnN0T3B0aW9uOiBfcmVhY3QuUHJvcFR5cGVzLmJvb2wsXG4gICAgbXVsdGlwbGU6IF9yZWFjdC5Qcm9wVHlwZXMuYm9vbCxcbiAgICBmaWx0ZXJPcHRpb246IF9yZWFjdC5Qcm9wVHlwZXMuYW55LFxuICAgIHNob3dTZWFyY2g6IF9yZWFjdC5Qcm9wVHlwZXMuYm9vbCxcbiAgICBkaXNhYmxlZDogX3JlYWN0LlByb3BUeXBlcy5ib29sLFxuICAgIGFsbG93Q2xlYXI6IF9yZWFjdC5Qcm9wVHlwZXMuYm9vbCxcbiAgICBzaG93QXJyb3c6IF9yZWFjdC5Qcm9wVHlwZXMuYm9vbCxcbiAgICB0YWdzOiBfcmVhY3QuUHJvcFR5cGVzLmJvb2wsXG4gICAgcHJlZml4Q2xzOiBfcmVhY3QuUHJvcFR5cGVzLnN0cmluZyxcbiAgICBjbGFzc05hbWU6IF9yZWFjdC5Qcm9wVHlwZXMuc3RyaW5nLFxuICAgIHRyYW5zaXRpb25OYW1lOiBfcmVhY3QuUHJvcFR5cGVzLnN0cmluZyxcbiAgICBvcHRpb25MYWJlbFByb3A6IF9yZWFjdC5Qcm9wVHlwZXMuc3RyaW5nLFxuICAgIG9wdGlvbkZpbHRlclByb3A6IF9yZWFjdC5Qcm9wVHlwZXMuc3RyaW5nLFxuICAgIGFuaW1hdGlvbjogX3JlYWN0LlByb3BUeXBlcy5zdHJpbmcsXG4gICAgY2hvaWNlVHJhbnNpdGlvbk5hbWU6IF9yZWFjdC5Qcm9wVHlwZXMuc3RyaW5nLFxuICAgIG9uQ2hhbmdlOiBfcmVhY3QuUHJvcFR5cGVzLmZ1bmMsXG4gICAgb25TZWxlY3Q6IF9yZWFjdC5Qcm9wVHlwZXMuZnVuYyxcbiAgICBvblNlYXJjaDogX3JlYWN0LlByb3BUeXBlcy5mdW5jLFxuICAgIHNlYXJjaFBsYWNlaG9sZGVyOiBfcmVhY3QuUHJvcFR5cGVzLnN0cmluZyxcbiAgICBwbGFjZWhvbGRlcjogX3JlYWN0LlByb3BUeXBlcy5hbnksXG4gICAgb25EZXNlbGVjdDogX3JlYWN0LlByb3BUeXBlcy5mdW5jLFxuICAgIGxhYmVsSW5WYWx1ZTogX3JlYWN0LlByb3BUeXBlcy5ib29sLFxuICAgIHZhbHVlOiBfcmVhY3QuUHJvcFR5cGVzLmFueSxcbiAgICBkZWZhdWx0VmFsdWU6IF9yZWFjdC5Qcm9wVHlwZXMuYW55LFxuICAgIGRyb3Bkb3duU3R5bGU6IF9yZWFjdC5Qcm9wVHlwZXMub2JqZWN0LFxuICAgIG1heFRhZ1RleHRMZW5ndGg6IF9yZWFjdC5Qcm9wVHlwZXMubnVtYmVyXG4gIH0sXG5cbiAgbWl4aW5zOiBbX0ZpbHRlck1peGluMltcImRlZmF1bHRcIl1dLFxuXG4gIGdldERlZmF1bHRQcm9wczogZnVuY3Rpb24gZ2V0RGVmYXVsdFByb3BzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBwcmVmaXhDbHM6ICdyYy1zZWxlY3QnLFxuICAgICAgZmlsdGVyT3B0aW9uOiBmaWx0ZXJGbixcbiAgICAgIGRlZmF1bHRPcGVuOiBmYWxzZSxcbiAgICAgIGxhYmVsSW5WYWx1ZTogZmFsc2UsXG4gICAgICBkZWZhdWx0QWN0aXZlRmlyc3RPcHRpb246IHRydWUsXG4gICAgICBzaG93U2VhcmNoOiB0cnVlLFxuICAgICAgYWxsb3dDbGVhcjogZmFsc2UsXG4gICAgICBwbGFjZWhvbGRlcjogJycsXG4gICAgICBzZWFyY2hQbGFjZWhvbGRlcjogJycsXG4gICAgICBkZWZhdWx0VmFsdWU6IFtdLFxuICAgICAgb25DaGFuZ2U6IG5vb3AsXG4gICAgICBvblNlbGVjdDogbm9vcCxcbiAgICAgIG9uU2VhcmNoOiBub29wLFxuICAgICAgb25EZXNlbGVjdDogbm9vcCxcbiAgICAgIHNob3dBcnJvdzogdHJ1ZSxcbiAgICAgIGRyb3Bkb3duTWF0Y2hTZWxlY3RXaWR0aDogdHJ1ZSxcbiAgICAgIGRyb3Bkb3duU3R5bGU6IHt9LFxuICAgICAgZHJvcGRvd25NZW51U3R5bGU6IHt9LFxuICAgICAgb3B0aW9uRmlsdGVyUHJvcDogJ3ZhbHVlJyxcbiAgICAgIG9wdGlvbkxhYmVsUHJvcDogJ3ZhbHVlJyxcbiAgICAgIG5vdEZvdW5kQ29udGVudDogJ05vdCBGb3VuZCdcbiAgICB9O1xuICB9LFxuICBnZXRJbml0aWFsU3RhdGU6IGZ1bmN0aW9uIGdldEluaXRpYWxTdGF0ZSgpIHtcbiAgICB2YXIgcHJvcHMgPSB0aGlzLnByb3BzO1xuICAgIHZhciB2YWx1ZSA9IFtdO1xuICAgIGlmICgndmFsdWUnIGluIHByb3BzKSB7XG4gICAgICB2YWx1ZSA9ICgwLCBfdXRpbC50b0FycmF5KShwcm9wcy52YWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbHVlID0gKDAsIF91dGlsLnRvQXJyYXkpKHByb3BzLmRlZmF1bHRWYWx1ZSk7XG4gICAgfVxuICAgIHZhbHVlID0gdGhpcy5hZGRMYWJlbFRvVmFsdWUocHJvcHMsIHZhbHVlKTtcbiAgICB2YXIgaW5wdXRWYWx1ZSA9ICcnO1xuICAgIGlmIChwcm9wcy5jb21ib2JveCkge1xuICAgICAgaW5wdXRWYWx1ZSA9IHZhbHVlLmxlbmd0aCA/IFN0cmluZyh2YWx1ZVswXS5rZXkpIDogJyc7XG4gICAgfVxuICAgIHRoaXMuc2F2ZUlucHV0UmVmID0gc2F2ZVJlZi5iaW5kKHRoaXMsICdpbnB1dEluc3RhbmNlJyk7XG4gICAgdmFyIG9wZW4gPSBwcm9wcy5vcGVuO1xuICAgIGlmIChvcGVuID09PSB1bmRlZmluZWQpIHtcbiAgICAgIG9wZW4gPSBwcm9wcy5kZWZhdWx0T3BlbjtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIGlucHV0VmFsdWU6IGlucHV0VmFsdWUsXG4gICAgICBvcGVuOiBvcGVuXG4gICAgfTtcbiAgfSxcbiAgY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wczogZnVuY3Rpb24gY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhuZXh0UHJvcHMpIHtcbiAgICBpZiAoJ3ZhbHVlJyBpbiBuZXh0UHJvcHMpIHtcbiAgICAgIHZhciB2YWx1ZSA9ICgwLCBfdXRpbC50b0FycmF5KShuZXh0UHJvcHMudmFsdWUpO1xuICAgICAgdmFsdWUgPSB0aGlzLmFkZExhYmVsVG9WYWx1ZShuZXh0UHJvcHMsIHZhbHVlKTtcbiAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgIH0pO1xuICAgICAgaWYgKG5leHRQcm9wcy5jb21ib2JveCkge1xuICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICBpbnB1dFZhbHVlOiB2YWx1ZS5sZW5ndGggPyBTdHJpbmcodmFsdWVbMF0ua2V5KSA6ICcnXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgY29tcG9uZW50RGlkVXBkYXRlOiBmdW5jdGlvbiBjb21wb25lbnREaWRVcGRhdGUoKSB7XG4gICAgdmFyIHN0YXRlID0gdGhpcy5zdGF0ZTtcbiAgICB2YXIgcHJvcHMgPSB0aGlzLnByb3BzO1xuXG4gICAgaWYgKHN0YXRlLm9wZW4gJiYgKCgwLCBfdXRpbC5pc011bHRpcGxlT3JUYWdzKShwcm9wcykgfHwgcHJvcHMuc2hvd1NlYXJjaCkpIHtcbiAgICAgIHZhciBpbnB1dE5vZGUgPSB0aGlzLmdldElucHV0RE9NTm9kZSgpO1xuICAgICAgaWYgKGlucHV0Tm9kZS52YWx1ZSkge1xuICAgICAgICBpbnB1dE5vZGUuc3R5bGUud2lkdGggPSAnJztcbiAgICAgICAgaW5wdXROb2RlLnN0eWxlLndpZHRoID0gaW5wdXROb2RlLnNjcm9sbFdpZHRoICsgJ3B4JztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlucHV0Tm9kZS5zdHlsZS53aWR0aCA9ICcnO1xuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgY29tcG9uZW50V2lsbFVubW91bnQ6IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgIGlmICh0aGlzLmRyb3Bkb3duQ29udGFpbmVyKSB7XG4gICAgICBfcmVhY3REb20yW1wiZGVmYXVsdFwiXS51bm1vdW50Q29tcG9uZW50QXROb2RlKHRoaXMuZHJvcGRvd25Db250YWluZXIpO1xuICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZCh0aGlzLmRyb3Bkb3duQ29udGFpbmVyKTtcbiAgICAgIHRoaXMuZHJvcGRvd25Db250YWluZXIgPSBudWxsO1xuICAgIH1cbiAgfSxcbiAgb25JbnB1dENoYW5nZTogZnVuY3Rpb24gb25JbnB1dENoYW5nZShldmVudCkge1xuICAgIHZhciB2YWwgPSBldmVudC50YXJnZXQudmFsdWU7XG4gICAgdmFyIHByb3BzID0gdGhpcy5wcm9wcztcblxuICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgaW5wdXRWYWx1ZTogdmFsLFxuICAgICAgb3BlbjogdHJ1ZVxuICAgIH0pO1xuICAgIGlmICgoMCwgX3V0aWwuaXNDb21ib2JveCkocHJvcHMpKSB7XG4gICAgICB0aGlzLmZpcmVDaGFuZ2UoW3tcbiAgICAgICAga2V5OiB2YWxcbiAgICAgIH1dKTtcbiAgICB9XG4gICAgcHJvcHMub25TZWFyY2godmFsKTtcbiAgfSxcbiAgb25Ecm9wZG93blZpc2libGVDaGFuZ2U6IGZ1bmN0aW9uIG9uRHJvcGRvd25WaXNpYmxlQ2hhbmdlKG9wZW4pIHtcbiAgICB0aGlzLnNldE9wZW5TdGF0ZShvcGVuKTtcbiAgfSxcblxuXG4gIC8vIGNvbWJvYm94IGlnbm9yZVxuICBvbktleURvd246IGZ1bmN0aW9uIG9uS2V5RG93bihldmVudCkge1xuICAgIHZhciBwcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgaWYgKHByb3BzLmRpc2FibGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBrZXlDb2RlID0gZXZlbnQua2V5Q29kZTtcbiAgICBpZiAodGhpcy5zdGF0ZS5vcGVuICYmICF0aGlzLmdldElucHV0RE9NTm9kZSgpKSB7XG4gICAgICB0aGlzLm9uSW5wdXRLZXlEb3duKGV2ZW50KTtcbiAgICB9IGVsc2UgaWYgKGtleUNvZGUgPT09IF9yY1V0aWwuS2V5Q29kZS5FTlRFUiB8fCBrZXlDb2RlID09PSBfcmNVdGlsLktleUNvZGUuRE9XTikge1xuICAgICAgdGhpcy5zZXRPcGVuU3RhdGUodHJ1ZSk7XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cbiAgfSxcbiAgb25JbnB1dEtleURvd246IGZ1bmN0aW9uIG9uSW5wdXRLZXlEb3duKGV2ZW50KSB7XG4gICAgdmFyIHByb3BzID0gdGhpcy5wcm9wcztcbiAgICBpZiAocHJvcHMuZGlzYWJsZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHN0YXRlID0gdGhpcy5zdGF0ZTtcbiAgICB2YXIga2V5Q29kZSA9IGV2ZW50LmtleUNvZGU7XG4gICAgaWYgKCgwLCBfdXRpbC5pc011bHRpcGxlT3JUYWdzKShwcm9wcykgJiYgIWV2ZW50LnRhcmdldC52YWx1ZSAmJiBrZXlDb2RlID09PSBfcmNVdGlsLktleUNvZGUuQkFDS1NQQUNFKSB7XG4gICAgICB2YXIgdmFsdWUgPSBzdGF0ZS52YWx1ZS5jb25jYXQoKTtcbiAgICAgIGlmICh2YWx1ZS5sZW5ndGgpIHtcbiAgICAgICAgdmFyIHBvcFZhbHVlID0gdmFsdWUucG9wKCk7XG4gICAgICAgIHByb3BzLm9uRGVzZWxlY3QocHJvcHMubGFiZWxJblZhbHVlID8gcG9wVmFsdWUgOiBwb3BWYWx1ZS5rZXkpO1xuICAgICAgICB0aGlzLmZpcmVDaGFuZ2UodmFsdWUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoa2V5Q29kZSA9PT0gX3JjVXRpbC5LZXlDb2RlLkRPV04pIHtcbiAgICAgIGlmICghc3RhdGUub3Blbikge1xuICAgICAgICB0aGlzLm9wZW5JZkhhc0NoaWxkcmVuKCk7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChrZXlDb2RlID09PSBfcmNVdGlsLktleUNvZGUuRVNDKSB7XG4gICAgICBpZiAoc3RhdGUub3Blbikge1xuICAgICAgICB0aGlzLnNldE9wZW5TdGF0ZShmYWxzZSk7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChzdGF0ZS5vcGVuKSB7XG4gICAgICB2YXIgbWVudSA9IHRoaXMucmVmcy50cmlnZ2VyLmdldElubmVyTWVudSgpO1xuICAgICAgaWYgKG1lbnUgJiYgbWVudS5vbktleURvd24oZXZlbnQpKSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgb25NZW51U2VsZWN0OiBmdW5jdGlvbiBvbk1lbnVTZWxlY3QoX3JlZikge1xuICAgIHZhciBpdGVtID0gX3JlZi5pdGVtO1xuXG4gICAgdmFyIHZhbHVlID0gdGhpcy5zdGF0ZS52YWx1ZTtcbiAgICB2YXIgcHJvcHMgPSB0aGlzLnByb3BzO1xuICAgIHZhciBzZWxlY3RlZFZhbHVlID0gKDAsIF91dGlsLmdldFZhbHVlUHJvcFZhbHVlKShpdGVtKTtcbiAgICB2YXIgc2VsZWN0ZWRMYWJlbCA9IHRoaXMuZ2V0TGFiZWxGcm9tT3B0aW9uKGl0ZW0pO1xuICAgIHZhciBldmVudCA9IHNlbGVjdGVkVmFsdWU7XG4gICAgaWYgKHByb3BzLmxhYmVsSW5WYWx1ZSkge1xuICAgICAgZXZlbnQgPSB7XG4gICAgICAgIGtleTogZXZlbnQsXG4gICAgICAgIGxhYmVsOiBzZWxlY3RlZExhYmVsXG4gICAgICB9O1xuICAgIH1cbiAgICBwcm9wcy5vblNlbGVjdChldmVudCwgaXRlbSk7XG4gICAgaWYgKCgwLCBfdXRpbC5pc011bHRpcGxlT3JUYWdzKShwcm9wcykpIHtcbiAgICAgIGlmICgoMCwgX3V0aWwuZmluZEluZGV4SW5WYWx1ZUJ5S2V5KSh2YWx1ZSwgc2VsZWN0ZWRWYWx1ZSkgIT09IC0xKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhbHVlID0gdmFsdWUuY29uY2F0KFt7XG4gICAgICAgIGtleTogc2VsZWN0ZWRWYWx1ZSxcbiAgICAgICAgbGFiZWw6IHNlbGVjdGVkTGFiZWxcbiAgICAgIH1dKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHZhbHVlLmxlbmd0aCAmJiB2YWx1ZVswXS5rZXkgPT09IHNlbGVjdGVkVmFsdWUpIHtcbiAgICAgICAgdGhpcy5zZXRPcGVuU3RhdGUoZmFsc2UsIHRydWUpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YWx1ZSA9IFt7XG4gICAgICAgIGtleTogc2VsZWN0ZWRWYWx1ZSxcbiAgICAgICAgbGFiZWw6IHNlbGVjdGVkTGFiZWxcbiAgICAgIH1dO1xuICAgICAgdGhpcy5zZXRPcGVuU3RhdGUoZmFsc2UsIHRydWUpO1xuICAgIH1cbiAgICB0aGlzLmZpcmVDaGFuZ2UodmFsdWUpO1xuICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgaW5wdXRWYWx1ZTogJydcbiAgICB9KTtcbiAgICBpZiAoKDAsIF91dGlsLmlzQ29tYm9ib3gpKHByb3BzKSkge1xuICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgIGlucHV0VmFsdWU6ICgwLCBfdXRpbC5nZXRQcm9wVmFsdWUpKGl0ZW0sIHByb3BzLm9wdGlvbkxhYmVsUHJvcClcbiAgICAgIH0pO1xuICAgIH1cbiAgfSxcbiAgb25NZW51RGVzZWxlY3Q6IGZ1bmN0aW9uIG9uTWVudURlc2VsZWN0KF9yZWYyKSB7XG4gICAgdmFyIGl0ZW0gPSBfcmVmMi5pdGVtO1xuICAgIHZhciBkb21FdmVudCA9IF9yZWYyLmRvbUV2ZW50O1xuXG4gICAgaWYgKGRvbUV2ZW50LnR5cGUgPT09ICdjbGljaycpIHtcbiAgICAgIHRoaXMucmVtb3ZlU2VsZWN0ZWQoKDAsIF91dGlsLmdldFZhbHVlUHJvcFZhbHVlKShpdGVtKSk7XG4gICAgfVxuICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgaW5wdXRWYWx1ZTogJydcbiAgICB9KTtcbiAgfSxcbiAgb25BcnJvd0NsaWNrOiBmdW5jdGlvbiBvbkFycm93Q2xpY2soZSkge1xuICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgdGhpcy5zZXRPcGVuU3RhdGUoIXRoaXMuc3RhdGUub3BlbiwgdHJ1ZSk7XG4gIH0sXG4gIG9uUGxhY2Vob2xkZXJDbGljazogZnVuY3Rpb24gb25QbGFjZWhvbGRlckNsaWNrKCkge1xuICAgIHRoaXMuZ2V0SW5wdXRET01Ob2RlKCkuZm9jdXMoKTtcbiAgfSxcbiAgb25PdXRlckZvY3VzOiBmdW5jdGlvbiBvbk91dGVyRm9jdXMoKSB7XG4gICAgdGhpcy5fZm9jdXNlZCA9IHRydWU7XG4gICAgdGhpcy51cGRhdGVGb2N1c0NsYXNzTmFtZSgpO1xuICB9LFxuICBvblBvcHVwRm9jdXM6IGZ1bmN0aW9uIG9uUG9wdXBGb2N1cygpIHtcbiAgICAvLyBmaXggaWUgc2Nyb2xsYmFyLCBmb2N1cyBlbGVtZW50IGFnYWluXG4gICAgdGhpcy5tYXliZUZvY3VzKHRydWUsIHRydWUpO1xuICB9LFxuICBvbk91dGVyQmx1cjogZnVuY3Rpb24gb25PdXRlckJsdXIoKSB7XG4gICAgdGhpcy5fZm9jdXNlZCA9IGZhbHNlO1xuICAgIHRoaXMudXBkYXRlRm9jdXNDbGFzc05hbWUoKTtcbiAgfSxcbiAgb25DbGVhclNlbGVjdGlvbjogZnVuY3Rpb24gb25DbGVhclNlbGVjdGlvbihldmVudCkge1xuICAgIHZhciBwcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgdmFyIHN0YXRlID0gdGhpcy5zdGF0ZTtcbiAgICBpZiAocHJvcHMuZGlzYWJsZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgaWYgKHN0YXRlLmlucHV0VmFsdWUgfHwgc3RhdGUudmFsdWUubGVuZ3RoKSB7XG4gICAgICB0aGlzLmZpcmVDaGFuZ2UoW10pO1xuICAgICAgdGhpcy5zZXRPcGVuU3RhdGUoZmFsc2UpO1xuICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgIGlucHV0VmFsdWU6ICcnXG4gICAgICB9KTtcbiAgICB9XG4gIH0sXG4gIGdldExhYmVsQnlTaW5nbGVWYWx1ZTogZnVuY3Rpb24gZ2V0TGFiZWxCeVNpbmdsZVZhbHVlKGNoaWxkcmVuLCB2YWx1ZSkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHZhciBsYWJlbCA9IG51bGw7XG4gICAgX3JlYWN0MltcImRlZmF1bHRcIl0uQ2hpbGRyZW4uZm9yRWFjaChjaGlsZHJlbiwgZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICBpZiAoY2hpbGQudHlwZSA9PT0gX09wdEdyb3VwMltcImRlZmF1bHRcIl0pIHtcbiAgICAgICAgdmFyIG1heWJlID0gX3RoaXMuZ2V0TGFiZWxCeVNpbmdsZVZhbHVlKGNoaWxkLnByb3BzLmNoaWxkcmVuLCB2YWx1ZSk7XG4gICAgICAgIGlmIChtYXliZSAhPT0gbnVsbCkge1xuICAgICAgICAgIGxhYmVsID0gbWF5YmU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoKDAsIF91dGlsLmdldFZhbHVlUHJvcFZhbHVlKShjaGlsZCkgPT09IHZhbHVlKSB7XG4gICAgICAgIGxhYmVsID0gX3RoaXMuZ2V0TGFiZWxGcm9tT3B0aW9uKGNoaWxkKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gbGFiZWw7XG4gIH0sXG4gIGdldExhYmVsRnJvbU9wdGlvbjogZnVuY3Rpb24gZ2V0TGFiZWxGcm9tT3B0aW9uKGNoaWxkKSB7XG4gICAgcmV0dXJuICgwLCBfdXRpbC5nZXRQcm9wVmFsdWUpKGNoaWxkLCB0aGlzLnByb3BzLm9wdGlvbkxhYmVsUHJvcCk7XG4gIH0sXG4gIGdldExhYmVsRnJvbVByb3BzOiBmdW5jdGlvbiBnZXRMYWJlbEZyb21Qcm9wcyhwcm9wcywgdmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRMYWJlbEJ5VmFsdWUocHJvcHMuY2hpbGRyZW4sIHZhbHVlKTtcbiAgfSxcbiAgZ2V0VkxGb3JPbkNoYW5nZTogZnVuY3Rpb24gZ2V0VkxGb3JPbkNoYW5nZSh2bHNfKSB7XG4gICAgdmFyIHZscyA9IHZsc187XG4gICAgaWYgKHZscyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAoIXRoaXMucHJvcHMubGFiZWxJblZhbHVlKSB7XG4gICAgICAgIHZscyA9IHZscy5tYXAoZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICByZXR1cm4gdi5rZXk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuICgwLCBfdXRpbC5pc011bHRpcGxlT3JUYWdzKSh0aGlzLnByb3BzKSA/IHZscyA6IHZsc1swXTtcbiAgICB9XG4gICAgcmV0dXJuIHZscztcbiAgfSxcbiAgZ2V0TGFiZWxCeVZhbHVlOiBmdW5jdGlvbiBnZXRMYWJlbEJ5VmFsdWUoY2hpbGRyZW4sIHZhbHVlKSB7XG4gICAgdmFyIGxhYmVsID0gdGhpcy5nZXRMYWJlbEJ5U2luZ2xlVmFsdWUoY2hpbGRyZW4sIHZhbHVlKTtcbiAgICBpZiAobGFiZWwgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGxhYmVsO1xuICB9LFxuICBnZXREcm9wZG93bkNvbnRhaW5lcjogZnVuY3Rpb24gZ2V0RHJvcGRvd25Db250YWluZXIoKSB7XG4gICAgaWYgKCF0aGlzLmRyb3Bkb3duQ29udGFpbmVyKSB7XG4gICAgICB0aGlzLmRyb3Bkb3duQ29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHRoaXMuZHJvcGRvd25Db250YWluZXIpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5kcm9wZG93bkNvbnRhaW5lcjtcbiAgfSxcbiAgZ2V0U2VhcmNoUGxhY2Vob2xkZXJFbGVtZW50OiBmdW5jdGlvbiBnZXRTZWFyY2hQbGFjZWhvbGRlckVsZW1lbnQoaGlkZGVuKSB7XG4gICAgdmFyIHByb3BzID0gdGhpcy5wcm9wcztcbiAgICB2YXIgcGxhY2Vob2xkZXIgPSB2b2lkIDA7XG4gICAgaWYgKCgwLCBfdXRpbC5pc011bHRpcGxlT3JUYWdzT3JDb21ib2JveCkocHJvcHMpKSB7XG4gICAgICBwbGFjZWhvbGRlciA9IHByb3BzLnBsYWNlaG9sZGVyIHx8IHByb3BzLnNlYXJjaFBsYWNlaG9sZGVyO1xuICAgIH0gZWxzZSB7XG4gICAgICBwbGFjZWhvbGRlciA9IHByb3BzLnNlYXJjaFBsYWNlaG9sZGVyO1xuICAgIH1cbiAgICBpZiAocGxhY2Vob2xkZXIpIHtcbiAgICAgIHJldHVybiBfcmVhY3QyW1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFxuICAgICAgICAnZGl2JyxcbiAgICAgICAgX2V4dGVuZHMoe1xuICAgICAgICAgIG9uTW91c2VEb3duOiBfdXRpbC5wcmV2ZW50RGVmYXVsdEV2ZW50LFxuICAgICAgICAgIHN0eWxlOiBfZXh0ZW5kcyh7XG4gICAgICAgICAgICBkaXNwbGF5OiBoaWRkZW4gPyAnbm9uZScgOiAnYmxvY2snXG4gICAgICAgICAgfSwgX3V0aWwuVU5TRUxFQ1RBQkxFX1NUWUxFKVxuICAgICAgICB9LCBfdXRpbC5VTlNFTEVDVEFCTEVfQVRUUklCVVRFLCB7XG4gICAgICAgICAgb25DbGljazogdGhpcy5vblBsYWNlaG9sZGVyQ2xpY2ssXG4gICAgICAgICAgY2xhc3NOYW1lOiBwcm9wcy5wcmVmaXhDbHMgKyAnLXNlYXJjaF9fZmllbGRfX3BsYWNlaG9sZGVyJ1xuICAgICAgICB9KSxcbiAgICAgICAgcGxhY2Vob2xkZXJcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9LFxuICBnZXRJbnB1dEVsZW1lbnQ6IGZ1bmN0aW9uIGdldElucHV0RWxlbWVudCgpIHtcbiAgICB2YXIgcHJvcHMgPSB0aGlzLnByb3BzO1xuICAgIHZhciBzaG91bGRTaG93UGxhY2Vob2xkZXIgPSAoMCwgX3V0aWwuaXNNdWx0aXBsZU9yVGFncykocHJvcHMpIHx8IHByb3BzLnNob3dTZWFyY2g7XG4gICAgcmV0dXJuIF9yZWFjdDJbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXG4gICAgICAnZGl2JyxcbiAgICAgIHsgY2xhc3NOYW1lOiBwcm9wcy5wcmVmaXhDbHMgKyAnLXNlYXJjaF9fZmllbGRfX3dyYXAnIH0sXG4gICAgICBfcmVhY3QyW1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KCdpbnB1dCcsIHtcbiAgICAgICAgcmVmOiB0aGlzLnNhdmVJbnB1dFJlZixcbiAgICAgICAgb25DaGFuZ2U6IHRoaXMub25JbnB1dENoYW5nZSxcbiAgICAgICAgb25LZXlEb3duOiB0aGlzLm9uSW5wdXRLZXlEb3duLFxuICAgICAgICB2YWx1ZTogdGhpcy5zdGF0ZS5pbnB1dFZhbHVlLFxuICAgICAgICBkaXNhYmxlZDogcHJvcHMuZGlzYWJsZWQsXG4gICAgICAgIGNsYXNzTmFtZTogcHJvcHMucHJlZml4Q2xzICsgJy1zZWFyY2hfX2ZpZWxkJ1xuICAgICAgfSksXG4gICAgICBzaG91bGRTaG93UGxhY2Vob2xkZXIgPyBudWxsIDogdGhpcy5nZXRTZWFyY2hQbGFjZWhvbGRlckVsZW1lbnQoISF0aGlzLnN0YXRlLmlucHV0VmFsdWUpXG4gICAgKTtcbiAgfSxcbiAgZ2V0SW5wdXRET01Ob2RlOiBmdW5jdGlvbiBnZXRJbnB1dERPTU5vZGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuaW5wdXRJbnN0YW5jZTtcbiAgfSxcbiAgZ2V0UG9wdXBET01Ob2RlOiBmdW5jdGlvbiBnZXRQb3B1cERPTU5vZGUoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVmcy50cmlnZ2VyLmdldFBvcHVwRE9NTm9kZSgpO1xuICB9LFxuICBnZXRQb3B1cE1lbnVDb21wb25lbnQ6IGZ1bmN0aW9uIGdldFBvcHVwTWVudUNvbXBvbmVudCgpIHtcbiAgICByZXR1cm4gdGhpcy5yZWZzLnRyaWdnZXIuZ2V0SW5uZXJNZW51KCk7XG4gIH0sXG4gIHNldE9wZW5TdGF0ZTogZnVuY3Rpb24gc2V0T3BlblN0YXRlKG9wZW4sIG5lZWRGb2N1cykge1xuICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgdmFyIHByb3BzID0gdGhpcy5wcm9wcztcbiAgICB2YXIgc3RhdGUgPSB0aGlzLnN0YXRlO1xuXG4gICAgaWYgKHN0YXRlLm9wZW4gPT09IG9wZW4pIHtcbiAgICAgIHRoaXMubWF5YmVGb2N1cyhvcGVuLCBuZWVkRm9jdXMpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgbmV4dFN0YXRlID0ge1xuICAgICAgb3Blbjogb3BlblxuICAgIH07XG4gICAgLy8gY2xlYXIgc2VhcmNoIGlucHV0IHZhbHVlIHdoZW4gb3BlbiBpcyBmYWxzZSBpbiBzaW5nbGVNb2RlLlxuICAgIGlmICghb3BlbiAmJiAoMCwgX3V0aWwuaXNTaW5nbGVNb2RlKShwcm9wcykgJiYgcHJvcHMuc2hvd1NlYXJjaCkge1xuICAgICAgbmV4dFN0YXRlLmlucHV0VmFsdWUgPSAnJztcbiAgICB9XG4gICAgaWYgKCFvcGVuKSB7XG4gICAgICB0aGlzLm1heWJlRm9jdXMob3BlbiwgbmVlZEZvY3VzKTtcbiAgICB9XG4gICAgdGhpcy5zZXRTdGF0ZShuZXh0U3RhdGUsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChvcGVuKSB7XG4gICAgICAgIF90aGlzMi5tYXliZUZvY3VzKG9wZW4sIG5lZWRGb2N1cyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0sXG4gIHVwZGF0ZUZvY3VzQ2xhc3NOYW1lOiBmdW5jdGlvbiB1cGRhdGVGb2N1c0NsYXNzTmFtZSgpIHtcbiAgICB2YXIgcmVmcyA9IHRoaXMucmVmcztcbiAgICB2YXIgcHJvcHMgPSB0aGlzLnByb3BzO1xuICAgIC8vIGF2b2lkIHNldFN0YXRlIGFuZCBpdHMgc2lkZSBlZmZlY3RcblxuICAgIGlmICh0aGlzLl9mb2N1c2VkIHx8IHRoaXMuc3RhdGUub3Blbikge1xuICAgICAgKDAsIF9jb21wb25lbnRDbGFzc2VzMltcImRlZmF1bHRcIl0pKHJlZnMucm9vdCkuYWRkKHByb3BzLnByZWZpeENscyArICctZm9jdXNlZCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICAoMCwgX2NvbXBvbmVudENsYXNzZXMyW1wiZGVmYXVsdFwiXSkocmVmcy5yb290KS5yZW1vdmUocHJvcHMucHJlZml4Q2xzICsgJy1mb2N1c2VkJyk7XG4gICAgfVxuICB9LFxuICBtYXliZUZvY3VzOiBmdW5jdGlvbiBtYXliZUZvY3VzKG9wZW4sIG5lZWRGb2N1cykge1xuICAgIGlmIChuZWVkRm9jdXMgfHwgb3Blbikge1xuICAgICAgdmFyIGlucHV0ID0gdGhpcy5nZXRJbnB1dERPTU5vZGUoKTtcbiAgICAgIHZhciBfZG9jdW1lbnQgPSBkb2N1bWVudDtcbiAgICAgIHZhciBhY3RpdmVFbGVtZW50ID0gX2RvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7XG5cbiAgICAgIGlmIChpbnB1dCAmJiAob3BlbiB8fCAoMCwgX3V0aWwuaXNNdWx0aXBsZU9yVGFnc09yQ29tYm9ib3gpKHRoaXMucHJvcHMpKSkge1xuICAgICAgICBpZiAoYWN0aXZlRWxlbWVudCAhPT0gaW5wdXQpIHtcbiAgICAgICAgICBpbnB1dC5mb2N1cygpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgc2VsZWN0aW9uID0gdGhpcy5yZWZzLnNlbGVjdGlvbjtcbiAgICAgICAgaWYgKGFjdGl2ZUVsZW1lbnQgIT09IHNlbGVjdGlvbikge1xuICAgICAgICAgIHNlbGVjdGlvbi5mb2N1cygpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBhZGRMYWJlbFRvVmFsdWU6IGZ1bmN0aW9uIGFkZExhYmVsVG9WYWx1ZShwcm9wcywgdmFsdWVfKSB7XG4gICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICB2YXIgdmFsdWUgPSB2YWx1ZV87XG4gICAgaWYgKHByb3BzLmxhYmVsSW5WYWx1ZSkge1xuICAgICAgdmFsdWUuZm9yRWFjaChmdW5jdGlvbiAodikge1xuICAgICAgICB2LmxhYmVsID0gdi5sYWJlbCB8fCBfdGhpczMuZ2V0TGFiZWxGcm9tUHJvcHMocHJvcHMsIHYua2V5KTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZSA9IHZhbHVlLm1hcChmdW5jdGlvbiAodikge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGtleTogdixcbiAgICAgICAgICBsYWJlbDogX3RoaXMzLmdldExhYmVsRnJvbVByb3BzKHByb3BzLCB2KVxuICAgICAgICB9O1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbiAgfSxcbiAgcmVtb3ZlU2VsZWN0ZWQ6IGZ1bmN0aW9uIHJlbW92ZVNlbGVjdGVkKHNlbGVjdGVkS2V5KSB7XG4gICAgdmFyIHByb3BzID0gdGhpcy5wcm9wcztcbiAgICBpZiAocHJvcHMuZGlzYWJsZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGxhYmVsID0gdm9pZCAwO1xuICAgIHZhciB2YWx1ZSA9IHRoaXMuc3RhdGUudmFsdWUuZmlsdGVyKGZ1bmN0aW9uIChzaW5nbGVWYWx1ZSkge1xuICAgICAgaWYgKHNpbmdsZVZhbHVlLmtleSA9PT0gc2VsZWN0ZWRLZXkpIHtcbiAgICAgICAgbGFiZWwgPSBzaW5nbGVWYWx1ZS5sYWJlbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzaW5nbGVWYWx1ZS5rZXkgIT09IHNlbGVjdGVkS2V5O1xuICAgIH0pO1xuICAgIHZhciBjYW5NdWx0aXBsZSA9ICgwLCBfdXRpbC5pc011bHRpcGxlT3JUYWdzKShwcm9wcyk7XG5cbiAgICBpZiAoY2FuTXVsdGlwbGUpIHtcbiAgICAgIHZhciBldmVudCA9IHNlbGVjdGVkS2V5O1xuICAgICAgaWYgKHByb3BzLmxhYmVsSW5WYWx1ZSkge1xuICAgICAgICBldmVudCA9IHtcbiAgICAgICAgICBrZXk6IHNlbGVjdGVkS2V5LFxuICAgICAgICAgIGxhYmVsOiBsYWJlbFxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgcHJvcHMub25EZXNlbGVjdChldmVudCk7XG4gICAgfVxuICAgIHRoaXMuZmlyZUNoYW5nZSh2YWx1ZSk7XG4gIH0sXG4gIG9wZW5JZkhhc0NoaWxkcmVuOiBmdW5jdGlvbiBvcGVuSWZIYXNDaGlsZHJlbigpIHtcbiAgICB2YXIgcHJvcHMgPSB0aGlzLnByb3BzO1xuICAgIGlmIChfcmVhY3QyW1wiZGVmYXVsdFwiXS5DaGlsZHJlbi5jb3VudChwcm9wcy5jaGlsZHJlbikgfHwgKDAsIF91dGlsLmlzU2luZ2xlTW9kZSkocHJvcHMpKSB7XG4gICAgICB0aGlzLnNldE9wZW5TdGF0ZSh0cnVlKTtcbiAgICB9XG4gIH0sXG4gIGZpcmVDaGFuZ2U6IGZ1bmN0aW9uIGZpcmVDaGFuZ2UodmFsdWUpIHtcbiAgICB2YXIgcHJvcHMgPSB0aGlzLnByb3BzO1xuICAgIGlmICghKCd2YWx1ZScgaW4gcHJvcHMpKSB7XG4gICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgICB9KTtcbiAgICB9XG4gICAgcHJvcHMub25DaGFuZ2UodGhpcy5nZXRWTEZvck9uQ2hhbmdlKHZhbHVlKSk7XG4gIH0sXG4gIHJlbmRlclRvcENvbnRyb2xOb2RlOiBmdW5jdGlvbiByZW5kZXJUb3BDb250cm9sTm9kZSgpIHtcbiAgICB2YXIgX3RoaXM0ID0gdGhpcztcblxuICAgIHZhciBfc3RhdGUgPSB0aGlzLnN0YXRlO1xuICAgIHZhciB2YWx1ZSA9IF9zdGF0ZS52YWx1ZTtcbiAgICB2YXIgb3BlbiA9IF9zdGF0ZS5vcGVuO1xuICAgIHZhciBpbnB1dFZhbHVlID0gX3N0YXRlLmlucHV0VmFsdWU7XG5cbiAgICB2YXIgcHJvcHMgPSB0aGlzLnByb3BzO1xuICAgIHZhciBjaG9pY2VUcmFuc2l0aW9uTmFtZSA9IHByb3BzLmNob2ljZVRyYW5zaXRpb25OYW1lO1xuICAgIHZhciBwcmVmaXhDbHMgPSBwcm9wcy5wcmVmaXhDbHM7XG4gICAgdmFyIG1heFRhZ1RleHRMZW5ndGggPSBwcm9wcy5tYXhUYWdUZXh0TGVuZ3RoO1xuICAgIHZhciBzaG93U2VhcmNoID0gcHJvcHMuc2hvd1NlYXJjaDtcbiAgICAvLyBzZWFyY2ggaW5wdXQgaXMgaW5zaWRlIHRvcENvbnRyb2xOb2RlIGluIHNpbmdsZSwgbXVsdGlwbGUgJiBjb21ib2JveC4gMjAxNi8wNC8xM1xuXG4gICAgaWYgKCgwLCBfdXRpbC5pc1NpbmdsZU1vZGUpKHByb3BzKSkge1xuICAgICAgdmFyIGlubmVyTm9kZSA9IG51bGw7XG4gICAgICB2YXIgc2VsZWN0ZWRWYWx1ZSA9IG51bGw7XG4gICAgICBpZiAoIXZhbHVlLmxlbmd0aCkge1xuICAgICAgICBzZWxlY3RlZFZhbHVlID0gX3JlYWN0MltcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAnZGl2JyxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBrZXk6ICdwbGFjZWhvbGRlcicsXG4gICAgICAgICAgICBjbGFzc05hbWU6IHByZWZpeENscyArICctc2VsZWN0aW9uX19wbGFjZWhvbGRlcidcbiAgICAgICAgICB9LFxuICAgICAgICAgIHByb3BzLnBsYWNlaG9sZGVyXG4gICAgICAgICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZWxlY3RlZFZhbHVlID0gX3JlYWN0MltcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAnZGl2JyxcbiAgICAgICAgICB7IGtleTogJ3ZhbHVlJywgY2xhc3NOYW1lOiBwcmVmaXhDbHMgKyAnLXNlbGVjdGlvbi1zZWxlY3RlZC12YWx1ZScgfSxcbiAgICAgICAgICB2YWx1ZVswXS5sYWJlbFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKCFzaG93U2VhcmNoIHx8ICFvcGVuKSB7XG4gICAgICAgIGlubmVyTm9kZSA9IHNlbGVjdGVkVmFsdWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbm5lck5vZGUgPSBfcmVhY3QyW1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICdkaXYnLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGNsYXNzTmFtZTogcHJlZml4Q2xzICsgJy1zZWFyY2ggJyArIHByZWZpeENscyArICctc2VhcmNoLS1pbmxpbmUnLFxuICAgICAgICAgICAga2V5OiAnaW5wdXQnXG4gICAgICAgICAgfSxcbiAgICAgICAgICAhIWlucHV0VmFsdWUgPyBudWxsIDogc2VsZWN0ZWRWYWx1ZSxcbiAgICAgICAgICB0aGlzLmdldElucHV0RWxlbWVudCgpXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICByZXR1cm4gX3JlYWN0MltcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChcbiAgICAgICAgJ2RpdicsXG4gICAgICAgIHsgY2xhc3NOYW1lOiBwcmVmaXhDbHMgKyAnLXNlbGVjdGlvbl9fcmVuZGVyZWQnIH0sXG4gICAgICAgIGlubmVyTm9kZVxuICAgICAgKTtcbiAgICB9XG5cbiAgICB2YXIgc2VsZWN0ZWRWYWx1ZU5vZGVzID0gW107XG4gICAgaWYgKCgwLCBfdXRpbC5pc011bHRpcGxlT3JUYWdzKShwcm9wcykpIHtcbiAgICAgIHNlbGVjdGVkVmFsdWVOb2RlcyA9IHZhbHVlLm1hcChmdW5jdGlvbiAoc2luZ2xlVmFsdWUpIHtcbiAgICAgICAgdmFyIGNvbnRlbnQgPSBzaW5nbGVWYWx1ZS5sYWJlbDtcbiAgICAgICAgdmFyIHRpdGxlID0gY29udGVudDtcbiAgICAgICAgaWYgKG1heFRhZ1RleHRMZW5ndGggJiYgdHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnICYmIGNvbnRlbnQubGVuZ3RoID4gbWF4VGFnVGV4dExlbmd0aCkge1xuICAgICAgICAgIGNvbnRlbnQgPSBjb250ZW50LnNsaWNlKDAsIG1heFRhZ1RleHRMZW5ndGgpICsgJy4uLic7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF9yZWFjdDJbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgJ2xpJyxcbiAgICAgICAgICBfZXh0ZW5kcyh7XG4gICAgICAgICAgICBzdHlsZTogX3V0aWwuVU5TRUxFQ1RBQkxFX1NUWUxFXG4gICAgICAgICAgfSwgX3V0aWwuVU5TRUxFQ1RBQkxFX0FUVFJJQlVURSwge1xuICAgICAgICAgICAgb25Nb3VzZURvd246IF91dGlsLnByZXZlbnREZWZhdWx0RXZlbnQsXG4gICAgICAgICAgICBjbGFzc05hbWU6IHByZWZpeENscyArICctc2VsZWN0aW9uX19jaG9pY2UnLFxuICAgICAgICAgICAga2V5OiBzaW5nbGVWYWx1ZS5rZXksXG4gICAgICAgICAgICB0aXRsZTogdGl0bGVcbiAgICAgICAgICB9KSxcbiAgICAgICAgICBfcmVhY3QyW1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICAgJ2RpdicsXG4gICAgICAgICAgICB7IGNsYXNzTmFtZTogcHJlZml4Q2xzICsgJy1zZWxlY3Rpb25fX2Nob2ljZV9fY29udGVudCcgfSxcbiAgICAgICAgICAgIGNvbnRlbnRcbiAgICAgICAgICApLFxuICAgICAgICAgIF9yZWFjdDJbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoJ3NwYW4nLCB7XG4gICAgICAgICAgICBjbGFzc05hbWU6IHByZWZpeENscyArICctc2VsZWN0aW9uX19jaG9pY2VfX3JlbW92ZScsXG4gICAgICAgICAgICBvbkNsaWNrOiBfdGhpczQucmVtb3ZlU2VsZWN0ZWQuYmluZChfdGhpczQsIHNpbmdsZVZhbHVlLmtleSlcbiAgICAgICAgICB9KVxuICAgICAgICApO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHNlbGVjdGVkVmFsdWVOb2Rlcy5wdXNoKF9yZWFjdDJbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXG4gICAgICAnbGknLFxuICAgICAge1xuICAgICAgICBjbGFzc05hbWU6IHByZWZpeENscyArICctc2VhcmNoICcgKyBwcmVmaXhDbHMgKyAnLXNlYXJjaC0taW5saW5lJyxcbiAgICAgICAga2V5OiAnX19pbnB1dCdcbiAgICAgIH0sXG4gICAgICB0aGlzLmdldElucHV0RWxlbWVudCgpXG4gICAgKSk7XG4gICAgdmFyIGNsYXNzTmFtZSA9IHByZWZpeENscyArICctc2VsZWN0aW9uX19yZW5kZXJlZCc7XG4gICAgaWYgKCgwLCBfdXRpbC5pc011bHRpcGxlT3JUYWdzKShwcm9wcykgJiYgY2hvaWNlVHJhbnNpdGlvbk5hbWUpIHtcbiAgICAgIHJldHVybiBfcmVhY3QyW1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFxuICAgICAgICBfcmNBbmltYXRlMltcImRlZmF1bHRcIl0sXG4gICAgICAgIHtcbiAgICAgICAgICBjbGFzc05hbWU6IGNsYXNzTmFtZSxcbiAgICAgICAgICBjb21wb25lbnQ6ICd1bCcsXG4gICAgICAgICAgdHJhbnNpdGlvbk5hbWU6IGNob2ljZVRyYW5zaXRpb25OYW1lXG4gICAgICAgIH0sXG4gICAgICAgIHNlbGVjdGVkVmFsdWVOb2Rlc1xuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIF9yZWFjdDJbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXG4gICAgICAndWwnLFxuICAgICAgeyBjbGFzc05hbWU6IGNsYXNzTmFtZSB9LFxuICAgICAgc2VsZWN0ZWRWYWx1ZU5vZGVzXG4gICAgKTtcbiAgfSxcbiAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgdmFyIF9yb290Q2xzO1xuXG4gICAgdmFyIHByb3BzID0gdGhpcy5wcm9wcztcbiAgICB2YXIgbXVsdGlwbGUgPSAoMCwgX3V0aWwuaXNNdWx0aXBsZU9yVGFncykocHJvcHMpO1xuICAgIHZhciBzdGF0ZSA9IHRoaXMuc3RhdGU7XG4gICAgdmFyIGNsYXNzTmFtZSA9IHByb3BzLmNsYXNzTmFtZTtcbiAgICB2YXIgZGlzYWJsZWQgPSBwcm9wcy5kaXNhYmxlZDtcbiAgICB2YXIgYWxsb3dDbGVhciA9IHByb3BzLmFsbG93Q2xlYXI7XG4gICAgdmFyIHByZWZpeENscyA9IHByb3BzLnByZWZpeENscztcblxuICAgIHZhciBjdHJsTm9kZSA9IHRoaXMucmVuZGVyVG9wQ29udHJvbE5vZGUoKTtcbiAgICB2YXIgZXh0cmFTZWxlY3Rpb25Qcm9wcyA9IHt9O1xuICAgIHZhciBvcGVuID0gdGhpcy5zdGF0ZS5vcGVuO1xuXG4gICAgdmFyIG9wdGlvbnMgPSBbXTtcbiAgICBpZiAob3Blbikge1xuICAgICAgb3B0aW9ucyA9IHRoaXMucmVuZGVyRmlsdGVyT3B0aW9ucygpO1xuICAgIH1cbiAgICBpZiAob3BlbiAmJiAoKDAsIF91dGlsLmlzTXVsdGlwbGVPclRhZ3NPckNvbWJvYm94KShwcm9wcykgfHwgIXByb3BzLnNob3dTZWFyY2gpICYmICFvcHRpb25zLmxlbmd0aCkge1xuICAgICAgb3BlbiA9IGZhbHNlO1xuICAgIH1cbiAgICBpZiAoISgwLCBfdXRpbC5pc011bHRpcGxlT3JUYWdzT3JDb21ib2JveCkocHJvcHMpKSB7XG4gICAgICBleHRyYVNlbGVjdGlvblByb3BzID0ge1xuICAgICAgICBvbktleURvd246IHRoaXMub25LZXlEb3duLFxuICAgICAgICB0YWJJbmRleDogMFxuICAgICAgfTtcbiAgICB9XG4gICAgdmFyIHJvb3RDbHMgPSAoX3Jvb3RDbHMgPSB7fSwgX2RlZmluZVByb3BlcnR5KF9yb290Q2xzLCBjbGFzc05hbWUsICEhY2xhc3NOYW1lKSwgX2RlZmluZVByb3BlcnR5KF9yb290Q2xzLCBwcmVmaXhDbHMsIDEpLCBfZGVmaW5lUHJvcGVydHkoX3Jvb3RDbHMsIHByZWZpeENscyArICctb3BlbicsIG9wZW4pLCBfZGVmaW5lUHJvcGVydHkoX3Jvb3RDbHMsIHByZWZpeENscyArICctZm9jdXNlZCcsIG9wZW4gfHwgISF0aGlzLl9mb2N1c2VkKSwgX2RlZmluZVByb3BlcnR5KF9yb290Q2xzLCBwcmVmaXhDbHMgKyAnLWNvbWJvYm94JywgKDAsIF91dGlsLmlzQ29tYm9ib3gpKHByb3BzKSksIF9kZWZpbmVQcm9wZXJ0eShfcm9vdENscywgcHJlZml4Q2xzICsgJy1kaXNhYmxlZCcsIGRpc2FibGVkKSwgX2RlZmluZVByb3BlcnR5KF9yb290Q2xzLCBwcmVmaXhDbHMgKyAnLWVuYWJsZWQnLCAhZGlzYWJsZWQpLCBfcm9vdENscyk7XG5cbiAgICB2YXIgY2xlYXIgPSBfcmVhY3QyW1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KCdzcGFuJywgX2V4dGVuZHMoe1xuICAgICAga2V5OiAnY2xlYXInLFxuICAgICAgb25Nb3VzZURvd246IF91dGlsLnByZXZlbnREZWZhdWx0RXZlbnQsXG4gICAgICBzdHlsZTogX3V0aWwuVU5TRUxFQ1RBQkxFX1NUWUxFXG4gICAgfSwgX3V0aWwuVU5TRUxFQ1RBQkxFX0FUVFJJQlVURSwge1xuICAgICAgY2xhc3NOYW1lOiBwcmVmaXhDbHMgKyAnLXNlbGVjdGlvbl9fY2xlYXInLFxuICAgICAgb25DbGljazogdGhpcy5vbkNsZWFyU2VsZWN0aW9uXG4gICAgfSkpO1xuICAgIHJldHVybiBfcmVhY3QyW1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFxuICAgICAgX1NlbGVjdFRyaWdnZXIyW1wiZGVmYXVsdFwiXSxcbiAgICAgIHtcbiAgICAgICAgb25Qb3B1cEZvY3VzOiB0aGlzLm9uUG9wdXBGb2N1cyxcbiAgICAgICAgZHJvcGRvd25BbGlnbjogcHJvcHMuZHJvcGRvd25BbGlnbixcbiAgICAgICAgZHJvcGRvd25DbGFzc05hbWU6IHByb3BzLmRyb3Bkb3duQ2xhc3NOYW1lLFxuICAgICAgICBkcm9wZG93bk1hdGNoU2VsZWN0V2lkdGg6IHByb3BzLmRyb3Bkb3duTWF0Y2hTZWxlY3RXaWR0aCxcbiAgICAgICAgZGVmYXVsdEFjdGl2ZUZpcnN0T3B0aW9uOiBwcm9wcy5kZWZhdWx0QWN0aXZlRmlyc3RPcHRpb24sXG4gICAgICAgIGRyb3Bkb3duTWVudVN0eWxlOiBwcm9wcy5kcm9wZG93bk1lbnVTdHlsZSxcbiAgICAgICAgdHJhbnNpdGlvbk5hbWU6IHByb3BzLnRyYW5zaXRpb25OYW1lLFxuICAgICAgICBhbmltYXRpb246IHByb3BzLmFuaW1hdGlvbixcbiAgICAgICAgcHJlZml4Q2xzOiBwcm9wcy5wcmVmaXhDbHMsXG4gICAgICAgIGRyb3Bkb3duU3R5bGU6IHByb3BzLmRyb3Bkb3duU3R5bGUsXG4gICAgICAgIGNvbWJvYm94OiBwcm9wcy5jb21ib2JveCxcbiAgICAgICAgc2hvd1NlYXJjaDogcHJvcHMuc2hvd1NlYXJjaCxcbiAgICAgICAgb3B0aW9uczogb3B0aW9ucyxcbiAgICAgICAgbXVsdGlwbGU6IG11bHRpcGxlLFxuICAgICAgICBkaXNhYmxlZDogZGlzYWJsZWQsXG4gICAgICAgIHZpc2libGU6IG9wZW4sXG4gICAgICAgIGlucHV0VmFsdWU6IHN0YXRlLmlucHV0VmFsdWUsXG4gICAgICAgIHZhbHVlOiBzdGF0ZS52YWx1ZSxcbiAgICAgICAgb25Ecm9wZG93blZpc2libGVDaGFuZ2U6IHRoaXMub25Ecm9wZG93blZpc2libGVDaGFuZ2UsXG4gICAgICAgIGdldFBvcHVwQ29udGFpbmVyOiBwcm9wcy5nZXRQb3B1cENvbnRhaW5lcixcbiAgICAgICAgb25NZW51U2VsZWN0OiB0aGlzLm9uTWVudVNlbGVjdCxcbiAgICAgICAgb25NZW51RGVzZWxlY3Q6IHRoaXMub25NZW51RGVzZWxlY3QsXG4gICAgICAgIHJlZjogJ3RyaWdnZXInXG4gICAgICB9LFxuICAgICAgX3JlYWN0MltcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChcbiAgICAgICAgJ2RpdicsXG4gICAgICAgIHtcbiAgICAgICAgICBzdHlsZTogcHJvcHMuc3R5bGUsXG4gICAgICAgICAgcmVmOiAncm9vdCcsXG4gICAgICAgICAgb25CbHVyOiB0aGlzLm9uT3V0ZXJCbHVyLFxuICAgICAgICAgIG9uRm9jdXM6IHRoaXMub25PdXRlckZvY3VzLFxuICAgICAgICAgIGNsYXNzTmFtZTogKDAsIF9jbGFzc25hbWVzMltcImRlZmF1bHRcIl0pKHJvb3RDbHMpXG4gICAgICAgIH0sXG4gICAgICAgIF9yZWFjdDJbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgJ2RpdicsXG4gICAgICAgICAgX2V4dGVuZHMoe1xuICAgICAgICAgICAgcmVmOiAnc2VsZWN0aW9uJyxcbiAgICAgICAgICAgIGtleTogJ3NlbGVjdGlvbicsXG4gICAgICAgICAgICBjbGFzc05hbWU6IHByZWZpeENscyArICctc2VsZWN0aW9uXFxuICAgICAgICAgICAgJyArIHByZWZpeENscyArICctc2VsZWN0aW9uLS0nICsgKG11bHRpcGxlID8gJ211bHRpcGxlJyA6ICdzaW5nbGUnKSxcbiAgICAgICAgICAgIHJvbGU6ICdjb21ib2JveCcsXG4gICAgICAgICAgICAnYXJpYS1hdXRvY29tcGxldGUnOiAnbGlzdCcsXG4gICAgICAgICAgICAnYXJpYS1oYXNwb3B1cCc6ICd0cnVlJyxcbiAgICAgICAgICAgICdhcmlhLWV4cGFuZGVkJzogb3BlblxuICAgICAgICAgIH0sIGV4dHJhU2VsZWN0aW9uUHJvcHMpLFxuICAgICAgICAgIGN0cmxOb2RlLFxuICAgICAgICAgIGFsbG93Q2xlYXIgJiYgIW11bHRpcGxlID8gY2xlYXIgOiBudWxsLFxuICAgICAgICAgIG11bHRpcGxlIHx8ICFwcm9wcy5zaG93QXJyb3cgPyBudWxsIDogX3JlYWN0MltcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAgICdzcGFuJyxcbiAgICAgICAgICAgIF9leHRlbmRzKHtcbiAgICAgICAgICAgICAga2V5OiAnYXJyb3cnLFxuICAgICAgICAgICAgICBjbGFzc05hbWU6IHByZWZpeENscyArICctYXJyb3cnLFxuICAgICAgICAgICAgICBzdHlsZTogX3V0aWwuVU5TRUxFQ1RBQkxFX1NUWUxFXG4gICAgICAgICAgICB9LCBfdXRpbC5VTlNFTEVDVEFCTEVfQVRUUklCVVRFLCB7XG4gICAgICAgICAgICAgIG9uTW91c2VEb3duOiBfdXRpbC5wcmV2ZW50RGVmYXVsdEV2ZW50LFxuICAgICAgICAgICAgICBvbkNsaWNrOiB0aGlzLm9uQXJyb3dDbGlja1xuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBfcmVhY3QyW1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KCdiJywgbnVsbClcbiAgICAgICAgICApLFxuICAgICAgICAgIG11bHRpcGxlID8gdGhpcy5nZXRTZWFyY2hQbGFjZWhvbGRlckVsZW1lbnQoISF0aGlzLnN0YXRlLmlucHV0VmFsdWUgfHwgdGhpcy5zdGF0ZS52YWx1ZS5sZW5ndGgpIDogbnVsbFxuICAgICAgICApXG4gICAgICApXG4gICAgKTtcbiAgfVxufSk7XG5cbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gU2VsZWN0O1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vdXhjb3JlLXRhYmxlL34vdXhjb3JlLXNlbGVjdDIvfi9yYy1zZWxlY3QvbGliL1NlbGVjdC5qc1xuICoqIG1vZHVsZSBpZCA9IDE2OFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5VTlNFTEVDVEFCTEVfQVRUUklCVVRFID0gZXhwb3J0cy5VTlNFTEVDVEFCTEVfU1RZTEUgPSB1bmRlZmluZWQ7XG5leHBvcnRzLmdldFZhbHVlUHJvcFZhbHVlID0gZ2V0VmFsdWVQcm9wVmFsdWU7XG5leHBvcnRzLmdldFByb3BWYWx1ZSA9IGdldFByb3BWYWx1ZTtcbmV4cG9ydHMuaXNDb21ib2JveCA9IGlzQ29tYm9ib3g7XG5leHBvcnRzLmlzTXVsdGlwbGVPclRhZ3MgPSBpc011bHRpcGxlT3JUYWdzO1xuZXhwb3J0cy5pc011bHRpcGxlT3JUYWdzT3JDb21ib2JveCA9IGlzTXVsdGlwbGVPclRhZ3NPckNvbWJvYm94O1xuZXhwb3J0cy5pc1NpbmdsZU1vZGUgPSBpc1NpbmdsZU1vZGU7XG5leHBvcnRzLnRvQXJyYXkgPSB0b0FycmF5O1xuZXhwb3J0cy5wcmV2ZW50RGVmYXVsdEV2ZW50ID0gcHJldmVudERlZmF1bHRFdmVudDtcbmV4cG9ydHMuZmluZEluZGV4SW5WYWx1ZUJ5S2V5ID0gZmluZEluZGV4SW5WYWx1ZUJ5S2V5O1xuZXhwb3J0cy5nZXRTZWxlY3RLZXlzID0gZ2V0U2VsZWN0S2V5cztcblxudmFyIF9yY01lbnUgPSByZXF1aXJlKCdyYy1tZW51Jyk7XG5cbnZhciBfcmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xuXG52YXIgX3JlYWN0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JlYWN0KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgXCJkZWZhdWx0XCI6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIGdldFZhbHVlUHJvcFZhbHVlKGNoaWxkKSB7XG4gIHZhciBwcm9wcyA9IGNoaWxkLnByb3BzO1xuICBpZiAoJ3ZhbHVlJyBpbiBwcm9wcykge1xuICAgIHJldHVybiBwcm9wcy52YWx1ZTtcbiAgfVxuICBpZiAoY2hpbGQua2V5KSB7XG4gICAgcmV0dXJuIGNoaWxkLmtleTtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoJ25vIGtleSBvciB2YWx1ZSBmb3IgJyArIGNoaWxkKTtcbn1cblxuZnVuY3Rpb24gZ2V0UHJvcFZhbHVlKGNoaWxkLCBwcm9wKSB7XG4gIGlmIChwcm9wID09PSAndmFsdWUnKSB7XG4gICAgcmV0dXJuIGdldFZhbHVlUHJvcFZhbHVlKGNoaWxkKTtcbiAgfVxuICByZXR1cm4gY2hpbGQucHJvcHNbcHJvcF07XG59XG5cbmZ1bmN0aW9uIGlzQ29tYm9ib3gocHJvcHMpIHtcbiAgcmV0dXJuIHByb3BzLmNvbWJvYm94O1xufVxuXG5mdW5jdGlvbiBpc011bHRpcGxlT3JUYWdzKHByb3BzKSB7XG4gIHJldHVybiBwcm9wcy5tdWx0aXBsZSB8fCBwcm9wcy50YWdzO1xufVxuXG5mdW5jdGlvbiBpc011bHRpcGxlT3JUYWdzT3JDb21ib2JveChwcm9wcykge1xuICByZXR1cm4gaXNNdWx0aXBsZU9yVGFncyhwcm9wcykgfHwgaXNDb21ib2JveChwcm9wcyk7XG59XG5cbmZ1bmN0aW9uIGlzU2luZ2xlTW9kZShwcm9wcykge1xuICByZXR1cm4gIWlzTXVsdGlwbGVPclRhZ3NPckNvbWJvYm94KHByb3BzKTtcbn1cblxuZnVuY3Rpb24gdG9BcnJheSh2YWx1ZSkge1xuICB2YXIgcmV0ID0gdmFsdWU7XG4gIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0ID0gW107XG4gIH0gZWxzZSBpZiAoIUFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgcmV0ID0gW3ZhbHVlXTtcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBwcmV2ZW50RGVmYXVsdEV2ZW50KGUpIHtcbiAgZS5wcmV2ZW50RGVmYXVsdCgpO1xufVxuXG5mdW5jdGlvbiBmaW5kSW5kZXhJblZhbHVlQnlLZXkodmFsdWUsIGtleSkge1xuICB2YXIgaW5kZXggPSAtMTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkrKykge1xuICAgIGlmICh2YWx1ZVtpXS5rZXkgPT09IGtleSkge1xuICAgICAgaW5kZXggPSBpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiBpbmRleDtcbn1cblxuZnVuY3Rpb24gZ2V0U2VsZWN0S2V5cyhtZW51SXRlbXMsIHZhbHVlKSB7XG4gIGlmICh2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIHZhciBzZWxlY3RlZEtleXMgPSBbXTtcbiAgX3JlYWN0MltcImRlZmF1bHRcIl0uQ2hpbGRyZW4uZm9yRWFjaChtZW51SXRlbXMsIGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgaWYgKGl0ZW0udHlwZSA9PT0gX3JjTWVudS5JdGVtR3JvdXApIHtcbiAgICAgIHNlbGVjdGVkS2V5cyA9IHNlbGVjdGVkS2V5cy5jb25jYXQoZ2V0U2VsZWN0S2V5cyhpdGVtLnByb3BzLmNoaWxkcmVuLCB2YWx1ZSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgaXRlbVZhbHVlID0gZ2V0VmFsdWVQcm9wVmFsdWUoaXRlbSk7XG4gICAgICB2YXIgaXRlbUtleSA9IGl0ZW0ua2V5O1xuICAgICAgaWYgKGZpbmRJbmRleEluVmFsdWVCeUtleSh2YWx1ZSwgaXRlbVZhbHVlKSAhPT0gLTEgJiYgaXRlbUtleSkge1xuICAgICAgICBzZWxlY3RlZEtleXMucHVzaChpdGVtS2V5KTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICByZXR1cm4gc2VsZWN0ZWRLZXlzO1xufVxuXG52YXIgVU5TRUxFQ1RBQkxFX1NUWUxFID0gZXhwb3J0cy5VTlNFTEVDVEFCTEVfU1RZTEUgPSB7XG4gIHVzZXJTZWxlY3Q6ICdub25lJyxcbiAgV2Via2l0VXNlclNlbGVjdDogJ25vbmUnXG59O1xuXG52YXIgVU5TRUxFQ1RBQkxFX0FUVFJJQlVURSA9IGV4cG9ydHMuVU5TRUxFQ1RBQkxFX0FUVFJJQlVURSA9IHtcbiAgdW5zZWxlY3RhYmxlOiAndW5zZWxlY3RhYmxlJ1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi91eGNvcmUtdGFibGUvfi91eGNvcmUtc2VsZWN0Mi9+L3JjLXNlbGVjdC9saWIvdXRpbC5qc1xuICoqIG1vZHVsZSBpZCA9IDE5OVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5EaXZpZGVyID0gZXhwb3J0cy5JdGVtR3JvdXAgPSBleHBvcnRzLk1lbnVJdGVtR3JvdXAgPSBleHBvcnRzLk1lbnVJdGVtID0gZXhwb3J0cy5JdGVtID0gZXhwb3J0cy5TdWJNZW51ID0gdW5kZWZpbmVkO1xuXG52YXIgX01lbnUgPSByZXF1aXJlKCcuL01lbnUnKTtcblxudmFyIF9NZW51MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX01lbnUpO1xuXG52YXIgX1N1Yk1lbnUgPSByZXF1aXJlKCcuL1N1Yk1lbnUnKTtcblxudmFyIF9TdWJNZW51MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1N1Yk1lbnUpO1xuXG52YXIgX01lbnVJdGVtID0gcmVxdWlyZSgnLi9NZW51SXRlbScpO1xuXG52YXIgX01lbnVJdGVtMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX01lbnVJdGVtKTtcblxudmFyIF9NZW51SXRlbUdyb3VwID0gcmVxdWlyZSgnLi9NZW51SXRlbUdyb3VwJyk7XG5cbnZhciBfTWVudUl0ZW1Hcm91cDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9NZW51SXRlbUdyb3VwKTtcblxudmFyIF9EaXZpZGVyID0gcmVxdWlyZSgnLi9EaXZpZGVyJyk7XG5cbnZhciBfRGl2aWRlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9EaXZpZGVyKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgXCJkZWZhdWx0XCI6IG9iaiB9OyB9XG5cbmV4cG9ydHMuU3ViTWVudSA9IF9TdWJNZW51MltcImRlZmF1bHRcIl07XG5leHBvcnRzLkl0ZW0gPSBfTWVudUl0ZW0yW1wiZGVmYXVsdFwiXTtcbmV4cG9ydHMuTWVudUl0ZW0gPSBfTWVudUl0ZW0yW1wiZGVmYXVsdFwiXTtcbmV4cG9ydHMuTWVudUl0ZW1Hcm91cCA9IF9NZW51SXRlbUdyb3VwMltcImRlZmF1bHRcIl07XG5leHBvcnRzLkl0ZW1Hcm91cCA9IF9NZW51SXRlbUdyb3VwMltcImRlZmF1bHRcIl07XG5leHBvcnRzLkRpdmlkZXIgPSBfRGl2aWRlcjJbXCJkZWZhdWx0XCJdO1xuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBfTWVudTJbXCJkZWZhdWx0XCJdO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3V4Y29yZS10YWJsZS9+L3V4Y29yZS1zZWxlY3QyL34vcmMtc2VsZWN0L34vcmMtbWVudS9saWIvaW5kZXguanNcbiAqKiBtb2R1bGUgaWQgPSAyMDBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9yZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5cbnZhciBfcmVhY3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmVhY3QpO1xuXG52YXIgX01lbnVNaXhpbiA9IHJlcXVpcmUoJy4vTWVudU1peGluJyk7XG5cbnZhciBfTWVudU1peGluMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX01lbnVNaXhpbik7XG5cbnZhciBfb2JqZWN0QXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xuXG52YXIgX29iamVjdEFzc2lnbjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9vYmplY3RBc3NpZ24pO1xuXG52YXIgX3V0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgXCJkZWZhdWx0XCI6IG9iaiB9OyB9XG5cbnZhciBNZW51ID0gX3JlYWN0MltcImRlZmF1bHRcIl0uY3JlYXRlQ2xhc3Moe1xuICBkaXNwbGF5TmFtZTogJ01lbnUnLFxuXG4gIHByb3BUeXBlczoge1xuICAgIG9wZW5TdWJNZW51T25Nb3VzZUVudGVyOiBfcmVhY3QuUHJvcFR5cGVzLmJvb2wsXG4gICAgY2xvc2VTdWJNZW51T25Nb3VzZUxlYXZlOiBfcmVhY3QuUHJvcFR5cGVzLmJvb2wsXG4gICAgc2VsZWN0ZWRLZXlzOiBfcmVhY3QuUHJvcFR5cGVzLmFycmF5T2YoX3JlYWN0LlByb3BUeXBlcy5zdHJpbmcpLFxuICAgIGRlZmF1bHRTZWxlY3RlZEtleXM6IF9yZWFjdC5Qcm9wVHlwZXMuYXJyYXlPZihfcmVhY3QuUHJvcFR5cGVzLnN0cmluZyksXG4gICAgZGVmYXVsdE9wZW5LZXlzOiBfcmVhY3QuUHJvcFR5cGVzLmFycmF5T2YoX3JlYWN0LlByb3BUeXBlcy5zdHJpbmcpLFxuICAgIG9wZW5LZXlzOiBfcmVhY3QuUHJvcFR5cGVzLmFycmF5T2YoX3JlYWN0LlByb3BUeXBlcy5zdHJpbmcpLFxuICAgIG1vZGU6IF9yZWFjdC5Qcm9wVHlwZXMuc3RyaW5nLFxuICAgIG9uQ2xpY2s6IF9yZWFjdC5Qcm9wVHlwZXMuZnVuYyxcbiAgICBvblNlbGVjdDogX3JlYWN0LlByb3BUeXBlcy5mdW5jLFxuICAgIG9uRGVzZWxlY3Q6IF9yZWFjdC5Qcm9wVHlwZXMuZnVuYyxcbiAgICBvbkRlc3Ryb3k6IF9yZWFjdC5Qcm9wVHlwZXMuZnVuYyxcbiAgICBvcGVuVHJhbnNpdGlvbk5hbWU6IF9yZWFjdC5Qcm9wVHlwZXMuc3RyaW5nLFxuICAgIG9wZW5BbmltYXRpb246IF9yZWFjdC5Qcm9wVHlwZXMub25lT2ZUeXBlKFtfcmVhY3QuUHJvcFR5cGVzLnN0cmluZywgX3JlYWN0LlByb3BUeXBlcy5vYmplY3RdKSxcbiAgICBsZXZlbDogX3JlYWN0LlByb3BUeXBlcy5udW1iZXIsXG4gICAgZXZlbnRLZXk6IF9yZWFjdC5Qcm9wVHlwZXMuc3RyaW5nLFxuICAgIHNlbGVjdGFibGU6IF9yZWFjdC5Qcm9wVHlwZXMuYm9vbCxcbiAgICBjaGlsZHJlbjogX3JlYWN0LlByb3BUeXBlcy5hbnlcbiAgfSxcblxuICBtaXhpbnM6IFtfTWVudU1peGluMltcImRlZmF1bHRcIl1dLFxuXG4gIGdldERlZmF1bHRQcm9wczogZnVuY3Rpb24gZ2V0RGVmYXVsdFByb3BzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBvcGVuU3ViTWVudU9uTW91c2VFbnRlcjogdHJ1ZSxcbiAgICAgIGNsb3NlU3ViTWVudU9uTW91c2VMZWF2ZTogdHJ1ZSxcbiAgICAgIHNlbGVjdGFibGU6IHRydWUsXG4gICAgICBvbkNsaWNrOiBfdXRpbC5ub29wLFxuICAgICAgb25TZWxlY3Q6IF91dGlsLm5vb3AsXG4gICAgICBvbk9wZW46IF91dGlsLm5vb3AsXG4gICAgICBvbkNsb3NlOiBfdXRpbC5ub29wLFxuICAgICAgb25EZXNlbGVjdDogX3V0aWwubm9vcCxcbiAgICAgIGRlZmF1bHRTZWxlY3RlZEtleXM6IFtdLFxuICAgICAgZGVmYXVsdE9wZW5LZXlzOiBbXVxuICAgIH07XG4gIH0sXG4gIGdldEluaXRpYWxTdGF0ZTogZnVuY3Rpb24gZ2V0SW5pdGlhbFN0YXRlKCkge1xuICAgIHZhciBwcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgdmFyIHNlbGVjdGVkS2V5cyA9IHByb3BzLmRlZmF1bHRTZWxlY3RlZEtleXM7XG4gICAgdmFyIG9wZW5LZXlzID0gcHJvcHMuZGVmYXVsdE9wZW5LZXlzO1xuICAgIGlmICgnc2VsZWN0ZWRLZXlzJyBpbiBwcm9wcykge1xuICAgICAgc2VsZWN0ZWRLZXlzID0gcHJvcHMuc2VsZWN0ZWRLZXlzIHx8IFtdO1xuICAgIH1cbiAgICBpZiAoJ29wZW5LZXlzJyBpbiBwcm9wcykge1xuICAgICAgb3BlbktleXMgPSBwcm9wcy5vcGVuS2V5cyB8fCBbXTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHNlbGVjdGVkS2V5czogc2VsZWN0ZWRLZXlzLCBvcGVuS2V5czogb3BlbktleXNcbiAgICB9O1xuICB9LFxuICBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzOiBmdW5jdGlvbiBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKG5leHRQcm9wcykge1xuICAgIHZhciBwcm9wcyA9IHt9O1xuICAgIGlmICgnc2VsZWN0ZWRLZXlzJyBpbiBuZXh0UHJvcHMpIHtcbiAgICAgIHByb3BzLnNlbGVjdGVkS2V5cyA9IG5leHRQcm9wcy5zZWxlY3RlZEtleXM7XG4gICAgfVxuICAgIGlmICgnb3BlbktleXMnIGluIG5leHRQcm9wcykge1xuICAgICAgcHJvcHMub3BlbktleXMgPSBuZXh0UHJvcHMub3BlbktleXM7XG4gICAgfVxuICAgIHRoaXMuc2V0U3RhdGUocHJvcHMpO1xuICB9LFxuICBvbkRlc3Ryb3k6IGZ1bmN0aW9uIG9uRGVzdHJveShrZXkpIHtcbiAgICB2YXIgc3RhdGUgPSB0aGlzLnN0YXRlO1xuICAgIHZhciBwcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgdmFyIHNlbGVjdGVkS2V5cyA9IHN0YXRlLnNlbGVjdGVkS2V5cztcbiAgICB2YXIgb3BlbktleXMgPSBzdGF0ZS5vcGVuS2V5cztcbiAgICB2YXIgaW5kZXggPSBzZWxlY3RlZEtleXMuaW5kZXhPZihrZXkpO1xuICAgIGlmICghKCdzZWxlY3RlZEtleXMnIGluIHByb3BzKSAmJiBpbmRleCAhPT0gLTEpIHtcbiAgICAgIHNlbGVjdGVkS2V5cy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIH1cbiAgICBpbmRleCA9IG9wZW5LZXlzLmluZGV4T2Yoa2V5KTtcbiAgICBpZiAoISgnb3BlbktleXMnIGluIHByb3BzKSAmJiBpbmRleCAhPT0gLTEpIHtcbiAgICAgIG9wZW5LZXlzLnNwbGljZShpbmRleCwgMSk7XG4gICAgfVxuICB9LFxuICBvbkl0ZW1Ib3ZlcjogZnVuY3Rpb24gb25JdGVtSG92ZXIoZSkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICB2YXIgaXRlbSA9IGUuaXRlbTtcbiAgICAvLyBzcGVjaWFsIGZvciB0b3Agc3ViIG1lbnVcblxuICAgIGlmICh0aGlzLnByb3BzLm1vZGUgIT09ICdpbmxpbmUnICYmICF0aGlzLnByb3BzLmNsb3NlU3ViTWVudU9uTW91c2VMZWF2ZSAmJiBpdGVtLmlzU3ViTWVudSkge1xuICAgICAgKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGFjdGl2ZUtleSA9IF90aGlzLnN0YXRlLmFjdGl2ZUtleTtcbiAgICAgICAgdmFyIGFjdGl2ZUl0ZW0gPSBfdGhpcy5nZXRGbGF0SW5zdGFuY2VBcnJheSgpLmZpbHRlcihmdW5jdGlvbiAoYykge1xuICAgICAgICAgIHJldHVybiBjICYmIGMucHJvcHMuZXZlbnRLZXkgPT09IGFjdGl2ZUtleTtcbiAgICAgICAgfSlbMF07XG4gICAgICAgIGlmIChhY3RpdmVJdGVtICYmIGFjdGl2ZUl0ZW0ucHJvcHMub3Blbikge1xuICAgICAgICAgIF90aGlzLm9uT3BlbkNoYW5nZSh7XG4gICAgICAgICAgICBrZXk6IGl0ZW0ucHJvcHMuZXZlbnRLZXksXG4gICAgICAgICAgICBpdGVtOiBlLml0ZW0sXG4gICAgICAgICAgICBvcGVuOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pKCk7XG4gICAgfVxuXG4gICAgdGhpcy5vbkNvbW1vbkl0ZW1Ib3ZlcihlKTtcbiAgfSxcbiAgb25TZWxlY3Q6IGZ1bmN0aW9uIG9uU2VsZWN0KHNlbGVjdEluZm8pIHtcbiAgICB2YXIgcHJvcHMgPSB0aGlzLnByb3BzO1xuICAgIGlmIChwcm9wcy5zZWxlY3RhYmxlKSB7XG4gICAgICAvLyByb290IG1lbnVcbiAgICAgIHZhciBzZWxlY3RlZEtleXMgPSB0aGlzLnN0YXRlLnNlbGVjdGVkS2V5cztcbiAgICAgIHZhciBzZWxlY3RlZEtleSA9IHNlbGVjdEluZm8ua2V5O1xuICAgICAgaWYgKHByb3BzLm11bHRpcGxlKSB7XG4gICAgICAgIHNlbGVjdGVkS2V5cyA9IHNlbGVjdGVkS2V5cy5jb25jYXQoW3NlbGVjdGVkS2V5XSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZWxlY3RlZEtleXMgPSBbc2VsZWN0ZWRLZXldO1xuICAgICAgfVxuICAgICAgaWYgKCEoJ3NlbGVjdGVkS2V5cycgaW4gcHJvcHMpKSB7XG4gICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgIHNlbGVjdGVkS2V5czogc2VsZWN0ZWRLZXlzXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcHJvcHMub25TZWxlY3QoKDAsIF9vYmplY3RBc3NpZ24yW1wiZGVmYXVsdFwiXSkoe30sIHNlbGVjdEluZm8sIHtcbiAgICAgICAgc2VsZWN0ZWRLZXlzOiBzZWxlY3RlZEtleXNcbiAgICAgIH0pKTtcbiAgICB9XG4gIH0sXG4gIG9uQ2xpY2s6IGZ1bmN0aW9uIG9uQ2xpY2soZSkge1xuICAgIHZhciBwcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgcHJvcHMub25DbGljayhlKTtcbiAgfSxcbiAgb25PcGVuQ2hhbmdlOiBmdW5jdGlvbiBvbk9wZW5DaGFuZ2UoZSkge1xuICAgIHZhciBwcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgdmFyIG9wZW5LZXlzID0gdGhpcy5zdGF0ZS5vcGVuS2V5cztcbiAgICB2YXIgY2hhbmdlZCA9IHRydWU7XG4gICAgaWYgKGUub3Blbikge1xuICAgICAgY2hhbmdlZCA9IG9wZW5LZXlzLmluZGV4T2YoZS5rZXkpID09PSAtMTtcbiAgICAgIGlmIChjaGFuZ2VkKSB7XG4gICAgICAgIG9wZW5LZXlzID0gb3BlbktleXMuY29uY2F0KGUua2V5KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGluZGV4ID0gb3BlbktleXMuaW5kZXhPZihlLmtleSk7XG4gICAgICBjaGFuZ2VkID0gaW5kZXggIT09IC0xO1xuICAgICAgaWYgKGNoYW5nZWQpIHtcbiAgICAgICAgb3BlbktleXMgPSBvcGVuS2V5cy5jb25jYXQoKTtcbiAgICAgICAgb3BlbktleXMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGNoYW5nZWQpIHtcbiAgICAgIC8vIGhhY2ssIHN5bmNocm9ub3VzIGNhbGwgZnJvbSBvblRpdGxlTW91c2VFbnRlclxuICAgICAgdGhpcy5zdGF0ZS5vcGVuS2V5cyA9IG9wZW5LZXlzO1xuICAgICAgaWYgKCEoJ29wZW5LZXlzJyBpbiB0aGlzLnByb3BzKSkge1xuICAgICAgICAvLyBoYWNrOiBiYXRjaCBkb2VzIG5vdCB1cGRhdGUgc3RhdGVcbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7IG9wZW5LZXlzOiBvcGVuS2V5cyB9KTtcbiAgICAgIH1cbiAgICAgIHZhciBpbmZvID0gKDAsIF9vYmplY3RBc3NpZ24yW1wiZGVmYXVsdFwiXSkoeyBvcGVuS2V5czogb3BlbktleXMgfSwgZSk7XG4gICAgICBpZiAoZS5vcGVuKSB7XG4gICAgICAgIHByb3BzLm9uT3BlbihpbmZvKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByb3BzLm9uQ2xvc2UoaW5mbyk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBvbkRlc2VsZWN0OiBmdW5jdGlvbiBvbkRlc2VsZWN0KHNlbGVjdEluZm8pIHtcbiAgICB2YXIgcHJvcHMgPSB0aGlzLnByb3BzO1xuICAgIGlmIChwcm9wcy5zZWxlY3RhYmxlKSB7XG4gICAgICB2YXIgc2VsZWN0ZWRLZXlzID0gdGhpcy5zdGF0ZS5zZWxlY3RlZEtleXMuY29uY2F0KCk7XG4gICAgICB2YXIgc2VsZWN0ZWRLZXkgPSBzZWxlY3RJbmZvLmtleTtcbiAgICAgIHZhciBpbmRleCA9IHNlbGVjdGVkS2V5cy5pbmRleE9mKHNlbGVjdGVkS2V5KTtcbiAgICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgICAgc2VsZWN0ZWRLZXlzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICB9XG4gICAgICBpZiAoISgnc2VsZWN0ZWRLZXlzJyBpbiBwcm9wcykpIHtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgc2VsZWN0ZWRLZXlzOiBzZWxlY3RlZEtleXNcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBwcm9wcy5vbkRlc2VsZWN0KCgwLCBfb2JqZWN0QXNzaWduMltcImRlZmF1bHRcIl0pKHt9LCBzZWxlY3RJbmZvLCB7XG4gICAgICAgIHNlbGVjdGVkS2V5czogc2VsZWN0ZWRLZXlzXG4gICAgICB9KSk7XG4gICAgfVxuICB9LFxuICBnZXRPcGVuVHJhbnNpdGlvbk5hbWU6IGZ1bmN0aW9uIGdldE9wZW5UcmFuc2l0aW9uTmFtZSgpIHtcbiAgICB2YXIgcHJvcHMgPSB0aGlzLnByb3BzO1xuICAgIHZhciB0cmFuc2l0aW9uTmFtZSA9IHByb3BzLm9wZW5UcmFuc2l0aW9uTmFtZTtcbiAgICB2YXIgYW5pbWF0aW9uTmFtZSA9IHByb3BzLm9wZW5BbmltYXRpb247XG4gICAgaWYgKCF0cmFuc2l0aW9uTmFtZSAmJiB0eXBlb2YgYW5pbWF0aW9uTmFtZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRyYW5zaXRpb25OYW1lID0gcHJvcHMucHJlZml4Q2xzICsgJy1vcGVuLScgKyBhbmltYXRpb25OYW1lO1xuICAgIH1cbiAgICByZXR1cm4gdHJhbnNpdGlvbk5hbWU7XG4gIH0sXG4gIGlzSW5saW5lTW9kZTogZnVuY3Rpb24gaXNJbmxpbmVNb2RlKCkge1xuICAgIHJldHVybiB0aGlzLnByb3BzLm1vZGUgPT09ICdpbmxpbmUnO1xuICB9LFxuICBsYXN0T3BlblN1Yk1lbnU6IGZ1bmN0aW9uIGxhc3RPcGVuU3ViTWVudSgpIHtcbiAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgIHZhciBsYXN0T3BlbiA9IFtdO1xuICAgIGlmICh0aGlzLnN0YXRlLm9wZW5LZXlzLmxlbmd0aCkge1xuICAgICAgbGFzdE9wZW4gPSB0aGlzLmdldEZsYXRJbnN0YW5jZUFycmF5KCkuZmlsdGVyKGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIHJldHVybiBjICYmIF90aGlzMi5zdGF0ZS5vcGVuS2V5cy5pbmRleE9mKGMucHJvcHMuZXZlbnRLZXkpICE9PSAtMTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gbGFzdE9wZW5bMF07XG4gIH0sXG4gIHJlbmRlck1lbnVJdGVtOiBmdW5jdGlvbiByZW5kZXJNZW51SXRlbShjLCBpLCBzdWJJbmRleCkge1xuICAgIGlmICghYykgcmV0dXJuIG51bGw7XG4gICAgdmFyIGtleSA9ICgwLCBfdXRpbC5nZXRLZXlGcm9tQ2hpbGRyZW5JbmRleCkoYywgdGhpcy5wcm9wcy5ldmVudEtleSwgaSk7XG4gICAgdmFyIHN0YXRlID0gdGhpcy5zdGF0ZTtcbiAgICB2YXIgZXh0cmFQcm9wcyA9IHtcbiAgICAgIG9wZW5LZXlzOiBzdGF0ZS5vcGVuS2V5cyxcbiAgICAgIG9wZW46IHN0YXRlLm9wZW5LZXlzLmluZGV4T2Yoa2V5KSAhPT0gLTEsXG4gICAgICBzZWxlY3RlZEtleXM6IHN0YXRlLnNlbGVjdGVkS2V5cyxcbiAgICAgIHNlbGVjdGVkOiBzdGF0ZS5zZWxlY3RlZEtleXMuaW5kZXhPZihrZXkpICE9PSAtMSxcbiAgICAgIG9wZW5TdWJNZW51T25Nb3VzZUVudGVyOiB0aGlzLnByb3BzLm9wZW5TdWJNZW51T25Nb3VzZUVudGVyXG4gICAgfTtcbiAgICByZXR1cm4gdGhpcy5yZW5kZXJDb21tb25NZW51SXRlbShjLCBpLCBzdWJJbmRleCwgZXh0cmFQcm9wcyk7XG4gIH0sXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgIHZhciBwcm9wcyA9ICgwLCBfb2JqZWN0QXNzaWduMltcImRlZmF1bHRcIl0pKHt9LCB0aGlzLnByb3BzKTtcbiAgICBwcm9wcy5jbGFzc05hbWUgKz0gJyAnICsgcHJvcHMucHJlZml4Q2xzICsgJy1yb290JztcbiAgICByZXR1cm4gdGhpcy5yZW5kZXJSb290KHByb3BzKTtcbiAgfVxufSk7XG5cbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gTWVudTtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3V4Y29yZS10YWJsZS9+L3V4Y29yZS1zZWxlY3QyL34vcmMtc2VsZWN0L34vcmMtbWVudS9saWIvTWVudS5qc1xuICoqIG1vZHVsZSBpZCA9IDIwMVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG52YXIgX3JlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxudmFyIF9yZWFjdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yZWFjdCk7XG5cbnZhciBfcmVhY3REb20gPSByZXF1aXJlKCdyZWFjdC1kb20nKTtcblxudmFyIF9yZWFjdERvbTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yZWFjdERvbSk7XG5cbnZhciBfcmNVdGlsID0gcmVxdWlyZSgncmMtdXRpbCcpO1xuXG52YXIgX2NsYXNzbmFtZXMgPSByZXF1aXJlKCdjbGFzc25hbWVzJyk7XG5cbnZhciBfY2xhc3NuYW1lczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jbGFzc25hbWVzKTtcblxudmFyIF9kb21TY3JvbGxJbnRvVmlldyA9IHJlcXVpcmUoJ2RvbS1zY3JvbGwtaW50by12aWV3Jyk7XG5cbnZhciBfZG9tU2Nyb2xsSW50b1ZpZXcyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZG9tU2Nyb2xsSW50b1ZpZXcpO1xuXG52YXIgX29iamVjdEFzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcblxudmFyIF9vYmplY3RBc3NpZ24yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfb2JqZWN0QXNzaWduKTtcblxudmFyIF91dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG5cbnZhciBfRE9NV3JhcCA9IHJlcXVpcmUoJy4vRE9NV3JhcCcpO1xuXG52YXIgX0RPTVdyYXAyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfRE9NV3JhcCk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IFwiZGVmYXVsdFwiOiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxuXG5mdW5jdGlvbiBhbGxEaXNhYmxlZChhcnIpIHtcbiAgaWYgKCFhcnIubGVuZ3RoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGFyci5ldmVyeShmdW5jdGlvbiAoYykge1xuICAgIHJldHVybiAhIWMucHJvcHMuZGlzYWJsZWQ7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBnZXRBY3RpdmVLZXkocHJvcHMsIG9yaWdpbmFsQWN0aXZlS2V5KSB7XG4gIHZhciBhY3RpdmVLZXkgPSBvcmlnaW5hbEFjdGl2ZUtleTtcbiAgdmFyIGNoaWxkcmVuID0gcHJvcHMuY2hpbGRyZW47XG4gIHZhciBldmVudEtleSA9IHByb3BzLmV2ZW50S2V5O1xuICBpZiAoYWN0aXZlS2V5KSB7XG4gICAgdmFyIGZvdW5kID0gdm9pZCAwO1xuICAgICgwLCBfdXRpbC5sb29wTWVudUl0ZW0pKGNoaWxkcmVuLCBmdW5jdGlvbiAoYywgaSkge1xuICAgICAgaWYgKCFjLnByb3BzLmRpc2FibGVkICYmIGFjdGl2ZUtleSA9PT0gKDAsIF91dGlsLmdldEtleUZyb21DaGlsZHJlbkluZGV4KShjLCBldmVudEtleSwgaSkpIHtcbiAgICAgICAgZm91bmQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGlmIChmb3VuZCkge1xuICAgICAgcmV0dXJuIGFjdGl2ZUtleTtcbiAgICB9XG4gIH1cbiAgYWN0aXZlS2V5ID0gbnVsbDtcbiAgaWYgKHByb3BzLmRlZmF1bHRBY3RpdmVGaXJzdCkge1xuICAgICgwLCBfdXRpbC5sb29wTWVudUl0ZW0pKGNoaWxkcmVuLCBmdW5jdGlvbiAoYywgaSkge1xuICAgICAgaWYgKCFhY3RpdmVLZXkgJiYgIWMucHJvcHMuZGlzYWJsZWQpIHtcbiAgICAgICAgYWN0aXZlS2V5ID0gKDAsIF91dGlsLmdldEtleUZyb21DaGlsZHJlbkluZGV4KShjLCBldmVudEtleSwgaSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGFjdGl2ZUtleTtcbiAgfVxuICByZXR1cm4gYWN0aXZlS2V5O1xufVxuXG5mdW5jdGlvbiBzYXZlUmVmKGluZGV4LCBzdWJJbmRleCwgYykge1xuICBpZiAoYykge1xuICAgIGlmIChzdWJJbmRleCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLmluc3RhbmNlQXJyYXlbaW5kZXhdID0gdGhpcy5pbnN0YW5jZUFycmF5W2luZGV4XSB8fCBbXTtcbiAgICAgIHRoaXMuaW5zdGFuY2VBcnJheVtpbmRleF1bc3ViSW5kZXhdID0gYztcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5pbnN0YW5jZUFycmF5W2luZGV4XSA9IGM7XG4gICAgfVxuICB9XG59XG5cbnZhciBNZW51TWl4aW4gPSB7XG4gIHByb3BUeXBlczoge1xuICAgIGZvY3VzYWJsZTogX3JlYWN0LlByb3BUeXBlcy5ib29sLFxuICAgIG11bHRpcGxlOiBfcmVhY3QuUHJvcFR5cGVzLmJvb2wsXG4gICAgc3R5bGU6IF9yZWFjdC5Qcm9wVHlwZXMub2JqZWN0LFxuICAgIGRlZmF1bHRBY3RpdmVGaXJzdDogX3JlYWN0LlByb3BUeXBlcy5ib29sLFxuICAgIHZpc2libGU6IF9yZWFjdC5Qcm9wVHlwZXMuYm9vbCxcbiAgICBhY3RpdmVLZXk6IF9yZWFjdC5Qcm9wVHlwZXMuc3RyaW5nLFxuICAgIHNlbGVjdGVkS2V5czogX3JlYWN0LlByb3BUeXBlcy5hcnJheU9mKF9yZWFjdC5Qcm9wVHlwZXMuc3RyaW5nKSxcbiAgICBkZWZhdWx0U2VsZWN0ZWRLZXlzOiBfcmVhY3QuUHJvcFR5cGVzLmFycmF5T2YoX3JlYWN0LlByb3BUeXBlcy5zdHJpbmcpLFxuICAgIGRlZmF1bHRPcGVuS2V5czogX3JlYWN0LlByb3BUeXBlcy5hcnJheU9mKF9yZWFjdC5Qcm9wVHlwZXMuc3RyaW5nKSxcbiAgICBvcGVuS2V5czogX3JlYWN0LlByb3BUeXBlcy5hcnJheU9mKF9yZWFjdC5Qcm9wVHlwZXMuc3RyaW5nKSxcbiAgICBjaGlsZHJlbjogX3JlYWN0LlByb3BUeXBlcy5hbnlcbiAgfSxcblxuICBnZXREZWZhdWx0UHJvcHM6IGZ1bmN0aW9uIGdldERlZmF1bHRQcm9wcygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgcHJlZml4Q2xzOiAncmMtbWVudScsXG4gICAgICBjbGFzc05hbWU6ICcnLFxuICAgICAgbW9kZTogJ3ZlcnRpY2FsJyxcbiAgICAgIGxldmVsOiAxLFxuICAgICAgaW5saW5lSW5kZW50OiAyNCxcbiAgICAgIHZpc2libGU6IHRydWUsXG4gICAgICBmb2N1c2FibGU6IHRydWUsXG4gICAgICBzdHlsZToge31cbiAgICB9O1xuICB9LFxuICBnZXRJbml0aWFsU3RhdGU6IGZ1bmN0aW9uIGdldEluaXRpYWxTdGF0ZSgpIHtcbiAgICB2YXIgcHJvcHMgPSB0aGlzLnByb3BzO1xuICAgIHJldHVybiB7XG4gICAgICBhY3RpdmVLZXk6IGdldEFjdGl2ZUtleShwcm9wcywgcHJvcHMuYWN0aXZlS2V5KVxuICAgIH07XG4gIH0sXG4gIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHM6IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMobmV4dFByb3BzKSB7XG4gICAgdmFyIHByb3BzID0gdm9pZCAwO1xuICAgIGlmICgnYWN0aXZlS2V5JyBpbiBuZXh0UHJvcHMpIHtcbiAgICAgIHByb3BzID0ge1xuICAgICAgICBhY3RpdmVLZXk6IGdldEFjdGl2ZUtleShuZXh0UHJvcHMsIG5leHRQcm9wcy5hY3RpdmVLZXkpXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgb3JpZ2luYWxBY3RpdmVLZXkgPSB0aGlzLnN0YXRlLmFjdGl2ZUtleTtcbiAgICAgIHZhciBhY3RpdmVLZXkgPSBnZXRBY3RpdmVLZXkobmV4dFByb3BzLCBvcmlnaW5hbEFjdGl2ZUtleSk7XG4gICAgICAvLyBmaXg6IHRoaXMuc2V0U3RhdGUoKSwgcGFyZW50LnJlbmRlcigpLFxuICAgICAgaWYgKGFjdGl2ZUtleSAhPT0gb3JpZ2luYWxBY3RpdmVLZXkpIHtcbiAgICAgICAgcHJvcHMgPSB7XG4gICAgICAgICAgYWN0aXZlS2V5OiBhY3RpdmVLZXlcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHByb3BzKSB7XG4gICAgICB0aGlzLnNldFN0YXRlKHByb3BzKTtcbiAgICB9XG4gIH0sXG4gIHNob3VsZENvbXBvbmVudFVwZGF0ZTogZnVuY3Rpb24gc2hvdWxkQ29tcG9uZW50VXBkYXRlKG5leHRQcm9wcykge1xuICAgIHJldHVybiB0aGlzLnByb3BzLnZpc2libGUgfHwgbmV4dFByb3BzLnZpc2libGU7XG4gIH0sXG4gIGNvbXBvbmVudFdpbGxNb3VudDogZnVuY3Rpb24gY29tcG9uZW50V2lsbE1vdW50KCkge1xuICAgIHRoaXMuaW5zdGFuY2VBcnJheSA9IFtdO1xuICB9LFxuXG5cbiAgLy8gYWxsIGtleWJvYXJkIGV2ZW50cyBjYWxsYmFja3MgcnVuIGZyb20gaGVyZSBhdCBmaXJzdFxuICBvbktleURvd246IGZ1bmN0aW9uIG9uS2V5RG93bihlKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIHZhciBrZXlDb2RlID0gZS5rZXlDb2RlO1xuICAgIHZhciBoYW5kbGVkID0gdm9pZCAwO1xuICAgIHRoaXMuZ2V0RmxhdEluc3RhbmNlQXJyYXkoKS5mb3JFYWNoKGZ1bmN0aW9uIChvYmopIHtcbiAgICAgIGlmIChvYmogJiYgb2JqLnByb3BzLmFjdGl2ZSkge1xuICAgICAgICBoYW5kbGVkID0gb2JqLm9uS2V5RG93bihlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAoaGFuZGxlZCkge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICAgIHZhciBhY3RpdmVJdGVtID0gbnVsbDtcbiAgICBpZiAoa2V5Q29kZSA9PT0gX3JjVXRpbC5LZXlDb2RlLlVQIHx8IGtleUNvZGUgPT09IF9yY1V0aWwuS2V5Q29kZS5ET1dOKSB7XG4gICAgICBhY3RpdmVJdGVtID0gdGhpcy5zdGVwKGtleUNvZGUgPT09IF9yY1V0aWwuS2V5Q29kZS5VUCA/IC0xIDogMSk7XG4gICAgfVxuICAgIGlmIChhY3RpdmVJdGVtKSB7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgYWN0aXZlS2V5OiBhY3RpdmVJdGVtLnByb3BzLmV2ZW50S2V5XG4gICAgICB9LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICgwLCBfZG9tU2Nyb2xsSW50b1ZpZXcyW1wiZGVmYXVsdFwiXSkoX3JlYWN0RG9tMltcImRlZmF1bHRcIl0uZmluZERPTU5vZGUoYWN0aXZlSXRlbSksIF9yZWFjdERvbTJbXCJkZWZhdWx0XCJdLmZpbmRET01Ob2RlKF90aGlzKSwge1xuICAgICAgICAgIG9ubHlTY3JvbGxJZk5lZWRlZDogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIDE7XG4gICAgfSBlbHNlIGlmIChhY3RpdmVJdGVtID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICBhY3RpdmVLZXk6IG51bGxcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICB9LFxuICBvbkNvbW1vbkl0ZW1Ib3ZlcjogZnVuY3Rpb24gb25Db21tb25JdGVtSG92ZXIoZSkge1xuICAgIHZhciBtb2RlID0gdGhpcy5wcm9wcy5tb2RlO1xuICAgIHZhciBrZXkgPSBlLmtleTtcbiAgICB2YXIgaG92ZXIgPSBlLmhvdmVyO1xuICAgIHZhciB0cmlnZ2VyID0gZS50cmlnZ2VyO1xuXG4gICAgdmFyIGFjdGl2ZUtleSA9IHRoaXMuc3RhdGUuYWN0aXZlS2V5O1xuICAgIGlmICghdHJpZ2dlciB8fCBob3ZlciB8fCB0aGlzLnByb3BzLmNsb3NlU3ViTWVudU9uTW91c2VMZWF2ZSB8fCAhZS5pdGVtLmlzU3ViTWVudSB8fCBtb2RlID09PSAnaW5saW5lJykge1xuICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgIGFjdGl2ZUtleTogaG92ZXIgPyBrZXkgOiBudWxsXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge31cbiAgICAvLyBrZWVwIGFjdGl2ZSBmb3Igc3ViIG1lbnUgZm9yIGNsaWNrIGFjdGl2ZVxuICAgIC8vIGVtcHR5XG5cbiAgICAvLyBjbGVhciBsYXN0IG9wZW4gc3RhdHVzXG4gICAgaWYgKGhvdmVyICYmIG1vZGUgIT09ICdpbmxpbmUnKSB7XG4gICAgICB2YXIgYWN0aXZlSXRlbSA9IHRoaXMuZ2V0RmxhdEluc3RhbmNlQXJyYXkoKS5maWx0ZXIoZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgcmV0dXJuIGMgJiYgYy5wcm9wcy5ldmVudEtleSA9PT0gYWN0aXZlS2V5O1xuICAgICAgfSlbMF07XG4gICAgICBpZiAoYWN0aXZlSXRlbSAmJiBhY3RpdmVJdGVtLmlzU3ViTWVudSAmJiBhY3RpdmVJdGVtLnByb3BzLmV2ZW50S2V5ICE9PSBrZXkpIHtcbiAgICAgICAgdGhpcy5vbk9wZW5DaGFuZ2Uoe1xuICAgICAgICAgIGl0ZW06IGFjdGl2ZUl0ZW0sXG4gICAgICAgICAga2V5OiBhY3RpdmVJdGVtLnByb3BzLmV2ZW50S2V5LFxuICAgICAgICAgIG9wZW46IGZhbHNlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgZ2V0RmxhdEluc3RhbmNlQXJyYXk6IGZ1bmN0aW9uIGdldEZsYXRJbnN0YW5jZUFycmF5KCkge1xuICAgIHZhciBpbnN0YW5jZUFycmF5ID0gdGhpcy5pbnN0YW5jZUFycmF5O1xuICAgIHZhciBoYXNJbm5lckFycmF5ID0gaW5zdGFuY2VBcnJheS5zb21lKGZ1bmN0aW9uIChhKSB7XG4gICAgICByZXR1cm4gQXJyYXkuaXNBcnJheShhKTtcbiAgICB9KTtcbiAgICBpZiAoaGFzSW5uZXJBcnJheSkge1xuICAgICAgaW5zdGFuY2VBcnJheSA9IFtdO1xuICAgICAgdGhpcy5pbnN0YW5jZUFycmF5LmZvckVhY2goZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYSkpIHtcbiAgICAgICAgICBpbnN0YW5jZUFycmF5LnB1c2guYXBwbHkoaW5zdGFuY2VBcnJheSwgYSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaW5zdGFuY2VBcnJheS5wdXNoKGEpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHRoaXMuaW5zdGFuY2VBcnJheSA9IGluc3RhbmNlQXJyYXk7XG4gICAgfVxuICAgIHJldHVybiBpbnN0YW5jZUFycmF5O1xuICB9LFxuICByZW5kZXJDb21tb25NZW51SXRlbTogZnVuY3Rpb24gcmVuZGVyQ29tbW9uTWVudUl0ZW0oY2hpbGQsIGksIHN1YkluZGV4LCBleHRyYVByb3BzKSB7XG4gICAgdmFyIHN0YXRlID0gdGhpcy5zdGF0ZTtcbiAgICB2YXIgcHJvcHMgPSB0aGlzLnByb3BzO1xuICAgIHZhciBrZXkgPSAoMCwgX3V0aWwuZ2V0S2V5RnJvbUNoaWxkcmVuSW5kZXgpKGNoaWxkLCBwcm9wcy5ldmVudEtleSwgaSk7XG4gICAgdmFyIGNoaWxkUHJvcHMgPSBjaGlsZC5wcm9wcztcbiAgICB2YXIgaXNBY3RpdmUgPSBrZXkgPT09IHN0YXRlLmFjdGl2ZUtleTtcbiAgICB2YXIgbmV3Q2hpbGRQcm9wcyA9ICgwLCBfb2JqZWN0QXNzaWduMltcImRlZmF1bHRcIl0pKHtcbiAgICAgIG1vZGU6IHByb3BzLm1vZGUsXG4gICAgICBsZXZlbDogcHJvcHMubGV2ZWwsXG4gICAgICBpbmxpbmVJbmRlbnQ6IHByb3BzLmlubGluZUluZGVudCxcbiAgICAgIHJlbmRlck1lbnVJdGVtOiB0aGlzLnJlbmRlck1lbnVJdGVtLFxuICAgICAgcm9vdFByZWZpeENsczogcHJvcHMucHJlZml4Q2xzLFxuICAgICAgaW5kZXg6IGksXG4gICAgICBwYXJlbnRNZW51OiB0aGlzLFxuICAgICAgcmVmOiBjaGlsZFByb3BzLmRpc2FibGVkID8gdW5kZWZpbmVkIDogKDAsIF9yY1V0aWwuY3JlYXRlQ2hhaW5lZEZ1bmN0aW9uKShjaGlsZC5yZWYsIHNhdmVSZWYuYmluZCh0aGlzLCBpLCBzdWJJbmRleCkpLFxuICAgICAgZXZlbnRLZXk6IGtleSxcbiAgICAgIGNsb3NlU3ViTWVudU9uTW91c2VMZWF2ZTogcHJvcHMuY2xvc2VTdWJNZW51T25Nb3VzZUxlYXZlLFxuICAgICAgb25JdGVtSG92ZXI6IHRoaXMub25JdGVtSG92ZXIsXG4gICAgICBhY3RpdmU6ICFjaGlsZFByb3BzLmRpc2FibGVkICYmIGlzQWN0aXZlLFxuICAgICAgbXVsdGlwbGU6IHByb3BzLm11bHRpcGxlLFxuICAgICAgb25DbGljazogdGhpcy5vbkNsaWNrLFxuICAgICAgb3BlblRyYW5zaXRpb25OYW1lOiB0aGlzLmdldE9wZW5UcmFuc2l0aW9uTmFtZSgpLFxuICAgICAgb3BlbkFuaW1hdGlvbjogcHJvcHMub3BlbkFuaW1hdGlvbixcbiAgICAgIG9uT3BlbkNoYW5nZTogdGhpcy5vbk9wZW5DaGFuZ2UsXG4gICAgICBvbkRlc2VsZWN0OiB0aGlzLm9uRGVzZWxlY3QsXG4gICAgICBvbkRlc3Ryb3k6IHRoaXMub25EZXN0cm95LFxuICAgICAgb25TZWxlY3Q6IHRoaXMub25TZWxlY3RcbiAgICB9LCBleHRyYVByb3BzKTtcbiAgICBpZiAocHJvcHMubW9kZSA9PT0gJ2lubGluZScpIHtcbiAgICAgIG5ld0NoaWxkUHJvcHMuY2xvc2VTdWJNZW51T25Nb3VzZUxlYXZlID0gbmV3Q2hpbGRQcm9wcy5vcGVuU3ViTWVudU9uTW91c2VFbnRlciA9IGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gX3JlYWN0MltcImRlZmF1bHRcIl0uY2xvbmVFbGVtZW50KGNoaWxkLCBuZXdDaGlsZFByb3BzKTtcbiAgfSxcbiAgcmVuZGVyUm9vdDogZnVuY3Rpb24gcmVuZGVyUm9vdChwcm9wcykge1xuICAgIHZhciBfY2xhc3NlcztcblxuICAgIHRoaXMuaW5zdGFuY2VBcnJheSA9IFtdO1xuICAgIHZhciBjbGFzc2VzID0gKF9jbGFzc2VzID0ge30sIF9kZWZpbmVQcm9wZXJ0eShfY2xhc3NlcywgcHJvcHMucHJlZml4Q2xzLCAxKSwgX2RlZmluZVByb3BlcnR5KF9jbGFzc2VzLCBwcm9wcy5wcmVmaXhDbHMgKyAnLScgKyBwcm9wcy5tb2RlLCAxKSwgX2RlZmluZVByb3BlcnR5KF9jbGFzc2VzLCBwcm9wcy5jbGFzc05hbWUsICEhcHJvcHMuY2xhc3NOYW1lKSwgX2NsYXNzZXMpO1xuICAgIHZhciBkb21Qcm9wcyA9IHtcbiAgICAgIGNsYXNzTmFtZTogKDAsIF9jbGFzc25hbWVzMltcImRlZmF1bHRcIl0pKGNsYXNzZXMpLFxuICAgICAgcm9sZTogJ21lbnUnLFxuICAgICAgJ2FyaWEtYWN0aXZlZGVzY2VuZGFudCc6ICcnXG4gICAgfTtcbiAgICBpZiAocHJvcHMuaWQpIHtcbiAgICAgIGRvbVByb3BzLmlkID0gcHJvcHMuaWQ7XG4gICAgfVxuICAgIGlmIChwcm9wcy5mb2N1c2FibGUpIHtcbiAgICAgIGRvbVByb3BzLnRhYkluZGV4ID0gJzAnO1xuICAgICAgZG9tUHJvcHMub25LZXlEb3duID0gdGhpcy5vbktleURvd247XG4gICAgfVxuICAgIHJldHVybihcbiAgICAgIC8vIEVTTGludCBpcyBub3Qgc21hcnQgZW5vdWdoIHRvIGtub3cgdGhhdCB0aGUgdHlwZSBvZiBgY2hpbGRyZW5gIHdhcyBjaGVja2VkLlxuICAgICAgLyogZXNsaW50LWRpc2FibGUgKi9cbiAgICAgIF9yZWFjdDJbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgIF9ET01XcmFwMltcImRlZmF1bHRcIl0sXG4gICAgICAgIF9leHRlbmRzKHsgc3R5bGU6IHByb3BzLnN0eWxlLFxuICAgICAgICAgIHRhZzogJ3VsJyxcbiAgICAgICAgICBoaWRkZW5DbGFzc05hbWU6IHByb3BzLnByZWZpeENscyArICctaGlkZGVuJyxcbiAgICAgICAgICB2aXNpYmxlOiBwcm9wcy52aXNpYmxlXG4gICAgICAgIH0sIGRvbVByb3BzKSxcbiAgICAgICAgX3JlYWN0MltcImRlZmF1bHRcIl0uQ2hpbGRyZW4ubWFwKHByb3BzLmNoaWxkcmVuLCB0aGlzLnJlbmRlck1lbnVJdGVtKVxuICAgICAgKVxuICAgICAgLyplc2xpbnQtZW5hYmxlICovXG5cbiAgICApO1xuICB9LFxuICBzdGVwOiBmdW5jdGlvbiBzdGVwKGRpcmVjdGlvbikge1xuICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuZ2V0RmxhdEluc3RhbmNlQXJyYXkoKTtcbiAgICB2YXIgYWN0aXZlS2V5ID0gdGhpcy5zdGF0ZS5hY3RpdmVLZXk7XG4gICAgdmFyIGxlbiA9IGNoaWxkcmVuLmxlbmd0aDtcbiAgICBpZiAoIWxlbikge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmIChkaXJlY3Rpb24gPCAwKSB7XG4gICAgICBjaGlsZHJlbiA9IGNoaWxkcmVuLmNvbmNhdCgpLnJldmVyc2UoKTtcbiAgICB9XG4gICAgLy8gZmluZCBjdXJyZW50IGFjdGl2ZUluZGV4XG4gICAgdmFyIGFjdGl2ZUluZGV4ID0gLTE7XG4gICAgY2hpbGRyZW4uZXZlcnkoZnVuY3Rpb24gKGMsIGNpKSB7XG4gICAgICBpZiAoYyAmJiBjLnByb3BzLmV2ZW50S2V5ID09PSBhY3RpdmVLZXkpIHtcbiAgICAgICAgYWN0aXZlSW5kZXggPSBjaTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSk7XG4gICAgaWYgKCF0aGlzLnByb3BzLmRlZmF1bHRBY3RpdmVGaXJzdCAmJiBhY3RpdmVJbmRleCAhPT0gLTEpIHtcbiAgICAgIGlmIChhbGxEaXNhYmxlZChjaGlsZHJlbi5zbGljZShhY3RpdmVJbmRleCwgbGVuIC0gMSkpKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgfVxuICAgIHZhciBzdGFydCA9IChhY3RpdmVJbmRleCArIDEpICUgbGVuO1xuICAgIHZhciBpID0gc3RhcnQ7XG4gICAgZm9yICg7Oykge1xuICAgICAgdmFyIGNoaWxkID0gY2hpbGRyZW5baV07XG4gICAgICBpZiAoIWNoaWxkIHx8IGNoaWxkLnByb3BzLmRpc2FibGVkKSB7XG4gICAgICAgIGkgPSAoaSArIDEgKyBsZW4pICUgbGVuO1xuICAgICAgICAvLyBjb21wbGV0ZSBhIGxvb3BcbiAgICAgICAgaWYgKGkgPT09IHN0YXJ0KSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBjaGlsZDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gTWVudU1peGluO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vdXhjb3JlLXRhYmxlL34vdXhjb3JlLXNlbGVjdDIvfi9yYy1zZWxlY3Qvfi9yYy1tZW51L2xpYi9NZW51TWl4aW4uanNcbiAqKiBtb2R1bGUgaWQgPSAyMDJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9yZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5cbnZhciBfcmVhY3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmVhY3QpO1xuXG52YXIgX29iamVjdEFzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcblxudmFyIF9vYmplY3RBc3NpZ24yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfb2JqZWN0QXNzaWduKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgXCJkZWZhdWx0XCI6IG9iaiB9OyB9XG5cbnZhciBET01XcmFwID0gX3JlYWN0MltcImRlZmF1bHRcIl0uY3JlYXRlQ2xhc3Moe1xuICBkaXNwbGF5TmFtZTogJ0RPTVdyYXAnLFxuXG4gIHByb3BUeXBlczoge1xuICAgIHRhZzogX3JlYWN0LlByb3BUeXBlcy5zdHJpbmdcbiAgfSxcblxuICBnZXREZWZhdWx0UHJvcHM6IGZ1bmN0aW9uIGdldERlZmF1bHRQcm9wcygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdGFnOiAnZGl2J1xuICAgIH07XG4gIH0sXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgIHZhciBwcm9wcyA9ICgwLCBfb2JqZWN0QXNzaWduMltcImRlZmF1bHRcIl0pKHt9LCB0aGlzLnByb3BzKTtcbiAgICBpZiAoIXByb3BzLnZpc2libGUpIHtcbiAgICAgIHByb3BzLmNsYXNzTmFtZSA9IHByb3BzLmNsYXNzTmFtZSB8fCAnJztcbiAgICAgIHByb3BzLmNsYXNzTmFtZSArPSAnICcgKyBwcm9wcy5oaWRkZW5DbGFzc05hbWU7XG4gICAgfVxuICAgIHZhciBUYWcgPSBwcm9wcy50YWc7XG4gICAgcmV0dXJuIF9yZWFjdDJbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoVGFnLCBwcm9wcyk7XG4gIH1cbn0pO1xuXG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IERPTVdyYXA7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi91eGNvcmUtdGFibGUvfi91eGNvcmUtc2VsZWN0Mi9+L3JjLXNlbGVjdC9+L3JjLW1lbnUvbGliL0RPTVdyYXAuanNcbiAqKiBtb2R1bGUgaWQgPSAyMDdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcblxudmFyIF9TdWJQb3B1cE1lbnUgPSByZXF1aXJlKCcuL1N1YlBvcHVwTWVudScpO1xuXG52YXIgX1N1YlBvcHVwTWVudTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9TdWJQb3B1cE1lbnUpO1xuXG52YXIgX3JlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxudmFyIF9yZWFjdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yZWFjdCk7XG5cbnZhciBfcmNVdGlsID0gcmVxdWlyZSgncmMtdXRpbCcpO1xuXG52YXIgX2NsYXNzbmFtZXMgPSByZXF1aXJlKCdjbGFzc25hbWVzJyk7XG5cbnZhciBfY2xhc3NuYW1lczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jbGFzc25hbWVzKTtcblxudmFyIF91dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IFwiZGVmYXVsdFwiOiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxuXG4vKiBlc2xpbnQgcmVhY3Qvbm8taXMtbW91bnRlZDowICovXG5cbnZhciBTdWJNZW51ID0gX3JlYWN0MltcImRlZmF1bHRcIl0uY3JlYXRlQ2xhc3Moe1xuICBkaXNwbGF5TmFtZTogJ1N1Yk1lbnUnLFxuXG4gIHByb3BUeXBlczoge1xuICAgIHBhcmVudE1lbnU6IF9yZWFjdC5Qcm9wVHlwZXMub2JqZWN0LFxuICAgIHRpdGxlOiBfcmVhY3QuUHJvcFR5cGVzLm5vZGUsXG4gICAgb25DbGljazogX3JlYWN0LlByb3BUeXBlcy5mdW5jLFxuICAgIG9uT3BlbkNoYW5nZTogX3JlYWN0LlByb3BUeXBlcy5mdW5jLFxuICAgIHJvb3RQcmVmaXhDbHM6IF9yZWFjdC5Qcm9wVHlwZXMuc3RyaW5nLFxuICAgIGV2ZW50S2V5OiBfcmVhY3QuUHJvcFR5cGVzLnN0cmluZyxcbiAgICBtdWx0aXBsZTogX3JlYWN0LlByb3BUeXBlcy5ib29sLFxuICAgIGFjdGl2ZTogX3JlYWN0LlByb3BUeXBlcy5ib29sLFxuICAgIG9wZW46IF9yZWFjdC5Qcm9wVHlwZXMuYm9vbCxcbiAgICBvblNlbGVjdDogX3JlYWN0LlByb3BUeXBlcy5mdW5jLFxuICAgIGNsb3NlU3ViTWVudU9uTW91c2VMZWF2ZTogX3JlYWN0LlByb3BUeXBlcy5ib29sLFxuICAgIG9wZW5TdWJNZW51T25Nb3VzZUVudGVyOiBfcmVhY3QuUHJvcFR5cGVzLmJvb2wsXG4gICAgb25EZXNlbGVjdDogX3JlYWN0LlByb3BUeXBlcy5mdW5jLFxuICAgIG9uRGVzdHJveTogX3JlYWN0LlByb3BUeXBlcy5mdW5jLFxuICAgIG9uSXRlbUhvdmVyOiBfcmVhY3QuUHJvcFR5cGVzLmZ1bmMsXG4gICAgb25Nb3VzZUVudGVyOiBfcmVhY3QuUHJvcFR5cGVzLmZ1bmMsXG4gICAgb25Nb3VzZUxlYXZlOiBfcmVhY3QuUHJvcFR5cGVzLmZ1bmMsXG4gICAgb25UaXRsZU1vdXNlRW50ZXI6IF9yZWFjdC5Qcm9wVHlwZXMuZnVuYyxcbiAgICBvblRpdGxlTW91c2VMZWF2ZTogX3JlYWN0LlByb3BUeXBlcy5mdW5jLFxuICAgIG9uVGl0bGVDbGljazogX3JlYWN0LlByb3BUeXBlcy5mdW5jXG4gIH0sXG5cbiAgbWl4aW5zOiBbcmVxdWlyZSgnLi9TdWJNZW51U3RhdGVNaXhpbicpXSxcblxuICBnZXREZWZhdWx0UHJvcHM6IGZ1bmN0aW9uIGdldERlZmF1bHRQcm9wcygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgb25Nb3VzZUVudGVyOiBfdXRpbC5ub29wLFxuICAgICAgb25Nb3VzZUxlYXZlOiBfdXRpbC5ub29wLFxuICAgICAgb25UaXRsZU1vdXNlRW50ZXI6IF91dGlsLm5vb3AsXG4gICAgICBvblRpdGxlTW91c2VMZWF2ZTogX3V0aWwubm9vcCxcbiAgICAgIG9uVGl0bGVDbGljazogX3V0aWwubm9vcCxcbiAgICAgIHRpdGxlOiAnJ1xuICAgIH07XG4gIH0sXG4gIGdldEluaXRpYWxTdGF0ZTogZnVuY3Rpb24gZ2V0SW5pdGlhbFN0YXRlKCkge1xuICAgIHRoaXMuaXNTdWJNZW51ID0gMTtcbiAgICByZXR1cm4ge1xuICAgICAgZGVmYXVsdEFjdGl2ZUZpcnN0OiBmYWxzZVxuICAgIH07XG4gIH0sXG4gIGNvbXBvbmVudFdpbGxVbm1vdW50OiBmdW5jdGlvbiBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICB2YXIgcHJvcHMgPSB0aGlzLnByb3BzO1xuICAgIGlmIChwcm9wcy5vbkRlc3Ryb3kpIHtcbiAgICAgIHByb3BzLm9uRGVzdHJveShwcm9wcy5ldmVudEtleSk7XG4gICAgfVxuICAgIGlmIChwcm9wcy5wYXJlbnRNZW51LnN1Yk1lbnVJbnN0YW5jZSA9PT0gdGhpcykge1xuICAgICAgdGhpcy5jbGVhclN1Yk1lbnVUaW1lcnMoKTtcbiAgICB9XG4gIH0sXG4gIG9uRGVzdHJveTogZnVuY3Rpb24gb25EZXN0cm95KGtleSkge1xuICAgIHRoaXMucHJvcHMub25EZXN0cm95KGtleSk7XG4gIH0sXG4gIG9uS2V5RG93bjogZnVuY3Rpb24gb25LZXlEb3duKGUpIHtcbiAgICB2YXIga2V5Q29kZSA9IGUua2V5Q29kZTtcbiAgICB2YXIgbWVudSA9IHRoaXMubWVudUluc3RhbmNlO1xuXG4gICAgaWYgKGtleUNvZGUgPT09IF9yY1V0aWwuS2V5Q29kZS5FTlRFUikge1xuICAgICAgdGhpcy5vblRpdGxlQ2xpY2soZSk7XG4gICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgZGVmYXVsdEFjdGl2ZUZpcnN0OiB0cnVlXG4gICAgICB9KTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmIChrZXlDb2RlID09PSBfcmNVdGlsLktleUNvZGUuUklHSFQpIHtcbiAgICAgIGlmICh0aGlzLnByb3BzLm9wZW4pIHtcbiAgICAgICAgbWVudS5vbktleURvd24oZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnRyaWdnZXJPcGVuQ2hhbmdlKHRydWUpO1xuICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICBkZWZhdWx0QWN0aXZlRmlyc3Q6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKGtleUNvZGUgPT09IF9yY1V0aWwuS2V5Q29kZS5MRUZUKSB7XG4gICAgICB2YXIgaGFuZGxlZCA9IHZvaWQgMDtcbiAgICAgIGlmICh0aGlzLnByb3BzLm9wZW4pIHtcbiAgICAgICAgaGFuZGxlZCA9IG1lbnUub25LZXlEb3duKGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIGlmICghaGFuZGxlZCkge1xuICAgICAgICB0aGlzLnRyaWdnZXJPcGVuQ2hhbmdlKGZhbHNlKTtcbiAgICAgICAgaGFuZGxlZCA9IHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gaGFuZGxlZDtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5wcm9wcy5vcGVuICYmIChrZXlDb2RlID09PSBfcmNVdGlsLktleUNvZGUuVVAgfHwga2V5Q29kZSA9PT0gX3JjVXRpbC5LZXlDb2RlLkRPV04pKSB7XG4gICAgICByZXR1cm4gbWVudS5vbktleURvd24oZSk7XG4gICAgfVxuICB9LFxuICBvbk9wZW5DaGFuZ2U6IGZ1bmN0aW9uIG9uT3BlbkNoYW5nZShlKSB7XG4gICAgdGhpcy5wcm9wcy5vbk9wZW5DaGFuZ2UodGhpcy5hZGRLZXlQYXRoKGUpKTtcbiAgfSxcbiAgb25Nb3VzZUVudGVyOiBmdW5jdGlvbiBvbk1vdXNlRW50ZXIoZSkge1xuICAgIHZhciBwcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgdGhpcy5jbGVhclN1Yk1lbnVMZWF2ZVRpbWVyKHByb3BzLnBhcmVudE1lbnUuc3ViTWVudUluc3RhbmNlICE9PSB0aGlzKTtcbiAgICBwcm9wcy5vbk1vdXNlRW50ZXIoe1xuICAgICAga2V5OiBwcm9wcy5ldmVudEtleSxcbiAgICAgIGRvbUV2ZW50OiBlXG4gICAgfSk7XG4gIH0sXG4gIG9uVGl0bGVNb3VzZUVudGVyOiBmdW5jdGlvbiBvblRpdGxlTW91c2VFbnRlcihlKSB7XG4gICAgdmFyIHByb3BzID0gdGhpcy5wcm9wcztcbiAgICB2YXIgcGFyZW50TWVudSA9IHByb3BzLnBhcmVudE1lbnU7XG4gICAgdGhpcy5jbGVhclN1Yk1lbnVUaXRsZUxlYXZlVGltZXIocGFyZW50TWVudS5zdWJNZW51SW5zdGFuY2UgIT09IHRoaXMpO1xuICAgIGlmIChwYXJlbnRNZW51Lm1lbnVJdGVtSW5zdGFuY2UpIHtcbiAgICAgIHBhcmVudE1lbnUubWVudUl0ZW1JbnN0YW5jZS5jbGVhck1lbnVJdGVtTW91c2VMZWF2ZVRpbWVyKHRydWUpO1xuICAgIH1cbiAgICBwcm9wcy5vbkl0ZW1Ib3Zlcih7XG4gICAgICBrZXk6IHByb3BzLmV2ZW50S2V5LFxuICAgICAgaXRlbTogdGhpcyxcbiAgICAgIGhvdmVyOiB0cnVlLFxuICAgICAgdHJpZ2dlcjogJ21vdXNlZW50ZXInXG4gICAgfSk7XG4gICAgaWYgKHByb3BzLm9wZW5TdWJNZW51T25Nb3VzZUVudGVyKSB7XG4gICAgICB0aGlzLnRyaWdnZXJPcGVuQ2hhbmdlKHRydWUpO1xuICAgIH1cbiAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgIGRlZmF1bHRBY3RpdmVGaXJzdDogZmFsc2VcbiAgICB9KTtcbiAgICBwcm9wcy5vblRpdGxlTW91c2VFbnRlcih7XG4gICAgICBrZXk6IHByb3BzLmV2ZW50S2V5LFxuICAgICAgZG9tRXZlbnQ6IGVcbiAgICB9KTtcbiAgfSxcbiAgb25UaXRsZU1vdXNlTGVhdmU6IGZ1bmN0aW9uIG9uVGl0bGVNb3VzZUxlYXZlKGUpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgdmFyIHByb3BzID0gdGhpcy5wcm9wcztcblxuICAgIHZhciBwYXJlbnRNZW51ID0gcHJvcHMucGFyZW50TWVudTtcbiAgICBwYXJlbnRNZW51LnN1Yk1lbnVJbnN0YW5jZSA9IHRoaXM7XG4gICAgcGFyZW50TWVudS5zdWJNZW51VGl0bGVMZWF2ZUZuID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGV2ZW50S2V5ID0gcHJvcHMuZXZlbnRLZXk7XG4gICAgICBpZiAoX3RoaXMuaXNNb3VudGVkKCkpIHtcbiAgICAgICAgLy8gbGVhdmUgd2hvbGUgc3ViIHRyZWVcbiAgICAgICAgLy8gc3RpbGwgYWN0aXZlXG4gICAgICAgIGlmIChwcm9wcy5tb2RlID09PSAnaW5saW5lJyAmJiBwcm9wcy5hY3RpdmUpIHtcbiAgICAgICAgICBwcm9wcy5vbkl0ZW1Ib3Zlcih7XG4gICAgICAgICAgICBrZXk6IGV2ZW50S2V5LFxuICAgICAgICAgICAgaXRlbTogX3RoaXMsXG4gICAgICAgICAgICBob3ZlcjogZmFsc2UsXG4gICAgICAgICAgICB0cmlnZ2VyOiAnbW91c2VsZWF2ZSdcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBwcm9wcy5vblRpdGxlTW91c2VMZWF2ZSh7XG4gICAgICAgICAga2V5OiBwcm9wcy5ldmVudEtleSxcbiAgICAgICAgICBkb21FdmVudDogZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHBhcmVudE1lbnUuc3ViTWVudVRpdGxlTGVhdmVUaW1lciA9IHNldFRpbWVvdXQocGFyZW50TWVudS5zdWJNZW51VGl0bGVMZWF2ZUZuLCAxMDApO1xuICB9LFxuICBvbk1vdXNlTGVhdmU6IGZ1bmN0aW9uIG9uTW91c2VMZWF2ZShlKSB7XG4gICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICB2YXIgcHJvcHMgPSB0aGlzLnByb3BzO1xuXG4gICAgdmFyIHBhcmVudE1lbnUgPSBwcm9wcy5wYXJlbnRNZW51O1xuICAgIHBhcmVudE1lbnUuc3ViTWVudUluc3RhbmNlID0gdGhpcztcbiAgICBwYXJlbnRNZW51LnN1Yk1lbnVMZWF2ZUZuID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGV2ZW50S2V5ID0gcHJvcHMuZXZlbnRLZXk7XG4gICAgICBpZiAoX3RoaXMyLmlzTW91bnRlZCgpKSB7XG4gICAgICAgIC8vIGxlYXZlIHdob2xlIHN1YiB0cmVlXG4gICAgICAgIC8vIHN0aWxsIGFjdGl2ZVxuICAgICAgICBpZiAocHJvcHMubW9kZSAhPT0gJ2lubGluZScpIHtcbiAgICAgICAgICBpZiAocHJvcHMuYWN0aXZlKSB7XG4gICAgICAgICAgICBwcm9wcy5vbkl0ZW1Ib3Zlcih7XG4gICAgICAgICAgICAgIGtleTogZXZlbnRLZXksXG4gICAgICAgICAgICAgIGl0ZW06IF90aGlzMixcbiAgICAgICAgICAgICAgaG92ZXI6IGZhbHNlLFxuICAgICAgICAgICAgICB0cmlnZ2VyOiAnbW91c2VsZWF2ZSdcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocHJvcHMub3Blbikge1xuICAgICAgICAgICAgaWYgKHByb3BzLmNsb3NlU3ViTWVudU9uTW91c2VMZWF2ZSkge1xuICAgICAgICAgICAgICBfdGhpczIudHJpZ2dlck9wZW5DaGFuZ2UoZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyB0cmlnZ2VyIG1vdXNlbGVhdmVcbiAgICAgICAgcHJvcHMub25Nb3VzZUxlYXZlKHtcbiAgICAgICAgICBrZXk6IGV2ZW50S2V5LFxuICAgICAgICAgIGRvbUV2ZW50OiBlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG4gICAgLy8gcHJldmVudCBwb3B1cCBtZW51IGFuZCBzdWJtZW51IGdhcFxuICAgIHBhcmVudE1lbnUuc3ViTWVudUxlYXZlVGltZXIgPSBzZXRUaW1lb3V0KHBhcmVudE1lbnUuc3ViTWVudUxlYXZlRm4sIDEwMCk7XG4gIH0sXG4gIG9uVGl0bGVDbGljazogZnVuY3Rpb24gb25UaXRsZUNsaWNrKGUpIHtcbiAgICB2YXIgcHJvcHMgPSB0aGlzLnByb3BzO1xuXG4gICAgcHJvcHMub25UaXRsZUNsaWNrKHtcbiAgICAgIGtleTogcHJvcHMuZXZlbnRLZXksXG4gICAgICBkb21FdmVudDogZVxuICAgIH0pO1xuICAgIGlmIChwcm9wcy5vcGVuU3ViTWVudU9uTW91c2VFbnRlcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnRyaWdnZXJPcGVuQ2hhbmdlKCFwcm9wcy5vcGVuLCAnY2xpY2snKTtcbiAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgIGRlZmF1bHRBY3RpdmVGaXJzdDogZmFsc2VcbiAgICB9KTtcbiAgfSxcbiAgb25TdWJNZW51Q2xpY2s6IGZ1bmN0aW9uIG9uU3ViTWVudUNsaWNrKGluZm8pIHtcbiAgICB0aGlzLnByb3BzLm9uQ2xpY2sodGhpcy5hZGRLZXlQYXRoKGluZm8pKTtcbiAgfSxcbiAgb25TZWxlY3Q6IGZ1bmN0aW9uIG9uU2VsZWN0KGluZm8pIHtcbiAgICB0aGlzLnByb3BzLm9uU2VsZWN0KGluZm8pO1xuICB9LFxuICBvbkRlc2VsZWN0OiBmdW5jdGlvbiBvbkRlc2VsZWN0KGluZm8pIHtcbiAgICB0aGlzLnByb3BzLm9uRGVzZWxlY3QoaW5mbyk7XG4gIH0sXG4gIGdldFByZWZpeENsczogZnVuY3Rpb24gZ2V0UHJlZml4Q2xzKCkge1xuICAgIHJldHVybiB0aGlzLnByb3BzLnJvb3RQcmVmaXhDbHMgKyAnLXN1Ym1lbnUnO1xuICB9LFxuICBnZXRBY3RpdmVDbGFzc05hbWU6IGZ1bmN0aW9uIGdldEFjdGl2ZUNsYXNzTmFtZSgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRQcmVmaXhDbHMoKSArICctYWN0aXZlJztcbiAgfSxcbiAgZ2V0RGlzYWJsZWRDbGFzc05hbWU6IGZ1bmN0aW9uIGdldERpc2FibGVkQ2xhc3NOYW1lKCkge1xuICAgIHJldHVybiB0aGlzLmdldFByZWZpeENscygpICsgJy1kaXNhYmxlZCc7XG4gIH0sXG4gIGdldE9wZW5DbGFzc05hbWU6IGZ1bmN0aW9uIGdldE9wZW5DbGFzc05hbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMucHJvcHMucm9vdFByZWZpeENscyArICctc3VibWVudS1vcGVuJztcbiAgfSxcbiAgc2F2ZU1lbnVJbnN0YW5jZTogZnVuY3Rpb24gc2F2ZU1lbnVJbnN0YW5jZShjKSB7XG4gICAgdGhpcy5tZW51SW5zdGFuY2UgPSBjO1xuICB9LFxuICBhZGRLZXlQYXRoOiBmdW5jdGlvbiBhZGRLZXlQYXRoKGluZm8pIHtcbiAgICByZXR1cm4gX2V4dGVuZHMoe30sIGluZm8sIHtcbiAgICAgIGtleVBhdGg6IChpbmZvLmtleVBhdGggfHwgW10pLmNvbmNhdCh0aGlzLnByb3BzLmV2ZW50S2V5KVxuICAgIH0pO1xuICB9LFxuICB0cmlnZ2VyT3BlbkNoYW5nZTogZnVuY3Rpb24gdHJpZ2dlck9wZW5DaGFuZ2Uob3BlbiwgdHlwZSkge1xuICAgIHZhciBrZXkgPSB0aGlzLnByb3BzLmV2ZW50S2V5O1xuICAgIHRoaXMub25PcGVuQ2hhbmdlKHtcbiAgICAgIGtleToga2V5LFxuICAgICAgaXRlbTogdGhpcyxcbiAgICAgIHRyaWdnZXI6IHR5cGUsXG4gICAgICBvcGVuOiBvcGVuXG4gICAgfSk7XG4gIH0sXG4gIGNsZWFyU3ViTWVudVRpbWVyczogZnVuY3Rpb24gY2xlYXJTdWJNZW51VGltZXJzKGNhbGxGbikge1xuICAgIHRoaXMuY2xlYXJTdWJNZW51TGVhdmVUaW1lcihjYWxsRm4pO1xuICAgIHRoaXMuY2xlYXJTdWJNZW51VGl0bGVMZWF2ZVRpbWVyKGNhbGxGbik7XG4gIH0sXG4gIGNsZWFyU3ViTWVudVRpdGxlTGVhdmVUaW1lcjogZnVuY3Rpb24gY2xlYXJTdWJNZW51VGl0bGVMZWF2ZVRpbWVyKGNhbGxGbikge1xuICAgIHZhciBwYXJlbnRNZW51ID0gdGhpcy5wcm9wcy5wYXJlbnRNZW51O1xuICAgIGlmIChwYXJlbnRNZW51LnN1Yk1lbnVUaXRsZUxlYXZlVGltZXIpIHtcbiAgICAgIGNsZWFyVGltZW91dChwYXJlbnRNZW51LnN1Yk1lbnVUaXRsZUxlYXZlVGltZXIpO1xuICAgICAgcGFyZW50TWVudS5zdWJNZW51VGl0bGVMZWF2ZVRpbWVyID0gbnVsbDtcbiAgICAgIGlmIChjYWxsRm4gJiYgcGFyZW50TWVudS5zdWJNZW51VGl0bGVMZWF2ZUZuKSB7XG4gICAgICAgIHBhcmVudE1lbnUuc3ViTWVudVRpdGxlTGVhdmVGbigpO1xuICAgICAgfVxuICAgICAgcGFyZW50TWVudS5zdWJNZW51VGl0bGVMZWF2ZUZuID0gbnVsbDtcbiAgICB9XG4gIH0sXG4gIGNsZWFyU3ViTWVudUxlYXZlVGltZXI6IGZ1bmN0aW9uIGNsZWFyU3ViTWVudUxlYXZlVGltZXIoY2FsbEZuKSB7XG4gICAgdmFyIHBhcmVudE1lbnUgPSB0aGlzLnByb3BzLnBhcmVudE1lbnU7XG4gICAgaWYgKHBhcmVudE1lbnUuc3ViTWVudUxlYXZlVGltZXIpIHtcbiAgICAgIGNsZWFyVGltZW91dChwYXJlbnRNZW51LnN1Yk1lbnVMZWF2ZVRpbWVyKTtcbiAgICAgIHBhcmVudE1lbnUuc3ViTWVudUxlYXZlVGltZXIgPSBudWxsO1xuICAgICAgaWYgKGNhbGxGbiAmJiBwYXJlbnRNZW51LnN1Yk1lbnVMZWF2ZUZuKSB7XG4gICAgICAgIHBhcmVudE1lbnUuc3ViTWVudUxlYXZlRm4oKTtcbiAgICAgIH1cbiAgICAgIHBhcmVudE1lbnUuc3ViTWVudUxlYXZlRm4gPSBudWxsO1xuICAgIH1cbiAgfSxcbiAgcmVuZGVyQ2hpbGRyZW46IGZ1bmN0aW9uIHJlbmRlckNoaWxkcmVuKGNoaWxkcmVuKSB7XG4gICAgdmFyIHByb3BzID0gdGhpcy5wcm9wcztcbiAgICB2YXIgYmFzZVByb3BzID0ge1xuICAgICAgbW9kZTogcHJvcHMubW9kZSA9PT0gJ2hvcml6b250YWwnID8gJ3ZlcnRpY2FsJyA6IHByb3BzLm1vZGUsXG4gICAgICB2aXNpYmxlOiBwcm9wcy5vcGVuLFxuICAgICAgbGV2ZWw6IHByb3BzLmxldmVsICsgMSxcbiAgICAgIGlubGluZUluZGVudDogcHJvcHMuaW5saW5lSW5kZW50LFxuICAgICAgZm9jdXNhYmxlOiBmYWxzZSxcbiAgICAgIG9uQ2xpY2s6IHRoaXMub25TdWJNZW51Q2xpY2ssXG4gICAgICBvblNlbGVjdDogdGhpcy5vblNlbGVjdCxcbiAgICAgIG9uRGVzZWxlY3Q6IHRoaXMub25EZXNlbGVjdCxcbiAgICAgIG9uRGVzdHJveTogdGhpcy5vbkRlc3Ryb3ksXG4gICAgICBzZWxlY3RlZEtleXM6IHByb3BzLnNlbGVjdGVkS2V5cyxcbiAgICAgIGV2ZW50S2V5OiBwcm9wcy5ldmVudEtleSArICctbWVudS0nLFxuICAgICAgb3BlbktleXM6IHByb3BzLm9wZW5LZXlzLFxuICAgICAgb3BlblRyYW5zaXRpb25OYW1lOiBwcm9wcy5vcGVuVHJhbnNpdGlvbk5hbWUsXG4gICAgICBvcGVuQW5pbWF0aW9uOiBwcm9wcy5vcGVuQW5pbWF0aW9uLFxuICAgICAgb25PcGVuQ2hhbmdlOiB0aGlzLm9uT3BlbkNoYW5nZSxcbiAgICAgIGNsb3NlU3ViTWVudU9uTW91c2VMZWF2ZTogcHJvcHMuY2xvc2VTdWJNZW51T25Nb3VzZUxlYXZlLFxuICAgICAgZGVmYXVsdEFjdGl2ZUZpcnN0OiB0aGlzLnN0YXRlLmRlZmF1bHRBY3RpdmVGaXJzdCxcbiAgICAgIG11bHRpcGxlOiBwcm9wcy5tdWx0aXBsZSxcbiAgICAgIHByZWZpeENsczogcHJvcHMucm9vdFByZWZpeENscyxcbiAgICAgIGlkOiB0aGlzLl9tZW51SWQsXG4gICAgICByZWY6IHRoaXMuc2F2ZU1lbnVJbnN0YW5jZVxuICAgIH07XG4gICAgcmV0dXJuIF9yZWFjdDJbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXG4gICAgICBfU3ViUG9wdXBNZW51MltcImRlZmF1bHRcIl0sXG4gICAgICBiYXNlUHJvcHMsXG4gICAgICBjaGlsZHJlblxuICAgICk7XG4gIH0sXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgIHZhciBfY2xhc3NlcztcblxuICAgIHRoaXMuaGF2ZU9wZW4gPSB0aGlzLmhhdmVPcGVuIHx8IHRoaXMucHJvcHMub3BlbjtcbiAgICB2YXIgcHJvcHMgPSB0aGlzLnByb3BzO1xuICAgIHZhciBwcmVmaXhDbHMgPSB0aGlzLmdldFByZWZpeENscygpO1xuICAgIHZhciBjbGFzc2VzID0gKF9jbGFzc2VzID0ge30sIF9kZWZpbmVQcm9wZXJ0eShfY2xhc3NlcywgcHJvcHMuY2xhc3NOYW1lLCAhIXByb3BzLmNsYXNzTmFtZSksIF9kZWZpbmVQcm9wZXJ0eShfY2xhc3NlcywgcHJlZml4Q2xzICsgJy0nICsgcHJvcHMubW9kZSwgMSksIF9jbGFzc2VzKTtcblxuICAgIGNsYXNzZXNbdGhpcy5nZXRPcGVuQ2xhc3NOYW1lKCldID0gdGhpcy5wcm9wcy5vcGVuO1xuICAgIGNsYXNzZXNbdGhpcy5nZXRBY3RpdmVDbGFzc05hbWUoKV0gPSBwcm9wcy5hY3RpdmU7XG4gICAgY2xhc3Nlc1t0aGlzLmdldERpc2FibGVkQ2xhc3NOYW1lKCldID0gcHJvcHMuZGlzYWJsZWQ7XG4gICAgdGhpcy5fbWVudUlkID0gdGhpcy5fbWVudUlkIHx8ICgwLCBfcmNVdGlsLmd1aWQpKCk7XG4gICAgY2xhc3Nlc1twcmVmaXhDbHNdID0gdHJ1ZTtcbiAgICBjbGFzc2VzW3ByZWZpeENscyArICctJyArIHByb3BzLm1vZGVdID0gMTtcbiAgICB2YXIgdGl0bGVDbGlja0V2ZW50cyA9IHt9O1xuICAgIHZhciBtb3VzZUV2ZW50cyA9IHt9O1xuICAgIHZhciB0aXRsZU1vdXNlRXZlbnRzID0ge307XG4gICAgaWYgKCFwcm9wcy5kaXNhYmxlZCkge1xuICAgICAgdGl0bGVDbGlja0V2ZW50cyA9IHtcbiAgICAgICAgb25DbGljazogdGhpcy5vblRpdGxlQ2xpY2tcbiAgICAgIH07XG4gICAgICBtb3VzZUV2ZW50cyA9IHtcbiAgICAgICAgb25Nb3VzZUxlYXZlOiB0aGlzLm9uTW91c2VMZWF2ZSxcbiAgICAgICAgb25Nb3VzZUVudGVyOiB0aGlzLm9uTW91c2VFbnRlclxuICAgICAgfTtcbiAgICAgIC8vIG9ubHkgd29ya3MgaW4gdGl0bGUsIG5vdCBvdXRlciBsaVxuICAgICAgdGl0bGVNb3VzZUV2ZW50cyA9IHtcbiAgICAgICAgb25Nb3VzZUVudGVyOiB0aGlzLm9uVGl0bGVNb3VzZUVudGVyLFxuICAgICAgICBvbk1vdXNlTGVhdmU6IHRoaXMub25UaXRsZU1vdXNlTGVhdmVcbiAgICAgIH07XG4gICAgfVxuICAgIHZhciBzdHlsZSA9IHt9O1xuICAgIGlmIChwcm9wcy5tb2RlID09PSAnaW5saW5lJykge1xuICAgICAgc3R5bGUucGFkZGluZ0xlZnQgPSBwcm9wcy5pbmxpbmVJbmRlbnQgKiBwcm9wcy5sZXZlbDtcbiAgICB9XG4gICAgcmV0dXJuIF9yZWFjdDJbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXG4gICAgICAnbGknLFxuICAgICAgX2V4dGVuZHMoeyBjbGFzc05hbWU6ICgwLCBfY2xhc3NuYW1lczJbXCJkZWZhdWx0XCJdKShjbGFzc2VzKSB9LCBtb3VzZUV2ZW50cyksXG4gICAgICBfcmVhY3QyW1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFxuICAgICAgICAnZGl2JyxcbiAgICAgICAgX2V4dGVuZHMoe1xuICAgICAgICAgIHN0eWxlOiBzdHlsZSxcbiAgICAgICAgICBjbGFzc05hbWU6IHByZWZpeENscyArICctdGl0bGUnXG4gICAgICAgIH0sIHRpdGxlTW91c2VFdmVudHMsIHRpdGxlQ2xpY2tFdmVudHMsIHtcbiAgICAgICAgICAnYXJpYS1vcGVuJzogcHJvcHMub3BlbixcbiAgICAgICAgICAnYXJpYS1vd25zJzogdGhpcy5fbWVudUlkLFxuICAgICAgICAgICdhcmlhLWhhc3BvcHVwJzogJ3RydWUnXG4gICAgICAgIH0pLFxuICAgICAgICBwcm9wcy50aXRsZVxuICAgICAgKSxcbiAgICAgIHRoaXMucmVuZGVyQ2hpbGRyZW4ocHJvcHMuY2hpbGRyZW4pXG4gICAgKTtcbiAgfVxufSk7XG5cbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gU3ViTWVudTtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3V4Y29yZS10YWJsZS9+L3V4Y29yZS1zZWxlY3QyL34vcmMtc2VsZWN0L34vcmMtbWVudS9saWIvU3ViTWVudS5qc1xuICoqIG1vZHVsZSBpZCA9IDIwOFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG52YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblxudmFyIF9yZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5cbnZhciBfcmVhY3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmVhY3QpO1xuXG52YXIgX01lbnVNaXhpbiA9IHJlcXVpcmUoJy4vTWVudU1peGluJyk7XG5cbnZhciBfTWVudU1peGluMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX01lbnVNaXhpbik7XG5cbnZhciBfb2JqZWN0QXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xuXG52YXIgX29iamVjdEFzc2lnbjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9vYmplY3RBc3NpZ24pO1xuXG52YXIgX3V0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcblxudmFyIF9yY0FuaW1hdGUgPSByZXF1aXJlKCdyYy1hbmltYXRlJyk7XG5cbnZhciBfcmNBbmltYXRlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JjQW5pbWF0ZSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IFwiZGVmYXVsdFwiOiBvYmogfTsgfVxuXG52YXIgU3ViUG9wdXBNZW51ID0gX3JlYWN0MltcImRlZmF1bHRcIl0uY3JlYXRlQ2xhc3Moe1xuICBkaXNwbGF5TmFtZTogJ1N1YlBvcHVwTWVudScsXG5cbiAgcHJvcFR5cGVzOiB7XG4gICAgb25TZWxlY3Q6IF9yZWFjdC5Qcm9wVHlwZXMuZnVuYyxcbiAgICBvbkNsaWNrOiBfcmVhY3QuUHJvcFR5cGVzLmZ1bmMsXG4gICAgb25EZXNlbGVjdDogX3JlYWN0LlByb3BUeXBlcy5mdW5jLFxuICAgIG9uT3BlbkNoYW5nZTogX3JlYWN0LlByb3BUeXBlcy5mdW5jLFxuICAgIG9uRGVzdHJveTogX3JlYWN0LlByb3BUeXBlcy5mdW5jLFxuICAgIG9wZW5UcmFuc2l0aW9uTmFtZTogX3JlYWN0LlByb3BUeXBlcy5zdHJpbmcsXG4gICAgb3BlbkFuaW1hdGlvbjogX3JlYWN0LlByb3BUeXBlcy5vbmVPZlR5cGUoW19yZWFjdC5Qcm9wVHlwZXMuc3RyaW5nLCBfcmVhY3QuUHJvcFR5cGVzLm9iamVjdF0pLFxuICAgIG9wZW5LZXlzOiBfcmVhY3QuUHJvcFR5cGVzLmFycmF5T2YoX3JlYWN0LlByb3BUeXBlcy5zdHJpbmcpLFxuICAgIGNsb3NlU3ViTWVudU9uTW91c2VMZWF2ZTogX3JlYWN0LlByb3BUeXBlcy5ib29sLFxuICAgIHZpc2libGU6IF9yZWFjdC5Qcm9wVHlwZXMuYm9vbCxcbiAgICBjaGlsZHJlbjogX3JlYWN0LlByb3BUeXBlcy5hbnlcbiAgfSxcblxuICBtaXhpbnM6IFtfTWVudU1peGluMltcImRlZmF1bHRcIl1dLFxuXG4gIG9uRGVzZWxlY3Q6IGZ1bmN0aW9uIG9uRGVzZWxlY3Qoc2VsZWN0SW5mbykge1xuICAgIHRoaXMucHJvcHMub25EZXNlbGVjdChzZWxlY3RJbmZvKTtcbiAgfSxcbiAgb25TZWxlY3Q6IGZ1bmN0aW9uIG9uU2VsZWN0KHNlbGVjdEluZm8pIHtcbiAgICB0aGlzLnByb3BzLm9uU2VsZWN0KHNlbGVjdEluZm8pO1xuICB9LFxuICBvbkNsaWNrOiBmdW5jdGlvbiBvbkNsaWNrKGUpIHtcbiAgICB0aGlzLnByb3BzLm9uQ2xpY2soZSk7XG4gIH0sXG4gIG9uT3BlbkNoYW5nZTogZnVuY3Rpb24gb25PcGVuQ2hhbmdlKGUpIHtcbiAgICB0aGlzLnByb3BzLm9uT3BlbkNoYW5nZShlKTtcbiAgfSxcbiAgb25EZXN0cm95OiBmdW5jdGlvbiBvbkRlc3Ryb3koa2V5KSB7XG4gICAgdGhpcy5wcm9wcy5vbkRlc3Ryb3koa2V5KTtcbiAgfSxcbiAgb25JdGVtSG92ZXI6IGZ1bmN0aW9uIG9uSXRlbUhvdmVyKGUpIHtcbiAgICB0aGlzLm9uQ29tbW9uSXRlbUhvdmVyKGUpO1xuICB9LFxuICBnZXRPcGVuVHJhbnNpdGlvbk5hbWU6IGZ1bmN0aW9uIGdldE9wZW5UcmFuc2l0aW9uTmFtZSgpIHtcbiAgICByZXR1cm4gdGhpcy5wcm9wcy5vcGVuVHJhbnNpdGlvbk5hbWU7XG4gIH0sXG4gIHJlbmRlck1lbnVJdGVtOiBmdW5jdGlvbiByZW5kZXJNZW51SXRlbShjLCBpLCBzdWJJbmRleCkge1xuICAgIHZhciBwcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgdmFyIGtleSA9ICgwLCBfdXRpbC5nZXRLZXlGcm9tQ2hpbGRyZW5JbmRleCkoYywgcHJvcHMuZXZlbnRLZXksIGkpO1xuICAgIHZhciBleHRyYVByb3BzID0ge1xuICAgICAgb3BlbktleXM6IHByb3BzLm9wZW5LZXlzLFxuICAgICAgc2VsZWN0ZWRLZXlzOiBwcm9wcy5zZWxlY3RlZEtleXMsXG4gICAgICBvcGVuOiBwcm9wcy5vcGVuS2V5cy5pbmRleE9mKGtleSkgIT09IC0xLFxuICAgICAgc2VsZWN0ZWQ6IHByb3BzLnNlbGVjdGVkS2V5cy5pbmRleE9mKGtleSkgIT09IC0xLFxuICAgICAgb3BlblN1Yk1lbnVPbk1vdXNlRW50ZXI6IHRydWVcbiAgICB9O1xuICAgIHJldHVybiB0aGlzLnJlbmRlckNvbW1vbk1lbnVJdGVtKGMsIGksIHN1YkluZGV4LCBleHRyYVByb3BzKTtcbiAgfSxcbiAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgdmFyIHJlbmRlckZpcnN0ID0gdGhpcy5yZW5kZXJGaXJzdDtcbiAgICB0aGlzLnJlbmRlckZpcnN0ID0gMTtcbiAgICB0aGlzLmhhdmVPcGVuZWQgPSB0aGlzLmhhdmVPcGVuZWQgfHwgdGhpcy5wcm9wcy52aXNpYmxlO1xuICAgIGlmICghdGhpcy5oYXZlT3BlbmVkKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdmFyIHRyYW5zaXRpb25BcHBlYXIgPSB0cnVlO1xuICAgIGlmICghcmVuZGVyRmlyc3QgJiYgdGhpcy5wcm9wcy52aXNpYmxlKSB7XG4gICAgICB0cmFuc2l0aW9uQXBwZWFyID0gZmFsc2U7XG4gICAgfVxuICAgIHZhciBwcm9wcyA9ICgwLCBfb2JqZWN0QXNzaWduMltcImRlZmF1bHRcIl0pKHt9LCB0aGlzLnByb3BzKTtcbiAgICBwcm9wcy5jbGFzc05hbWUgKz0gJyAnICsgcHJvcHMucHJlZml4Q2xzICsgJy1zdWInO1xuICAgIHZhciBhbmltUHJvcHMgPSB7fTtcbiAgICBpZiAocHJvcHMub3BlblRyYW5zaXRpb25OYW1lKSB7XG4gICAgICBhbmltUHJvcHMudHJhbnNpdGlvbk5hbWUgPSBwcm9wcy5vcGVuVHJhbnNpdGlvbk5hbWU7XG4gICAgfSBlbHNlIGlmIChfdHlwZW9mKHByb3BzLm9wZW5BbmltYXRpb24pID09PSAnb2JqZWN0Jykge1xuICAgICAgYW5pbVByb3BzLmFuaW1hdGlvbiA9ICgwLCBfb2JqZWN0QXNzaWduMltcImRlZmF1bHRcIl0pKHt9LCBwcm9wcy5vcGVuQW5pbWF0aW9uKTtcbiAgICAgIGlmICghdHJhbnNpdGlvbkFwcGVhcikge1xuICAgICAgICBkZWxldGUgYW5pbVByb3BzLmFuaW1hdGlvbi5hcHBlYXI7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBfcmVhY3QyW1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFxuICAgICAgX3JjQW5pbWF0ZTJbXCJkZWZhdWx0XCJdLFxuICAgICAgX2V4dGVuZHMoe30sIGFuaW1Qcm9wcywge1xuICAgICAgICBzaG93UHJvcDogJ3Zpc2libGUnLFxuICAgICAgICBjb21wb25lbnQ6ICcnLFxuICAgICAgICB0cmFuc2l0aW9uQXBwZWFyOiB0cmFuc2l0aW9uQXBwZWFyXG4gICAgICB9KSxcbiAgICAgIHRoaXMucmVuZGVyUm9vdChwcm9wcylcbiAgICApO1xuICB9XG59KTtcblxuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBTdWJQb3B1cE1lbnU7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi91eGNvcmUtdGFibGUvfi91eGNvcmUtc2VsZWN0Mi9+L3JjLXNlbGVjdC9+L3JjLW1lbnUvbGliL1N1YlBvcHVwTWVudS5qc1xuICoqIG1vZHVsZSBpZCA9IDIwOVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX3JjVXRpbCA9IHJlcXVpcmUoJ3JjLXV0aWwnKTtcblxudmFyIF9yY1V0aWwyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmNVdGlsKTtcblxudmFyIF9yZWFjdERvbSA9IHJlcXVpcmUoJ3JlYWN0LWRvbScpO1xuXG52YXIgX3JlYWN0RG9tMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JlYWN0RG9tKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgXCJkZWZhdWx0XCI6IG9iaiB9OyB9XG5cbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0ge1xuICBjb21wb25lbnREaWRNb3VudDogZnVuY3Rpb24gY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgdGhpcy5jb21wb25lbnREaWRVcGRhdGUoKTtcbiAgfSxcbiAgY29tcG9uZW50RGlkVXBkYXRlOiBmdW5jdGlvbiBjb21wb25lbnREaWRVcGRhdGUoKSB7XG4gICAgaWYgKHRoaXMucHJvcHMubW9kZSAhPT0gJ2lubGluZScpIHtcbiAgICAgIGlmICh0aGlzLnByb3BzLm9wZW4pIHtcbiAgICAgICAgdGhpcy5iaW5kUm9vdENsb3NlSGFuZGxlcnMoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMudW5iaW5kUm9vdENsb3NlSGFuZGxlcnMoKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIGhhbmRsZURvY3VtZW50S2V5VXA6IGZ1bmN0aW9uIGhhbmRsZURvY3VtZW50S2V5VXAoZSkge1xuICAgIGlmIChlLmtleUNvZGUgPT09IF9yY1V0aWwuS2V5Q29kZS5FU0MpIHtcbiAgICAgIHRoaXMucHJvcHMub25JdGVtSG92ZXIoe1xuICAgICAgICBrZXk6IHRoaXMucHJvcHMuZXZlbnRLZXksXG4gICAgICAgIGl0ZW06IHRoaXMsXG4gICAgICAgIGhvdmVyOiBmYWxzZVxuICAgICAgfSk7XG4gICAgfVxuICB9LFxuICBoYW5kbGVEb2N1bWVudENsaWNrOiBmdW5jdGlvbiBoYW5kbGVEb2N1bWVudENsaWNrKGUpIHtcbiAgICAvLyBJZiB0aGUgY2xpY2sgb3JpZ2luYXRlZCBmcm9tIHdpdGhpbiB0aGlzIGNvbXBvbmVudFxuICAgIC8vIGRvbid0IGRvIGFueXRoaW5nLlxuICAgIGlmIChfcmNVdGlsMltcImRlZmF1bHRcIl0uRG9tLmNvbnRhaW5zKF9yZWFjdERvbTJbXCJkZWZhdWx0XCJdLmZpbmRET01Ob2RlKHRoaXMpLCBlLnRhcmdldCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHByb3BzID0gdGhpcy5wcm9wcztcbiAgICBwcm9wcy5vbkl0ZW1Ib3Zlcih7XG4gICAgICBob3ZlcjogZmFsc2UsXG4gICAgICBpdGVtOiB0aGlzLFxuICAgICAga2V5OiB0aGlzLnByb3BzLmV2ZW50S2V5XG4gICAgfSk7XG4gICAgdGhpcy50cmlnZ2VyT3BlbkNoYW5nZShmYWxzZSk7XG4gIH0sXG4gIGJpbmRSb290Q2xvc2VIYW5kbGVyczogZnVuY3Rpb24gYmluZFJvb3RDbG9zZUhhbmRsZXJzKCkge1xuICAgIGlmICghdGhpcy5fb25Eb2N1bWVudENsaWNrTGlzdGVuZXIpIHtcbiAgICAgIHRoaXMuX29uRG9jdW1lbnRDbGlja0xpc3RlbmVyID0gX3JjVXRpbDJbXCJkZWZhdWx0XCJdLkRvbS5hZGRFdmVudExpc3RlbmVyKGRvY3VtZW50LCAnY2xpY2snLCB0aGlzLmhhbmRsZURvY3VtZW50Q2xpY2spO1xuICAgICAgdGhpcy5fb25Eb2N1bWVudEtleXVwTGlzdGVuZXIgPSBfcmNVdGlsMltcImRlZmF1bHRcIl0uRG9tLmFkZEV2ZW50TGlzdGVuZXIoZG9jdW1lbnQsICdrZXl1cCcsIHRoaXMuaGFuZGxlRG9jdW1lbnRLZXlVcCk7XG4gICAgfVxuICB9LFxuICB1bmJpbmRSb290Q2xvc2VIYW5kbGVyczogZnVuY3Rpb24gdW5iaW5kUm9vdENsb3NlSGFuZGxlcnMoKSB7XG4gICAgaWYgKHRoaXMuX29uRG9jdW1lbnRDbGlja0xpc3RlbmVyKSB7XG4gICAgICB0aGlzLl9vbkRvY3VtZW50Q2xpY2tMaXN0ZW5lci5yZW1vdmUoKTtcbiAgICAgIHRoaXMuX29uRG9jdW1lbnRDbGlja0xpc3RlbmVyID0gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fb25Eb2N1bWVudEtleXVwTGlzdGVuZXIpIHtcbiAgICAgIHRoaXMuX29uRG9jdW1lbnRLZXl1cExpc3RlbmVyLnJlbW92ZSgpO1xuICAgICAgdGhpcy5fb25Eb2N1bWVudEtleXVwTGlzdGVuZXIgPSBudWxsO1xuICAgIH1cbiAgfSxcbiAgY29tcG9uZW50V2lsbFVubW91bnQ6IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgIHRoaXMudW5iaW5kUm9vdENsb3NlSGFuZGxlcnMoKTtcbiAgfVxufTtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3V4Y29yZS10YWJsZS9+L3V4Y29yZS1zZWxlY3QyL34vcmMtc2VsZWN0L34vcmMtbWVudS9saWIvU3ViTWVudVN0YXRlTWl4aW4uanNcbiAqKiBtb2R1bGUgaWQgPSAyMTBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcblxudmFyIF9yZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5cbnZhciBfcmVhY3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmVhY3QpO1xuXG52YXIgX3JjVXRpbCA9IHJlcXVpcmUoJ3JjLXV0aWwnKTtcblxudmFyIF9jbGFzc25hbWVzID0gcmVxdWlyZSgnY2xhc3NuYW1lcycpO1xuXG52YXIgX2NsYXNzbmFtZXMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY2xhc3NuYW1lcyk7XG5cbnZhciBfdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBcImRlZmF1bHRcIjogb2JqIH07IH1cblxuLyogZXNsaW50IHJlYWN0L25vLWlzLW1vdW50ZWQ6MCAqL1xuXG52YXIgTWVudUl0ZW0gPSBfcmVhY3QyW1wiZGVmYXVsdFwiXS5jcmVhdGVDbGFzcyh7XG4gIGRpc3BsYXlOYW1lOiAnTWVudUl0ZW0nLFxuXG4gIHByb3BUeXBlczoge1xuICAgIHJvb3RQcmVmaXhDbHM6IF9yZWFjdC5Qcm9wVHlwZXMuc3RyaW5nLFxuICAgIGV2ZW50S2V5OiBfcmVhY3QuUHJvcFR5cGVzLnN0cmluZyxcbiAgICBhY3RpdmU6IF9yZWFjdC5Qcm9wVHlwZXMuYm9vbCxcbiAgICBzZWxlY3RlZDogX3JlYWN0LlByb3BUeXBlcy5ib29sLFxuICAgIGRpc2FibGVkOiBfcmVhY3QuUHJvcFR5cGVzLmJvb2wsXG4gICAgdGl0bGU6IF9yZWFjdC5Qcm9wVHlwZXMuc3RyaW5nLFxuICAgIG9uU2VsZWN0OiBfcmVhY3QuUHJvcFR5cGVzLmZ1bmMsXG4gICAgb25DbGljazogX3JlYWN0LlByb3BUeXBlcy5mdW5jLFxuICAgIG9uRGVzZWxlY3Q6IF9yZWFjdC5Qcm9wVHlwZXMuZnVuYyxcbiAgICBwYXJlbnRNZW51OiBfcmVhY3QuUHJvcFR5cGVzLm9iamVjdCxcbiAgICBvbkl0ZW1Ib3ZlcjogX3JlYWN0LlByb3BUeXBlcy5mdW5jLFxuICAgIG9uRGVzdHJveTogX3JlYWN0LlByb3BUeXBlcy5mdW5jLFxuICAgIG9uTW91c2VFbnRlcjogX3JlYWN0LlByb3BUeXBlcy5mdW5jLFxuICAgIG9uTW91c2VMZWF2ZTogX3JlYWN0LlByb3BUeXBlcy5mdW5jXG4gIH0sXG5cbiAgZ2V0RGVmYXVsdFByb3BzOiBmdW5jdGlvbiBnZXREZWZhdWx0UHJvcHMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG9uU2VsZWN0OiBfdXRpbC5ub29wLFxuICAgICAgb25Nb3VzZUVudGVyOiBfdXRpbC5ub29wLFxuICAgICAgb25Nb3VzZUxlYXZlOiBfdXRpbC5ub29wXG4gICAgfTtcbiAgfSxcbiAgY29tcG9uZW50V2lsbFVubW91bnQ6IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgIHZhciBwcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgaWYgKHByb3BzLm9uRGVzdHJveSkge1xuICAgICAgcHJvcHMub25EZXN0cm95KHByb3BzLmV2ZW50S2V5KTtcbiAgICB9XG4gICAgaWYgKHByb3BzLnBhcmVudE1lbnUubWVudUl0ZW1JbnN0YW5jZSA9PT0gdGhpcykge1xuICAgICAgdGhpcy5jbGVhck1lbnVJdGVtTW91c2VMZWF2ZVRpbWVyKCk7XG4gICAgfVxuICB9LFxuICBvbktleURvd246IGZ1bmN0aW9uIG9uS2V5RG93bihlKSB7XG4gICAgdmFyIGtleUNvZGUgPSBlLmtleUNvZGU7XG4gICAgaWYgKGtleUNvZGUgPT09IF9yY1V0aWwuS2V5Q29kZS5FTlRFUikge1xuICAgICAgdGhpcy5vbkNsaWNrKGUpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9LFxuICBvbk1vdXNlTGVhdmU6IGZ1bmN0aW9uIG9uTW91c2VMZWF2ZShlKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIHZhciBwcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgdmFyIGV2ZW50S2V5ID0gcHJvcHMuZXZlbnRLZXk7XG4gICAgdmFyIHBhcmVudE1lbnUgPSBwcm9wcy5wYXJlbnRNZW51O1xuICAgIHBhcmVudE1lbnUubWVudUl0ZW1JbnN0YW5jZSA9IHRoaXM7XG4gICAgcGFyZW50TWVudS5tZW51SXRlbU1vdXNlTGVhdmVGbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChfdGhpcy5pc01vdW50ZWQoKSAmJiBwcm9wcy5hY3RpdmUpIHtcbiAgICAgICAgcHJvcHMub25JdGVtSG92ZXIoe1xuICAgICAgICAgIGtleTogZXZlbnRLZXksXG4gICAgICAgICAgaXRlbTogX3RoaXMsXG4gICAgICAgICAgaG92ZXI6IGZhbHNlLFxuICAgICAgICAgIHRyaWdnZXI6ICdtb3VzZWxlYXZlJ1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHBhcmVudE1lbnUubWVudUl0ZW1Nb3VzZUxlYXZlVGltZXIgPSBzZXRUaW1lb3V0KHBhcmVudE1lbnUubWVudUl0ZW1Nb3VzZUxlYXZlRm4sIDMwKTtcbiAgICBwcm9wcy5vbk1vdXNlTGVhdmUoe1xuICAgICAga2V5OiBldmVudEtleSxcbiAgICAgIGRvbUV2ZW50OiBlXG4gICAgfSk7XG4gIH0sXG4gIG9uTW91c2VFbnRlcjogZnVuY3Rpb24gb25Nb3VzZUVudGVyKGUpIHtcbiAgICB2YXIgcHJvcHMgPSB0aGlzLnByb3BzO1xuICAgIHZhciBwYXJlbnRNZW51ID0gcHJvcHMucGFyZW50TWVudTtcbiAgICB0aGlzLmNsZWFyTWVudUl0ZW1Nb3VzZUxlYXZlVGltZXIocGFyZW50TWVudS5tZW51SXRlbUluc3RhbmNlICE9PSB0aGlzKTtcbiAgICBpZiAocGFyZW50TWVudS5zdWJNZW51SW5zdGFuY2UpIHtcbiAgICAgIHBhcmVudE1lbnUuc3ViTWVudUluc3RhbmNlLmNsZWFyU3ViTWVudVRpbWVycyh0cnVlKTtcbiAgICB9XG4gICAgdmFyIGV2ZW50S2V5ID0gcHJvcHMuZXZlbnRLZXk7XG4gICAgcHJvcHMub25JdGVtSG92ZXIoe1xuICAgICAga2V5OiBldmVudEtleSxcbiAgICAgIGl0ZW06IHRoaXMsXG4gICAgICBob3ZlcjogdHJ1ZSxcbiAgICAgIHRyaWdnZXI6ICdtb3VzZWVudGVyJ1xuICAgIH0pO1xuICAgIHByb3BzLm9uTW91c2VFbnRlcih7XG4gICAgICBrZXk6IGV2ZW50S2V5LFxuICAgICAgZG9tRXZlbnQ6IGVcbiAgICB9KTtcbiAgfSxcbiAgb25DbGljazogZnVuY3Rpb24gb25DbGljayhlKSB7XG4gICAgdmFyIHByb3BzID0gdGhpcy5wcm9wcztcbiAgICB2YXIgZXZlbnRLZXkgPSBwcm9wcy5ldmVudEtleTtcbiAgICB2YXIgaW5mbyA9IHtcbiAgICAgIGtleTogZXZlbnRLZXksXG4gICAgICBrZXlQYXRoOiBbZXZlbnRLZXldLFxuICAgICAgaXRlbTogdGhpcyxcbiAgICAgIGRvbUV2ZW50OiBlXG4gICAgfTtcbiAgICBwcm9wcy5vbkNsaWNrKGluZm8pO1xuICAgIGlmIChwcm9wcy5tdWx0aXBsZSkge1xuICAgICAgaWYgKHByb3BzLnNlbGVjdGVkKSB7XG4gICAgICAgIHByb3BzLm9uRGVzZWxlY3QoaW5mbyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwcm9wcy5vblNlbGVjdChpbmZvKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCFwcm9wcy5zZWxlY3RlZCkge1xuICAgICAgcHJvcHMub25TZWxlY3QoaW5mbyk7XG4gICAgfVxuICB9LFxuICBnZXRQcmVmaXhDbHM6IGZ1bmN0aW9uIGdldFByZWZpeENscygpIHtcbiAgICByZXR1cm4gdGhpcy5wcm9wcy5yb290UHJlZml4Q2xzICsgJy1pdGVtJztcbiAgfSxcbiAgZ2V0QWN0aXZlQ2xhc3NOYW1lOiBmdW5jdGlvbiBnZXRBY3RpdmVDbGFzc05hbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0UHJlZml4Q2xzKCkgKyAnLWFjdGl2ZSc7XG4gIH0sXG4gIGdldFNlbGVjdGVkQ2xhc3NOYW1lOiBmdW5jdGlvbiBnZXRTZWxlY3RlZENsYXNzTmFtZSgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRQcmVmaXhDbHMoKSArICctc2VsZWN0ZWQnO1xuICB9LFxuICBnZXREaXNhYmxlZENsYXNzTmFtZTogZnVuY3Rpb24gZ2V0RGlzYWJsZWRDbGFzc05hbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0UHJlZml4Q2xzKCkgKyAnLWRpc2FibGVkJztcbiAgfSxcbiAgY2xlYXJNZW51SXRlbU1vdXNlTGVhdmVUaW1lcjogZnVuY3Rpb24gY2xlYXJNZW51SXRlbU1vdXNlTGVhdmVUaW1lcihjYWxsRm4pIHtcbiAgICB2YXIgcHJvcHMgPSB0aGlzLnByb3BzO1xuICAgIHZhciBwYXJlbnRNZW51ID0gcHJvcHMucGFyZW50TWVudTtcbiAgICBpZiAocGFyZW50TWVudS5tZW51SXRlbU1vdXNlTGVhdmVUaW1lcikge1xuICAgICAgY2xlYXJUaW1lb3V0KHBhcmVudE1lbnUubWVudUl0ZW1Nb3VzZUxlYXZlVGltZXIpO1xuICAgICAgcGFyZW50TWVudS5tZW51SXRlbU1vdXNlTGVhdmVUaW1lciA9IG51bGw7XG4gICAgICBpZiAoY2FsbEZuICYmIHBhcmVudE1lbnUubWVudUl0ZW1Nb3VzZUxlYXZlRm4pIHtcbiAgICAgICAgcGFyZW50TWVudS5tZW51SXRlbU1vdXNlTGVhdmVGbigpO1xuICAgICAgfVxuICAgICAgcGFyZW50TWVudS5tZW51SXRlbU1vdXNlTGVhdmVGbiA9IG51bGw7XG4gICAgfVxuICB9LFxuICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICB2YXIgcHJvcHMgPSB0aGlzLnByb3BzO1xuICAgIHZhciBjbGFzc2VzID0ge307XG4gICAgY2xhc3Nlc1t0aGlzLmdldEFjdGl2ZUNsYXNzTmFtZSgpXSA9ICFwcm9wcy5kaXNhYmxlZCAmJiBwcm9wcy5hY3RpdmU7XG4gICAgY2xhc3Nlc1t0aGlzLmdldFNlbGVjdGVkQ2xhc3NOYW1lKCldID0gcHJvcHMuc2VsZWN0ZWQ7XG4gICAgY2xhc3Nlc1t0aGlzLmdldERpc2FibGVkQ2xhc3NOYW1lKCldID0gcHJvcHMuZGlzYWJsZWQ7XG4gICAgY2xhc3Nlc1t0aGlzLmdldFByZWZpeENscygpXSA9IHRydWU7XG4gICAgY2xhc3Nlc1twcm9wcy5jbGFzc05hbWVdID0gISFwcm9wcy5jbGFzc05hbWU7XG4gICAgdmFyIGF0dHJzID0gX2V4dGVuZHMoe30sIHByb3BzLmF0dHJpYnV0ZSwge1xuICAgICAgdGl0bGU6IHByb3BzLnRpdGxlLFxuICAgICAgY2xhc3NOYW1lOiAoMCwgX2NsYXNzbmFtZXMyW1wiZGVmYXVsdFwiXSkoY2xhc3NlcyksXG4gICAgICByb2xlOiAnbWVudWl0ZW0nLFxuICAgICAgJ2FyaWEtc2VsZWN0ZWQnOiBwcm9wcy5zZWxlY3RlZCxcbiAgICAgICdhcmlhLWRpc2FibGVkJzogcHJvcHMuZGlzYWJsZWRcbiAgICB9KTtcbiAgICB2YXIgbW91c2VFdmVudCA9IHt9O1xuICAgIGlmICghcHJvcHMuZGlzYWJsZWQpIHtcbiAgICAgIG1vdXNlRXZlbnQgPSB7XG4gICAgICAgIG9uQ2xpY2s6IHRoaXMub25DbGljayxcbiAgICAgICAgb25Nb3VzZUxlYXZlOiB0aGlzLm9uTW91c2VMZWF2ZSxcbiAgICAgICAgb25Nb3VzZUVudGVyOiB0aGlzLm9uTW91c2VFbnRlclxuICAgICAgfTtcbiAgICB9XG4gICAgdmFyIHN0eWxlID0gX2V4dGVuZHMoe30sIHByb3BzLnN0eWxlKTtcbiAgICBpZiAocHJvcHMubW9kZSA9PT0gJ2lubGluZScpIHtcbiAgICAgIHN0eWxlLnBhZGRpbmdMZWZ0ID0gcHJvcHMuaW5saW5lSW5kZW50ICogcHJvcHMubGV2ZWw7XG4gICAgfVxuICAgIHJldHVybiBfcmVhY3QyW1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFxuICAgICAgJ2xpJyxcbiAgICAgIF9leHRlbmRzKHtcbiAgICAgICAgc3R5bGU6IHN0eWxlXG4gICAgICB9LCBhdHRycywgbW91c2VFdmVudCksXG4gICAgICBwcm9wcy5jaGlsZHJlblxuICAgICk7XG4gIH1cbn0pO1xuXG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IE1lbnVJdGVtO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vdXhjb3JlLXRhYmxlL34vdXhjb3JlLXNlbGVjdDIvfi9yYy1zZWxlY3Qvfi9yYy1tZW51L2xpYi9NZW51SXRlbS5qc1xuICoqIG1vZHVsZSBpZCA9IDIxMVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG52YXIgX3JjVHJpZ2dlciA9IHJlcXVpcmUoJ3JjLXRyaWdnZXInKTtcblxudmFyIF9yY1RyaWdnZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmNUcmlnZ2VyKTtcblxudmFyIF9yZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5cbnZhciBfcmVhY3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmVhY3QpO1xuXG52YXIgX2NsYXNzbmFtZXMgPSByZXF1aXJlKCdjbGFzc25hbWVzJyk7XG5cbnZhciBfY2xhc3NuYW1lczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jbGFzc25hbWVzKTtcblxudmFyIF9Ecm9wZG93bk1lbnUgPSByZXF1aXJlKCcuL0Ryb3Bkb3duTWVudScpO1xuXG52YXIgX0Ryb3Bkb3duTWVudTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9Ecm9wZG93bk1lbnUpO1xuXG52YXIgX3JlYWN0RG9tID0gcmVxdWlyZSgncmVhY3QtZG9tJyk7XG5cbnZhciBfcmVhY3REb20yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmVhY3REb20pO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBcImRlZmF1bHRcIjogb2JqIH07IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cblxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKG9iaiwga2V5cykgeyB2YXIgdGFyZ2V0ID0ge307IGZvciAodmFyIGkgaW4gb2JqKSB7IGlmIChrZXlzLmluZGV4T2YoaSkgPj0gMCkgY29udGludWU7IGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgaSkpIGNvbnRpbnVlOyB0YXJnZXRbaV0gPSBvYmpbaV07IH0gcmV0dXJuIHRhcmdldDsgfVxuXG52YXIgQlVJTFRfSU5fUExBQ0VNRU5UUyA9IHtcbiAgYm90dG9tTGVmdDoge1xuICAgIHBvaW50czogWyd0bCcsICdibCddLFxuICAgIG9mZnNldDogWzAsIDRdLFxuICAgIG92ZXJmbG93OiB7XG4gICAgICBhZGp1c3RYOiAwLFxuICAgICAgYWRqdXN0WTogMVxuICAgIH1cbiAgfSxcbiAgdG9wTGVmdDoge1xuICAgIHBvaW50czogWydibCcsICd0bCddLFxuICAgIG9mZnNldDogWzAsIC00XSxcbiAgICBvdmVyZmxvdzoge1xuICAgICAgYWRqdXN0WDogMCxcbiAgICAgIGFkanVzdFk6IDFcbiAgICB9XG4gIH1cbn07XG5cbnZhciBTZWxlY3RUcmlnZ2VyID0gX3JlYWN0MltcImRlZmF1bHRcIl0uY3JlYXRlQ2xhc3Moe1xuICBkaXNwbGF5TmFtZTogJ1NlbGVjdFRyaWdnZXInLFxuXG4gIHByb3BUeXBlczoge1xuICAgIG9uUG9wdXBGb2N1czogX3JlYWN0LlByb3BUeXBlcy5mdW5jLFxuICAgIGRyb3Bkb3duTWF0Y2hTZWxlY3RXaWR0aDogX3JlYWN0LlByb3BUeXBlcy5ib29sLFxuICAgIGRyb3Bkb3duQWxpZ246IF9yZWFjdC5Qcm9wVHlwZXMub2JqZWN0LFxuICAgIHZpc2libGU6IF9yZWFjdC5Qcm9wVHlwZXMuYm9vbCxcbiAgICBtdWx0aXBsZTogX3JlYWN0LlByb3BUeXBlcy5ib29sLFxuICAgIGlucHV0VmFsdWU6IF9yZWFjdC5Qcm9wVHlwZXMuc3RyaW5nLFxuICAgIGZpbHRlck9wdGlvbjogX3JlYWN0LlByb3BUeXBlcy5hbnksXG4gICAgb3B0aW9uczogX3JlYWN0LlByb3BUeXBlcy5hbnksXG4gICAgcHJlZml4Q2xzOiBfcmVhY3QuUHJvcFR5cGVzLnN0cmluZyxcbiAgICBwb3B1cENsYXNzTmFtZTogX3JlYWN0LlByb3BUeXBlcy5zdHJpbmcsXG4gICAgY2hpbGRyZW46IF9yZWFjdC5Qcm9wVHlwZXMuYW55XG4gIH0sXG5cbiAgY29tcG9uZW50RGlkVXBkYXRlOiBmdW5jdGlvbiBjb21wb25lbnREaWRVcGRhdGUoKSB7XG4gICAgdmFyIF9wcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgdmFyIHZpc2libGUgPSBfcHJvcHMudmlzaWJsZTtcbiAgICB2YXIgZHJvcGRvd25NYXRjaFNlbGVjdFdpZHRoID0gX3Byb3BzLmRyb3Bkb3duTWF0Y2hTZWxlY3RXaWR0aDtcblxuICAgIGlmICh2aXNpYmxlKSB7XG4gICAgICB2YXIgZHJvcGRvd25ET01Ob2RlID0gdGhpcy5nZXRQb3B1cERPTU5vZGUoKTtcbiAgICAgIGlmIChkcm9wZG93bkRPTU5vZGUpIHtcbiAgICAgICAgdmFyIHdpZHRoUHJvcCA9IGRyb3Bkb3duTWF0Y2hTZWxlY3RXaWR0aCA/ICd3aWR0aCcgOiAnbWluV2lkdGgnO1xuICAgICAgICBkcm9wZG93bkRPTU5vZGUuc3R5bGVbd2lkdGhQcm9wXSA9IF9yZWFjdERvbTJbXCJkZWZhdWx0XCJdLmZpbmRET01Ob2RlKHRoaXMpLm9mZnNldFdpZHRoICsgJ3B4JztcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIGdldElubmVyTWVudTogZnVuY3Rpb24gZ2V0SW5uZXJNZW51KCkge1xuICAgIHJldHVybiB0aGlzLnBvcHVwTWVudSAmJiB0aGlzLnBvcHVwTWVudS5yZWZzLm1lbnU7XG4gIH0sXG4gIGdldFBvcHVwRE9NTm9kZTogZnVuY3Rpb24gZ2V0UG9wdXBET01Ob2RlKCkge1xuICAgIHJldHVybiB0aGlzLnJlZnMudHJpZ2dlci5nZXRQb3B1cERvbU5vZGUoKTtcbiAgfSxcbiAgZ2V0RHJvcGRvd25FbGVtZW50OiBmdW5jdGlvbiBnZXREcm9wZG93bkVsZW1lbnQobmV3UHJvcHMpIHtcbiAgICB2YXIgcHJvcHMgPSB0aGlzLnByb3BzO1xuICAgIHJldHVybiBfcmVhY3QyW1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KF9Ecm9wZG93bk1lbnUyW1wiZGVmYXVsdFwiXSwgX2V4dGVuZHMoe1xuICAgICAgcmVmOiB0aGlzLnNhdmVNZW51XG4gICAgfSwgbmV3UHJvcHMsIHtcbiAgICAgIHByZWZpeENsczogdGhpcy5nZXREcm9wZG93blByZWZpeENscygpLFxuICAgICAgb25NZW51U2VsZWN0OiBwcm9wcy5vbk1lbnVTZWxlY3QsXG4gICAgICBvbk1lbnVEZXNlbGVjdDogcHJvcHMub25NZW51RGVzZWxlY3QsXG4gICAgICB2YWx1ZTogcHJvcHMudmFsdWUsXG4gICAgICBkZWZhdWx0QWN0aXZlRmlyc3RPcHRpb246IHByb3BzLmRlZmF1bHRBY3RpdmVGaXJzdE9wdGlvbixcbiAgICAgIGRyb3Bkb3duTWVudVN0eWxlOiBwcm9wcy5kcm9wZG93bk1lbnVTdHlsZVxuICAgIH0pKTtcbiAgfSxcbiAgZ2V0RHJvcGRvd25UcmFuc2l0aW9uTmFtZTogZnVuY3Rpb24gZ2V0RHJvcGRvd25UcmFuc2l0aW9uTmFtZSgpIHtcbiAgICB2YXIgcHJvcHMgPSB0aGlzLnByb3BzO1xuICAgIHZhciB0cmFuc2l0aW9uTmFtZSA9IHByb3BzLnRyYW5zaXRpb25OYW1lO1xuICAgIGlmICghdHJhbnNpdGlvbk5hbWUgJiYgcHJvcHMuYW5pbWF0aW9uKSB7XG4gICAgICB0cmFuc2l0aW9uTmFtZSA9IHRoaXMuZ2V0RHJvcGRvd25QcmVmaXhDbHMoKSArICctJyArIHByb3BzLmFuaW1hdGlvbjtcbiAgICB9XG4gICAgcmV0dXJuIHRyYW5zaXRpb25OYW1lO1xuICB9LFxuICBnZXREcm9wZG93blByZWZpeENsczogZnVuY3Rpb24gZ2V0RHJvcGRvd25QcmVmaXhDbHMoKSB7XG4gICAgcmV0dXJuIHRoaXMucHJvcHMucHJlZml4Q2xzICsgJy1kcm9wZG93bic7XG4gIH0sXG4gIHNhdmVNZW51OiBmdW5jdGlvbiBzYXZlTWVudShtZW51KSB7XG4gICAgdGhpcy5wb3B1cE1lbnUgPSBtZW51O1xuICB9LFxuICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICB2YXIgX3BvcHVwQ2xhc3NOYW1lO1xuXG4gICAgdmFyIF9wcm9wczIgPSB0aGlzLnByb3BzO1xuICAgIHZhciBvblBvcHVwRm9jdXMgPSBfcHJvcHMyLm9uUG9wdXBGb2N1cztcblxuICAgIHZhciBwcm9wcyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhfcHJvcHMyLCBbJ29uUG9wdXBGb2N1cyddKTtcblxuICAgIHZhciBtdWx0aXBsZSA9IHByb3BzLm11bHRpcGxlO1xuICAgIHZhciB2aXNpYmxlID0gcHJvcHMudmlzaWJsZTtcbiAgICB2YXIgaW5wdXRWYWx1ZSA9IHByb3BzLmlucHV0VmFsdWU7XG4gICAgdmFyIGRyb3Bkb3duQWxpZ24gPSBwcm9wcy5kcm9wZG93bkFsaWduO1xuXG4gICAgdmFyIGRyb3Bkb3duUHJlZml4Q2xzID0gdGhpcy5nZXREcm9wZG93blByZWZpeENscygpO1xuICAgIHZhciBwb3B1cENsYXNzTmFtZSA9IChfcG9wdXBDbGFzc05hbWUgPSB7fSwgX2RlZmluZVByb3BlcnR5KF9wb3B1cENsYXNzTmFtZSwgcHJvcHMuZHJvcGRvd25DbGFzc05hbWUsICEhcHJvcHMuZHJvcGRvd25DbGFzc05hbWUpLCBfZGVmaW5lUHJvcGVydHkoX3BvcHVwQ2xhc3NOYW1lLCBkcm9wZG93blByZWZpeENscyArICctLScgKyAobXVsdGlwbGUgPyAnbXVsdGlwbGUnIDogJ3NpbmdsZScpLCAxKSwgX3BvcHVwQ2xhc3NOYW1lKTtcbiAgICB2YXIgcG9wdXBFbGVtZW50ID0gdGhpcy5nZXREcm9wZG93bkVsZW1lbnQoe1xuICAgICAgbWVudUl0ZW1zOiBwcm9wcy5vcHRpb25zLFxuICAgICAgb25Qb3B1cEZvY3VzOiBvblBvcHVwRm9jdXMsXG4gICAgICBtdWx0aXBsZTogbXVsdGlwbGUsXG4gICAgICBpbnB1dFZhbHVlOiBpbnB1dFZhbHVlLFxuICAgICAgdmlzaWJsZTogdmlzaWJsZVxuICAgIH0pO1xuICAgIHJldHVybiBfcmVhY3QyW1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFxuICAgICAgX3JjVHJpZ2dlcjJbXCJkZWZhdWx0XCJdLFxuICAgICAgX2V4dGVuZHMoe30sIHByb3BzLCB7XG4gICAgICAgIHNob3dBY3Rpb246IHByb3BzLmRpc2FibGVkID8gW10gOiBbJ2NsaWNrJ10sXG4gICAgICAgIGhpZGVBY3Rpb246IHByb3BzLmRpc2FibGVkID8gW10gOiBbJ2JsdXInXSxcbiAgICAgICAgcmVmOiAndHJpZ2dlcicsXG4gICAgICAgIHBvcHVwUGxhY2VtZW50OiAnYm90dG9tTGVmdCcsXG4gICAgICAgIGJ1aWx0aW5QbGFjZW1lbnRzOiBCVUlMVF9JTl9QTEFDRU1FTlRTLFxuICAgICAgICBwcmVmaXhDbHM6IGRyb3Bkb3duUHJlZml4Q2xzLFxuICAgICAgICBwb3B1cFRyYW5zaXRpb25OYW1lOiB0aGlzLmdldERyb3Bkb3duVHJhbnNpdGlvbk5hbWUoKSxcbiAgICAgICAgb25Qb3B1cFZpc2libGVDaGFuZ2U6IHByb3BzLm9uRHJvcGRvd25WaXNpYmxlQ2hhbmdlLFxuICAgICAgICBwb3B1cDogcG9wdXBFbGVtZW50LFxuICAgICAgICBwb3B1cEFsaWduOiBkcm9wZG93bkFsaWduLFxuICAgICAgICBwb3B1cFZpc2libGU6IHZpc2libGUsXG4gICAgICAgIGdldFBvcHVwQ29udGFpbmVyOiBwcm9wcy5nZXRQb3B1cENvbnRhaW5lcixcbiAgICAgICAgcG9wdXBDbGFzc05hbWU6ICgwLCBfY2xhc3NuYW1lczJbXCJkZWZhdWx0XCJdKShwb3B1cENsYXNzTmFtZSksXG4gICAgICAgIHBvcHVwU3R5bGU6IHByb3BzLmRyb3Bkb3duU3R5bGVcbiAgICAgIH0pLFxuICAgICAgcHJvcHMuY2hpbGRyZW5cbiAgICApO1xuICB9XG59KTtcblxuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBTZWxlY3RUcmlnZ2VyO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vdXhjb3JlLXRhYmxlL34vdXhjb3JlLXNlbGVjdDIvfi9yYy1zZWxlY3QvbGliL1NlbGVjdFRyaWdnZXIuanNcbiAqKiBtb2R1bGUgaWQgPSAyMTRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbnZhciBfcmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xuXG52YXIgX3JlYWN0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JlYWN0KTtcblxudmFyIF9yZWFjdERvbSA9IHJlcXVpcmUoJ3JlYWN0LWRvbScpO1xuXG52YXIgX3V0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcblxudmFyIF9yY01lbnUgPSByZXF1aXJlKCdyYy1tZW51Jyk7XG5cbnZhciBfcmNNZW51MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JjTWVudSk7XG5cbnZhciBfZG9tU2Nyb2xsSW50b1ZpZXcgPSByZXF1aXJlKCdkb20tc2Nyb2xsLWludG8tdmlldycpO1xuXG52YXIgX2RvbVNjcm9sbEludG9WaWV3MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2RvbVNjcm9sbEludG9WaWV3KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgXCJkZWZhdWx0XCI6IG9iaiB9OyB9XG5cbnZhciBEcm9wZG93bk1lbnUgPSBfcmVhY3QyW1wiZGVmYXVsdFwiXS5jcmVhdGVDbGFzcyh7XG4gIGRpc3BsYXlOYW1lOiAnRHJvcGRvd25NZW51JyxcblxuICBwcm9wVHlwZXM6IHtcbiAgICBkZWZhdWx0QWN0aXZlRmlyc3RPcHRpb246IF9yZWFjdC5Qcm9wVHlwZXMuYm9vbCxcbiAgICB2YWx1ZTogX3JlYWN0LlByb3BUeXBlcy5hbnksXG4gICAgZHJvcGRvd25NZW51U3R5bGU6IF9yZWFjdC5Qcm9wVHlwZXMub2JqZWN0LFxuICAgIG11bHRpcGxlOiBfcmVhY3QuUHJvcFR5cGVzLmJvb2wsXG4gICAgb25Qb3B1cEZvY3VzOiBfcmVhY3QuUHJvcFR5cGVzLmZ1bmMsXG4gICAgb25NZW51RGVTZWxlY3Q6IF9yZWFjdC5Qcm9wVHlwZXMuZnVuYyxcbiAgICBvbk1lbnVTZWxlY3Q6IF9yZWFjdC5Qcm9wVHlwZXMuZnVuYyxcbiAgICBwcmVmaXhDbHM6IF9yZWFjdC5Qcm9wVHlwZXMuc3RyaW5nLFxuICAgIG1lbnVJdGVtczogX3JlYWN0LlByb3BUeXBlcy5hbnksXG4gICAgaW5wdXRWYWx1ZTogX3JlYWN0LlByb3BUeXBlcy5zdHJpbmcsXG4gICAgdmlzaWJsZTogX3JlYWN0LlByb3BUeXBlcy5ib29sXG4gIH0sXG5cbiAgY29tcG9uZW50V2lsbE1vdW50OiBmdW5jdGlvbiBjb21wb25lbnRXaWxsTW91bnQoKSB7XG4gICAgdGhpcy5sYXN0SW5wdXRWYWx1ZSA9IHRoaXMucHJvcHMuaW5wdXRWYWx1ZTtcbiAgfSxcbiAgY29tcG9uZW50RGlkTW91bnQ6IGZ1bmN0aW9uIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgIHRoaXMuc2Nyb2xsQWN0aXZlSXRlbVRvVmlldygpO1xuICAgIHRoaXMubGFzdFZpc2libGUgPSB0aGlzLnByb3BzLnZpc2libGU7XG4gIH0sXG4gIHNob3VsZENvbXBvbmVudFVwZGF0ZTogZnVuY3Rpb24gc2hvdWxkQ29tcG9uZW50VXBkYXRlKG5leHRQcm9wcykge1xuICAgIGlmICghbmV4dFByb3BzLnZpc2libGUpIHtcbiAgICAgIHRoaXMubGFzdFZpc2libGUgPSBmYWxzZTtcbiAgICB9XG4gICAgLy8gZnJlZXplIHdoZW4gaGlkZVxuICAgIHJldHVybiBuZXh0UHJvcHMudmlzaWJsZTtcbiAgfSxcbiAgY29tcG9uZW50RGlkVXBkYXRlOiBmdW5jdGlvbiBjb21wb25lbnREaWRVcGRhdGUocHJldlByb3BzKSB7XG4gICAgdmFyIHByb3BzID0gdGhpcy5wcm9wcztcbiAgICBpZiAoIXByZXZQcm9wcy52aXNpYmxlICYmIHByb3BzLnZpc2libGUpIHtcbiAgICAgIHRoaXMuc2Nyb2xsQWN0aXZlSXRlbVRvVmlldygpO1xuICAgIH1cbiAgICB0aGlzLmxhc3RWaXNpYmxlID0gcHJvcHMudmlzaWJsZTtcbiAgICB0aGlzLmxhc3RJbnB1dFZhbHVlID0gcHJvcHMuaW5wdXRWYWx1ZTtcbiAgfSxcbiAgc2Nyb2xsQWN0aXZlSXRlbVRvVmlldzogZnVuY3Rpb24gc2Nyb2xsQWN0aXZlSXRlbVRvVmlldygpIHtcbiAgICAvLyBzY3JvbGwgaW50byB2aWV3XG4gICAgdmFyIGl0ZW1Db21wb25lbnQgPSAoMCwgX3JlYWN0RG9tLmZpbmRET01Ob2RlKSh0aGlzLmZpcnN0QWN0aXZlSXRlbSk7XG4gICAgaWYgKGl0ZW1Db21wb25lbnQpIHtcbiAgICAgICgwLCBfZG9tU2Nyb2xsSW50b1ZpZXcyW1wiZGVmYXVsdFwiXSkoaXRlbUNvbXBvbmVudCwgKDAsIF9yZWFjdERvbS5maW5kRE9NTm9kZSkodGhpcy5yZWZzLm1lbnUpLCB7XG4gICAgICAgIG9ubHlTY3JvbGxJZk5lZWRlZDogdHJ1ZVxuICAgICAgfSk7XG4gICAgfVxuICB9LFxuICByZW5kZXJNZW51OiBmdW5jdGlvbiByZW5kZXJNZW51KCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICB2YXIgcHJvcHMgPSB0aGlzLnByb3BzO1xuICAgIHZhciBtZW51SXRlbXMgPSBwcm9wcy5tZW51SXRlbXM7XG4gICAgdmFyIGRlZmF1bHRBY3RpdmVGaXJzdE9wdGlvbiA9IHByb3BzLmRlZmF1bHRBY3RpdmVGaXJzdE9wdGlvbjtcbiAgICB2YXIgdmFsdWUgPSBwcm9wcy52YWx1ZTtcbiAgICB2YXIgcHJlZml4Q2xzID0gcHJvcHMucHJlZml4Q2xzO1xuICAgIHZhciBtdWx0aXBsZSA9IHByb3BzLm11bHRpcGxlO1xuICAgIHZhciBvbk1lbnVTZWxlY3QgPSBwcm9wcy5vbk1lbnVTZWxlY3Q7XG4gICAgdmFyIGlucHV0VmFsdWUgPSBwcm9wcy5pbnB1dFZhbHVlO1xuXG4gICAgaWYgKG1lbnVJdGVtcyAmJiBtZW51SXRlbXMubGVuZ3RoKSB7XG4gICAgICB2YXIgX3JldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG1lbnVQcm9wcyA9IHt9O1xuICAgICAgICBpZiAobXVsdGlwbGUpIHtcbiAgICAgICAgICBtZW51UHJvcHMub25EZXNlbGVjdCA9IHByb3BzLm9uTWVudURlc2VsZWN0O1xuICAgICAgICAgIG1lbnVQcm9wcy5vblNlbGVjdCA9IG9uTWVudVNlbGVjdDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBtZW51UHJvcHMub25DbGljayA9IG9uTWVudVNlbGVjdDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzZWxlY3RlZEtleXMgPSAoMCwgX3V0aWwuZ2V0U2VsZWN0S2V5cykobWVudUl0ZW1zLCB2YWx1ZSk7XG4gICAgICAgIHZhciBhY3RpdmVLZXlQcm9wcyA9IHt9O1xuXG4gICAgICAgIHZhciBjbG9uZWRNZW51SXRlbXMgPSBtZW51SXRlbXM7XG4gICAgICAgIGlmIChzZWxlY3RlZEtleXMubGVuZ3RoKSB7XG4gICAgICAgICAgKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChwcm9wcy52aXNpYmxlICYmICFfdGhpcy5sYXN0VmlzaWJsZSkge1xuICAgICAgICAgICAgICBhY3RpdmVLZXlQcm9wcy5hY3RpdmVLZXkgPSBzZWxlY3RlZEtleXNbMF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgZm91bmRGaXJzdCA9IGZhbHNlO1xuICAgICAgICAgICAgLy8gc2V0IGZpcnN0QWN0aXZlSXRlbSB2aWEgY2xvbmluZyBtZW51c1xuICAgICAgICAgICAgLy8gZm9yIHNjcm9sbCBpbnRvIHZpZXdcbiAgICAgICAgICAgIHZhciBjbG9uZSA9IGZ1bmN0aW9uIGNsb25lKGl0ZW0pIHtcbiAgICAgICAgICAgICAgaWYgKCFmb3VuZEZpcnN0ICYmIHNlbGVjdGVkS2V5cy5pbmRleE9mKGl0ZW0ua2V5KSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICBmb3VuZEZpcnN0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gKDAsIF9yZWFjdC5jbG9uZUVsZW1lbnQpKGl0ZW0sIHtcbiAgICAgICAgICAgICAgICAgIHJlZjogZnVuY3Rpb24gcmVmKF9yZWYpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuZmlyc3RBY3RpdmVJdGVtID0gX3JlZjtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGNsb25lZE1lbnVJdGVtcyA9IG1lbnVJdGVtcy5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICAgICAgaWYgKGl0ZW0udHlwZSA9PT0gX3JjTWVudS5JdGVtR3JvdXApIHtcbiAgICAgICAgICAgICAgICB2YXIgY2hpbGRyZW4gPSBpdGVtLnByb3BzLmNoaWxkcmVuLm1hcChjbG9uZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuICgwLCBfcmVhY3QuY2xvbmVFbGVtZW50KShpdGVtLCB7fSwgY2hpbGRyZW4pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBjbG9uZShpdGVtKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pKCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjbGVhciBhY3RpdmVLZXkgd2hlbiBpbnB1dFZhbHVlIGNoYW5nZVxuICAgICAgICBpZiAoaW5wdXRWYWx1ZSAhPT0gX3RoaXMubGFzdElucHV0VmFsdWUpIHtcbiAgICAgICAgICBhY3RpdmVLZXlQcm9wcy5hY3RpdmVLZXkgPSAnJztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdjogX3JlYWN0MltcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAgIF9yY01lbnUyW1wiZGVmYXVsdFwiXSxcbiAgICAgICAgICAgIF9leHRlbmRzKHtcbiAgICAgICAgICAgICAgcmVmOiAnbWVudScsXG4gICAgICAgICAgICAgIHN0eWxlOiBfdGhpcy5wcm9wcy5kcm9wZG93bk1lbnVTdHlsZSxcbiAgICAgICAgICAgICAgZGVmYXVsdEFjdGl2ZUZpcnN0OiBkZWZhdWx0QWN0aXZlRmlyc3RPcHRpb25cbiAgICAgICAgICAgIH0sIGFjdGl2ZUtleVByb3BzLCB7XG4gICAgICAgICAgICAgIG11bHRpcGxlOiBtdWx0aXBsZSxcbiAgICAgICAgICAgICAgZm9jdXNhYmxlOiBmYWxzZVxuICAgICAgICAgICAgfSwgbWVudVByb3BzLCB7XG4gICAgICAgICAgICAgIHNlbGVjdGVkS2V5czogc2VsZWN0ZWRLZXlzLFxuICAgICAgICAgICAgICBwcmVmaXhDbHM6IHByZWZpeENscyArICctbWVudSdcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgY2xvbmVkTWVudUl0ZW1zXG4gICAgICAgICAgKVxuICAgICAgICB9O1xuICAgICAgfSgpO1xuXG4gICAgICBpZiAoKHR5cGVvZiBfcmV0ID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihfcmV0KSkgPT09IFwib2JqZWN0XCIpIHJldHVybiBfcmV0LnY7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9LFxuICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICByZXR1cm4gX3JlYWN0MltcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChcbiAgICAgICdkaXYnLFxuICAgICAge1xuICAgICAgICBzdHlsZTogeyBvdmVyZmxvdzogJ2F1dG8nIH0sXG4gICAgICAgIG9uRm9jdXM6IHRoaXMucHJvcHMub25Qb3B1cEZvY3VzLFxuICAgICAgICBvbk1vdXNlRG93bjogX3V0aWwucHJldmVudERlZmF1bHRFdmVudFxuICAgICAgfSxcbiAgICAgIHRoaXMucmVuZGVyTWVudSgpXG4gICAgKTtcbiAgfVxufSk7XG5cbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gRHJvcGRvd25NZW51O1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vdXhjb3JlLXRhYmxlL34vdXhjb3JlLXNlbGVjdDIvfi9yYy1zZWxlY3QvbGliL0Ryb3Bkb3duTWVudS5qc1xuICoqIG1vZHVsZSBpZCA9IDIzMlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG52YXIgX3JlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxudmFyIF9yZWFjdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yZWFjdCk7XG5cbnZhciBfT3B0R3JvdXAgPSByZXF1aXJlKCcuL09wdEdyb3VwJyk7XG5cbnZhciBfT3B0R3JvdXAyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfT3B0R3JvdXApO1xuXG52YXIgX3V0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcblxudmFyIF9yY01lbnUgPSByZXF1aXJlKCdyYy1tZW51Jyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IFwiZGVmYXVsdFwiOiBvYmogfTsgfVxuXG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IHtcbiAgZmlsdGVyT3B0aW9uOiBmdW5jdGlvbiBmaWx0ZXJPcHRpb24oaW5wdXQsIGNoaWxkKSB7XG4gICAgaWYgKCFpbnB1dCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHZhciBmaWx0ZXJPcHRpb24gPSB0aGlzLnByb3BzLmZpbHRlck9wdGlvbjtcbiAgICBpZiAoIWZpbHRlck9wdGlvbikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmIChjaGlsZC5wcm9wcy5kaXNhYmxlZCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gZmlsdGVyT3B0aW9uLmNhbGwodGhpcywgaW5wdXQsIGNoaWxkKTtcbiAgfSxcbiAgcmVuZGVyRmlsdGVyT3B0aW9uczogZnVuY3Rpb24gcmVuZGVyRmlsdGVyT3B0aW9ucyhpbnB1dFZhbHVlKSB7XG4gICAgcmV0dXJuIHRoaXMucmVuZGVyRmlsdGVyT3B0aW9uc0Zyb21DaGlsZHJlbih0aGlzLnByb3BzLmNoaWxkcmVuLCB0cnVlLCBpbnB1dFZhbHVlKTtcbiAgfSxcbiAgcmVuZGVyRmlsdGVyT3B0aW9uc0Zyb21DaGlsZHJlbjogZnVuY3Rpb24gcmVuZGVyRmlsdGVyT3B0aW9uc0Zyb21DaGlsZHJlbihjaGlsZHJlbiwgc2hvd05vdEZvdW5kLCBpdikge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICB2YXIgc2VsID0gW107XG4gICAgdmFyIHByb3BzID0gdGhpcy5wcm9wcztcbiAgICB2YXIgaW5wdXRWYWx1ZSA9IGl2ID09PSB1bmRlZmluZWQgPyB0aGlzLnN0YXRlLmlucHV0VmFsdWUgOiBpdjtcbiAgICB2YXIgY2hpbGRyZW5LZXlzID0gW107XG4gICAgdmFyIHRhZ3MgPSBwcm9wcy50YWdzO1xuICAgIF9yZWFjdDJbXCJkZWZhdWx0XCJdLkNoaWxkcmVuLmZvckVhY2goY2hpbGRyZW4sIGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgaWYgKGNoaWxkLnR5cGUgPT09IF9PcHRHcm91cDJbXCJkZWZhdWx0XCJdKSB7XG4gICAgICAgIHZhciBpbm5lckl0ZW1zID0gX3RoaXMucmVuZGVyRmlsdGVyT3B0aW9uc0Zyb21DaGlsZHJlbihjaGlsZC5wcm9wcy5jaGlsZHJlbiwgZmFsc2UpO1xuICAgICAgICBpZiAoaW5uZXJJdGVtcy5sZW5ndGgpIHtcbiAgICAgICAgICB2YXIgbGFiZWwgPSBjaGlsZC5wcm9wcy5sYWJlbDtcbiAgICAgICAgICB2YXIga2V5ID0gY2hpbGQua2V5O1xuICAgICAgICAgIGlmICgha2V5ICYmIHR5cGVvZiBsYWJlbCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGtleSA9IGxhYmVsO1xuICAgICAgICAgIH0gZWxzZSBpZiAoIWxhYmVsICYmIGtleSkge1xuICAgICAgICAgICAgbGFiZWwgPSBrZXk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHNlbC5wdXNoKF9yZWFjdDJbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgICBfcmNNZW51Lkl0ZW1Hcm91cCxcbiAgICAgICAgICAgIHsga2V5OiBrZXksIHRpdGxlOiBsYWJlbCB9LFxuICAgICAgICAgICAgaW5uZXJJdGVtc1xuICAgICAgICAgICkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBjaGlsZFZhbHVlID0gKDAsIF91dGlsLmdldFZhbHVlUHJvcFZhbHVlKShjaGlsZCk7XG4gICAgICBpZiAoX3RoaXMuZmlsdGVyT3B0aW9uKGlucHV0VmFsdWUsIGNoaWxkKSkge1xuICAgICAgICBzZWwucHVzaChfcmVhY3QyW1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KF9yY01lbnUuSXRlbSwgX2V4dGVuZHMoe1xuICAgICAgICAgIHN0eWxlOiBfdXRpbC5VTlNFTEVDVEFCTEVfU1RZTEUsXG4gICAgICAgICAgYXR0cmlidXRlOiBfdXRpbC5VTlNFTEVDVEFCTEVfQVRUUklCVVRFLFxuICAgICAgICAgIHZhbHVlOiBjaGlsZFZhbHVlLFxuICAgICAgICAgIGtleTogY2hpbGRWYWx1ZVxuICAgICAgICB9LCBjaGlsZC5wcm9wcykpKTtcbiAgICAgIH1cbiAgICAgIGlmICh0YWdzICYmICFjaGlsZC5wcm9wcy5kaXNhYmxlZCkge1xuICAgICAgICBjaGlsZHJlbktleXMucHVzaChjaGlsZFZhbHVlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAodGFncykge1xuICAgICAgLy8gdGFncyB2YWx1ZSBtdXN0IGJlIHN0cmluZ1xuICAgICAgdmFyIHZhbHVlID0gdGhpcy5zdGF0ZS52YWx1ZSB8fCBbXTtcbiAgICAgIHZhbHVlID0gdmFsdWUuZmlsdGVyKGZ1bmN0aW9uIChzaW5nbGVWYWx1ZSkge1xuICAgICAgICByZXR1cm4gY2hpbGRyZW5LZXlzLmluZGV4T2Yoc2luZ2xlVmFsdWUua2V5KSA9PT0gLTEgJiYgKCFpbnB1dFZhbHVlIHx8IFN0cmluZyhzaW5nbGVWYWx1ZS5rZXkpLmluZGV4T2YoU3RyaW5nKGlucHV0VmFsdWUpKSA+IC0xKTtcbiAgICAgIH0pO1xuICAgICAgc2VsID0gc2VsLmNvbmNhdCh2YWx1ZS5tYXAoZnVuY3Rpb24gKHNpbmdsZVZhbHVlKSB7XG4gICAgICAgIHZhciBrZXkgPSBzaW5nbGVWYWx1ZS5rZXk7XG4gICAgICAgIHJldHVybiBfcmVhY3QyW1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgIF9yY01lbnUuSXRlbSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBzdHlsZTogX3V0aWwuVU5TRUxFQ1RBQkxFX1NUWUxFLFxuICAgICAgICAgICAgYXR0cmlidXRlOiBfdXRpbC5VTlNFTEVDVEFCTEVfQVRUUklCVVRFLFxuICAgICAgICAgICAgdmFsdWU6IGtleSxcbiAgICAgICAgICAgIGtleToga2V5XG4gICAgICAgICAgfSxcbiAgICAgICAgICBrZXlcbiAgICAgICAgKTtcbiAgICAgIH0pKTtcbiAgICAgIGlmIChpbnB1dFZhbHVlKSB7XG4gICAgICAgIHZhciBub3RGaW5kSW5wdXRJdGVtID0gc2VsLmV2ZXJ5KGZ1bmN0aW9uIChvcHRpb24pIHtcbiAgICAgICAgICByZXR1cm4gKDAsIF91dGlsLmdldFZhbHVlUHJvcFZhbHVlKShvcHRpb24pICE9PSBpbnB1dFZhbHVlO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKG5vdEZpbmRJbnB1dEl0ZW0pIHtcbiAgICAgICAgICBzZWwudW5zaGlmdChfcmVhY3QyW1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICAgX3JjTWVudS5JdGVtLFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBzdHlsZTogX3V0aWwuVU5TRUxFQ1RBQkxFX1NUWUxFLFxuICAgICAgICAgICAgICBhdHRyaWJ1dGU6IF91dGlsLlVOU0VMRUNUQUJMRV9BVFRSSUJVVEUsXG4gICAgICAgICAgICAgIHZhbHVlOiBpbnB1dFZhbHVlLFxuICAgICAgICAgICAgICBrZXk6IGlucHV0VmFsdWVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBpbnB1dFZhbHVlXG4gICAgICAgICAgKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFzZWwubGVuZ3RoICYmIHNob3dOb3RGb3VuZCAmJiBwcm9wcy5ub3RGb3VuZENvbnRlbnQpIHtcbiAgICAgIHNlbCA9IFtfcmVhY3QyW1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFxuICAgICAgICBfcmNNZW51Lkl0ZW0sXG4gICAgICAgIHtcbiAgICAgICAgICBzdHlsZTogX3V0aWwuVU5TRUxFQ1RBQkxFX1NUWUxFLFxuICAgICAgICAgIGF0dHJpYnV0ZTogX3V0aWwuVU5TRUxFQ1RBQkxFX0FUVFJJQlVURSxcbiAgICAgICAgICBkaXNhYmxlZDogdHJ1ZSxcbiAgICAgICAgICB2YWx1ZTogJ05PVF9GT1VORCcsXG4gICAgICAgICAga2V5OiAnTk9UX0ZPVU5EJ1xuICAgICAgICB9LFxuICAgICAgICBwcm9wcy5ub3RGb3VuZENvbnRlbnRcbiAgICAgICldO1xuICAgIH1cbiAgICByZXR1cm4gc2VsO1xuICB9XG59O1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vdXhjb3JlLXRhYmxlL34vdXhjb3JlLXNlbGVjdDIvfi9yYy1zZWxlY3QvbGliL0ZpbHRlck1peGluLmpzXG4gKiogbW9kdWxlIGlkID0gMjMzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogUmFkaW9ncm91cCBDb21wb25lbnQgZm9yIHV4Y29yZVxuICogQGF1dGhvciBcbiAqXG4gKiBDb3B5cmlnaHQgMjAxNC0yMDE1LCBVeGNvcmUgVGVhbSwgQWxpbncuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9SYWRpb2dyb3VwJyk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vdXhjb3JlLXRhYmxlL34vdXhjb3JlLXJhZGlvZ3JvdXAvYnVpbGQvaW5kZXguanNcbiAqKiBtb2R1bGUgaWQgPSAyMzZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG4vKipcbiogdGhhbmtzIGZvciBodHRwczovL2dpdGh1Yi5jb20vY2hlbmdsb3UvcmVhY3QtcmFkaW8tZ3JvdXBcbiogQGF1dGhvcjogemhvdXF1YW4ueWV6cVxuKiBAdGltZSAgOiA1LzI1IDIwMTVcbiovXG5cbnZhciBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG52YXIgUmVhY3RET00gPSByZXF1aXJlKCdyZWFjdC1kb20nKTtcbnZhciBJdGVtID0gcmVxdWlyZSgnLi9SYWRpb2dyb3VwSXRlbScpO1xudmFyIGNsYXNzbmFtZXMgPSByZXF1aXJlKFwiY2xhc3NuYW1lc1wiKTtcblxudmFyIFJhZGlvZ3JvdXAgPSBmdW5jdGlvbiAoX1JlYWN0JENvbXBvbmVudCkge1xuICAgIF9pbmhlcml0cyhSYWRpb2dyb3VwLCBfUmVhY3QkQ29tcG9uZW50KTtcblxuICAgIGZ1bmN0aW9uIFJhZGlvZ3JvdXAocHJvcHMpIHtcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFJhZGlvZ3JvdXApO1xuXG4gICAgICAgIHZhciBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9SZWFjdCRDb21wb25lbnQuY2FsbCh0aGlzLCBwcm9wcykpO1xuXG4gICAgICAgIF90aGlzLnN0YXRlID0ge1xuICAgICAgICAgICAgZGVmYXVsdFZhbHVlOiBwcm9wcy5kZWZhdWx0VmFsdWVcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cblxuICAgIFJhZGlvZ3JvdXAucHJvdG90eXBlLl9oYW5kbGVDaGFuZ2UgPSBmdW5jdGlvbiBfaGFuZGxlQ2hhbmdlKHZhbHVlKSB7XG4gICAgICAgIHZhciBtZSA9IHRoaXM7XG4gICAgICAgIG1lLnByb3BzLm9uQ2hhbmdlKHZhbHVlKTtcbiAgICB9O1xuXG4gICAgUmFkaW9ncm91cC5wcm90b3R5cGUuX3Byb2Nlc3NDaGlsZCA9IGZ1bmN0aW9uIF9wcm9jZXNzQ2hpbGQoKSB7XG4gICAgICAgIHZhciBtZSA9IHRoaXM7XG4gICAgICAgIHZhciBsZW5ndGggPSBSZWFjdC5DaGlsZHJlbi5jb3VudChtZS5wcm9wcy5jaGlsZHJlbik7XG4gICAgICAgIGlmICghbGVuZ3RoKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIHZhciBlbGVtZW50cyA9IFJlYWN0LkNoaWxkcmVuLm1hcChtZS5wcm9wcy5jaGlsZHJlbiwgZnVuY3Rpb24gKGNoaWxkLCBpbmRleCkge1xuICAgICAgICAgICAgaWYgKCEhY2hpbGQudHlwZSAmJiBjaGlsZC50eXBlLmRpc3BsYXlOYW1lID09IFwiUmFkaW9ncm91cEl0ZW1cIikge1xuICAgICAgICAgICAgICAgIHJldHVybiBSZWFjdC5jbG9uZUVsZW1lbnQoY2hpbGQsIHtcbiAgICAgICAgICAgICAgICAgICAgb25DaGFuZ2U6IG1lLl9oYW5kbGVDaGFuZ2UuYmluZChtZSksXG4gICAgICAgICAgICAgICAgICAgIGtleTogaW5kZXgsXG4gICAgICAgICAgICAgICAgICAgIGNoZWNrZWQ6IG1lLnByb3BzLnZhbHVlID09IGNoaWxkLnByb3BzLnZhbHVlXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZWxlbWVudHM7XG4gICAgfTtcblxuICAgIFJhZGlvZ3JvdXAucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICAgICAgdmFyIF9jbGFzc25hbWVzO1xuXG4gICAgICAgIHZhciBtZSA9IHRoaXM7XG4gICAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICAgJ2RpdicsXG4gICAgICAgICAgICB7IGNsYXNzTmFtZTogY2xhc3NuYW1lcygoX2NsYXNzbmFtZXMgPSB7XG4gICAgICAgICAgICAgICAgICAgIFwia3VtYS1yYWRpby1ncm91cFwiOiB0cnVlXG4gICAgICAgICAgICAgICAgfSwgX2NsYXNzbmFtZXNbbWUucHJvcHMuY2xhc3NOYW1lXSA9ICEhbWUucHJvcHMuY2xhc3NOYW1lLCBfY2xhc3NuYW1lcykpIH0sXG4gICAgICAgICAgICBtZS5fcHJvY2Vzc0NoaWxkKClcbiAgICAgICAgKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIFJhZGlvZ3JvdXA7XG59KFJlYWN0LkNvbXBvbmVudCk7XG5cblJhZGlvZ3JvdXAuZGlzcGxheU5hbWUgPSBcIlJhZGlvZ3JvdXBcIjtcblJhZGlvZ3JvdXAucHJvcFR5cGVzID0ge1xuICAgIHZhbHVlOiBSZWFjdC5Qcm9wVHlwZXMuc3RyaW5nLFxuICAgIG9uQ2hhbmdlOiBSZWFjdC5Qcm9wVHlwZXMuZnVuY1xufTtcblJhZGlvZ3JvdXAuZGVmYXVsdFByb3BzID0ge1xuICAgIHZhbHVlOiBcIlwiLFxuICAgIG9uQ2hhbmdlOiBmdW5jdGlvbiBvbkNoYW5nZSgpIHt9XG59O1xuXG5SYWRpb2dyb3VwLkl0ZW0gPSBJdGVtO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJhZGlvZ3JvdXA7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vdXhjb3JlLXRhYmxlL34vdXhjb3JlLXJhZGlvZ3JvdXAvYnVpbGQvUmFkaW9ncm91cC5qc1xuICoqIG1vZHVsZSBpZCA9IDIzN1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBGb3JtYXR0ZXIgQ29tcG9uZW50IGZvciB1eGNvcmVcbiAqIEBhdXRob3IgZ3Vhbmdob25nLndzalxuICpcbiAqIENvcHlyaWdodCAyMDE0LTIwMTUsIFV4Y29yZSBUZWFtLCBBbGludy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL0Zvcm1hdHRlcicpO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3V4Y29yZS10YWJsZS9+L3V4Y29yZS1mb3JtYXR0ZXIvc3JjL2luZGV4LmpzXG4gKiogbW9kdWxlIGlkID0gMjQwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgcFNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xudmFyIG9iamVjdEtleXMgPSByZXF1aXJlKCcuL2xpYi9rZXlzLmpzJyk7XG52YXIgaXNBcmd1bWVudHMgPSByZXF1aXJlKCcuL2xpYi9pc19hcmd1bWVudHMuanMnKTtcblxudmFyIGRlZXBFcXVhbCA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGFjdHVhbCwgZXhwZWN0ZWQsIG9wdHMpIHtcbiAgaWYgKCFvcHRzKSBvcHRzID0ge307XG4gIC8vIDcuMS4gQWxsIGlkZW50aWNhbCB2YWx1ZXMgYXJlIGVxdWl2YWxlbnQsIGFzIGRldGVybWluZWQgYnkgPT09LlxuICBpZiAoYWN0dWFsID09PSBleHBlY3RlZCkge1xuICAgIHJldHVybiB0cnVlO1xuXG4gIH0gZWxzZSBpZiAoYWN0dWFsIGluc3RhbmNlb2YgRGF0ZSAmJiBleHBlY3RlZCBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICByZXR1cm4gYWN0dWFsLmdldFRpbWUoKSA9PT0gZXhwZWN0ZWQuZ2V0VGltZSgpO1xuXG4gIC8vIDcuMy4gT3RoZXIgcGFpcnMgdGhhdCBkbyBub3QgYm90aCBwYXNzIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0JyxcbiAgLy8gZXF1aXZhbGVuY2UgaXMgZGV0ZXJtaW5lZCBieSA9PS5cbiAgfSBlbHNlIGlmICghYWN0dWFsIHx8ICFleHBlY3RlZCB8fCB0eXBlb2YgYWN0dWFsICE9ICdvYmplY3QnICYmIHR5cGVvZiBleHBlY3RlZCAhPSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBvcHRzLnN0cmljdCA/IGFjdHVhbCA9PT0gZXhwZWN0ZWQgOiBhY3R1YWwgPT0gZXhwZWN0ZWQ7XG5cbiAgLy8gNy40LiBGb3IgYWxsIG90aGVyIE9iamVjdCBwYWlycywgaW5jbHVkaW5nIEFycmF5IG9iamVjdHMsIGVxdWl2YWxlbmNlIGlzXG4gIC8vIGRldGVybWluZWQgYnkgaGF2aW5nIHRoZSBzYW1lIG51bWJlciBvZiBvd25lZCBwcm9wZXJ0aWVzIChhcyB2ZXJpZmllZFxuICAvLyB3aXRoIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCksIHRoZSBzYW1lIHNldCBvZiBrZXlzXG4gIC8vIChhbHRob3VnaCBub3QgbmVjZXNzYXJpbHkgdGhlIHNhbWUgb3JkZXIpLCBlcXVpdmFsZW50IHZhbHVlcyBmb3IgZXZlcnlcbiAgLy8gY29ycmVzcG9uZGluZyBrZXksIGFuZCBhbiBpZGVudGljYWwgJ3Byb3RvdHlwZScgcHJvcGVydHkuIE5vdGU6IHRoaXNcbiAgLy8gYWNjb3VudHMgZm9yIGJvdGggbmFtZWQgYW5kIGluZGV4ZWQgcHJvcGVydGllcyBvbiBBcnJheXMuXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG9iakVxdWl2KGFjdHVhbCwgZXhwZWN0ZWQsIG9wdHMpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGlzVW5kZWZpbmVkT3JOdWxsKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBpc0J1ZmZlciAoeCkge1xuICBpZiAoIXggfHwgdHlwZW9mIHggIT09ICdvYmplY3QnIHx8IHR5cGVvZiB4Lmxlbmd0aCAhPT0gJ251bWJlcicpIHJldHVybiBmYWxzZTtcbiAgaWYgKHR5cGVvZiB4LmNvcHkgIT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIHguc2xpY2UgIT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKHgubGVuZ3RoID4gMCAmJiB0eXBlb2YgeFswXSAhPT0gJ251bWJlcicpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIG9iakVxdWl2KGEsIGIsIG9wdHMpIHtcbiAgdmFyIGksIGtleTtcbiAgaWYgKGlzVW5kZWZpbmVkT3JOdWxsKGEpIHx8IGlzVW5kZWZpbmVkT3JOdWxsKGIpKVxuICAgIHJldHVybiBmYWxzZTtcbiAgLy8gYW4gaWRlbnRpY2FsICdwcm90b3R5cGUnIHByb3BlcnR5LlxuICBpZiAoYS5wcm90b3R5cGUgIT09IGIucHJvdG90eXBlKSByZXR1cm4gZmFsc2U7XG4gIC8vfn5+SSd2ZSBtYW5hZ2VkIHRvIGJyZWFrIE9iamVjdC5rZXlzIHRocm91Z2ggc2NyZXd5IGFyZ3VtZW50cyBwYXNzaW5nLlxuICAvLyAgIENvbnZlcnRpbmcgdG8gYXJyYXkgc29sdmVzIHRoZSBwcm9ibGVtLlxuICBpZiAoaXNBcmd1bWVudHMoYSkpIHtcbiAgICBpZiAoIWlzQXJndW1lbnRzKGIpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGEgPSBwU2xpY2UuY2FsbChhKTtcbiAgICBiID0gcFNsaWNlLmNhbGwoYik7XG4gICAgcmV0dXJuIGRlZXBFcXVhbChhLCBiLCBvcHRzKTtcbiAgfVxuICBpZiAoaXNCdWZmZXIoYSkpIHtcbiAgICBpZiAoIWlzQnVmZmVyKGIpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChhLmxlbmd0aCAhPT0gYi5sZW5ndGgpIHJldHVybiBmYWxzZTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGFbaV0gIT09IGJbaV0pIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgdHJ5IHtcbiAgICB2YXIga2EgPSBvYmplY3RLZXlzKGEpLFxuICAgICAgICBrYiA9IG9iamVjdEtleXMoYik7XG4gIH0gY2F0Y2ggKGUpIHsvL2hhcHBlbnMgd2hlbiBvbmUgaXMgYSBzdHJpbmcgbGl0ZXJhbCBhbmQgdGhlIG90aGVyIGlzbid0XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8vIGhhdmluZyB0aGUgc2FtZSBudW1iZXIgb2Ygb3duZWQgcHJvcGVydGllcyAoa2V5cyBpbmNvcnBvcmF0ZXNcbiAgLy8gaGFzT3duUHJvcGVydHkpXG4gIGlmIChrYS5sZW5ndGggIT0ga2IubGVuZ3RoKVxuICAgIHJldHVybiBmYWxzZTtcbiAgLy90aGUgc2FtZSBzZXQgb2Yga2V5cyAoYWx0aG91Z2ggbm90IG5lY2Vzc2FyaWx5IHRoZSBzYW1lIG9yZGVyKSxcbiAga2Euc29ydCgpO1xuICBrYi5zb3J0KCk7XG4gIC8vfn5+Y2hlYXAga2V5IHRlc3RcbiAgZm9yIChpID0ga2EubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBpZiAoa2FbaV0gIT0ga2JbaV0pXG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLy9lcXVpdmFsZW50IHZhbHVlcyBmb3IgZXZlcnkgY29ycmVzcG9uZGluZyBrZXksIGFuZFxuICAvL35+fnBvc3NpYmx5IGV4cGVuc2l2ZSBkZWVwIHRlc3RcbiAgZm9yIChpID0ga2EubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBrZXkgPSBrYVtpXTtcbiAgICBpZiAoIWRlZXBFcXVhbChhW2tleV0sIGJba2V5XSwgb3B0cykpIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHlwZW9mIGEgPT09IHR5cGVvZiBiO1xufVxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vdXhjb3JlLXRhYmxlL34vZGVlcC1lcXVhbC9pbmRleC5qc1xuICoqIG1vZHVsZSBpZCA9IDI1MVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIFZhbGlkYXRvciBDb21wb25lbnQgZm9yIHV4Y29yZVxuICogQGF1dGhvciBldGVybmFsc2t5XG4gKlxuICogQ29weXJpZ2h0IDIwMTQtMjAxNSwgVXhjb3JlIFRlYW0sIEFsaW53LlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vVmFsaWRhdG9yJyk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vdXhjb3JlLWZvcm0vfi91eGNvcmUtdmFsaWRhdG9yL2J1aWxkL2luZGV4LmpzXG4gKiogbW9kdWxlIGlkID0gMjgxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iXSwibWFwcGluZ3MiOiI7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDdENBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7Ozs7OztBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQzVzQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FDbldBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ3BGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FDckJBOzs7Ozs7QUNBQTs7Ozs7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ2xGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQzNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUNsQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUM5UEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUN2VkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FDcEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7O0FDL0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUN2Z0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUN4SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDbFBBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ25MQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FDOURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7QUNYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FDdGJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQ3JDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQ3pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FDcFVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7OztBQzFIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7O0FDaEhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ3ZGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQzNCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUMvRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUN2S0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUMzREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQ2pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUN4Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDMUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7O0FDNWVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUN2Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ1hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUMxQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUM3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7O0FDM0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3ZGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FDaE1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FDaFVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUM3VUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FDOUZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQ25FQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FDeEhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNsRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUMvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7OztBQ3JDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FDekRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUMvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FDL0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7QUMvRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FDN0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQy9EQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQ3RPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQzdGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUM3Z0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDM0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ25GQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUMza0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7O0FDdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQ2xFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUMzSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FDekVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUNyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUM3SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FDOUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FDclZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUN6REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUNuSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQ3pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUN2UEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FDMUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7OztBQzNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQ3ZUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUN0Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FDOUZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUNwSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FDN1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FDcFRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQ25CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUM1RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUMxWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FDOUZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUN4RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7QUN6U0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FDN01BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQzVXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FDN1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQ3AwQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FDbElBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUMzSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FDaERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FDbEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FDalFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUM3R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FDbjBCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUM3REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FDdE5BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUN4S0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FDaFFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FDeE1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUNqTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQzVHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUNqREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQ2pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FDcElBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUN6REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FDckNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQ3pLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUMvTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQzVGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FDN0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDblNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUNsS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQzNCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FDckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FDbk9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQ3pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUMvS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQ3BJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUN4Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDakVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQ3BDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FDckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUNyRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQ3pHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FDL0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQ3RLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQzFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUM1RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUN6RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FDM0lBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQzFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUMxUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FDbENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FDL0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUMzT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FDekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUNwQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FDclJBO0FBQ0E7QUFDQTs7Ozs7O0FDRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUNoSUE7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUNwVUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FDakdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQ3hMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDOUxBO0FBQ0E7QUFDQTs7Ozs7O0FDRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQzdhQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUMvTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUMzSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FDek5BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQ3BEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FDM0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUN0REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUNuQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUNuQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQ25EQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQ3pDQTtBQUNBO0FBQ0E7Ozs7OztBQ0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUNqSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUM1Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FDekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQ3B3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUM5R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUNuQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQ25QQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FDblZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQ3hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FDellBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUNySEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FDekVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FDL0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUNsS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQzlLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FDcElBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQ2xGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDN0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OzsiLCJzb3VyY2VSb290IjoiIn0=